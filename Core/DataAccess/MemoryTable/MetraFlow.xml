<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="MetraFlow.xsl"?>
<operators version="6.6.0.1">
<!--

This XML describes the specification of arguments and input/output ports
for the MetraFlow operators

Glossary

alias          - a list of alias names for the operator
aliasname      - another name that maybe used in the script for the operator
argdescription - a description of the operator argument
argname        - the name of the argument to use in the script
argtype        - the type of the argument. The different types of arguments
                 are: String, Boolean, Integer, Sublist. See sublist below
                 for more details on this type.
argunlimited   - if true, the argument may be specified multiple times
argument       - an operator argument
controlledpresence - indicates that a given port may appear only if
                a condition has been met (example: see parameter).
controlvalue  - used to describe controlledpresence. The given port can
                only be specified if an argument identified by parameter
                is also present and matches the one of the specified
                control values.
default       - if true, indicates that this is the default value that
                will be used for the argument if none is specified.
description   - a description of the operator
displayname   - a displayable name of the operator
input         - an input port for the operator
inputname     - the name that is used to identify the port in the script
inputs        - a list of input ports for the operator
inputlimited  - indicates that an input port may occur multiple times
                but the number of times is limited (see "mustequal").
                The multiple ports are identified by using the extensions
                (0), (1), (2)...
inputunbounded - indicates that the port name may occur multiple times
                by using the extensions (0), (1), (2)... to the port name.
metraflowname - the name for the operator to use in the script. Some
                operators also have aliases. In this case, the metraflowname
                is the preferred name to use.
mustequal     - the number of occurrences of a given port to the operator
                must match the number of occurrences of another given port.
operator      - a MetraFlow operator
optional      - if true, then the argument is not required
output        - an output port for the operator
outputlimited - indicates that an output port may occur multiple times
                but the number of times is limited (see "mustequal").
                The multiple ports are identified by using the extensions
                (0), (1), (2)...
outputname    - the name that is used to identify the port in the script
outputs       - a list of output ports for the operator
outputunbounded - indicates that the port name may occur multiple times
                by using the extensions (0), (1), (2)... to the port name.
parameter     - used to define a controlledpresence. The given port can
                only be specified if an argument identified by parameter
                is also present (see also controlvalue).
singlename    - this is used to qualify the naming of an unbounded port.
                If singlename is true, then if there is just a single
                port of this type, it is NOT given the (0) extension. 
                For example, a single input port might be named "input" 
                rather than "input(0)".
sublist       - A type of argument. The sublist argument is unusual in that
                a sublist contains a list of sub-arguments.
                A sublist argument has this syntax:
                <argname>=[<sublist argument list>] For example:
                copy[columnList=[column="a", column="b"]].
value         - an acceptable argument value
 
-->
    <operator>
        <displayname>Account Lookup</displayname>
     <description>
          Looks up account information.
          The operator expects an input field (column) containing
          the account to look up.  This can be either an internal
          or external account.  If an external account, a
          namespace must also be given.  The operator also expects
          a timestamp that specifies the date and time for which the account data is to be loaded. 
          The operator also provides the ability to specify which properties of the account
          to retrieve. These properties become output fields.
          This operator branches the dataflow.
          If there are no errors, then the dataflow continues
          to "output" port.  If there is an error, the dataflows
          continues to "error" port.
     </description>
        <metraflowname>account_lookup</metraflowname>
        <argument>
            <argname>timestamp</argname>
            <displayName>Timestamp Field</displayName>
            <argtype>String</argtype>
         <argdescription>
              Specifies the name of the input field to this
              operator that will contain a timestamp value. 
              This timestamp value indicates the time that
              should be used in resolving this account lookup.
              Make sure that the dataflow to this operator
              contains a field with this specified name,
              and that the data type of the field is DATETIME.
              If not specified, the input field name is assumed
              to be "_Timestamp".
         </argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>lookup</argname>
            <displayName>Lookup Mode</displayName>
            <argtype>String</argtype>
         <argdescription>Resolves accounts based on either external identifier or internal identifier. 
         </argdescription>
        <argvalue><argvaluename>external</argvaluename>
          <argvaluedescription>Resolve external account.
            This is the default.</argvaluedescription>
        </argvalue>
        <argvalue>
          <argvaluename>internal</argvaluename>
          <argvaluedescription>
            Resolve the account internal.  You do not need
            to use namespace or namespaceValueType.
            They will be ignored.
          </argvaluedescription>
        </argvalue>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>identifier</argname>
            <displayName>Account Identifier</displayName>
            <argtype>String</argtype>
         <argdescription>
              Specifies the name of the input field to this
              operator that will contain the account ID. 
              This is the account that caused the charge
              to be generated - the payee (as opposed to the account
              that may make the payment - the payer).
              Make sure that the dataflow to this operator
              contains a field with this specified name.
              If this is an "internal" lookup, the
              data type of the field must be INTEGER.
              If this is an "external" lookup, the
              data type of the field must be STRING.
              (If this is an "external" lookup, it 
              is expected that the namespace and the
              payee will be found in the t_account_mapper
              table, and thus the corresponding account ID
              is discovered. It is also expected that for both
              internal and external accounts the payee account ID
              will be found in both the t_payment_redirection 
              and t_acc_usage_cycle tables. Finally, it
              is expected that the timespace will fall within 
              the range of the start and end time of the cycle.)
         </argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>namespace</argname>
            <displayName>Account Identifier Namespace</displayName>
            <argtype>String</argtype>
         <argdescription>
              This argument is present if this is an
              "external" lookup.  The argument may either
              be a constant or the name of an input field.
              If "namespaceValueType" is "constant", this
              argument contains the hard-coded namespace to use.
              If "namespaceValueType" is "fieldReference",
              this argument is a field reference, and
              the argument specifies the name of the input field to this
              operator that will contain the namespace to use.
              In either case, the operator will consider only
              accounts in t_account_mapper whose "nm_space" 
              equals the given namespace value.
         </argdescription>
        </argument>
        <argument>
            <argname>namespaceValueType</argname>
            <displayName>Account Identifier Namespace Value Indicator</displayName>
            <argtype>String</argtype>
            <argdescription>Indicates whether the value in the "namespace" argument is a constant or a field reference.</argdescription>
            <optional>true</optional>
            <argvalue>
              <argvaluename>fieldReference</argvaluename>
              <argvaluedescription>
                namespace identifies the column containing the
                value to use for namespace.
                This is the default.
              </argvaluedescription>
            </argvalue>
            <argvalue>
              <argvaluename>constant</argvaluename>
              <argvaluedescription>
                namespace is a constant.
              </argvaluedescription>
            </argvalue>
            <!-- Only required if binding by external name -->
            <optional>
              <value>true</value>
              <optionalRule>
                <conditionalArg>lookup</conditionalArg>
                <value>internal</value>
              </optionalRule>
            </optional>
        </argument>
        <argument>
            <argunlimited>true</argunlimited>
            <argname>property</argname>
            <displayName>Account Retrieval Property</displayName>
            <!-- Type of argument is Binding -->
            <argtype>String</argtype>
         <argdescription>
            Identifies a property to retrieve.
         The value of this argument should
         match the name of a column in t_av_contact,
         but without the "c_" prefix.
         As an example, if the column in t_av_contact is
         "c_FirstName", this argument is specified as "FirstName".
         The argument is used hand-in-hand with the "as" argument
         and the two arguments are specified as pairs.
         The "as" argument specifies the name to use for the
         output field containing the looked-up property.
         NOTE: It is mandatory that the following 
         properties are specified: "PayingAccountID", 
         "UsageCycleID", "AccountID".
         </argdescription>
            <optional>true</optional>
        </argument>
        <argument>
            <argunlimited>true</argunlimited>
            <argname>as</argname>
            <displayName>Account Retrieval Property Field</displayName>
            <argtype>String</argtype>
         <argdescription>
              This argument is specified for each "property" argument.
              This argument identifies the name of the output
              field to create that will contain the looked-up
              property.
         </argdescription>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
          <inputdescription></inputdescription>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
        <outputs>
            <output>
                <outputname>error</outputname>
                <outputnumber>1</outputnumber>
                <outputdescription>
                  If an error occurs, the dataflow
                  continues out this port rather than
                  port 0 ("output").
                </outputdescription>
           </output>
        </outputs>
        <example>
<!--
This is an example of using account_lookup to find
an internal account.
<pre>
<font color="#0000AA">
g: generate [
        program =
        "CREATE PROCEDURE gen @myAccountToFind INTEGER OUTPUT
                              @myTimestamp DATETIME OUTPUT
        AS
        SET @myAccountToFind = 123
        SET @myTimestamp = CAST('1 OCT 2010' AS DATETIME)",
        numRecords = 1];

p1: print[numToPrint=20];
p2: print[numToPrint=20];

d1:devNull;
d2:devNull;

a: account_lookup[
        identifier = "myAccountToFind",
        lookup = "internal",
        timestamp = "myTimestamp",
        property = "AccountID",
        as = "asAccountID",
        property = "PayingAccountID",
        as = "asPayingAccountID",
        property = "UsageCycleID",
        as = "asUsageCycleID",
        property = "FirstName",
        as = "asPropertyFirstName",
        property = "Currency",
        as = "asCurrency"];

g -> a("input");

a("output") -> p1 -> d1;
a("error") -> p2 -> d2;
</font>
</pre>
The output is:
<pre>
<font color="#0000AA">
asPayingAccountID:123, 
asUsageCycleID:30, 
asCurrency:USD, 
asPropertyFirstName:Allan, 
myAccountToFind:123, 
myTimestamp:10/1/2010, 
asAccountID:123, 
_ErrorCode:NULL, 
_ErrorString:NULL, 
_Plugin:NULL, 
_Module:NULL
</font>
</pre>
If the account cannot be found, then the output is:
<pre>
<font color="#0000AA">
asPayingAccountID:NULL, 
asUsageCycleID:NULL, 
asCurrency:NULL, 
asPropertyFirstName:NULL, 
myAccountToFind:12545, 
myTimestamp:10/1/2010, 
asAccountID:12545, 
_ErrorCode:-517996508, 
_ErrorString:Unable to resolve paying account for accountID 12545, 
_Plugin:a, _Module:account_lookup
</font>
</pre>
This is an example of finding an external account
using a constant namespace:
<pre>
<font color="#0000AA">
g: generate [
        program =
        "CREATE PROCEDURE gen @myAccountToFind NVARCHAR OUTPUT
                              @myTimestamp DATETIME OUTPUT
        AS
        SET @myAccountToFind = N'demo'
        SET @myTimestamp = CAST('1 OCT 2010' AS DATETIME)",
        numRecords = 1];

p1: print[numToPrint=20];
p2: print[numToPrint=20];

d1:devNull;
d2:devNull;

a: account_lookup[
        mode = "external",
        identifier = "myAccountToFind",
        namespaceValueType = "constant",
        namespace = "mt",
        timestamp = "myTimestamp",
        property = "AccountID",
        as = "asAccountID",
        property = "PayingAccountID",
        as = "asPayingAccountID",
        property = "UsageCycleID",
        as = "asUsageCycleID",
        property = "FirstName",
        as = "asPropertyFirstName",
        property = "Currency",
        as = "asCurrency"];

g -> a("input");

a("output") -> p1 -> d1;
a("error") -> p2 -> d2;
</font>
</pre>
The output is:
<pre>
<font color="#0000AA">
asPayingAccountID:123, 
asUsageCycleID:30, 
asCurrency:USD, 
asPropertyFirstName:Allan, 
asAccountID:123, 
myAccountToFind:demo, 
myTimestamp:10/1/2010, 
_ErrorCode:NULL, 
_ErrorString:NULL, 
_Plugin:NULL, 
_Module:NULL
</font>
</pre>
This is an example of finding an external account
by dynamically passing in the namespace:
<pre>
<font color="#0000AA">
g: generate [
        program =
        "CREATE PROCEDURE gen @myAccountToFind NVARCHAR OUTPUT
                              @myNamespace NVARCHAR OUTPUT
                              @myTimestamp DATETIME OUTPUT
        AS
        SET @myAccountToFind = N'demo'
        SET @myNamespace = N'mt'
        SET @myTimestamp = CAST('1 OCT 2010' AS DATETIME)",
        numRecords = 1];

p1: print[numToPrint=20];
p2: print[numToPrint=20];

d1:devNull;
d2:devNull;

a: account_lookup[
        mode = "external",
        identifier = "myAccountToFind",
        namespaceValueType = "fieldReference",
        namespace = "myNamespace",
        timestamp = "myTimestamp",
        property = "AccountID",
        as = "asAccountID",
        property = "PayingAccountID",
        as = "asPayingAccountID",
        property = "UsageCycleID",
        as = "asUsageCycleID",
        property = "FirstName",
        as = "asPropertyFirstName",
        property = "Currency",
        as = "asCurrency"];

g -> a("input");

a("output") -> p1 -> d1;
a("error") -> p2 -> d2;
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Assert Sort Order</displayname>
        <description>Confirms that the given input is indeed sorted by the given key(s). 
        If the input is not sorted, MetraFlow will exit with an error. Note that the sort order is ascending.</description>
        <metraflowname>assert_sort_order</metraflowname>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value default="true">parallel</value>
            <value>sequential</value>
            <optional>true</optional>
        </argument>
        <argument>
            <argunlimited>true</argunlimited>
            <argname>key</argname>
            <argdescription>Name of the sort key.</argdescription>
            <argtype>String</argtype>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
                <inputdescription>The records to check the sorting order of.</inputdescription>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputdescription>The output records are the unaltered input records.</outputdescription>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
        <example>
<!--
<pre>
<font color="#0000AA">
g:generate [
  program =
    "CREATE PROCEDURE gen
      @bigintVal BIGINT
      @intVal INTEGER
      @decVal DECIMAL
      @doubleVal DOUBLE
      @strVal VARCHAR
      @wstrVal NVARCHAR
    AS
      SET @bigintVal = @@RECORDCOUNT
      SET @intVal = 1
      SET @decVal = CAST(@@RECORDCOUNT AS DECIMAL)
      SET @strVal = CAST(@@RECORDCOUNT % 100000LL AS VARCHAR)
      SET @wstrVal = CAST(@@RECORDCOUNT % 100000LL AS NVARCHAR)",
  numRecords = 30];

st:assert_sort_order[key="intVal", key="bigintVal"];

print[numToPrint=20];

dn1:devNull;

g -> st -> print -> dn1;
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Broadcast</displayname>
        <description>Distributes data to all downstream partitions. This is useful in a parallel scenario where there is a small table
that you want to read in its entirety from one partition and then 
broadcast to the other partitions. </description>
        <metraflowname>broadcast</metraflowname>
        <alias>
            <aliasname>bcast</aliasname>
        </alias>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value default="true">parallel</value>
            <value>sequential</value>
            <optional>true</optional>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
                <inputdescription>The records to broadcast.</inputdescription>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
                <outputdescription>The broadcasted output records. These are the unaltered input records.</outputdescription>
            </output>
        </outputs>
        <example>
<!--
<pre>
<font color="#0000AA">
s1:select[baseQuery="SELECT * FROM t_acc_usage 
          WHERE {fn mod(id_sess, %%NUMPARTITIONS%%)} = %%PARTITION%%"];
s2:select[baseQuery="SELECT id_interval, dt_start, dt_end from t_usage_interval",
          mode="sequential"];

p2:broadcast[mode="sequential"];

s2 -> p2;
j:inner_hash_join[probeKey="id_usage_interval", tableKey="id_interval"];

s1 -> j("probe(0)");
p2 -> j("table");

p:print[numToPrint=10];
j -> p;
d:devNull[];
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Non-Deterministic Collector</displayname>
        <description>Merges multiple streams of records coming from parallel partitions. 
        Coll is the collection operator that is usually paired with the hash_part partition operator. 
        The order of records is not preserved. See also sort_merge_coll.</description>
        <metraflowname>coll</metraflowname>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value default="true">parallel</value>
            <value>sequential</value>
            <optional>true</optional>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
                <inputdescription>Notice that there is a single input port.
                Keep in mind, however, that since the coll operator is running
                on parallel partitions, the operator is merging these multiple
                ports.
                </inputdescription>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
                <outputdescription>The merged output stream of records.</outputdescription>
            </output>
        </outputs>
        <example>
<!--
With MetraFlow's partition parallelism comes the need for partitioner and
collector operators to exchange records. In this example, the partitioned
data from the select operation is repartitioned by the hash_part operator using
the "id_acc" field. This repartitioning is followed by the coll collection
operator, which guarantees that a given partition will receive all the records
pertaining to id_acc.
<pre>
<font color="#0000AA">
s: select[baseQuery="SELECT * FROM t_acc_usage 
                     WHERE {fn mod(id_sess, %%NUMPARTITIONS%%)} = %%PARTITION%%"];

p: hash_part[key="id_acc"];

c: coll[];
s -> p -> c;

</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Copy Operator</displayname>
        <description>Copies a single input stream to multiple output streams.</description>
        <metraflowname>copy</metraflowname>
        <argument>
            <argname>columnList</argname>
            <argunlimited>true</argunlimited>
            <argtype>Sublist</argtype>
            <argdescription>
              The list of columns to copy.
                                This argument is optional.
                                If not provided, all columns are copied.
                                If using this argument repeatedly, use the argument
                                for each copy.  The first specification of the argument
                                applies to output(0), the second specification applies
                                to output(1), etc.  See the example below for more 
                                details on the syntax of this argument.
            </argdescription>
            <optional>true</optional>
            <argument>
                <argname>column</argname>
                <argtype>String</argtype>
                <argdescription>A column to copy.  
                </argdescription>
            </argument>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value default="true">parallel</value>
            <value>sequential</value>
            <optional>true</optional>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
                <inputdescription>Records to copy.</inputdescription>
            </input>
        </inputs>
        <outputs>
            <outputunbounded>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
                <outputdescription>A copy of the input stream. The copy may have fewer columns than the original input
                if the "columnList" argument is used.</outputdescription>
            </outputunbounded>
        </outputs>
        <example>
<!--
<pre>
<font color="#0000AA">
s: import[filename="test_data4",
          format="myRec (
               nm_login text_delimited_nvarchar(delimiter='|'),
               nm_space text_delimited_nvarchar(delimiter='|',NULL_value=''),
               id_acc text_delimited_base10_int32(delimiter=crlf))",
          mode="sequential"];
c: copy[];
p1:print [numToPrint=5];
p2:print [numToPrint=5];
dn1:devNull;
dn2:devNull;

s -> c;
copy(0) -> p1 -> dn1;
copy(1) -> p2 -> dn2;

</font>
</pre>
<p/>
Here is another example:
<pre>
<font color="#0000AA">
s: import[filename="test_data1",
          format="myRec (
               nm_login text_delimited_nvarchar(delimiter='|'),
               nm_space text_delimited_nvarchar(delimiter='|'),
               id_acc text_delimited_base10_int32(delimiter='|'))",
          mode="sequential"];



copy[columnList=[column="nm_login", column="nm_space"],
     columnList=[column="nm_login", column="id_acc"]];

p1:print [numToPrint=5];
dn1:devNull;
p2:print [numToPrint=5];
dn2:devNull;

s -> copy;
copy(0) -> p1 -> dn1;
copy(1) -> p2 -> dn2;
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Null Device</displayname>
        <description>Consumes a single input stream without side effect.</description>
        <metraflowname>devNull</metraflowname>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value default="true">parallel</value>
            <value>sequential</value>
            <optional>true</optional>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
                <inputdescription>The input stream to consume.</inputdescription>
            </input>
        </inputs>
        <example>
<!--
<pre>
<font color="#0000AA">
s: select[baseQuery="SELECT * FROM t_acc_usage au"];
p: print[];
d: devNull[];
s -> p -> d;
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Export Operator</displayname>
        <description>Formats and writes a stream to a flat file.</description>
        <metraflowname>export</metraflowname>
        <argument>
            <argname>filename</argname>
            <argtype>String</argtype>
            <argdescription>Path to the export file to be written.</argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>format</argname>
            <argtype>String</argtype>
            <argdescription>Export file format description.
              See the example for the syntax of the format.
The delimiter maybe a character or the special
value crlf indicating an end of line is expected.
Acceptable values for specifying the format are:
iso8601_datetime, 
text_datetime, text_delimited_base10_int32, text_delimited_base10_int64,
text_delimited_base10_decimal, text_delimited_varchar, text_delimited_nvarchar,
iso_8859_1_delimited_nvarchar, text_delimited_enum, text_delimited_boolean,
text_fixed_hex_binary
            </argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>compress</argname>
            <argtype>Boolean</argtype>
            <argdescription>Indicates whether or not gzip compression should be applied to the output file.</argdescription>
            <optional>true</optional>
            <default>false</default>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
                <inputdescription>The stream to export.</inputdescription>
            </input>
        </inputs>
        <example>
<!--
This is an example of export.  In this example, in the "format" argument,
the text "myRec", "a", "b", "c", "d", and "e" is arbitrary.  You 
can change this terms to better describe the record and columns.
The delimiter character in the example is the vertical bar
but another character could be used.
<pre>
<font color="#0000AA">
g:generate [
  program =
    "CREATE PROCEDURE gen
      @bigintVal BIGINT
      @intVal INTEGER
      @decVal DECIMAL
      @strVal VARCHAR
      @wstrVal NVARCHAR
    AS
      SET @bigintVal = @@RECORDCOUNT
      SET @intVal = 1
      SET @decVal = CAST(@@RECORDCOUNT AS DECIMAL)
      SET @strVal = CAST(@@RECORDCOUNT % 100000LL AS VARCHAR)
      SET @wstrVal = CAST(@@RECORDCOUNT % 100000LL AS NVARCHAR)",
  numRecords = 5];

export[filename="export.temp",
       format="myRec (
               a text_delimited_base10_int64(delimiter='|'),
               b text_delimited_base10_int32(delimiter='|'),
               c text_delimited_base10_decimal(delimiter='|'),
               d text_delimited_varchar(delimiter='|'),
               e text_delimited_nvarchar(delimiter='|'))",
       mode="sequential"];

g -> export;
  
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Export Queue Operator</displayname>
        <description>Formats and writes an in-memory MetraFlowQueue.
          This operator can be used if you want to fill an in-memory data
          structure from a MetraFlow script.
          To use this operator, you must use MetraFlow code
          libraries to construct a MetraFlowQueue.  This MetraFlowQueue
          is given a name that should match the name specified
          in the operator using the "queuename" argument.
          The MetraFlow script will them push the data into the queue.
        </description>
        <metraflowname>export_queue</metraflowname>
        <argument>
            <argname>queuename</argname>
            <argtype>String</argtype>
            <argdescription>Queue to export to.</argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
                <inputdescription>The record stream to export.</inputdescription>
            </input>
        </inputs>
        <example>
<!--
        See <a href="#import_queue">import_queue</a> for example usage.
-->
        </example>
    </operator>
    <operator>
        <displayname>Expression Operator</displayname>
        <description>Modifies or creates fields in a record using an MTSQL program. The MTSQL program is invoked on each record
        in the stream independently.</description>
        <metraflowname>expr</metraflowname>
        <argument>
            <argname>program</argname>
            <argdescription>The MTSQL program that operates on the record.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
                <inputdescription>The input stream.</inputdescription>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
                <outputdescription>The output stream is the input stream plus any modifications.</outputdescription>
            </output>
        </outputs>
        <example>
<!--
This is an example script that creates a new
column named "nm_login_space".
<font color="#0000AA">
<pre>
<font color="#0000AA">
i: import[filename="test_data1",
          format="myRec (
               nm_login text_delimited_nvarchar(delimiter='|'),
               nm_space text_delimited_nvarchar(delimiter='|'),
               id_acc text_delimited_base10_int32(delimiter='|'))",
          mode="sequential"];

expr [program=
      "CREATE PROCEDURE f @nm_login NVARCHAR @nm_space NVARCHAR @nm_login_space NVARCHAR OUTPUT
       AS
       SET @nm_login_space = @nm_space + N'/' + @nm_login"
     ];
print[numToPrint=100];
devNull[];
i -> expr -> print -> devNull;
  
</font>
</pre>
</font>
Example output from this script: <br/>
<pre>
<font color="#0000AA">
nm_login:syntheticroot, nm_space:mt, id_acc:-1, nm_login_space:mt/syntheticroot
nm_login:root, nm_space:mt, id_acc:1, nm_login_space:mt/root
</font>
</pre>

-->
        </example>
    </operator>
    <operator>
        <displayname>Filter Operator</displayname>
        <description>Selects records from the input stream based on a given predicate. 
        The predicate is an MTSQL function that returns a BOOLEAN.</description>
        <metraflowname>filter</metraflowname>
        <argument>
            <argname>program</argname>
            <argdescription>The filter predicate realized as a BOOLEAN values MTSQL function.
            The filter predicate is an MTSQL function that returns a BOOLEAN.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
                <inputdescription>The input stream to filter.</inputdescription>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
                <outputdescription>The output stream is the filtered input stream.</outputdescription>
            </output>
        </outputs>
<example>
<!--
<pre>
<font color="#0000AA">
i: import[filename="test_data1",
          format="myRec (
               nm_login text_delimited_nvarchar(delimiter='|'),
               nm_space text_delimited_nvarchar(delimiter='|'),
               id_acc text_delimited_base10_int32(delimiter='|'))",
          mode="sequential"];

f: filter [program="CREATE FUNCTION f (@nm_space NVARCHAR) RETURNS BOOLEAN 
                    AS RETURN @nm_space = N'mt'"];
p: print[numToPrint=100];
devNull;
i -> f -> p -> devNull;
  
</font>
</pre>
The output of this example begins as follows:
<pre>
<font color="#0000AA">
  nm_login:syntheticroot, nm_space:mt, id_acc:-1
  nm_login:root, nm_space:mt, id_acc:1
</font>
</pre>
-->
</example>
    </operator>
    <operator>
        <displayname>Generate Operator</displayname>
        <description>Generates a record based on an MTSQL procedure.
                     It is similar in behavior to the expr operator,
                     but it can also access special variables.
                     Although generate has an input port, use of
                     this port is optional.
        </description>
        <metraflowname>generate</metraflowname>
        <argument>
            <argname>numRecords</argname>
            <argdescription>The number of records to generate in each partition of the operator.</argdescription>
            <argtype>Integer</argtype>
        </argument>
        <argument>
            <argname>program</argname>
            <argdescription>An MTSQL procedure that specifies the record values. Generate programs may reference
            special variables @@RECORDCOUNT, @@PARTITION, and @@PARTITIONCOUNT.
            The generate operator will iterate, creating the records. @@RECORDCOUNT is
            that value of this iterator, starting at 0 and increasing.
            </argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
                <inputdescription>If given, the input stream will be augmented
                                  with the generated columns.</inputdescription>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
                <outputdescription>The generated columns (plus the input stream, if given).
                </outputdescription>
            </output>
        </outputs>
<example>
<!--
<pre>
<font color="#0000AA">
generate [program =
             "CREATE PROCEDURE gen @bigintVal BIGINT @intVal INTEGER @decVal DECIMAL 
                                   @doubleVal DOUBLE @strVal VARCHAR @wstrVal NVARCHAR
              AS
              SET @bigintVal = @@RECORDCOUNT
              SET @intVal = CAST(@@RECORDCOUNT AS INTEGER)
              SET @decVal = CAST(@@RECORDCOUNT AS DECIMAL)
              SET @strVal = CAST(@@RECORDCOUNT % 100000LL AS VARCHAR)
              SET @wstrVal = CAST(@@RECORDCOUNT % 100000LL AS NVARCHAR)",
            numRecords = 30];
print[numToPrint=20];
devNull;

generate -> print -> devNull;

</font>
</pre>
The output of this example begins as follows:
<pre>
<font color="#0000AA">
    bigintVal:1, intVal:1, decVal:1, doubleVal:NULL, strVal:1, wstrVal:1
    bigintVal:2, intVal:2, decVal:2, doubleVal:NULL, strVal:2, wstrVal:2
</font>
</pre>
-->
</example>
    </operator>
    <operator>
        <displayname>Hash Group By Operator</displayname>
        <description>
          Groups a selected set of rows into 
          a set of summary rows by the values of one or more columns.
          One row is returned for each group. 
          The output record contains a group-by-key column and 
          the newly created column
          produced by the logic in the "initialize" and "update" procedures.
          The resulting records are not sorted.
          NOTE: Before any output is produced, 
          the entire input stream is consumed and stored in memory.
          This is because we do not know the result for the group until we 
          process every record in that group.
        </description>
        <metraflowname>hash_group_by</metraflowname>
        <alias>
            <aliasname>group_by</aliasname>
        </alias>
        <argument>
            <argname>key</argname>
            <argunlimited>true</argunlimited>
            <argdescription>Name of the group-by key. You can specify multiple keys.
              If you have a single input stream, the multiple keys are used to 
              produce multiple groupings: each unique combination of multiple key
              values corresponds with a separate group.
              If you have multiple input streams, you must specify a key or keys
              and update for each port.  The keys must be identical
              across all ports.
            </argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>initialize</argname>
            <argdescription>An MTSQL procedure that initializes group-by outputs upon each new key value.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>update</argname>
            <argunlimited>true</argunlimited>
            <argdescription>An MTSQL procedure that updates group-by outputs upon receipt of each record in a group.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <inputlimited singlename="true" mustequal="update">
                <inputname>input</inputname>
                <inputnumber>*</inputnumber>
            </inputlimited>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
<example>
<!--
<pre>
<font color="#0000AA">
  g1: generate [
  program = 
    "CREATE PROCEDURE gen 
      @a BIGINT 
      @c INTEGER
      @b INTEGER 
  AS
    SET @a = @@RECORDCOUNT
    SET @c = CAST(@@RECORDCOUNT AS INTEGER)
    SET @b = CAST(@@RECORDCOUNT AS INTEGER) % 2",
  numRecords = 4];

group_by [
  initialize = 
    "CREATE PROCEDURE init @sumOfA BIGINT 
     AS SET @sumOfA = 0LL",
  key = "b",
  update = "CREATE PROCEDURE upd @sumOfA BIGINT @a BIGINT 
            AS SET @sumOfA = @sumOfA + @a"];

p2: print[];
p3: print[];

devNull;

g1("output") -> p2 -> group_by("input");
st:sort[key="b"];
group_by ->st -> p3 -> devNull;
</font>
</pre>
The output from this is:
<pre>
<font color="#0000AA">
a:0, c:0, b:0
a:1, c:1, b:1
a:2, c:2, b:0
a:3, c:3, b:1
b:0, sumOfA:2
b:1, sumOfA:4
</font>
</pre>
If we change the hash_group_by to use multiple keys:
<pre>
<font color="#0000AA">
hash_group_by [
  initialize = 
    "CREATE PROCEDURE init @sumOfA BIGINT 
     AS SET @sumOfA = 0LL",
  key = "b", key="c",
  update = "CREATE PROCEDURE upd @sumOfA BIGINT @a BIGINT 
            AS SET @sumOfA = @sumOfA + @a"];
</font>
</pre>
the output is:
<pre>
<font color="#0000AA">
a:0, c:0, b:0
a:1, c:1, b:1
a:2, c:2, b:0
a:3, c:3, b:1
b:0, c:0, sumOfA:0
b:0, c:2, sumOfA:2
b:1, c:3, sumOfA:3
b:1, c:1, sumOfA:1
</font>
</pre>
Another example using multiple input ports:
<pre>
<font color="#0000AA">
  g1: generate [
  program = 
    "CREATE PROCEDURE gen 
      @a BIGINT 
      @c INTEGER
      @b INTEGER 
  AS
    SET @a = @@RECORDCOUNT
    SET @c = CAST(@@RECORDCOUNT AS INTEGER)
    SET @b = CAST(@@RECORDCOUNT AS INTEGER) % 2",
  numRecords = 4];

g2: generate [
  program = 
    "CREATE PROCEDURE gen 
      @a BIGINT 
      @d INTEGER
      @b INTEGER 
  AS
    SET @a = @@RECORDCOUNT
    SET @d = CAST(@@RECORDCOUNT AS INTEGER)
    SET @b = CAST(@@RECORDCOUNT AS INTEGER) % 2",
  numRecords = 4];

group_by [
  initialize = 
    "CREATE PROCEDURE init @sumOfA BIGINT 
     AS SET @sumOfA = 0LL",
  key = "b",
  update = "CREATE PROCEDURE upd @sumOfA BIGINT @a BIGINT 
            AS SET @sumOfA = @sumOfA + @a",
  key = "b",
  update = "CREATE PROCEDURE upd @sumOfA BIGINT @a BIGINT 
            AS SET @sumOfA = @sumOfA + @a"];

p1: print[];
p2: print[];
p3: print[];

d: devNull;

g1("output") -> p1 -> group_by("input(0)");
g2("output") -> p2 -> group_by("input(1)");
st:sort[key="b"];
group_by ->st -> p3 -> d
</font>
</pre>
The output is:
<pre>
<font color="#0000AA">
a:0, c:0, b:0
a:1, c:1, b:1
a:2, c:2, b:0
a:3, c:3, b:1
a:0, d:0, b:0
a:1, d:1, b:1
a:2, d:2, b:0
a:3, d:3, b:1
b:0, sumOfA:4
b:1, sumOfA:8
</font>
</pre>
-->
</example>
    </operator>
    <operator>
        <displayname>Hash Partitioner</displayname>
        <description>
           Redistributes data in a parallel stream based on a hash of the values of a configurable set of keys. 
           MetraFlow is optimized for partition parallelism, meaning processing is automatically distributed 
           across multiple threads or processes. The partitioning occurs when the data is selected/read, and 
           the records are distributed to each thread or process. 
           However, it's often the case that you want to perform an operation that requires ALL the records of
           a particular type, such as account ID.  Since each partition only has a subset of the records, 
           you must first repartition the data using the field or fields in question. Performing a hash_part 
           with a key="id_acc" argument guarantees that each partition has "account integrity".  
           This is the purpose of the hash_part operator.
        </description>
        <metraflowname>hash_part</metraflowname>
        <alias>
            <aliasname>hashpart</aliasname>
        </alias>
        <argument>
            <argname>key</argname>
            <argunlimited>true</argunlimited>
            <argdescription>Name of a hash key.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
        <example>
<!--
In this example, the partitioned
data from the select operation is repartitioned by the hash_part operator using
the "id_acc" field. This repartitioning is followed by the coll collection
operator, which guarantees that a given partition will receive all the records
pertaining to id_acc.
<pre>
<font color="#0000AA">
s1:select[baseQuery="SELECT * FROM t_acc_usage 
                       WHERE {fn mod(id_sess, %%NUMPARTITIONS%%)} = %%PARTITION%%"];
p1:hash_part[key="id_acc"];
s1 -> p1;

c1:coll[];
p1 -> c1;

s2:select[baseQuery="SELECT nm_login, id_acc as am_id_acc FROM t_account_mapper 
                     WHERE {fn mod(id_acc, %%NUMPARTITIONS%%)} = %%PARTITION%%"];
p2:hash_part[key="am_id_acc"];
s2 -> p2;

c2:coll[];
p2 -> c2;

j:inner_hash_join[probeKey="id_acc", tableKey="am_id_acc"];

c1 -> j("probe(0)");
c2 -> j("table");

p:print[numToPrint=10];
j -> p;
d:devNull[];
p -> d;
s -> p -> d;
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Hash Running Total</displayname>
        <description>
          Calculates a running total based on a set of 
          configurable group-by keys 
          and, optionally, a set of sort keys.
          The hash_running_total operator groups a selected set of rows into 
          by the values of one or more columns.
          Every output row contains a group-by-key column and 
          the newly created column
          produced by the logic in the "initialize" and "update" procedures.
          It is important to note that this operator does not permit
          you to use an existing field for the running total -- you
          must refer to a new variable in the "initialize" procedure.
          The resulting records are not sorted.
          This operator is very similar to hash_group_by.
          The main difference is, whereas hash_group_by produces one output
          record for each group, hash_running_total produces an output
          record for each input record received (showing the total
          accumulating, record by record).
          NOTE: Before any output is produced, 
          the entire input stream is consumed and stored in memory.
          This is because the result for the group is unknown until 
          every record in that group has been processed.
        </description>
        <metraflowname>hash_running_total</metraflowname>
        <argument>
            <argname>key</argname>
            <argunlimited>true</argunlimited>
            <argdescription>Name of a grouping key.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>sortKey</argname>
            <argunlimited>true</argunlimited>
            <argdescription>Name of a sorting key to support a sorted merge in the case of a multiple-input running total.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>initialize</argname>
            <argdescription>An MTSQL procedure that initializes group-by outputs upon each new key value.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argunlimited>true</argunlimited>
            <argname>update</argname>
            <argdescription>An MTSQL procedure that updates group-by outputs upon receipt of each record in a group.  
            If the output from the summation is the same as an input column, we can distinguish by prepending the words
            "Table_" and "Probe_" respectively to the column names. For example, "CREATE PROCEDURE upd @Table_bigintVal
            BIGINT @Probe_bigintVal BIGINT AS SET @Table_bigintVal = @Table_bigintVal + @Probe_bigintVal" distinguishes 
            between bigintVal in the input and the output </argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>preIncrement</argname>
            <argdescription>Sets whether running total records are output before or after the update procedure is run.</argdescription>
            <argtype>Boolean</argtype>
        </argument>
        <argument>
            <argname>outputGroupBy</argname>
            <argdescription>Sets whether group by totals are output after all records are consumed.</argdescription>
            <argtype>Boolean</argtype>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <inputlimited singlename="true" mustequal="update">
                <inputname>input</inputname>
                <inputnumber>*</inputnumber>
            </inputlimited>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
        <comments> This operator has a notion of an input-spec. There must be one input-spec for each input to the operator.
        The input-spec is specified by a list of "key" arguments followed by a single "update" argument. For example, 
        if there were two inputs to the operator, then the arguments might look like: key="a", key="b", update="c", key="d", update="e"</comments>
        <example>
<!--
An example:
<pre>
<font color="#0000AA">
generate [
program = 
"CREATE PROCEDURE gen @bigintVal BIGINT @intVal INTEGER 
AS
SET @bigintVal = @@RECORDCOUNT
SET @intVal = CAST(@@RECORDCOUNT AS INTEGER) % 4",
numRecords = 10000];

hash_running_total [
key = "intVal",
initialize = "CREATE PROCEDURE init @sum BIGINT AS SET @sum = 0LL",
update = "CREATE PROCEDURE upd @sum BIGINT @bigintVal BIGINT AS SET @sum = @sum + @bigintVal"];

print[numToPrint=40];
devNull;
generate -> hash_running_total -> print -> devNull
</font>
</pre>
The output is:
<pre>
<font color="#0000AA">
bigintVal:0, intVal:0, intVal#:0, sum:0
bigintVal:1, intVal:1, intVal#:1, sum:0
bigintVal:2, intVal:2, intVal#:2, sum:0
bigintVal:3, intVal:3, intVal#:3, sum:0
bigintVal:4, intVal:0, intVal#:0, sum:0
bigintVal:5, intVal:1, intVal#:1, sum:1
bigintVal:6, intVal:2, intVal#:2, sum:2
bigintVal:7, intVal:3, intVal#:3, sum:3
</font>
</pre>
Another example using the Table_ and Probe_ prefixes:
<pre>
<font color="#0000AA">
generate [
  program = "CREATE PROCEDURE gen @bigintVal BIGINT @intVal INTEGER 
           AS
           SET @bigintVal = @@RECORDCOUNT
           SET @intVal = CAST(@@RECORDCOUNT AS INTEGER) % 4",
  numRecords = 10000];

hash_running_total [
  key = "intVal",
  initialize = "CREATE PROCEDURE init 
                  @Table_sum_bigintVal BIGINT 
                AS 
                SET @Table_sum_bigintVal = 0LL",
  update = "CREATE PROCEDURE upd 
              @Table_sum_bigintVal BIGINT 
              @Probe_bigintVal BIGINT 
            AS 
            SET @Table_sum_bigintVal = @Table_sum_bigintVal + 
                                       @Probe_bigintVal"];
print[numToPrint=40];
devNull;

generate -> hash_running_total -> print -> devNull;
</font>
</pre>
The output is:
<pre>
<font color="#0000AA">
bigintVal:0, intVal:0, intVal#:0, sum_bigintVal:0
bigintVal:1, intVal:1, intVal#:1, sum_bigintVal:0
bigintVal:2, intVal:2, intVal#:2, sum_bigintVal:0
bigintVal:3, intVal:3, intVal#:3, sum_bigintVal:0
bigintVal:4, intVal:0, intVal#:0, sum_bigintVal:0
bigintVal:5, intVal:1, intVal#:1, sum_bigintVal:1
bigintVal:6, intVal:2, intVal#:2, sum_bigintVal:2
bigintVal:7, intVal:3, intVal#:3, sum_bigintVal:3
bigintVal:8, intVal:0, intVal#:0, sum_bigintVal:4
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>ID Generator</displayname>
        <description>Adds a new field to the input stream that is a guaranteed unique ID. The unique ID is created by using the database. 
          The database can track multiple series of unique IDs.  
          The argument sequenceName identifies the "sequence".   A "sequence" in
          database terminology is a generator that generates unique numbers. 
          The identified sequence must have been created in
          the database (through database commands) in advance.
	  The sequences are tracked in the tables t_current_id and
	  t_current_long_id.
</description>
        <metraflowname>id_generator</metraflowname>
        <argument>
            <argname>idName</argname>
            <aliasname>id</aliasname>
            <argtype>String</argtype>
	    <argdescription>
		    The name of the new field being created.
		    The type of this new field will either be an integer
		    or a big integer.  This is determined by first looking
		    for the sequence name in the t_current_id table.
		    If found, then the type is an integer. If not found,
		    then the sequence name should be in the t_current_long_id
		    table and the type is a big integer.
	    </argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>sequence</argname>
            <aliasname>sequenceName</aliasname>
            <argtype>String</argtype>
	    <argdescription>
		    Identifies the series of unique IDs.  
		    The series must already exist in the
		    database tables t_current_id or 
		    t_current_long_id.</argdescription>
        </argument>
        <argument>
            <argname>blockSize</argname>
            <argtype>Integer</argtype>
            <argdescription>Indicates the size of chunks in which blocks of IDs are 
                            allocated from the database. This is needed to avoid roundtrips 
                            to the database.  Once this pool of IDs is allocated,
                            each time this operator needs a new ID 
                            it is taken from the pool. Once the pool is emptied,
                            more are acquired.  IDs left in the pool once the script
                            exits are wasted.
            </argdescription>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
        <example>
<!--
<pre>
<font color="#0000AA">
i:generate [
  program = 
    "CREATE PROCEDURE gen 
      @i INTEGER 
    AS
      SET @i = CAST(@@RECORDCOUNT AS INTEGER)",
  numRecords = 1];

makeId: id_generator[id="myId", sequence="id_dbqueue", blockSize=10];

p: print[];

d: devNull[];

i -> makeId -> p -> d;
</font>
</pre>
Output:
<pre>
<font color="#0000AA">
i:0, myId: 10
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Import Operator</displayname>
        <description>
          Reads and parses a stream from a flat file containing UTF8 text.
          For each field you must specify the field format and
          the delimiter of the field.  Each field must be followed
          by its delimiter.  NOTE: this even applies to the very
	  last field in the file.  For example, if the delimiter
	  for the last column is a carriage return/line feed (crlf),
	  then there must be a carriage return/line feed
	  after the last line.  Be careful what editor you
	  use -- some editors (example: vi) do not write
	  carriage return/line feeds.  Notepad is acceptable.

The MetraFlow import operator expects the datafile to be in UTF8 format. UTF8
is a multibyte character coding that supports foreign character (unicode) sets.
UTF8 is the dominant character set because it is backward-compatible with ASCII.

Normally, when using MetraFlow to read a file, the user doesn't
really notice that MetraFlow is reading UTF8.  This is because
typically the user has a file containing ANSI characters and it
works due to the backward-compatible of UTF8.

But it is possible for the user to run in trouble when using
foreign characters if care isn't taken to work in UTF8.
You can find online hexdump tools to show the hex representation of the
the text file if you question whether it is in UTF8 format or not.

The user also has to be careful
when creating the UTF8 file.   MetraFlow does not support a UTF8
that begins with a BOM (byte-order mark) that some editors
put at the front of the file.  If you examine your file with
a hexdump tool, make sure it does NOT start with: EF BB BF.
That is the BOM.

        </description>
        <metraflowname>import</metraflowname>
        <argument>
            <argname>filename</argname>
            <argtype>String</argtype>
            <argdescription>Path to the import file to be read.</argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>header</argname>
            <argtype>Boolean</argtype>
            <argdescription>If true, then the first line of the datafile should be
                an integer telling the number of records that are in the file.
                This argument is typically used in conjunction with collectIDEncoded.
           </argdescription>
            <optional>true</optional>
            <default>false</default>
        </argument>
        <argument>
            <argname>collectionIDEncoded</argname>
            <argtype>String</argtype>
            <argdescription>
                This argument in combination with the argument "header"
                can be used to create a batch (t_batch) entry
                indicating the number of expected records.
                This is sometimes done in scripts that are metering.
                To have a batch entry created with the number of
                expected records, do the following: (1) use the
                argument "header=true", (2) use the argument collectionIDEncoded
                set to a base64 encoding of a 16-byte identifier
                (example: collectionIDEncoded="Csj8G/k7zO1qLVCPxP1veg=="), and
                (3) at the beginning of the datafile, the first line should
                be an integer telling the number of records in the file.
            </argdescription>
        </argument>
        <argument>
            <argname>format</argname>
            <argtype>String</argtype>
            <argdescription>Import file format description.  
See the examples below.
The delimiter maybe a character or the special
value crlf indicating an end of line is expected.
            </argdescription>
            <argvalue>
              <argvaluename>iso8601_datetime</argvaluename>
              <argvaluedescription>Example formatted input value: 2010-10-01 09:01:00 AM</argvaluedescription>
            </argvalue>
            <argvalue>
              <argvaluename>text_delimited_base10_int32</argvaluename>
              <argvaluedescription></argvaluedescription>
            </argvalue>
            <argvalue>
              <argvaluename>text_delimited_base10_int64</argvaluename>
              <argvaluedescription></argvaluedescription>
            </argvalue>
            <argvalue>
              <argvaluename>text_delimited_base10_decimal</argvaluename>
              <argvaluedescription></argvaluedescription>
            </argvalue>
            <argvalue>
              <argvaluename>text_delimited_varchar</argvaluename>
              <argvaluedescription></argvaluedescription>
            </argvalue>
            <argvalue>
              <argvaluename>text_delimited_nvarchar</argvaluename>
              <argvaluedescription></argvaluedescription>
            </argvalue>
            <argvalue>
              <argvaluename>iso_8859_1_delimited_nvarchar</argvaluename>
              <argvaluedescription></argvaluedescription>
            </argvalue>
            <argvalue>
              <argvaluename>text_delimited_enum</argvaluename>
              <argvaluedescription>
                 You must specify the enum_space and enum_type.
                 The input value should be the enum text
                 without quotes.
                 Here is an example: c_ItemType  text_delimited_enum(enum_space='ForSale.com', enum_type='ItemType', delimiter=',').
                 The input might be: BooksandMusic
              </argvaluedescription>
            </argvalue>
            <argvalue>
              <argvaluename>text_delimited_boolean</argvaluename>
              <argvaluedescription>
                  The boolean cannot have a multi-character delimiter (crlf).
                  This may prevent you from having it be the last item
                  on the input line of the file.  Specify the input
                  data as a single character without quotes: Y or N.
              </argvaluedescription>
            </argvalue>
            <argvalue>
              <argvaluename>text_fixed_hex_binary</argvaluename>
              <argvaluedescription>
The value in the datafile should be 0x followed by 32 hex characters (example: 0x00000000000000000000000000000000).
              </argvaluedescription>
            </argvalue>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>uncompress</argname>
            <argtype>Boolean</argtype>
            <argdescription>Indicates that gzip uncompression should be applied to the input file.</argdescription>
            <optional>true</optional>
            <default>false</default>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
                <outputdescription>The imported data.</outputdescription>
            </output>
        </outputs>
        <example>
<!--
An example:
<pre>
<font color="#0000AA">
i: import[filename="test_data4",
          format="myRec (
               nm_login text_delimited_nvarchar(delimiter='|'),
               nm_space text_delimited_nvarchar(delimiter='|',NULL_value=''),
               id_acc text_delimited_base10_int32(delimiter=crlf))",
          mode="sequential"];
</font>
</pre>
An example datafile that can be read by this example is:
<pre>
<font color="#0000AA">
syntheticroot|mt|-1
root|mt|1
demo|mt|123
GL123|metratech.com/external|123
</font>
</pre>
<p/>
Here is an example that creates a batch record
indicating an expected number of records.
<pre>
<font color="#0000AA">
i1: import[filename="test_data_header", 
           header=true,
           collectionIDEncoded="Csj8G/k7zO1qLVCPxP3veg==",
           format="myRec (
               nm_login text_delimited_nvarchar(delimiter='|'),
               nm_space text_delimited_nvarchar(delimiter='|'),
               id_acc text_delimited_base10_int32(delimiter=crlf))",
           mode="sequential"];

p: print;
d: devNull;

i1 -> p -> d
</font>
</pre>
An example datafile that can be read by this example is:
<pre>
<font color="#0000AA">
4
syntheticroot|mt|-1
root|mt|1
demo|mt|123
GL123|metratech.com/external|123
</font>
</pre>
<p/>
Here is another example:
<pre>
<font color="#0000AA">
i:import[format="myRec
         INTEGER  =text_delimited_base10_int32(delimiter='|', NULL_value='')
         BIGINT   =text_delimited_base10_int64(delimiter='|', NULL_value='')
         DECIMAL  =text_delimited_base10_decimal(delimiter='|', NULL_value='')
         BOOLEAN  =text_delimited_boolean(delimiter='|', true_value='Y', 
                         false_value='N', NULL_value='')
         NVARCHAR =text_delimited_nvarchar(delimiter='|', NULL_value='')
         ENUM     =text_delimited_enum(enum_space='Global',
                         enum_type='CountryName', delimiter='|', NULL_value='')
         DATETIME =iso8601_datetime(delimiter='|', NULL_value='')
         (
            AccountName       NVARCHAR,
            Description       NVARCHAR,
            Units             DECIMAL,
            Time              DATETIME,
            DecProp1          DECIMAL,
            DecProp2          DECIMAL,
            DecProp3          DECIMAL,
            IntegerProperty   INTEGER,
            Integer64Property BIGINT,
            StringProperty    NVARCHAR,
            EncryptedStringProperty_ NVARCHAR,
            DecimalProperty   DECIMAL,
            DoubleProperty    DECIMAL,
            BooleanProperty   BOOLEAN,
            EnumProperty      ENUM,
            TimestampProperty DATETIME,
            PipelineTime iso8601_datetime(delimiter=crlf, NULL_value='')
         )",
         filename=$USAGERECORDFILE,
         mode="sequential"];
</font>
</pre>  

-->
        </example>
    </operator>

    <operator>
        <displayname>Import Queue Operator</displayname>
        <description>
          Streams in-memory data into a queue for a MetraFlow script.
          This provides a way to programmatically pass data to a 
          MetraFlow script.
          To use this operator, you must use MetraFlow code
          libraries to construct a MetraFlowQueue.  This MetraFlowQueue
          is given a name that should match the name specified
          in the operator using the "queuename" argument.
          The MetraFlow script will then pull the data from the queue.
        </description>
        <metraflowname>import_queue</metraflowname>
        <argument>
            <argname>queuename</argname>
            <argtype>String</argtype>
            <argdescription>Queue to import from.</argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
        <example>
<!--
Here is a portion of C# code that is using
import and export queue to pass data to and
from MetraFlow.
<pre>
<font color="#0000AA">
    public void SimpleInputOutputQueueTest()
    {
      try
      {
        System.Console.WriteLine("Simple Input Output Queue Test.");

        // Define the program are running as a MetraFlowScript program.
        // This example program takes one tables in memory and prints.

        String programTextFormat = 
          "a:import_queue[queueName=\"{0}\"];\n"
        + "p:print[];\n"
        + "b:export_queue[queueName=\"{1}\"];\n"
        + "a -> p -> b;\n";

        // Define a dataset that contains table corresponding to each input that is
        // to come from program state.
        System.Data.DataSet inputs = new System.Data.DataSet();
        String tableA = System.Guid.NewGuid().ToString();
        System.Data.DataTable table = new System.Data.DataTable(tableA);
        table.Columns.Add(new System.Data.DataColumn("SomeName", System.Type.GetType("System.String")));
        table.Columns.Add(new System.Data.DataColumn("SomeValue", System.Type.GetType("System.Int32")));
        inputs.Tables.Add(table);


        // Now define the outputs.
        System.Data.DataSet outputs = new System.Data.DataSet();
        String tableB = System.Guid.NewGuid().ToString();
        table = new System.Data.DataTable(tableB);
        table.Columns.Add(new System.Data.DataColumn("SomeName", System.Type.GetType("System.String")));
        table.Columns.Add(new System.Data.DataColumn("SomeValue", System.Type.GetType("System.Int32")));
        outputs.Tables.Add(table);

        // Now fill in the queue names so the MetraFlow program knows where to look.
        String programText = String.Format(programTextFormat, tableA, tableB);

        MetraTech.Dataflow.MetraFlowProgram p = new MetraTech.Dataflow.MetraFlowProgram(programText, inputs, outputs);

        // Create input data
        System.Data.DataRow row1, row2;
        row1 = inputs.Tables[tableA].NewRow();
        row1["SomeName"] = "Hello";
        row1["SomeValue"] = 10;
        inputs.Tables[tableA].Rows.Add(row1);

        row2 = inputs.Tables[tableA].NewRow();
        row2["SomeName"] = "World";
        row2["SomeValue"] = 11;
        inputs.Tables[tableA].Rows.Add(row2);

        p.Run(); 

        System.Console.WriteLine("Output:");

        // Now the output data is populated.
        // There should be 2 rows.
        for(int i=0; i lessThan outputs.Tables[tableB].Rows.Count; i++)
        {
          System.Console.WriteLine("SomeName={0}; SomeValue={1}",
                                  outputs.Tables[tableB].Rows[i]["SomeName"],
                                  outputs.Tables[tableB].Rows[i]["SomeValue"]);
        }

        System.Console.WriteLine("Done.");
      }
      catch (Exception ex)
      {
        System.Console.WriteLine("Received expected exception: " + ex);
      }
  }
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Inner Hash Join Operator</displayname>
        <description>Performs an inner hash join of inputs based on equijoin keys and an optional predicate.
        The inner join creates a new result table by combining column values of two tables (A and B) based 
        upon the join-predicate. The query compares each row of A with each row of B to find all pairs of 
        rows that satisfy the join-predicate. When the join-predicate is satisfied, column values for each
        matched pair of rows of A and B are combined into a result row. One input port is named "table".  
        This input data is stored in a hash map while the operator is executing.  Carefully consider the
        size of this input to make sure it does not exceed the memory of the system.  The operator performs
        separate inner joins with each of the other input ports.  For example, suppose you wanted to inner-join 
        table A with table B and also inner-join table A with table C.  In this case, you would have 
        3 input ports: "table" (table A), "probe(0)" (table B), and "probe(1)" (table C). You would also need
        to specify two probe keys for the join.  The operator would produce two output ports: 
        "output(0)" (join of A and B), and "output(1)" (join of A and C).  </description>
        <metraflowname>inner_hash_join</metraflowname>
        <argument>
            <argname>probeKey</argname>
            <argunlimited>true</argunlimited>
            <argtype>String</argtype>
            <argdescription>Name of an equijoin key from the probe input.</argdescription>
        </argument>
        <argument>
            <argname>residual</argname>
            <argtype>String</argtype>
            <argdescription>Non-equijoin predicate expressed as a BOOLEAN-valued MTSQL function.
                            If specified, only records that evaluate to true
                            are sent to the output.
            </argdescription>
        </argument>
        <argument>
            <argname>tableKey</argname>
            <argunlimited>true</argunlimited>
            <argtype>String</argtype>
            <argdescription>Name of an equijoin key from the table input.</argdescription>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>table</inputname>
                <inputnumber>0</inputnumber>
            </input>
            <inputunbounded>
                <inputname>probe</inputname>
                <inputnumber>*</inputnumber>
            </inputunbounded>
        </inputs>
        <outputs>
            <outputlimited mustequal="probe">
                <outputname>output</outputname>
                <outputnumber>*</outputnumber>
            </outputlimited>
        </outputs>
        <example>
<!--
An example:
<pre>
<font color="#0000AA">
a: generate [
  program = 
    "CREATE PROCEDURE gen @a BIGINT @b INTEGER 
     AS
       SET @a = @@RECORDCOUNT
       SET @b = CAST(@@RECORDCOUNT AS INTEGER) % 2",
  numRecords = 4];

b: generate [
  program = "CREATE PROCEDURE gen @d BIGINT @e INTEGER 
             AS
              SET @d = @@RECORDCOUNT
              SET @e = CAST(@@RECORDCOUNT AS INTEGER)",
  numRecords = 4];

j:inner_hash_join [tableKey="b", probeKey="e"];

p1: print[];
p2: print[];
p3: print[numToPrint=50];
devNull;
a -> p1 -> j("table");
b -> p2 -> j("probe(0)");
j -> p3 -> devNull;
</font>
</pre>
The output from this example is:
<pre>
<font color="#0000AA">
a:0, b:0
a:1, b:1
a:2, b:0
a:3, b:1
d:0, e:0
d:1, e:1
d:2, e:2
d:3, e:3
a:0, b:0, d:0, e:0
a:2, b:0, d:0, e:0
a:1, b:1, d:1, e:1
a:3, b:1, d:1, e:1

</font>
</pre>
Another example:
<pre>
<font color="#0000AA">
a: import[filename="test_data1",
          format="myRec (
               nm_login text_delimited_nvarchar(delimiter='|'),
               nm_space text_delimited_nvarchar(delimiter='|'),
               id_acc text_delimited_base10_int32(delimiter='|'))",
          mode="sequential"];

b: import[filename="test_data2",
          format="myRec (
               av_id_acc text_delimited_base10_int32(delimiter='|'),
               c_paymentmethod text_delimited_base10_int32(delimiter='|'),
               c_currency text_delimited_nvarchar(delimiter='|'))",
          mode="sequential"];

j:inner_hash_join [tableKey="id_acc", probeKey="av_id_acc",
                   residual="CREATE FUNCTION f (@id_acc INTEGER @av_id_acc INTEGER) 
                             RETURNS BOOLEAN AS RETURN @id_acc = 124 " ];
print[numToPrint=100];
devNull;
a -> j("table");
b -> j("probe(0)");
j -> print -> devNull;

The output from this example is:
    nm_login:hanzel, nm_space:mt, id_acc:124, av_id_acc:124, c_paymentmethod:405, c_currency:USD
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Inner Merge Operator</displayname>
        <description>Performs an inner join of sorted inputs based on equijoin keys and an optional predicate.
        An inner join creates a new result table by combining column values of two tables (A and B) based upon
        the join-predicate. The query compares each row of A with each row of B to find all pairs of rows 
        which satisfy the join-predicate. 
        When the join-predicate is satisfied, column values for each matched pair of rows of A and B 
        are combined into a result row.
        An in addition to joining, this operator can be used to nest parent/child records.
        NOTE: the left and right inputs to the operator must be sorted by the
              specified keys otherwise the results are undefined.
        </description>
        <metraflowname>inner_merge_join</metraflowname>
        <argument>
            <argname>leftKey</argname>
            <argunlimited>true</argunlimited>
            <argtype>String</argtype>
            <argdescription>Name of an equijoin key from the left input.</argdescription>
        </argument>
        <argument>
            <argname>residual</argname>
            <argtype>String</argtype>
            <argdescription>Non-equijoin predicate expressed as a BOOLEAN-valued MTSQL function.
                            If specified, only records that evaluate to true
                            are sent to the output.
            </argdescription>
        </argument>
        <argument>
            <argname>rightKey</argname>
            <argunlimited>true</argunlimited>
            <argtype>String</argtype>
            <argdescription>Name of an equijoin key from the right input.</argdescription>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <argument>
            <argname>nest</argname>
            <argtype>String</argtype>
            <argdescription>
              If this argument is present, then records from the right
              input will be nested under records from the left.
              This argument specifies the name that should be given
              to the nested record.  See the example below.
            </argdescription>
        </argument>
        <inputs>
            <input>
                <inputname>left</inputname>
                <inputnumber>0</inputnumber>
                <inputdescription>
                If this operator is being used to nest,
                the left input should be the parent records.
                </inputdescription>
            </input>
            <input>
                <inputname>right</inputname>
                <inputdescription>
                If this operator is being used to nest,
                the right input should be the children records.
                </inputdescription>
                <inputnumber>1</inputnumber>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
        <example>
<!--
An example:
<pre>
<font color="#0000AA">
left: generate [
  program =
    "CREATE PROCEDURE gen
      @deptNo INTEGER
      @deptCount INTEGER
  AS
    SET @deptNo = CAST(@@RECORDCOUNT AS INTEGER)
    SET @deptCount = CAST(@@RECORDCOUNT AS INTEGER) + 10",
  numRecords = 5];

right: generate [
  program =
    "CREATE PROCEDURE gen
      @employeeNo INTEGER
      @deptNo1 INTEGER
  AS
    SET @employeeNo = CAST(@@RECORDCOUNT AS INTEGER) + 1000
    SET @deptNo1 = CAST(@@RECORDCOUNT AS INTEGER) % 5",
  numRecords = 5];

inner_merge_join [leftKey="deptNo", rightKey="deptNo1"];

p1: print[numToPrint=100];
p2: print[numToPrint=100];
p3: print[numToPrint=100];

s1: sort[key="deptNo"];
s2: sort[key="deptNo1"];

devNull;

left -> s1 -> p1 -> inner_merge_join("left");
right -> s2 -> p2 -> inner_merge_join("right");

inner_merge_join -> p3 -> devNull;
  
</font>
</pre>
The output:
<pre>
<font color="#0000AA">
deptNo:0, deptCount:10
deptNo:1, deptCount:11
deptNo:2, deptCount:12
deptNo:3, deptCount:13
deptNo:4, deptCount:14
employeeNo:1000, deptNo1:0
employeeNo:1005, deptNo1:0
employeeNo:1001, deptNo1:1
employeeNo:1006, deptNo1:1
employeeNo:1002, deptNo1:2
employeeNo:1007, deptNo1:2
employeeNo:1003, deptNo1:3
employeeNo:1008, deptNo1:3
employeeNo:1004, deptNo1:4
employeeNo:1009, deptNo1:4
deptNo:0, deptCount:10, employeeNo:1000, deptNo1:0
deptNo:0, deptCount:10, employeeNo:1005, deptNo1:0
deptNo:1, deptCount:11, employeeNo:1001, deptNo1:1
deptNo:1, deptCount:11, employeeNo:1006, deptNo1:1
deptNo:2, deptCount:12, employeeNo:1002, deptNo1:2
deptNo:2, deptCount:12, employeeNo:1007, deptNo1:2
deptNo:3, deptCount:13, employeeNo:1003, deptNo1:3
deptNo:3, deptCount:13, employeeNo:1008, deptNo1:3
deptNo:4, deptCount:14, employeeNo:1004, deptNo1:4
deptNo:4, deptCount:14, employeeNo:1009, deptNo1:4
</font>
</pre>
A nesting example:
<pre>
<font color="#0000AA">
right: generate [
  program = 
    "CREATE PROCEDURE gen 
      @confId INTEGER 
      @accountId INTEGER 
  AS
    SET @confId = CAST(@@RECORDCOUNT AS INTEGER)
    SET @accountId = CAST(@@RECORDCOUNT AS INTEGER) + 10",
  numRecords = 5];

left: generate [
  program = 
    "CREATE PROCEDURE gen 
      @confId1 INTEGER 
      @confLegId INTEGER 
  AS
    SET @confId1 = CAST(@@RECORDCOUNT AS INTEGER) % 5
    SET @confLegId = CAST(@@RECORDCOUNT AS INTEGER) % 2",
  numRecords = 10];

inner_merge_join [rightKey="confId", leftKey="confId1", nest="children"];

p1: print[label= "parent: ", numToPrint=100];
p2: print[label= "child:  ", numToPrint=100];
p3: print[label= "result: ", numToPrint=100];

s1: sort[key="confId"];
s2: sort[key="confId1"];

devNull;

right -> s1 -> p1 -> inner_merge_join("right");
left -> s2 -> p2 -> inner_merge_join("left");

inner_merge_join -> p3 -> devNull;
</font>
</pre>
The output:
<pre>
<font color="#0000AA">
parent: confId:0, accountId:10
parent: confId:1, accountId:11
parent: confId:2, accountId:12
parent: confId:3, accountId:13
parent: confId:4, accountId:14
child:  confId1:0, confLegId:0
child:  confId1:0, confLegId:1
child:  confId1:1, confLegId:1
child:  confId1:1, confLegId:0
child:  confId1:2, confLegId:0
child:  confId1:2, confLegId:1
child:  confId1:3, confLegId:1
child:  confId1:3, confLegId:0
child:  confId1:4, confLegId:0
child:  confId1:4, confLegId:1
result: confId:0, accountId:10, children:[
    [confId1:0, confLegId:0], 
    [confId1:0, confLegId:1]
]
result: confId:1, accountId:11, children:[
    [confId1:1, confLegId:1], 
    [confId1:1, confLegId:0]
]
result: confId:2, accountId:12, children:[
    [confId1:2, confLegId:0], 
    [confId1:2, confLegId:1]
]
result: confId:3, accountId:13, children:[
    [confId1:3, confLegId:1], 
    [confId1:3, confLegId:0]
]
result: confId:4, accountId:14, children:[
    [confId1:4, confLegId:0], 
    [confId1:4, confLegId:1]
]
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Database Insert Operator</displayname>
        <description>
        Inserts data into a database table. 
        This operator is currently limited to inserting into the 
        configured NetMeterStage database.
        You must then copy the table from the NetMeterStage
        database to the NetMeter database.  See the example
        below for how this can be done.
        CAUTION: if the insert operation fails, the only
        indication of failure is an error message written
        to the log, but execution continues.
        </description>
        <metraflowname>insert</metraflowname>
        <argument>
            <argname>table</argname>
            <argtype>String</argtype>
            <argdescription>Name of the database table into which to insert data.</argdescription>
        </argument>
        <argument>
            <argname>schema</argname>
            <argtype>String</argtype>
            <argdescription>Name of the database schema in which the target table resides.</argdescription>
        </argument>
        <argument>
            <argname>createTable</argname>
            <argtype>Boolean</argtype>
            <argdescription>
              If set to true, the table will be dropped (if it exists) and
              created. The created table format is based on
              the input record format.
              </argdescription>
        </argument>
        <argument>
            <argname>batchSize</argname>
            <argtype>Integer</argtype>
            <argdescription>The number of records to batch in the operator before sending to the server. Depending on the 
            database interface used, this may only be a guideline. (For example, SQL Server BCP may send data before the 
            configured batch size has been reached.)</argdescription>
        </argument>
        <argument>
            <argname>transactionKey</argname>
            <argtype>String</argtype>
            <argdescription>Name of the input key that contains an abstract transaction identifier. The operator assumes
            that input data is grouped (though not necessarily sorted) by the transactionKey. When this property is set,
            the operator will create a temporary table for every transaction identifier and will output the name of that
            temporary table upon key changes.</argdescription>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
            </input>
        </inputs>
        <outputs>
            <output isoptional="true">
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
        <example>
<!--
An example:
<pre>
<font color="#0000AA">

  /* Generate the data you want to insert. */
  /* Note that the table data are the fields "a" and "b". */

input:generate[program="
                 CREATE PROCEDURE p @a INTEGER @b BIGINT
                 AS
                 SET @a = CAST(@@RECORDCOUNT AS INTEGER)
                 SET @b = @@RECORDCOUNT",
                 numRecords=100];

/****
 * Here is the example of how you insert into NetMeter
 *
 * Right now the inserter only writes to NetMeterStage so we have
 * to execute some SQL from MetraFlow to move the data into the NetMeter
 * database.  This is actually a bit subtle because we have to mimic control
 * flow (e.g. write to NetMeterStage and when you are done, execute the SQL)
 * using dataflow.  This is done using a control flow token which is the
 * id_commit_unit column we create.
 * Essentially this token identifies a transactional
 * unit of work that we want the sql_exec_direct operator use.  Note that this
 * is exactly what the meter operator is doing under the wraps.
 */

 /* Bucket all of the data into a single unit of work */
 /* which is identified by the integer 1 */

txn:expr[program="CREATE PROCEDURE e @a INTEGER @id_commit_unit INTEGER OUTPUT
                  AS
                  SET @id_commit_unit = @a/8"];

/* Copy because we need the data to insert and */
/* we need to create the control token/record. */

c:copy[]

/**
 * Note that the insert will not actually put any data
 * in the staging database table you create though
 * (it will use some additional temporary
 * tables that are dynamically created
 * from it).
 */

i:insert[table="t_simple_insert_net_meter",
         schema="NetMeter", transactionKey="id_commit_unit",
         batchSize=7, createTable=true];

/* Here we create the control record */

sgb:sort_group_by[key="id_commit_unit",
                  initialize="CREATE PROCEDURE i @size_0 INTEGER
                              AS
                              SET @size_0 = 0",
                  update="CREATE PROCEDURE u @size_0 INTEGER
                          AS
                          SET @size_0 = @size_0 + 1"];


/* Glue it all together; it should all be clear by now  */

input -> txn -> c;

/**
 * Execute the sql.  Note that this example is for SQL Server;
 * As previously mentioned, the actual data will be placed into temporary
 * tables that are created dynamically,
 * the insert will pass that name to this operator
 * which will INSERT INTO SELECT FROM and delete the dynamic table.
 */

commit_stuff:sql_exec_direct[
  statementList=[
    query="INSERT INTO NetMeter..t_simple_insert_net_meter SELECT * FROM %%%NETMETERSTAGE_PREFIX%%%%1%",
    postprocess="DROP TABLE %%%NETMETERSTAGE_PREFIX%%%%1%"]];

p1: print[];

c(0) -> sgb -> p1 -> commit_stuff("control");
c(1) -> i -> commit_stuff("input(0)");

</font>
</pre>
The output:
<pre>
<font color="#0000AA">
id_commit_unit:1, size_0:8
id_commit_unit:2, size_0:8
id_commit_unit:3, size_0:8
id_commit_unit:4, size_0:8
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Load Error</displayname>
        <description>
            load_error can be used to write to the db message queue
	    (tables: t_message, t_session_set, t_session, t_svc_*)
	    and to failed transaction (t_failed_transaction) to 
	    record that a received transaction could not be processed.
	    The overall scenario for this is you are running a metraflow
	    script to perform rating and an error occurs.  When metraflow
	    rates, the incoming transaction data is in text files and
	    is NOT written to the db_message_queue.  When an error
	    occurs, we then must write the transaction data out and
	    reference it in t_failed_transactions.
	    The basic structure of load_error is that it takes 4
	    input ports ("message", "session_set", "failed_transaction",
	    and "service").  These ports should contain the columns
	    that should be written to the tables.  See port descriptions
	    below for more information.
	    This operator is sometimes used with operator
	    prepareToReportTransactionError which helps to prepare the
	    input ports (see example below).
        </description>
        <metraflowname>load_error</metraflowname>
        <argument>
            <argname>service</argname>
            <argtype>String</argtype>
            <argdescription>The name of the service definition.
            </argdescription>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>message</inputname>
                <inputnumber>0</inputnumber>
                <inputfield>
                  <inputfieldname>id_message</inputfieldname>
                  <inputfielddescription>
			  Contains the id_message to write to
			  t_message
                  </inputfielddescription>
                </inputfield>
            </input>
            <input>
                <inputname>session_set</inputname>
                <inputnumber>1</inputnumber>
                <inputfield>
                  <inputfieldname>id_ss</inputfieldname>
                  <inputfielddescription>
			  Contains the id_ss to write to t_session_set.
                  </inputfielddescription>
                </inputfield>
                <inputfield>
                  <inputfieldname>session_count</inputfieldname>
                  <inputfielddescription>
			  Contains the session_count to write to t_session_set.
                  </inputfielddescription>
                </inputfield>
                <inputfield>
                  <inputfieldname>id_message</inputfieldname>
                  <inputfielddescription>
			  Contains the id_message to write to t_session_set.
                  </inputfielddescription>
                </inputfield>
            </input>
            <input>
                <inputname>failed_transaction</inputname>
                <inputnumber>2</inputnumber>
		<inputdescription>
			Should contain the columns to write to
			t_failed_transaction.
		</inputdescription>
            </input>
            <input>
                <inputname>service</inputname>
                <inputnumber>3</inputnumber>
		<inputdescription>
			Should contain the columns to write to
			t_svc_* and t_session.
		</inputdescription>
                <inputfield>
                  <inputfieldname>*</inputfieldname>
                  <inputfielddescription>
			  All the service definition columns preceded
			  by c_.
                  </inputfielddescription>
                </inputfield>
                <inputfield>
                  <inputfieldname>id_source_sess</inputfieldname>
                  <inputfielddescription>
			  The id_source_sess to write to t_svc_*
			  and to t_session.
                  </inputfielddescription>
                </inputfield>
                <inputfield>
                  <inputfieldname>id_ss</inputfieldname>
                  <inputfielddescription>
			  The id_ss to write to t_session.
                  </inputfielddescription>
                </inputfield>
            </input>
        </inputs>
        <example>
<!--
An example:
<pre>
<font color="#0000AA">
include "prepareToReportTransactionError.mfs"

createErrorCounter: generate[
    program="
      CREATE PROCEDURE p 
        @_ErrorCounter INTEGER OUTPUT
      AS
        SET @_ErrorCounter = 1",
      numRecords=1];

createTransaction: expr[
    program="
      CREATE PROCEDURE p
        @id_source_sess      BINARY   OUTPUT
        @c_ticketspurchased  DECIMAL  OUTPUT
        @c_transactiontime   DATETIME OUTPUT
        @c_moviename         NVARCHAR OUTPUT
        @c_popcorns          DECIMAL  OUTPUT
        @c_payer             NVARCHAR OUTPUT
        @c_transactionID     NVARCHAR OUTPUT
      AS
        SET @id_source_sess     = CAST(0xB AS BINARY)
        SET @c_ticketspurchased = 1
        SET @c_transactiontime  = CAST('2 SEP 2010' AS DATETIME)
        SET @c_moviename        = N'The Godfather'
        SET @c_popcorns         = 3
        SET @c_payer            = N'Marlon Brando'
        SET @c_transactionID    = N'Fandango1a8332'",
    mode="sequential"];

createErrorCounter -> createTransaction;

/* 
 * We are pretending at this point we have
 * a failure.
 */

createError: expr[
    program="
      CREATE PROCEDURE p 
        @id_source_sess        BINARY
        @_ErrorCode            INTEGER OUTPUT
        @_ErrorString          NVARCHAR OUTPUT
        @_Plugin               NVARCHAR OUTPUT
        @_Module               NVARCHAR OUTPUT
        @SessionID             BINARY OUTPUT
      AS
        SET @_ErrorCode            = 3
        SET @_ErrorString          = N'Cannot find subscriber'
        SET @_Plugin               = N'SubscriberLookup'
        SET @_Module               = N'Some module'
        SET @SessionID             = @id_source_sess
        "];

createTransaction -> createError;

prepareError: prepareToReportTransactionError[];

createError -> prepareError;

storeTransaction: load_error[service="metratech.com/movietickets"];

prepareError("failed_transaction")  -> storeTransaction("failed_transaction");
prepareError("session_set")  -> storeTransaction("session_set");
prepareError("message") -> storeTransaction("message");
prepareError("service") -> storeTransaction("service");

</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Longest Prefix Match Operator</displayname>
        <description>Returns rows where the test key matches the beginning of the probe key</description>
        <metraflowname>longest_prefix_match</metraflowname>
        <argument>
            <argname>probeKey</argname>
            <argtype>String</argtype>
            <argunlimited>true</argunlimited>
            <argdescription>Name of an equijoin key from the probe input. Must be NVARCHAR</argdescription>
        </argument>
        <argument>
            <argname>tableKey</argname>
            <argunlimited>true</argunlimited>
            <argtype>String</argtype>
            <argdescription>Name of an equijoin key from the table input.  Must be NVARCHAR</argdescription>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>table</inputname>
                <inputnumber>0</inputnumber>
            </input>
            <input>
                <inputname>probe</inputname>
                <inputnumber>1</inputnumber>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
    </operator>
    <operator>
        <displayname>MD5 Hash</displayname>
        <description>Creates an MD5 hash</description>
        <metraflowname>md5</metraflowname>
        <argument>
            <argname>key</argname>
            <argunlimited>true</argunlimited>
            <argtype>String</argtype>
            <argdescription>Hash key.</argdescription>
        </argument>
        <argument>
            <argname>output</argname>
            <argtype>String</argtype>
            <argdescription>Output key.</argdescription>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
    </operator>
    <operator>
        <displayname>Metering Operator</displayname>
    <description>
    Inserts data into the service tables of a MetraNet metering database. 
    The data is insert in anticipation of the 
    pipeline reading the data and rating.
    The operator meters both atomic and multipoint services. 
    For multipoint services 
    the parent and children are assumed to be in different 
    input streams. In those cases there is 
    assumed to be a natural primary key on 
    parent records and that child records have 
    a foreign-key relationship to their parent.
    The operator assumes that input data has 
    been grouped (not necessarily sorted) on this key.
    The operator currently supports only a simple 
    primary key for the parent record.
    The specific tables that are inserted into are: 
    t_session, t_svc_..., t_message, and t_session_set.
    Make sure that the NetMeterStage database contains
    the tables t_session, t_session_set, and t_message.
    These tables can be created by hitting the listener.
    The meter operator can have an optional output port
    which gives information about the metered records.
    As MetraFlow chugs through the data, it is actually writing 
    to NetMeterStage db (not NetMeter).  If something goes wrong (bad file format, insert fails) 
    the whole thing is thrown away.  If MF gets through all the records, 
    then the last step is to copy the NetMeterStage tables to NetMeter.
    The meter operator does little to no auditing on the file being metered.  
    The operator can write the BatchID (if provided) 
    into the t_svc table (column collectionID).
    The auditing is done by the pipeline when it does the rating.  
    The pipeline gets the batchID and updates that batchID statistics 
    as it processes the records.  The pipeline writes any failed transactions.
    
        </description>
        <metraflowname>meter</metraflowname>
        <argument>
            <argname>service</argname>
            <argtype>String</argtype>
            <argdescription>
                Service definition to which the input corresponds. 
                The number of service
                specifications must equal the number of inputs.
                An example: "metratech.com/Payment".
            </argdescription>
        </argument>
        <argument>
            <argname>key</argname>
            <argtype>String</argtype>
            <argdescription>
            This argument is only needed for multipoint metering
            (parent/children).
            If you are metering multipoint (parent/children), then
            you must specify how to relate parent and children
            by column keys.  The first key you specify is the
            parent key.  Next, you must specify a key for each
            child service definition.  These means the number
            of keys must equal the number of input ports.
            The keys must be specified
            in the order matching the port numbering for the
            child input ports being sent to the operator.
        </argdescription>
        </argument>
        <argument>
            <argname>authorization</argname>
            <argtype>String</argtype>
            <argdescription>
               Describes the type of authorization data,
               if any, that should be written to the t_message
               table.
            </argdescription>
            <argvalue>
              <argvaluename>user</argvaluename>
              <argvaluedescription>
               The last input port of the
               meter operator must contain a single row with the columns 
               "user", "namespace", and "password".  
               The input data must be
               strings containing unicode characters (although the
               type is NVARCHAR), since the authorization data is
               ultimately written to columns of type VARCHAR in t_message.
              </argvaluedescription>
            </argvalue>
            <argvalue>
              <argvaluename>serialized</argvaluename>
              <argvaluedescription>
               The last input port of the meter
               operator must contain a single row with the column
               "serialized". 
               The input data must be
               strings containing unicode characters (although the
               type is NVARCHAR), since the authorization data is
               ultimately written to columns of type VARCHAR in t_message.
              </argvaluedescription>
            </argvalue>
            <argvalue>
              <argvaluename>none</argvaluename>
              <argvaluedescription>
                Nulls are written for the authorization data in the
                t_message table.
              </argvaluedescription>
            </argvalue>
            <optional>true</optional>
            <default>none</default>
        </argument>
        <argument>
            <argname>targetCommitSize</argname>
            <argtype>Integer</argtype>
            <argdescription>
                Number of records between transactional 
                commits into the metering database.
                Note that in the case of multipoint services, 
                the operator guarantees that parent and children
                records are committed in the same transaction 
                - hence, this value may be exceeded out of necessity
                when multipoints are metered.
            </argdescription>
        </argument>
        <argument>
            <argname>targetMessageSize</argname>
            <argtype>Integer</argtype>
            <argdescription>
                Number of records in a MetraNet message. 
                Note that in the case of multipoint services, 
                MetraNet guarantees that parent and children 
                records are in the same message, hence this value may be
                exceeded out of necessity when multipoints are metered.
            </argdescription>
        </argument>
        <argument>
            <argname>collectionID</argname>
            <argtype>String</argtype>
            <argdescription>
                Batch identifier to be used when metering with batches. 
                This value is a 16-byte quantity 
                represented in hexadecimal format.
                The meter operator does not update the batch information.
                Batch information is updated when the pipeline processes
                the meter data.
                Example: collectionID=0xC0A80145A5F8256C3FCAD6D74BBDDCFC;
            </argdescription>
        </argument>
        <argument>
            <argname>collectionIDEncoded</argname>
            <argtype>String</argtype>
            <argdescription>
                Batch identifier to be used when metering with batches. 
                This value is a base64 encoded 16-byte quantity.
                The meter operator does not update the batch information.
                Batch information is updated when the pipeline processes
                the meter data.
                Example: collectionIDEncoded="Csj8G/k7zO1qLVCPxP1veg=="
            </argdescription>
        </argument>
        <argument>
            <argname>generateSummaryTable</argname>
            <argtype>Boolean</argtype>
            <argdescription>
                If set to true, then the operator will create a 
                table named tmp_meter_summary_log in the staging
                database.  If the table already
                exists, then the table will be drop and re-added.
                Do not use this flag if you are running more multiple
                instances of the script (collision will occur).
                This table contains the columns id_commit_unit, size_0.
                This can be used to determine the number of records
                that were meter.  This is used by the aggregrate rating
                adapter (see config/Queries/ProductCatalog/CommonQueries.xml).
              </argdescription>
            <optional>true</optional>
            <default>true</default>
        </argument>
        <argument>
            <argname>areEnumsBeingUsed</argname>
            <argtype>Boolean</argtype>
            <argdescription>
                If set to false, this means enum data arriving to
                the meter operator will have the datatype integer
                rather than enum.  This can happen when the data
                being meter is coming from import_queue.  Import_queues
                use DataSets which support datatype integer but not
                enum.
              </argdescription>
            <optional>true</optional>
            <default>true</default>
        </argument>
        <argument>
            <argname>isAuthorizationNeeded</argname>
            <argtype>Boolean</argtype>
            <argdescription>
                If set to true, then there must be an additional
                input port containing a single row of authorization
                data to be written to t_message.  The columns must
                be "user", "namespace", "password", and "serialized".
                They can be null or strings but the strings must
                not contain multibyte characters since they are
                ultimately written as VARCHARs.
                This argument defaults to false.
              </argdescription>
            <optional>true</optional>
            <default>false</default>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>parent</inputname>
                <inputnumber>0</inputnumber>
                <inputdescription>
                The parent input port must contain all
                the columns specified in the service definition.
                These are typical columns that have c_ prefix.
                If the value of the
		        column is NULL, then the default value as specified
		        in the service definition will be applied.
                These are the values that are inserted into
                the t_svc_... table.
                </inputdescription>
            </input>
            <inputlimited mustequal="service">
                <inputname>child</inputname>
                <inputnumber>*</inputnumber>
                <inputdescription>
                The child input port must contain all
                the columns specified in the service definition
                for the child.
                These are typical columns that have c_ prefix.
                These are the values that are inserted into
                the t_svc_... table.
                If authorization was specified 
                then the last port must contain
                the authorization information.
                </inputdescription>
            </inputlimited>
        </inputs>
        <outputs>
            <output>
                <outputnumber>0</outputnumber>
                <outputdescription>
                  The Meter operator can optionally have an output port.
                  The output port contains that fields that are
                  written to the t_message table.
                </outputdescription>
            </output>
        </outputs>
        <example>
<!--
An example:
<pre>
<font color="#0000AA">
readTravel: import[
  filename="travelSpotUsage.csv",
    format="myRec (
      c_account       text_delimited_nvarchar(delimiter=','),
      c_duration       text_delimited_base10_decimal(delimiter=','),
      c_language       text_delimited_enum(enum_space='travelspot.com/TravSpotEnums', enum_type='Languages', delimiter=','),
      c_ConferenceID   text_delimited_base10_int32(delimiter=','),
      c_ConferenceName text_delimited_nvarchar(delimiter=crlf))",
    mode="sequential"];

meterTravel: meter[service="travelspot.com/TranslationService",
                   collectionID=0xC0A80145A5F8256C3FCAD6D74BBDDCFC];

readTravel -> meterTravel
</font>
</pre>
The datafile corresponding to this example is:
<pre>
<font color="#0000AA">
jcook,20,French,1001,Team Meeting
jcook,44,German,1002,Sales Conference
jcook,105,German,1003,Europe Team Teleconference
jcook,10,Spanish,1004,Customer Planning Conference

</font>
</pre>
Another single point example:
<pre>
<font color="#0000AA">
read: import[
  filename="test_meter2.data",
    format="myRec (
      c_ticketspurchased  text_delimited_base10_decimal(delimiter=','),
      c_transactiontime   iso8601_datetime(delimiter=','),
      c_moviename         text_delimited_nvarchar(delimiter=','),
      c_popcorns          text_delimited_base10_decimal(delimiter=','),
      c_payer            text_delimited_nvarchar(delimiter=','),
      c_transactionID     text_delimited_nvarchar(delimiter=crlf))",
    mode="sequential"];
testMeter: meter[service="metratech.com/movietickets"];
printResult: print[label="\nMeter Output:\n",
                   fieldSeparator="\n"];
devNull: devNull[];
read -> testMeter -> printResult -> devNull;
</font>
</pre>
Results:
<pre>
<font color="#0000AA">
Meter Output:
id_commit_unit: 0
id_message: 3000
size_0: 1
dt_crt: 3/21/2011 2:20:17 PM
dt_metered: 3/21/2011 2:20:17 PM
tx_ip_address: 127.0.0.1
</font>
</pre>
A multipoint (parent/child) example:
<pre>
<font color="#0000AA">
Conf_Rename:rename[
    from="res_id",          to="c_res_id",
    from="ace_conf_id",     to="c_conf_id",
    from="conf_name",       to="c_conf_name",
    from="conf_type",       to="c_conf_type_str",
    from="conf_sub_type",   to="c_conf_sub_type_str",
    from="owner_number",    to="c_owner_number",
    from="res_name",        to="c_res_name",
    from="res_time",        to="c_res_time",
    from="timezone_code",   to="c_timezone_code",
    from="pac_code",        to="c_pac_code",
    from="rate_flag",       to="c_rate_flag_str",
    from="company_name",    to="c_company_name",
    from="ldr_dest_number", to="c_ldr_dest_number",
    from="ldr_origin_number", to="c_ldr_origin_number",
    from="ldr_up_id",       to="c_ldr_udr_id",
    from="ldr_name",        to="c_ldr_name",
    from="ldr_call_type",   to="c_ldr_call_type_str",
    from="folo_start_time", to="c_folo_start_time",
    from="folo_end_time",   to="c_folo_end_time",
    from="max_part_duration", to="c_max_part_duration",
    from="scheduled_legs",  to="c_scheduled_ports",
    from="dt_crt",          to="c_batch_date",
    from="wholesaler_flag", to="c_wholesaler_flag",
    from="bu_id",           to="c_bu_id",
    from="ws_owner_number", to="c_ws_owner_number"
];

sConn:select[baseQuery="%%ConnQuery%%"];

Conn_Rename:rename[
    from="res_id", to="c_res_id",
    from="base_billing_code", to="c_premium_bill_code_str",
    from="billing_code", to="c_bill_code_str",
    from="part_start_time", to="c_part_start_time",
    from="part_end_time", to="c_part_end_time",
    from="rurd_duration", to="c_rurd_duration",
    from="leg_id", to="c_udr_id",
    from="call_type", to="c_call_type_str",
    from="bln_intl_call", to="c_intl_call",
    from="line_name", to="c_line_name",
    from="int_line_number", to="c_line_number",
    from="bln_moderator_code", to="c_moderator_code",
    from="origin_number", to="c_origin_number",
    from="dest_number", to="c_dest_number",
    from="country_code", to="c_surcharge_code_str",
    from="bln_call_reconnect", to="c_call_reconnect",
    from="extract_date", to="c_extract_date",
    from="bln_rebill_flag", to="c_rebill_flag",
    from="folo_duration", to="c_folo_duration",
    from="orig_country_code", to="c_orig_country_code",
    from="second_duration", to="c_second_duration",
    from="product_type", to="c_prod_type_str",
    from="remote_bridge_id", to="c_remote_bridge_id",
    from="bridge_id", to="c_bridge_id",
    from="bridge_number", to="c_bridge_number",
    from="int_bridge_type", to="c_bridge_type",
    from="bridge_state", to="c_bridge_state",
    from="bridge_tz", to="c_bridge_timezone_code",
    from="passcode", to="c_passcode",
    from="wholesaler_flag", to="c_wholesaler_flag",
    from="dt_crt", to="c_batch_date"
];

sConfFeat:select[baseQuery="%%FeatQuery%%"];

Feat_Rename:rename[
    from="res_id", to="c_res_id",
    from="feature_id", to="c_udr_id",
    from="text_mdtr_id", to="c_mdtrid",
    from="record_type", to="c_record_type_str",
    from="trans_code", to="c_trans_code_str",
    from="trans_datetime", to="c_trans_datetime",
    from="trans_description", to="c_transdesc",
    from="entry_type", to="c_entry_type_str",
    from="rate_flag", to="c_rate_flag_str",
    from="quantity", to="c_quantity",
    from="cost", to="c_cost",
    from="dec_txn_idetail1", to="c_txn_idetail1",
    from="dec_txn_idetail2", to="c_txn_idetail2",
    from="dec_txn_idetail3", to="c_txn_idetail3",
    from="dec_txn_idetail4", to="c_txn_idetail4",
    from="dec_txn_idetail5", to="c_txn_idetail5",
    from="txn_cdetail1", to="c_txn_cdetail1",
    from="txn_cdetail2", to="c_txn_cdetail2",
    from="txn_cdetail3", to="c_txn_cdetail3",
    from="txn_cdetail4", to="c_txn_cdetail4",
    from="txn_cdetail5", to="c_txn_cdetail5",
    from="extract_date", to="c_ExtractDate",
    from="wholesaler_flag", to="c_wholesaler_flag",
    from="dt_crt", to="c_batch_date",
    from="owner_number", to="c_owner_number", 
    from="pac_code", to="c_paccode",
    from="company_name", to="c_companyname",
    from="timezone_code", to="c_timezone",
    from="ws_owner_number", to="c_ws_owner_number",
    from="bu_id", to="c_bu_id"
];

m:meter[service="intercall.com/InterCallConference", key="res_key", 
        service="intercall.com/InterCallConnection", key="res_key", 
        service="intercall.com/InterCallFeature", key="res_key", 
        targetMessageSize=900, collectionID=%%BatchID%%];

sConf ->     Conf_Rename -> m(0);
sConn ->     Conn_Rename -> m(1);
sConfFeat -> Feat_Rename -> m(2);
</font>
</pre>

-->
        </example>
    </operator>
    <operator>
        <displayname>Multi Hash Join Operator</displayname>
        <description>Performs several hash joins of different probes against 
          one test table based on equijoin keys and an optional predicate.  
          NOTE: The table input is loaded into memory. Since the table input 
          is costly in terms of memory, being able to share the table 
          can improve performance.  
        </description>
        <metraflowname>multi_hash_join</metraflowname>
        <argument>
            <argname>probe</argname>
            <argtype>String</argtype>
            <argunlimited>true</argunlimited>
            <argdescription>Type of join to perform.
              "probe" and "probeKey" are repeated for
              each probe input port.
            </argdescription>
            <argvalue> <argvaluename>inner</argvaluename> </argvalue>
            <argvalue> <argvaluename>right</argvaluename> </argvalue>
            <argvalue> <argvaluename>right_outer</argvaluename> </argvalue>
            <argvalue> <argvaluename>right_split</argvaluename> </argvalue>
            <argvalue> <argvaluename>right_outer_split</argvaluename> 
              <argvaluedescription>
          The "right" port is for the probe 
          "right_outer_split." In this mode, the operator performs an outer 
          join. But instead of spitting out the non-matching rows on the 
          primary output (with NULLs for the table columns), it outputs the 
          non-matching probe to a separate output port.
              </argvaluedescription>
            </argvalue>
            <argvalue> <argvaluename>right_semi</argvaluename> </argvalue>
            <argvalue> <argvaluename>right_anti_semi</argvaluename> </argvalue>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <argument>
            <argname>probeKey</argname>
            <argunlimited>true</argunlimited>
            <argtype>String</argtype>
            <argdescription>Name of an equijoin key from the probe input.</argdescription>
        </argument>
        <argument>
            <argname>residual</argname>
            <argtype>String</argtype>
            <argdescription>Non-equijoin predicate expressed as a BOOLEAN-valued MTSQL function.
                            If specified, only records that evaluate to true
                            are sent to the output.
            </argdescription>
        </argument>
        <argument>
            <argname>tableKey</argname>
            <argtype>String</argtype>
            <argdescription>Name of an equijoin key from the table input.</argdescription>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>table</inputname>
                <inputnumber>0</inputnumber>
            </input>
            <inputunbounded>
                <inputname>probe</inputname>
                <inputnumber>*</inputnumber>
            </inputunbounded>
        </inputs>
        <outputs>
            <outputlimited mustequal="probe">
                <outputname>output</outputname>
                <outputnumber>*</outputnumber>
            </outputlimited>
            <outputlimited mustequal="probe">
                <controlledpresence parameter="probeKey">
                    <controlvalue>right split</controlvalue>
                    <controlvalue>right outer split</controlvalue>
                    <controlvalue>right_outer_split</controlvalue>
                </controlledpresence>
                <outputname>right</outputname>
                <outputnumber>*</outputnumber>
            </outputlimited>
        </outputs>
<example>
<!--
An example:
<pre>
<font color="#0000AA">
left:generate[program="CREATE PROCEDURE p @a BIGINT
                       AS SET @a = @@RECORDCOUNT", numRecords = 5];

right:generate[program="CREATE PROCEDURE p @b BIGINT
                        AS SET @b = 2LL*@@RECORDCOUNT", numRecords=10];

right2:generate[program="CREATE PROCEDURE p @c BIGINT AS SET @c = 2LL*@@RECORDCOUNT",
                numRecords=10];

j:multi_hash_join[tableKey="a",
                  probe="right_outer", probeKey="b",
                  probe="inner", probeKey="c" ];

p1:print[];
p2:print[];
p3:print[];
p4:print[];
p5:print[];

d1:devNull[];
d2:devNull[];

left -> p1 -> j("table");
right -> p2 -> j("probe(0)");
right2 -> p3 -> j("probe(1)");

j("output(0)") -> p4 -> d1;
j("output(1)") -> p5 -> d2;
</font>
</pre>
The output:
<pre>
<font color="#0000AA">
a:0
a:1
a:2
a:3
a:4
b:0
b:2
b:4
b:6
b:8
a:0, b:0
a:2, b:2
a:4, b:4
a:NULL, b:6
a:NULL, b:8
c:0
c:2
c:4
c:6
c:8
a:0, c:0
a:2, c:2
a:4, c:4
</font>
</pre>
-->
</example>
    </operator>
    <operator>
        <displayname>Parameter Table Lookup</displayname>
     <description>
          Calculates amount to charge.
          Calculated amount
          is added to the "output" port as a new field.
          See the "output" description below for more details.
          This operator branches the dataflow.
          If there are no errors, then the dataflow continues
          to "output" port.  If there is an error, the dataflows
          continues to "error" port.
     </description>
        <metraflowname>parameter_table_lookup</metraflowname>
        <argument>
            <argname>parameterTable</argname>
            <argunlimited>true</argunlimited>
            <displayName>Parameter Table</displayName>
            <argtype>String</argtype>
         <argdescription>
           Specifies the full qualified name associated with
           the priceable item type.
         </argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>isScheduleUnderParent</argname>
            <argtype>Boolean</argtype>
            <argdescription>
              When working with parent/child records, sometimes the
              parameter table record (output of rate_schedule_lookup)
              is stored under "parent.".  If this is the case,
              set this flag to true.
            </argdescription>
            <optional>true</optional>
            <default>false</default>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value default="true">parallel</value>
            <value>sequential</value>
            <optional>true</optional>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
                <inputdescription>
                  In input record describing the parameter table is required.
                  The record name must match the parameter
                  table specified in the operator argument.
                  If argument "isScheduleUnderParent" is true,
                  This record must be filled in.
                  This is typically done by the operator rate_schedule_lookup.
                </inputdescription>
                <inputfield>
                  <inputfieldname>"name".PORateScheduleID</inputfieldname>
                  <inputfielddescription>Contains the
                  ID of the best non-ICB schedule to use.
                  This ID can be found in the table t_rsched.</inputfielddescription>
                </inputfield>
                <inputfield>
                  <inputfieldname>"name".ICBRateScheduleID</inputfieldname>
                  <inputfielddescription>ID of the best ICB schedule to use or NULL if 
                    there isn't an ICB schedule. This ID can be found in the table t_rsched.
                  </inputfielddescription>
                </inputfield>
                <inputfield>
                  <inputfieldname>"name".ParameterTableName</inputfieldname>
                  <inputfielddescription>The name of the parameter table.</inputfielddescription>
                </inputfield>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
                <outputdescription>
                  Output fields are named with parameter table
                  with the extensions.
                  See the example below.
                </outputdescription>
            </output>
        </outputs>
        <outputs>
            <output>
                <outputname>error</outputname>
                <outputnumber>1</outputnumber>
                <outputdescription>
                  If an error occurs, the dataflow
                  continues out this port rather than
                  port 0 ("output").
                </outputdescription>
           </output>
        </outputs>
        <example>
<!--
This is an example:
<pre>
<font color="#0000AA">
g: generate [
        program =
        "CREATE PROCEDURE gen @myPriceableItemName       NVARCHAR OUTPUT
                              @myAccountID               INTEGER  OUTPUT
                              @myTimestamp               DATETIME OUTPUT
        AS
        SET @myPriceableItemName       = N'Flat Rate Recurring Charge'
        SET @myAccountID               = 1634383330
        SET @myTimestamp               = CAST('23 OCT 2010' AS DATETIME)",
        numRecords = 1];

renameTimestamp: rename[from="myTimestamp", to="Usage.Timestamp"];

g -> renameTimestamp;

/** Subscription Lookup **/
subLookup: subscription_lookup[
        priceableItemName         = "myPriceableItemName",
        priceableItemNameValueType= "fieldReference",
        timestamp                 = "Usage.Timestamp",
    accountId                 = "myAccountID",
        priceableItemTypeID       = "myPriceableItemTypeID",
        priceableItemTemplateID   = "myPriceableItemTemplateID",
        subscription              = "Subscription"
        ];

renameTimestamp -> subLookup("input");

subErrorDevNull: devNull;
subErrorPrint:   print[label="SubscriberError:   ", numToPrint=20];
subLookup("error") -> subErrorPrint -> subErrorDevNull;

/** Rate Lookup **/
rateLookup: rate_schedule_lookup[parameterTable="metratech.com/flatrecurringcharge"];

subLookup("output") -> rateLookup;

rateErrorDevNull: devNull;
rateErrorPrint:   print[label="RateError:   ", numToPrint=20];
rateLookup("error") -> rateErrorPrint -> rateErrorDevNull;

/** Rate Calculation */

rateCalc: parameter_table_lookup[parameterTable="metratech.com/flatrecurringcharge"];

rateLookup("output") -> rateCalc;

calcErrorDevNull: devNull;
calcErrorPrint:   print[label="RateError:   ", numToPrint=20];
rateCalc("error") -> calcErrorPrint -> calcErrorDevNull;

calcOutputDevNull: devNull[];
calcOutputPrint:   print[label="Result:  ", numToPrint=20];
rateCalc("output") -> calcOutputPrint -> calcOutputDevNull;
</font>
</pre>
The output is:
<pre>
<font color="#0000AA">
Result:  
FlatRecurringCharge_icb_id_sched: null,  
FlatRecurringCharge_icb_n_order: null,  
FlatRecurringCharge_icb_RCAmount: null,  
FlatRecurringCharge_icb_id_sub: null,  
FlatRecurringCharge_po_id_sched:424, 
FlatRecurringCharge_po_n_order:0, 
FlatRecurringCharge_po_RCAmount:1.23, 
FlatRecurringCharge_po_id_sub: null,  
id_rs_request_max_score:0, 
FlatRecurringCharge_po_max_score:5494112896, 
FlatRecurringCharge_po_rs:424, 
ums_plm_id_pi_type:212, 
myPriceableItemTemplateID:419, 
ums_s_id_acc:1634383330,
ums_s_id_po:418, 
myPriceableItemTypeID:212, 
ums_nm_name:flat rate recurring charge, 
myPriceableItemName:Flat Rate Recurring Charge, 
myAccountID:1634383330, 
Usage.Timestamp:10/23/2010, 
umsPriceableItemName:flat rate recurring charge, 
Subscription.PriceableItemInstanceID:420, 
Subscription.ProductOfferingID:418, 
Subscription.SubscriptionID:1812999333, 
Subscription.SubscriptionStart:10/22/2010, 
Subscription.SubscriptionEnd:1/1/2038, 
id_rs_request:0, 
FlatRecurringCharge_icb_rs: null,  
_ErrorCode:null,   _ErrorString:null,   _Plugin:null,   _Module:null,   
RCAmount:1.23
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Print operator</displayname>
        <description>Writes record values to the console.  This can be used for debugging.  Arguments can control
        the number of records that are printed and which records are printed.</description>
        <metraflowname>print</metraflowname>
        <argument>
            <argname>numToPrint</argname>
            <argtype>Integer</argtype>
            <argdescription>The number of records from each partition to print.  The default is 5.
            </argdescription>
            <optional>true</optional>
        </argument>
        <argument>
            <argname>label</argname>
            <argtype>String</argtype>
            <argdescription>A label that will be printed before
                            each row that is printed.
            </argdescription>
            <optional>true</optional>
        </argument>
        <argument>
            <argname>fieldSeparator</argname>
            <argtype>String</argtype>
            <argdescription>The separator printed between fields.
                            The default is a comma.
            </argdescription>
            <optional>true</optional>
        </argument>
        <argument>
            <argname>valueSeparator</argname>
            <argtype>String</argtype>
            <argdescription>The separator printed between the field label and the field value.
                            The default is a semi-colon.
            </argdescription>
            <optional>true</optional>
        </argument>
        <argument>
            <argname>logFileOnly</argname>
            <argtype>Boolean</argtype>
            <argdescription>If true, the print message will appear only
                            in the log file (debug level) and will not
                            appear on standard out. The default value
                            is false.
            </argdescription>
            <optional>true</optional>
            <default>false</default>
        </argument>
        <argument>
            <argname>program</argname>
            <argtype>String</argtype>
            <argdescription>A SQL expression giving logic for which records should print.</argdescription>
            <optional>true</optional>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
                <inputdescription>The records to print.</inputdescription>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
                <outputdescription>The output records are simply the unaltered input records.</outputdescription>
            </output>
        </outputs>
        <example>
<!--
In this example, we will only print at most 20 records and
only records where id_acc equals 124.
<pre>
<font color="#0000AA">
  p: print[numToPrint=20, 
           label="My Output Is: \n",
           fieldSeparator=",\n",
           valueSeparator=":  ",
           program="CREATE FUNCTION f (@id_acc INTEGER)  
                    RETURNS BOOLEAN AS @id_acc = 124"];
</font>
</pre>
Sample output:
<pre>
<font color="#0000AA">
My Output Is: 
nm_login:  root, 
nm_space:  mt, 
id_acc:  124
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Projection operator</displayname>
        <description>Lets you select
          which columns in the input stream you would like
          to see in the output stream.  You can also use this
          operator to specify which columns you do NOT want to see.
          The operator does not remove duplicates.</description>
        <metraflowname>project</metraflowname>
        <alias>
            <aliasname>proj</aliasname>
            <aliasname>project</aliasname>
            <aliasname>projection</aliasname>
        </alias>
        <argument>
            <argname>column</argname>
            <argunlimited>true</argunlimited>
            <argtype>String</argtype>
            <argdescription>Name of a column to include in the output.
                            If the inverse argument is set to true,
                            then this is the name of the column you
                            do NOT want to see.
            </argdescription>
        </argument>
        <argument>
            <argname>inverse</argname>
            <argtype>Boolean</argtype>
            <argdescription>If true, performs the inverse of the projection.
                            Instead of column indicating the columns that
                            you want to keep, column indicates the columns
                            that you want to discard.
            </argdescription>
            <optional>true</optional>
            <default>false</default>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
                <inputdescription>The input stream.</inputdescription>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
                <outputdescription>The output stream consists of
                                  the columns identified by the
                                  "column" argument..</outputdescription>
            </output>
        </outputs>
        <example>
<!--
An example:
<pre>
<font color="#0000AA">
i1: import[filename="test_data1",
           format="myRec (
               nm_login text_delimited_nvarchar(delimiter='|'),
               nm_space text_delimited_nvarchar(delimiter='|'),
               id_acc text_delimited_base10_int32(delimiter='|'))",
           mode="sequential"];

projection [column="nm_login", column="nm_space"];
print [numToPrint=5];
devNull;

i1 -> projection -> print -> devNull;
</font>
</pre>
The output:
<pre>
<font color="#0000AA">
nm_login:syntheticroot, nm_space:mt
nm_login:root, nm_space:mt
nm_login:demo, nm_space:mt
nm_login:GL123, nm_space:metratech.com/external
nm_login:hanzel, nm_space:mt
</font>
</pre>
An inverse example:
<pre>
<font color="#0000AA">
i1: import[filename="test_data1",
           format="myRec (
               nm_login text_delimited_nvarchar(delimiter='|'),
               nm_space text_delimited_nvarchar(delimiter='|'),
               id_acc text_delimited_base10_int32(delimiter='|'))",
           mode="sequential"];

projection [column="nm_login", column="nm_space", inverse=true];
print [numToPrint=5];
devNull;

i1 -> projection -> print -> devNull;
</font>
</pre>
The output:
<pre>
<font color="#0000AA">
id_acc:-1
id_acc:1
id_acc:123
id_acc:123
id_acc:124
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Range Partitioner</displayname>
        <description>Redistributes data in a parallel stream based on a range of the values of a configurable set of keys.</description>
        <metraflowname>rangepart</metraflowname>
        <argument>
            <argname>value</argname>
            <argunlimited>true</argunlimited>
            <argtype>Integer</argtype>
            <argdescription>The value for the range.</argdescription>
            <optional>true</optional>
        </argument>
        <argument>
            <argname>key</argname>
            <argunlimited>true</argunlimited>
            <argtype>String</argtype>
            <argdescription>The key to apply the range to.</argdescription>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputdescription>The dataflow to be partitioned.
                </inputdescription>
                <inputnumber>0</inputnumber>
            </input>
            <input>
                <inputname>range</inputname>
                <inputnumber>1</inputnumber>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
    </operator>
    <operator>
        <displayname>Rate Schedule Lookup</displayname>
     <description>
          Looks up rate schedules for the given parameter tables.
	  This operator is given a subscription record (containing
	  details of subscriber's subscription to a priceable item) and
	  the names of parameter tables.  Based on this information,
	  the operator returns the specific rate tables that should be
	  applied.  If your are confused by this, consider that a 
	  parameter table describes a structure, but it is a rate table
	  that actual has filled in values.  For a given parameter table,
	  you may have many rate schedules (for example, different ones
	  are applied depending on the date).  This operator identifies
	  the appropriate rate schedules to use.
	  The operator expects input containing a filled in subscription
	  record (identifies the priceable item), and the 
	  fully qualified names of the parameter
	  tables you are interested in.  
          For each parameter table, this operator determines the best
          rate schedule to use.  Also, this operator determines if
	  there is an ICB rate schedule.  For each given parameter table,
	  these two rate schedules are returned as output.
          See the "output" description below for more details.
          This operator branches the dataflow.
          If there are no errors, then the dataflow continues
          to "output" port.  If there is an error, the dataflows
          continues to "error" port.
     </description>
        <metraflowname>rate_schedule_lookup</metraflowname>
        <argument>
            <argname>parameterTable</argname>
            <argunlimited>true</argunlimited>
            <displayName>Parameter Table</displayName>
            <argtype>String</argtype>
         <argdescription>
           Specifies the full qualified name associated with
           the priceable item type.
         </argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value default="true">parallel</value>
            <value>sequential</value>
            <optional>true</optional>
        </argument>
        <argument>
            <argname>subscription</argname>
            <displayName>Subscription</displayName>
            <argtype>String</argtype>
         <argdescription>
           Specifies the name of the input field that 
           holds the
           subscription record containing information
           about the subscription. Default value: "Subscription"
         </argdescription>
            <optional>false</optional>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
            <inputfield>
              <inputfieldname>Usage.Timestamp</inputfieldname>
              <inputfielddescription>Contains the timestamp of when the
                                     charging event occurred.  The service definition
                                     typically specifies that incoming charging data
                                     contains a timestamp.
              </inputfielddescription>
            </inputfield>
            <inputfield>
              <inputfieldname>subscription</inputfieldname>
              <inputfielddescription>The name of this field must match
                                     what you specified in the "subscription" argument
                                     to the operator.  This subscription record must
                                     be filled in before calling the operator. This
                                     is typically done using the subscription_lookup_operator.
              </inputfielddescription>
            </inputfield>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
                <outputdescription>
                  An output record is named after each parameter table.
                  See the example below.
                </outputdescription>
                <outputfield>
                  <outputfieldname>"name".PORateScheduleID</outputfieldname>
                  <outputfielddescription>Contains the
                  ID of the best non-ICB schedule to use.
                  This ID can be found in the table t_rsched.</outputfielddescription>
                </outputfield>
                <outputfield>
                  <outputfieldname>"name".ICBRateScheduleID</outputfieldname>
                  <outputfielddescription>ID of the best ICB schedule to use or NULL if 
                    there isn't an ICB schedule. This ID can be found in the table t_rsched.
                  </outputfielddescription>
                </outputfield>
                <outputfield>
                  <outputfieldname>"name".ParameterTableName</outputfieldname>
                  <outputfielddescription>The name of the parameter table.</outputfielddescription>
                </outputfield>
            </output>
        </outputs>
        <outputs>
            <output>
                <outputname>error</outputname>
                <outputnumber>1</outputnumber>
                <outputdescription>
                  If an error occurs, the dataflow
                  continues out this port rather than
                  port 0 ("output").
                </outputdescription>
           </output>
        </outputs>
        <example>
<!--
This is an example that looks up the rate schedule for two parameter tables.
Before running this test, we used ICE to create a new Priceable Item
Type called "AllanTravelCharge".  We gave the "AllanTravelCharge" two
parameters tables: "metratech.com/AllanTravelParamTable1" and 
"metratech.com/AllanTravelParamTable2".  In MetraCare we subscribed
the account to this priceable item.  We also used gave the account
a custom rate for AllanTravelParamTable1.
<pre>
<font color="#0000AA">
g: generate [
        program =
        "CREATE PROCEDURE gen @myPriceableItemName       NVARCHAR OUTPUT
                              @myAccountID               INTEGER  OUTPUT
                              @myTimestamp               DATETIME OUTPUT
        AS
        SET @myPriceableItemName       = N'AllanTravelCharge'
        SET @myAccountID               = 1634383330
        SET @myTimestamp               = CAST('24 NOV 2010' AS DATETIME)",
        numRecords = 1];

renameTimestamp: rename[from="myTimestamp", to="Usage.Timestamp"];

g -> renameTimestamp;

subLookup: subscription_lookup[
        priceableItemName         = "myPriceableItemName",
        priceableItemNameValueType= "fieldReference",
        timestamp                 = "Usage.Timestamp",
        accountId                 = "myAccountID",
        priceableItemTypeID       = "myPriceableItemTypeID",
        priceableItemTemplateID   = "myPriceableItemTemplateID",
        subscription              = "mySubscription"
        ];

renameTimestamp -> subLookup("input");

subErrorDevNull: devNull;
subErrorPrint: print[label="SubscriberError:   ", numToPrint=20];
subLookup("error") -> subErrorPrint -> subErrorDevNull;

rateLookup: rate_schedule_lookup[
              subscription = "mySubscription",
              parameterTable="metratech.com/AllanTravelParamTable1",
              parameterTable="metratech.com/AllanTravelParamTable2"];

printSubscriptionLookup: print[label="Subscription Lookup Output:\n",
                               fieldSeparator="\n",
                               valueSeparator=":  "];

subLookup("output") -> printSubscriptionLookup -> rateLookup;

rateErrorDevNull: devNull;
rateErrorPrint:   print[label="RateError:   ", numToPrint=20];
rateLookup("error") -> rateErrorPrint -> rateErrorDevNull;

rateOutputDevNull: devNull[];
rateOutputPrint:   print[label="Result:  \n", fieldSeparator="\n", 
                         valueSeparator=":  ", numToPrint=20];
rateLookup("output") -> rateOutputPrint -> rateOutputDevNull;
</font>
</pre>
The output is given below.
Note that for AllanTravelParamTable1, there is an ICB rate
schedule but for AllanTravelParamTable2, there is not.
<pre>
<font color="#0000AA">
Result:
myPriceableItemTemplateID:  454
myPriceableItemTypeID:  453
myPriceableItemName:  AllanTravelCharge
myAccountID:  1634383330
Usage.Timestamp:  11/24/2010
mySubscription.PriceableItemInstanceID:  456
mySubscription.ProductOfferingID:  446
mySubscription.SubscriptionID:  1834728403
mySubscription.SubscriptionStart:  11/23/2010
mySubscription.SubscriptionEnd:  1/1/2038
AllanTravelParamTable1.PORateScheduleID:  458
AllanTravelParamTable1.ParameterTableName:  AllanTravelParamTable1
AllanTravelParamTable1.ICBRateScheduleID:  463
AllanTravelParamTable2.PORateScheduleID:  460
AllanTravelParamTable2.ParameterTableName:  AllanTravelParamTable2
AllanTravelParamTable2.ICBRateScheduleID:  null
_ErrorCode:  null  
_ErrorString:  null  
_Plugin:  null  
_Module:  null  
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Rename operator</displayname>
        <description>Renames columns in an input without changing values. Requires pairs of "to" and "from" arguments. 
          Rename can also be used to combined fields into
          a subrecord.  Likewise, rename can be used to
          take subrecord fields and promote them to
          fields.  See the examples below.
        </description>
        <metraflowname>rename</metraflowname>
        <argument>
            <argname>from</argname>
            <argunlimited>true</argunlimited>
            <argtype>String</argtype>
            <argdescription>
                Name of a column to rename. 
                Number of "from" arguments should equal the number of 
                "to" arguments.
		If the "from" column does not exist, then no
		renaming will occur.
                If you want to promote subrecords into individual
                fields, you can use this example syntax: from="a.*", where a
                is the name of subrecord.
                You MAY NOT specify a
                specific subfield.  For example, a.b is invalid.
            </argdescription>
        </argument>
        <argument>
            <argname>to</argname>
            <argunlimited>true</argunlimited>
            <argtype>String</argtype>
            <argdescription>New name for a column. Number of "to" arguments should equal the number of "from" arguments. 
                You can change a field into a subrecord by using 
                a . in the "to" argument.  For example, from="a", to="mySub.a",
                from="b", to="mySub.b".   You can only push a field down
                one level.  See examples for away to push a field down
                two levels.
            </argdescription>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
        <example>
<!--
A simple rename example.
<pre>
<font color="#0000AA">
g: generate [
  program =
    "CREATE PROCEDURE gen @a BIGINT @b INTEGER
     AS
       SET @a = @@RECORDCOUNT
       SET @b = CAST(@@RECORDCOUNT AS INTEGER) % 2",
  numRecords = 4];

p: print[];
d: devNull;
r: rename[from="a", to="d",
          from="b", to="e"];

g->r->p->d;
</font>
</pre>
The output:
<pre>
<font color="#0000AA">
d:0, e:0
d:1, e:1
d:2, e:0
d:3, e:1
</font>
</pre>
An example of collapsing separate fields 
into subrecords.
<pre>
<font color="#0000AA">

g:generate[program="CREATE PROCEDURE p
                    @a BIGINT
                    @b BIGINT
                    @c BIGINT
                    @d BIGINT
                    AS
                    SET @a = @@RECORDCOUNT
                    SET @b = @@RECORDCOUNT
                    SET @c = @@RECORDCOUNT
                    SET @d = @@RECORDCOUNT",
                    numRecords = 2];

r:rename[from="a", to="aa.a",
         from="b", to="aa.b",
         from="c", to="bb.c",
         from="d", to="bb.d"];

g -> r;

p:print[];

r -> p;

d:devNull[];

p -> d;
</font>
</pre>
The output:
<pre>
<font color="#0000AA">
aa.a:0, aa.b:0, bb.c:0, bb.d:0
aa.a:1, aa.b:1, bb.c:1, bb.d:1
</font>
</pre>
An example of promoting separate subrecord
fields into traditional fields.  Note the 
special asterix syntax.
<pre>
<font color="#0000AA">
g:generate[program="CREATE PROCEDURE p
           @a BIGINT
           @b BIGINT
           AS
           SET @a = @@RECORDCOUNT
           SET @b = @@RECORDCOUNT",
           numRecords = 2];

r:rename[from="a", to="aa.a",
         from="b", to="aa.b"];

r2:rename[from="aa.*", to="field_"];

g -> r -> r2;

p:print[];

r2 -> p;

d:devNull[];

p -> d;
</font>
</pre>
The output:
<pre>
<font color="#0000AA">
field_a:0, field_b:0
field_a:1, field_b:1
</font>
</pre>
An example of collapsing separate fields 
into subrecord two levels deep:
<pre>
<font color="#0000AA">
g:generate[program="CREATE PROCEDURE p
           @a BIGINT
           @b BIGINT
           AS
           SET @a = @@RECORDCOUNT
           SET @b = @@RECORDCOUNT",
           numRecords = 2];

r:rename[from="a", to="usage.a",
         from="b", to="usage.b"];

r2:rename[from="usage", to="parent.usage"];

g -> r -> r2;

p:print[];

r2 -> p;

d:devNull[];

p -> d;
</font>
</pre>
The output:
<pre>
<font color="#0000AA">
parent.usage.a:0, parent.usage.b:0
parent.usage.a:1, parent.usage.b:1
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Right Merge Anti Semi Join Operator</displayname>
        <description>Outputs each row from the "right" input when a matching row in the "left" input does not exist. 
        (This is also known as an anti-join operator.)  Because it uses a merge, data must be sorted before being passed in.
          The operator outputs each row from the 
          "right" input when a matching row in the "left" input does not exist. 
        NOTE: the left and right inputs to the operator must be sorted by the
              specified keys otherwise the results are undefined.
        </description>
        <metraflowname>right_merge_anti_semi_join</metraflowname>
        <argument>
            <argname>leftKey</argname>
            <argtype>String</argtype>
            <argdescription>Name of a key from the left input.</argdescription>
        </argument>
        <argument>
            <argname>residual</argname>
            <argtype>String</argtype>
            <argdescription>Non-equijoin predicate expressed as a BOOLEAN-valued MTSQL function.
                            If specified, only records that evaluate to true
                            are sent to the output.
            </argdescription>
        </argument>
        <argument>
            <argname>rightKey</argname>
            <argtype>String</argtype>
            <argdescription>Name of a key from the right input.</argdescription>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>left</inputname>
                <inputnumber>0</inputnumber>
            </input>
            <input>
                <inputname>right</inputname>
                <inputnumber>1</inputnumber>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
        <example>
<!--
An example:
<pre>
<font color="#0000AA">
right: generate [
  program =
    "CREATE PROCEDURE gen
      @employeeNo INTEGER
      @deptNo INTEGER
  AS
    SET @employeeNo = CAST(@@RECORDCOUNT AS INTEGER) + 1000
    SET @deptNo = CAST(@@RECORDCOUNT AS INTEGER)",
  numRecords = 8];

left: generate [
  program =
    "CREATE PROCEDURE gen
      @deptNo INTEGER
      @deptCount INTEGER
  AS
    SET @deptNo = CAST(@@RECORDCOUNT AS INTEGER)
    SET @deptCount = CAST(@@RECORDCOUNT AS INTEGER) + 10",
  numRecords = 4];

right_merge_anti_semi_join [leftKey="deptNo", rightKey="deptNo"];

p1: print[numToPrint=4];
p2: print[numToPrint=8];
p3: print[numToPrint=8];

s1: sort[key="deptNo"];
s2: sort[key="deptNo"];

devNull;

right -> s2 -> p2 -> right_merge_anti_semi_join("right");
left -> s1 -> p1 -> right_merge_anti_semi_join("left");

right_merge_anti_semi_join -> p3 -> devNull;
</font>
</pre>
The output:
<pre>
<font color="#0000AA">
employeeNo:1000, deptNo:0
employeeNo:1001, deptNo:1
employeeNo:1002, deptNo:2
employeeNo:1003, deptNo:3
employeeNo:1004, deptNo:4
employeeNo:1005, deptNo:5
employeeNo:1006, deptNo:6
employeeNo:1007, deptNo:7
deptNo:0, deptCount:10
deptNo:1, deptCount:11
deptNo:2, deptCount:12
deptNo:3, deptCount:13
employeeNo:1004, deptNo:4
employeeNo:1005, deptNo:5
employeeNo:1006, deptNo:6
employeeNo:1007, deptNo:7
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Right Merge Semi Join Operator</displayname>
        <description>
          Outputs each row from the "right" input when there is a matching row in the "left" input. 
        NOTE: the left and right inputs to the operator must be sorted by the
              specified keys otherwise the results are undefined.
        </description>
        <metraflowname>right_merge_semi_join</metraflowname>
        <argument>
            <argname>leftKey</argname>
            <argtype>String</argtype>
            <argdescription>Name a key from the left input.</argdescription>
        </argument>
        <argument>
            <argname>residual</argname>
            <argtype>String</argtype>
            <argdescription>Non-equijoin predicate expressed as a BOOLEAN-valued MTSQL function.
                            If specified, only records that evaluate to true
                            are sent to the output.
            </argdescription>
        </argument>
        <argument>
            <argname>rightKey</argname>
            <argtype>String</argtype>
            <argdescription>Name a key from the right input.</argdescription>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>left</inputname>
                <inputnumber>0</inputnumber>
            </input>
            <input>
                <inputname>right</inputname>
                <inputnumber>1</inputnumber>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
        <example>
<!--
An example:
<pre>
<font color="#0000AA">
right: generate [
  program =
    "CREATE PROCEDURE gen
      @employeeNo INTEGER
      @deptNo INTEGER
  AS
    SET @employeeNo = CAST(@@RECORDCOUNT AS INTEGER) + 1000
    SET @deptNo = CAST(@@RECORDCOUNT AS INTEGER)",
  numRecords = 8];

left: generate [
  program =
    "CREATE PROCEDURE gen
      @deptNo INTEGER
      @deptCount INTEGER
  AS
    SET @deptNo = CAST(@@RECORDCOUNT AS INTEGER)
    SET @deptCount = CAST(@@RECORDCOUNT AS INTEGER) + 10",
  numRecords = 4];

right_merge_semi_join [leftKey="deptNo", rightKey="deptNo"];

p1: print[numToPrint=4];
p2: print[numToPrint=8];
p3: print[numToPrint=8];

s1: sort[key="deptNo"];
s2: sort[key="deptNo"];

devNull;

right -> s2 -> p2 -> right_merge_semi_join("right");
left -> s1 -> p1 -> right_merge_semi_join("left");

right_merge_semi_join -> p3 -> devNull;
  
</font>
</pre>
The output:
<pre>
<font color="#0000AA">
employeeNo:1000, deptNo:0
employeeNo:1001, deptNo:1
employeeNo:1002, deptNo:2
employeeNo:1003, deptNo:3
employeeNo:1004, deptNo:4
employeeNo:1005, deptNo:5
employeeNo:1006, deptNo:6
employeeNo:1007, deptNo:7
deptNo:0, deptCount:10
deptNo:1, deptCount:11
deptNo:2, deptCount:12
deptNo:3, deptCount:13
employeeNo:1000, deptNo:0
employeeNo:1001, deptNo:1
employeeNo:1002, deptNo:2
employeeNo:1003, deptNo:3

</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Right Outer Hash Join Operator</displayname>
        <description>Performs a right outer join of inputs based on equijoin keys and an optional predicate.
          The operator returns each row that satisfies the join of the "right" input with each matching row from the "left" input.
          It also returns any rows from the "right" input that had no matching rows in the "left" input, joined with NULL. 
          NOTE: The "left" table is loaded into memory - carefully consider
          the size of this table.
        </description>
        <metraflowname>right_outer_hash_join</metraflowname>
        <aliasname>right_hash_join</aliasname>
        <argument>
            <argname>probeKey</argname>
            <argtype>String</argtype>
            <argdescription>Name of an equijoin key from the probe input.</argdescription>
        </argument>
        <argument>
            <argname>residual</argname>
            <argtype>String</argtype>
            <argdescription>Non-equijoin predicate expressed as a BOOLEAN-valued MTSQL function.
                            If specified, only records that evaluate to true
                            are sent to the output.
            </argdescription>
        </argument>
        <argument>
            <argname>tableKey</argname>
            <argtype>String</argtype>
            <argdescription>Name of an equijoin key from the table input.</argdescription>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>table</inputname>
                <inputnumber>0</inputnumber>
            </input>
            <inputunbounded>
                <inputname>probe</inputname>
                <inputnumber>*</inputnumber>
            </inputunbounded>
        </inputs>
        <outputs>
            <outputlimited mustequal="probe">
                <outputname>output</outputname>
                <outputnumber>*</outputnumber>
            </outputlimited>
        </outputs>
        <example>
<!--
An example:
<pre>
<font color="#0000AA">
a: generate [
  program =
    "CREATE PROCEDURE gen @a BIGINT @b INTEGER
     AS
       SET @a = @@RECORDCOUNT
       SET @b = CAST(@@RECORDCOUNT AS INTEGER) % 2",
  numRecords = 4];

b: generate [
  program = "CREATE PROCEDURE gen @d BIGINT @e INTEGER
             AS
              SET @d = @@RECORDCOUNT
              SET @e = CAST(@@RECORDCOUNT AS INTEGER)",
  numRecords = 4];

j:right_outer_hash_join [tableKey="b", probeKey="e"];

p1: print[];
p2: print[];
p3: print[numToPrint=50];
devNull;
a -> p1 -> j("table");
b -> p2 -> j("probe(0)");
j -> p3 -> devNull;
</font>
</pre>
Output:
<pre>
<font color="#0000AA">
a:0, b:0
a:1, b:1
a:2, b:0
a:3, b:1
d:0, e:0
d:1, e:1
d:2, e:2
d:3, e:3
a:0, b:0, d:0, e:0
a:2, b:0, d:0, e:0
a:1, b:1, d:1, e:1
a:3, b:1, d:1, e:1
a:NULL, b:NULL, d:2, e:2
a:NULL, b:NULL, d:3, e:3
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Right Outer Merge Join Operator</displayname>
        <description>Outputs each row that satisfies the join of the "right" input
        with each matching row from the "left" input. Since this is a merge, inputs 
        must be sorted by the join key. The operator also returns any rows from the 
        "right" input that has no matching rows in the "left" input, joined with NULL. 
        This operator can also be used to nest parent and child records.
        NOTE: the left and right inputs to the operator must be sorted by the
              specified keys otherwise the results are undefined.
        </description>
        <metraflowname>right_outer_merge_join</metraflowname>
        <aliasname>right_merge_join</aliasname>
        <metraflowname>right_outer_merge_join</metraflowname>
        <aliasname>right_merge_join</aliasname>
        <argument>
            <argname>leftKey</argname>
            <argtype>String</argtype>
            <argdescription>Name of a key from the "left" input.</argdescription>
        </argument>
        <argument>
            <argname>residual</argname>
            <argtype>String</argtype>
            <argdescription>Non-equijoin predicate expressed as a BOOLEAN-valued MTSQL function.
                            If specified, only records that evaluate to true
                            are sent to the output.
            </argdescription>
        </argument>
        <argument>
            <argname>rightKey</argname>
            <argtype>String</argtype>
            <argdescription>Name of a key from the "right" input.</argdescription>
        </argument>
        <argument>
            <argname>nest</argname>
            <argtype>String</argtype>
            <argdescription>
              If this argument is present, then records from the left
              input will be nested under records from the right.
              This argument specifies the name that should be given
              to the nested record.  See inner_merge_join for an 
              example of this type of use.
            </argdescription>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>left</inputname>
                <inputnumber>0</inputnumber>
                <inputdescription>
                If this operator is being used to nest,
                the left input should be the parent records.
                </inputdescription>
            </input>
            <input>
                <inputname>right</inputname>
                <inputdescription>
                If this operator is being used to nest,
                the right input should be the children records.
                </inputdescription>
                <inputnumber>1</inputnumber>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
    </operator>
    <operator>
        <displayname>Database Select Operator</displayname>
        <description>Executes a query against a database and outputs the resultset to a single output stream.</description>
        <metraflowname>select</metraflowname>
        <argument>
            <argname>baseQuery</argname>
            <argtype>String</argtype>
            <argdescription>The query to execute against the database.  This is an SQL query, not an MTSQL query.
            This query can be used to partition the data. See the example below. </argdescription>
        </argument>
        <argument>
            <argname>maxRecords</argname>
            <argtype>Integer</argtype>
            <argdescription>The maximum number of records to read from each partition of the operator.</argdescription>
            <optional>true</optional>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value default="true">parallel</value>
            <value>sequential</value>
            <optional>true</optional>
        </argument>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
        <example>
<!--
In this example, the data partitioning is based on
modular arithmetic. NUMPARTITIONS is the number of
partitions. PARTITION is the particular
partition number that is executing.
<pre>
<font color="#0000AA">
    s: select[baseQuery="SELECT au.id_sess FROM t_acc_usage au 
              WHERE {fn MOD(au.id_sess, %%NUMPARTITIONS%%)} = %%PARTITION%%"];
             ]]>

</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Sequential File Delete Operator</displayname>
        <description>Deletes a file.</description>
        <metraflowname>sequential_file_delete</metraflowname>
        <argument>
            <argname>filename</argname>
            <argtype>String</argtype>
            <argdescription>Path to the file to be deleted.</argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
    </operator>
    <operator>
        <displayname>Sequential File Rename Operator</displayname>
        <description>Renames a file.</description>
        <metraflowname>sequential_file_rename</metraflowname>
        <argument>
            <argname>from</argname>
            <argtype>String</argtype>
            <argdescription>Name of the file to be renamed.</argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>to</argname>
            <argtype>String</argtype>
            <argdescription>New name of the file.</argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
    </operator>
    <operator>
        <displayname>Sequential File Scan Operator</displayname>
        <description>This is a deprecated operator.  Use the import operator instead.
                     This operator reads in data from a file.
                     The file must be in boost serialization xml format.
        </description>
        <metraflowname>sequential_file_scan</metraflowname>
        <argument>
            <argname>filename</argname>
            <argtype>String</argtype>
            <argdescription>Path to the file to be scanned.</argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
    </operator>
    <operator>
        <displayname>Sequential File Write Operator</displayname>
        <description>This is a deprecated operator.  Use the export operator instead.
                     This operator writes to file the structure of the given data.
                     The file is written in boost serialization xml format.
        </description>
        <metraflowname>sequential_file_write</metraflowname>
        <argument>
            <argname>filename</argname>
            <argtype>String</argtype>
            <argdescription>Path to the file to be written.</argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
    </operator>
    <operator>
        <displayname>Sort Operator</displayname>
        <description>
        Sorts a stream on a configurable set of input keys. The order that the keys are specified
        in determines the sort order. 
        The data is sorted in ascending order.
        If the specified memory limit is reached, a single pass external merge sort will be used. 
        If performing an external sort, temporary files may be written.
        The directory location of the temporary files is determined by these rules
        in order of precedence: (1) if specified, the value of argument "temp_dir",
        (2) if specified, the value of environmental variable "TEMP", 
        (3) if specified, the value of environmental variable "TMP",
        (4) C:/temp
      </description>
        <metraflowname>sort</metraflowname>
        <argument>
            <argunlimited>true</argunlimited>
            <argname>key</argname>
            <argtype>String</argtype>
            <argdescription>Name of a sort key from the input.</argdescription>
        </argument>
        <argument>
            <argname>allowedMemory</argname>
            <argtype>Integer</argtype>
            <argdescription>
              Maximum amount of memory to use in a single partition during sorting.
              This is an optional argument.  The default value is one megabyte.
              This argument is specified in bytes.  For example, one megabyte is
              specified as 1048576.
              </argdescription>
        </argument>
        <argument>
            <argname>temp_dir</argname>
            <argtype>String</argtype>
            <argdescription>Full path to a directory in which to put sort run files during an external sort. 
            Assumes that the path is valid on every machine in a cluster when executing in a distributed environment.</argdescription>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
                <inputdescription>Unsorted input.</inputdescription>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
                <outputdescription>Sorted output.</outputdescription>
            </output>
        </outputs>
        <example>
<!--
An example:
<pre>
<font color="#0000AA">
g:generate [
  program =
    "CREATE PROCEDURE gen
      @a BIGINT
      @b INTEGER
      @c DECIMAL
    AS
      SET @a = @@RECORDCOUNT
      SET @b = 9 - (CAST(@@RECORDCOUNT AS INTEGER))
      SET @c = CAST(@@RECORDCOUNT AS DECIMAL)",
  numRecords = 5];

st:sort[key="b", key="a"];

print[numToPrint=20];

dn1:devNull;

g -> st -> print -> dn1;
</font>
</pre>
Output:
<pre>
<font color="#0000AA">
a:4, b:5, c:4
a:3, b:6, c:3
a:2, b:7, c:2
a:1, b:8, c:1
a:0, b:9, c:0
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Sort Group By Operator</displayname>
        <description>
          Groups a selected set of rows into 
          a set of summary rows by the values of one or more columns.
          One row is returned for each group. 
          The output record contains a group-by-key column and 
          the newly created column
          produced by the logic in the "initialize" and "update" procedures.
          The resulting records are not sorted.
          NOTE: The operator does not actually require that the input be sorted rather that it be grouped on its group-by keys.
          The most common case is that this grouping is achieved by sorting the data.</description>
        <metraflowname>sort_group_by</metraflowname>
        <argument>
            <argname>key</argname>
            <argunlimited>true</argunlimited>
            <argdescription>Name of a group-by key.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>initialize</argname>
            <argdescription>An MTSQL procedure that initializes group-by outputs upon each new key value.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>update</argname>
            <argdescription>An MTSQL procedure that updates group-by outputs upon receipt of each record in a group.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
    </operator>
    <operator>
        <displayname>Sort Merge Operator</displayname>
        <description>
          Given multiple inputs, all containing the same columns
          and sorted by a set of keys, creates a sorted output that
          is the union of the inputs.
        NOTE: if the input is not sorted, the results are undefined.
        </description>
        <metraflowname>sort_merge</metraflowname>
        <aliasname>sortmerge</aliasname>
        <argument>
            <argname>key</argname>
            <argunlimited>true</argunlimited>
            <argdescription>Name of a sort key.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <inputunbounded>
                <inputname>input</inputname>
                <inputnumber>*</inputnumber>
            </inputunbounded>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
        <example>
<!--
An example:
<pre>
<font color="#0000AA">
  i1: generate [
  program = 
    "CREATE PROCEDURE gen @a INTEGER @b INTEGER 
     AS
       SET @a = CAST(@@RECORDCOUNT AS INTEGER)
       SET @b = CAST(@@RECORDCOUNT AS INTEGER)",
  numRecords = 4];

i2: generate [
  program = 
    "CREATE PROCEDURE gen @a INTEGER @b INTEGER 
     AS
       SET @a = 10 - CAST(@@RECORDCOUNT AS INTEGER)
       SET @b = 10 - CAST(@@RECORDCOUNT AS INTEGER)",
  numRecords = 4];

s1:sort [key="a"];
s2:sort [key="a"];

sm:sort_merge [key = "a"];
p1:print [numToPrint=8];
dn1:devNull;

i1 -> s1 -> sm(0);
i2 -> s2 -> sm(1);
sm -> p1 -> dn1;
</font>
</pre>
The output:
<pre>
<font color="#0000AA">
a:0, b:0
a:1, b:1
a:2, b:2
a:3, b:3
a:7, b:7
a:8, b:8
a:9, b:9
a:10, b:10
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Sort Merge Collector</displayname>
        <description>Merges multiple streams of records coming from parallel partitions and creates a sorted output that
          is the union of the inputs. For sorted output, all the steams of records must contain the same columns. See also coll.
          NOTE: if the input is not sorted, the results are undefined.
        </description>
        <metraflowname>sort_merge_coll</metraflowname>
        <aliasname>sort_merge_coll</aliasname>
        <argument>
            <argname>key</argname>
            <argunlimited>true</argunlimited>
            <argdescription>Name of a sort key.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
    </operator>
    <operator>
        <displayname>Sort Nest Operator</displayname>
        <description>
This operator is used to group children records
with parent records. This is known as nesting.
Given a row of input, we have some fields that
belong to the parent record, and some that belong
to the child record.  
We have to identify which rows are all part
of the same parent. The "key" argument identifies
this field.
We also need to identify all parent
fields using the "parentKey" argument.
         </description>
        <metraflowname>sort_nest</metraflowname>
        <argument>
            <argname>key</argname>
            <argunlimited>true</argunlimited>
            <argdescription>Name of a sort key for identify which
                            children records are grouped with
                            the parent.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>parentKey</argname>
            <argunlimited>true</argunlimited>
            <argdescription>Identifies which fields pertain to
                            the parent rather than the children.
                            </argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>recordName</argname>
            <argdescription>Name record used to group
                            the children fields together.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>alwaysUpdateParent</argname>
            <argdescription>
              When nesting each child in the parent, should
              all parent fields be set?  If this is set to false,
              then when the first record is encountered (contains
              a child and parent values), then the parent values
              will be permenantly set and the parent values will not be altered 
              by subsequent children records encountered. If this is
              set to true, then each record encountered (contains
              a child and parent values), the parent values will be
              overwritten.
            </argdescription>
            <argtype>Boolean</argtype>
            <default>false</default>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
        <example>
<!--
This is an example:
<pre>
<font color="#0000AA">

readData: import[filename="test_sort_nest.data",
          format="myRec (
               ConferenceID    text_delimited_base10_int32(delimiter='|'),
               ConferenceAcct  text_delimited_base10_int32(delimiter='|'),
               ChildID         text_delimited_base10_int32(delimiter='|'),
               NumMinutes      text_delimited_base10_int32(delimiter=crlf))",
          mode="sequential"];

printInput: print[label="Input:   ", numToPrint=10];

readData -> printInput;

nest: sort_nest[key="ConferenceID",
                recordName="children",
                parentKey="ConferenceID",
                parentKey="ConferenceAcct",
                alwaysUpdateParent=true];

printInput -> nest;

printNestOutput: print[label="Input After Nesting:   ", numToPrint=10];

nest -> printNestOutput;

unnest: unnest[prefix="parent",
               recordName="children"];

printNestOutput -> unnest;

printUnnestOutput: print[label="After Unnesting:   ", numToPrint=10];

unnest -> printUnnestOutput;

devNull[];

printUnnestOutput -> devNull;
</font>
</pre>
The output is:
<pre>
<font color="#0000AA">
Input:   ConferenceID:100, ConferenceAcct:1000, ChildID:1, NumMinutes:10
Input:   ConferenceID:100, ConferenceAcct:1000, ChildID:2, NumMinutes:11
Input:   ConferenceID:100, ConferenceAcct:1000, ChildID:3, NumMinutes:9
Input:   ConferenceID:200, ConferenceAcct:2000, ChildID:1, NumMinutes:5
Input:   ConferenceID:200, ConferenceAcct:2000, ChildID:2, NumMinutes:6
Input After Nesting:   ConferenceID:100, ConferenceAcct:1000, children:[
    [ChildID:1, NumMinutes:10], 
    [ChildID:2, NumMinutes:11], 
    [ChildID:3, NumMinutes:9]
]
Input After Nesting:   ConferenceID:200, ConferenceAcct:2000, children:[
    [ChildID:1, NumMinutes:5], 
    [ChildID:2, NumMinutes:6]
]
After Unnesting:   parent.ConferenceID:100, parent.ConferenceAcct:1000, ChildID:1, NumMinutes:10
After Unnesting:   parent.ConferenceID:100, parent.ConferenceAcct:1000, ChildID:2, NumMinutes:11
After Unnesting:   parent.ConferenceID:100, parent.ConferenceAcct:1000, ChildID:3, NumMinutes:9
After Unnesting:   parent.ConferenceID:200, parent.ConferenceAcct:2000, ChildID:1, NumMinutes:5
After Unnesting:   parent.ConferenceID:200, parent.ConferenceAcct:2000, ChildID:2, NumMinutes:6

</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Sort Running Total</displayname>
        <description>
          Calculates a running total based on a set of 
          configurable group-by keys 
          and, optionally, a set of sort keys.
          The input must be sorted.
          The operator groups a selected set of rows  
          by the values of one or more columns.
          Every output row contains a group-by-key column and 
          the newly created column
          produced by the logic in the "initialize" and "update" procedures.
          The resulting records are not sorted.
          This operator is very similar to sort_group_by.
          The main difference is that, whereas sort_group_by produces one output
          record for each group, sort_running_total produces an output
          record for each input record received (showing the total
          accumulating, record by record).  See also hash_running_total.
        </description>
        <metraflowname>sort_running_total</metraflowname>
        <argument>
            <argname>key</argname>
            <argunlimited>true</argunlimited>
            <argdescription>Name of a grouping key.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>sortKey</argname>
            <argunlimited>true</argunlimited>
            <argdescription>Name of a sorting key to support sorted merge in the case of a multiple input running total.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>initialize</argname>
            <argdescription>An MTSQL procedure that initializes group-by outputs upon each new key value.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>update</argname>
            <argunlimited>true</argunlimited>
            <argdescription>An MTSQL procedure that updates group-by outputs upon receipt of each record in a group.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>preIncrement</argname>
            <argdescription>Sets whether running total records are output before or after the update procedure is run.</argdescription>
            <argtype>Boolean</argtype>
        </argument>
        <argument>
            <argname>outputGroupBy</argname>
            <argdescription>Sets whether group by totals are output after all records are consumed.</argdescription>
            <argtype>Boolean</argtype>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <inputunbounded singlename="true">
                <inputname>input</inputname>
                <inputnumber>*</inputnumber>
                <inputdescription>Must be sorted by the keys.</inputdescription>
            </inputunbounded>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
    </operator>
    <operator>
        <displayname>SQL Execute Direct Operator</displayname>
        <description>Executes SQL statements.
          "control" is a required input port to this
          operator.  This port can be used to control
          when the operator is executed.  See below for
          an example of this.
          This operator has no output ports.
        </description>
        <metraflowname>sql_exec_direct</metraflowname>
        <argument>
            <argname>statementList</argname>
            <argtype>Sublist</argtype>
            <argdescription>The list of SQL statements to execute.</argdescription>
            <argument>
                <argname>preprocess</argname>
                <argtype>String</argtype>
                <argdescription>The pre-transaction query.</argdescription>
            </argument>
            <argument>
                <argname>postprocess</argname>
                <argtype>String</argtype>
                <argdescription>The post-transaction query.</argdescription>
            </argument>
            <argument>
                <argname>query</argname>
                <argtype>String</argtype>
                <argdescription>The query to execute.</argdescription>
            </argument>
            <argument>
                <argname>mode</argname>
                <argtype>String</argtype>
                <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
                <value default="true">parallel</value>
                <value>sequential</value>
                <optional>true</optional>
            </argument>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value default="true">parallel</value>
            <value>sequential</value>
            <optional>true</optional>
        </argument>
        <inputs>
            <input>
                <inputname>control</inputname>
                <inputnumber>0</inputnumber>
            </input>
            <inputunbounded>
                <inputname>input</inputname>
                <inputnumber>*</inputnumber>
            </inputunbounded>
        </inputs>
        <example>
<!--
An example:
<pre>
<font color="#0000AA">

  /* Generate the data you want to insert. */
  /* Note that the table data are the fields "a" and "b". */

input:generate[program="
                 CREATE PROCEDURE p @a INTEGER @b BIGINT
                 AS
                 SET @a = CAST(@@RECORDCOUNT AS INTEGER)
                 SET @b = @@RECORDCOUNT",
                 numRecords=100];

/****
 * Here is the example of how you insert into NetMeter
 *
 * Right now the inserter only writes to NetMeterStage so we have
 * to execute some SQL from MetraFlow to move the data into the NetMeter
 * database.  This is actually a bit subtle because we have to mimic control
 * flow (e.g. write to NetMeterStage and when you are done, execute the SQL)
 * using dataflow.  This is done using a control flow token which is the
 * id_commit_unit column we create.
 * Essentially this token identifies a transactional
 * unit of work that we want the sql_exec_direct operator use.  Note that this
 * is exactly what the meter operator is doing under the wraps.
 */

 /* Bucket all of the data into a single unit of work */
 /* which is identified by the integer 1 */

txn:expr[program="CREATE PROCEDURE e @a INTEGER @id_commit_unit INTEGER OUTPUT
                  AS
                  SET @id_commit_unit = @a/8"];

/* Copy because we need the data to insert and */
/* we need to create the control token/record. */

c:copy[]

/**
 * Here we insert, note that we don't support createTable=true with this model.
 * So you'll have to create
 * a table in the staging database and in the NetMeter database.
 * Note that the insert will not actually put any data
 * in the staging database table you create though
 * (it will use some additional temporary
 * tables that are dynamically created
 * from it).
 */

i:insert[table="t_simple_insert_net_meter",
         schema="NetMeter", transactionKey="id_commit_unit",
         batchSize=7, createTable=true];

/* Here we create the control record */

sgb:sort_group_by[key="id_commit_unit",
                  initialize="CREATE PROCEDURE i @size_0 INTEGER
                              AS
                              SET @size_0 = 0",
                  update="CREATE PROCEDURE u @size_0 INTEGER
                          AS
                          SET @size_0 = @size_0 + 1"];


/* Glue it all together; it should all be clear by now  */

input -> txn -> c;

/**
 * Execute the sql.  Note that this example is for SQL Server;
 * As previously mentioned, the actual data will be placed into temporary
 * tables that are created dynamically,
 * the insert will pass that name to this operator
 * which will INSERT INTO SELECT FROM and delete the dynamic table.
 */

commit_stuff:sql_exec_direct[
  statementList=[
    query="INSERT INTO NetMeter..t_simple_insert_net_meter SELECT * FROM %%%NETMETERSTAGE_PREFIX%%%%1%",
    postprocess="DROP TABLE %%%NETMETERSTAGE_PREFIX%%%%1%"]];

p1: print[];

c(0) -> sgb -> p1 -> commit_stuff("control");
c(1) -> i -> commit_stuff("input(0)");

</font>
</pre>
The output:
<pre>
<font color="#0000AA">
id_commit_unit:1, size_0:8
id_commit_unit:2, size_0:8
id_commit_unit:3, size_0:8
id_commit_unit:4, size_0:8
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Subscription Lookup</displayname>
     <description>
          Looks up a subscriber's subscription to a priceable item.
          The operator expects an input field (column) containing
          the priceable item type name to look up for a given account.  
          The priceable item type name can be a literal priceable
          item name to look up or can be a field containing the name
          to look up.  This operator also takes a timestamp
          that specifies the date and time that applies for
          the look up.
          Output fields contain information about the found subscription.
          This operator branches the dataflow.
          If there are no errors, then the dataflow continues
          to "output" port.  If there is an error, the dataflows
          continues to "error" port.
     </description>
        <metraflowname>subscription_lookup</metraflowname>
        <argument>
            <argname>timestamp</argname>
            <displayName>Timestamp Field</displayName>
            <argtype>String</argtype>
         <argdescription>
              Specifies the name of the input field to this
              operator that will contain a timestamp value. 
              This timestamp value indicates the time that
              should be used in resolving this subscription lookup.
              Make sure that the dataflow to this operator
              contains a field with this specified name,
              and that the data type of the field is DATETIME.
         </argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>priceableItemNameValueType</argname>
            <displayName>Lookup Mode</displayName>
            <argtype>String</argtype>
         <argdescription>
            Specifies whether the "priceableItemName" is a "constant"
            (a literal priceable item type name to look up) or is
            a "fieldReference" (a variable containing the priceable
            item name to look up).
         </argdescription>
         <argvalue>
           <argvaluename>fieldReference</argvaluename>
           <argvaluedescription>
             This indicates that the value specified by priceableItemName
             is identiying the name of the incoming column that 
             contains the name of the priceable item.
           </argvaluedescription>
         </argvalue>
         <argvalue>
           <argvaluename>constant</argvaluename>
           <argvaluedescription>
             This indicates that the value specified by priceableItemName
             is a literal priceable item.
           </argvaluedescription>
         </argvalue>
         <optional>false</optional>
        </argument>
        <argument>
            <argname>priceableItemName</argname>
            <displayName>Priceable Item Name</displayName>
            <argtype>String</argtype>
         <argdescription>
            Either contains the priceable item type name to look up
            (if "priceableItemNameValueType" is "constant") or
            contains the name of the field holding the 
            priceable item name (if "priceableItemNameValueType"
            is "fieldReference").
         </argdescription>
        </argument>
        <argument>
            <argname>accountId</argname>
            <displayName>Account Identifier</displayName>
            <argtype>String</argtype>
         <argdescription>
              Specifies the name of the input field to this
              operator that will contain the account ID. 
              This account_id should be found in the table
              t_sub, column id_acc.
         </argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>priceableItemTypeId</argname>
            <displayName>Priceable Item Type ID</displayName>
            <argtype>String</argtype>
         <argdescription>
           Specifies the name of the output field that 
           the operator will create to hold the
	   priceable item type ID.  Note that this field
	   is also stored in the output susbcriber record.
         </argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>priceableItemTemplateId</argname>
            <displayName>Priceable Item Template ID</displayName>
            <argtype>String</argtype>
         <argdescription>
           Specifies the name of the output field that 
           the operator will create to hold the
           priceable item template ID.
	   Note that this field is also stored in the output
	   subscriber record.
         </argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>subscription</argname>
            <displayName>Subscription</displayName>
            <argtype>String</argtype>
         <argdescription>
           Specifies the name of the output field that 
           the operator will create to hold the
           subscription record containing information
	   about the subscription. The subscription record
	   contains: PriceableItemTemplateID, PriceableItemInstanceID,
	   PriceableItemTypeID,
	   ProductOfferingID, SubscriptionID, SubscriptionStart,
	   SubscriptionEnd.
	   Default value: "Subscription"
         </argdescription>
            <optional>false</optional>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value default="true">parallel</value>
            <value>sequential</value>
            <optional>true</optional>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
          <inputdescription></inputdescription>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
                <outputdescription>
                </outputdescription>
		            <outputfield>
			              <outputfieldname>priceableItemTypeId</outputfieldname>
                    <outputfielddescription>The name of this field depends
                                            on arguments specified in the operator.
                    </outputfielddescription>
		            </outputfield>
		            <outputfield>
			              <outputfieldname>priceableItemTemplateId</outputfieldname>
                    <outputfielddescription>The name of this field depends
                                            on arguments specified in the operator.
                    </outputfielddescription>
		            </outputfield>
		            <outputfield>
			              <outputfieldname>subscription</outputfieldname>
                    <outputfielddescription>The name of this record matches 
                                            the name that was specified by the subscription
                                            operator to the operator.  The subscription record
                                            contains many useful fields and is required 
                                            when doing a rate_schedule_lookup (typically
                                            the following operator in the flow).
                    </outputfielddescription>
		            </outputfield>
            </output>
        </outputs>
        <outputs>
            <output>
                <outputname>error</outputname>
                <outputnumber>1</outputnumber>
                <outputdescription>
                  If an error occurs, the dataflow
                  continues out this port rather than
                  port 0 ("output").
                </outputdescription>
           </output>
        </outputs>
        <example>
<!--
See <a href="#subscriberRecord">Subscription Record</a> for more details
about the subscriber record.
<p/>
This is an example:
<pre>
<font color="#0000AA">
g: generate [
        program =
        "CREATE PROCEDURE gen @myPriceableItemName       NVARCHAR OUTPUT
                              @myAccountID               INTEGER  OUTPUT
                              @myTimestamp               DATETIME OUTPUT
        AS
        SET @myPriceableItemName       = N'BikeTourParentCharge'
        SET @myAccountID               = 2077104464
        SET @myTimestamp               = CAST('11 FEB 2011' AS DATETIME)",
        numRecords = 1];

p1: print[label="\nResult:  ", fieldSeparator=",\n", valueSeparator=": ", numToPrint=20];
p2: print[label="\nError:   ", numToPrint=20];

d1:devNull;
d2:devNull;

s: subscription_lookup[
        priceableItemName         = "myPriceableItemName",
        priceableItemNameValueType= "fieldReference",
        timestamp                 = "myTimestamp",
	accountId                 = "myAccountID",
        priceableItemTypeID       = "myPriceableItemTypeID",
        priceableItemTemplateID   = "myPriceableItemTemplateID",
        subscription              = "mySubscription"
        ];

g -> s("input");

s("output") -> p1 -> d1;
s("error") -> p2 -> d2;
</font>
</pre>
The output is:
<pre>
<font color="#0000AA">
Result:  myPriceableItemTypeID: 650,
myPriceableItemName: BikeTourParentCharge,
myAccountID: 2077104464,
myTimestamp: 2/11/2011,
myPriceableItemTemplateID: 651,
mySubscription.PriceableItemTemplateID: 651,
mySubscription.PriceableItemInstanceID: 656,
mySubscription.ProductOfferingID: 649,
mySubscription.SubscriptionID: 1854752297,
mySubscription.SubscriptionStart: 2/9/2011,
mySubscription.SubscriptionEnd: 1/1/2038,
mySubscription.PriceableItemTypeID: 650
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Switch Operator</displayname>
        <description>Splits an input stream based on an INTEGER valued expression. The value of the expression identifies the
        output to which each record will be directed. The output numbers are 0-based. If the function returns a negative integer
        or an integer greater than or equal to the number of inputs, a runtime error will occur.</description>
        <metraflowname>switch</metraflowname>
        <argument>
            <argname>program</argname>
            <argdescription>An INTEGER-valued MTSQL function that assigns each input record to an output.</argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
            </input>
        </inputs>
        <outputs>
            <outputunbounded>
                <outputname>output</outputname>
                <outputnumber>*</outputnumber>
            </outputunbounded>
        </outputs>
        <example>
<!--
An example:
<pre>
<font color="#0000AA">
g:generate[program="CREATE PROCEDURE p @a INTEGER
                    AS SET @a = CAST(@@RECORDCOUNT AS INTEGER)", numRecords = 5];


switch [program="CREATE FUNCTION evenOrOdd (@a INTEGER) RETURNS INTEGER AS RETURN (@a)%2"];

wentEven:expr[program="CREATE PROCEDURE f @c VARCHAR OUTPUT
                       AS SET @c = 'even'"];

wentOdd:expr[program="CREATE PROCEDURE f @c VARCHAR OUTPUT
                        AS SET @c = 'odd'"];

p1:print [numToPrint=100];
dn1:devNull;

p2:print [numToPrint=100];
dn2:devNull;

g -> switch;
switch(0) -> wentEven -> p1 -> dn1;
switch(1) -> wentOdd -> p2 -> dn2;
</font>
</pre>
The output:
<pre>
<font color="#0000AA">
a:0, c:even
a:2, c:even
a:4, c:even
a:1, c:odd
a:3, c:odd
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Taxware</displayname>
        <description>
		An operator that calls the third party software Taxware.
		The operator calculates the taxable amount.
		This operator takes arguments that identify the name of
		input columns that correspond to an argument for the
		taxware call.  Unless specified otherwise, these input
		columns should be strings.  This operator also takes
		arguments that specify the output column names to
		use for the calculated taxes.
		See the example below.
        </description>
        <metraflowname>taxware</metraflowname>
<argument><argname>systemIndicator</argname><argtype>String</argtype><argdescription> Name of input column. integer</argdescription></argument>
<argument><argname>companyID </argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>shipFromCountryCode</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>shipFromTerritory</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>shipFromProvinceCode</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>shipFromCounty</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>shipFromCountyCode</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>shipFromCity</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>shipFromPostalCode</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>shipFromZipExtension</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>destinationCountryCode</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>destinationTerritory</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>destinationProvinceCode</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>destinationCounty</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>destinationCountyCode</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>destinationCity</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>destinationPostalCode</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>destinationZipExtension</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>pooCountryCode</argname><argtype>String</argtype><argdescription>Point of origin. Name of input column.</argdescription></argument>
<argument><argname>pooTerritory</argname><argtype>String</argtype><argdescription>Point of origin. Name of input column.</argdescription></argument>
<argument><argname>pooProvinceCode</argname><argtype>String</argtype><argdescription>Point of origin. Name of input column.</argdescription></argument>
<argument><argname>pooCounty</argname><argtype>String</argtype><argdescription>Point of origin. Name of input column.</argdescription></argument>
<argument><argname>pooCountyCode</argname><argtype>String</argtype><argdescription>Point of origin. Name of input column.</argdescription></argument>
<argument><argname>pooCity</argname><argtype>String</argtype><argdescription>Point of origin. Name of input column.</argdescription></argument>
<argument><argname>pooPostalCode</argname><argtype>String</argtype><argdescription>Point of origin. Name of input column.</argdescription></argument>
<argument><argname>pooZipExtension</argname><argtype>String</argtype><argdescription>Point of origin. Name of input column.</argdescription></argument>
<argument><argname>poaCountryCode</argname><argtype>String</argtype><argdescription>Point of acceptance. Name of input column.</argdescription></argument>
<argument><argname>poaTerritory</argname><argtype>String</argtype><argdescription>Point of acceptance. Name of input column.</argdescription></argument>
<argument><argname>poaProvinceCode</argname><argtype>String</argtype><argdescription>Point of acceptance. Name of input column.</argdescription></argument>
<argument><argname>poaCounty</argname><argtype>String</argtype><argdescription>Point of acceptance. Name of input column.</argdescription></argument>
<argument><argname>poaCountyCode</argname><argtype>String</argtype><argdescription>Point of acceptance. Name of input column.</argdescription></argument>
<argument><argname>poaCity</argname><argtype>String</argtype><argdescription>Point of acceptance. Name of input column.</argdescription></argument>
<argument><argname>poaPostalCode</argname><argtype>String</argtype><argdescription>Point of acceptance. Name of input column.</argdescription></argument>
<argument><argname>poaZipExtension</argname><argtype>String</argtype><argdescription>Point of acceptance. Name of input column.</argdescription></argument>
<argument><argname>pointOfTitlePassage</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>taxingLocation</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>calculationMode</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>transactionType</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>worldTaxCode</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>taxType</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>taxPoint</argname><argtype>String</argtype> <argdescription>Name of input column. date</argdescription></argument>
<argument><argname>deliveryDate</argname><argtype>String</argtype> <argdescription>Name of input column. date</argdescription></argument>
<argument><argname>modeOfTransport</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>commodityCode</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>creditIndicator</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>countryExemptionReasonCode</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>provinceExemptionReasonCode</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>countyExemptionReasonCode</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>cityExemptionReasonCode</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>countryTaxCertificateNumber</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>provinceTaxCertificateNumber</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>countyTaxCertificateNumber</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>cityTaxCertificateNumber</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>exemptAll</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>exemptCountry</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>exemptTerritory</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>exemptProvince</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>exemptCounty</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>exemptCity</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>documentNumber</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>currencyCode</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>secondaryCurrencyCode</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>accountingReference</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>originalDocumentNumber</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>documentType</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>sellerRegistrationNumber</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>buyerRegistrationNumber</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>agentRegistrationNumber</argname><argtype>String</argtype><argdescription>Name of input column.</argdescription></argument>
<argument><argname>lineItemAmount</argname><argtype>String</argtype><argdescription>Name of input column. big integer</argdescription></argument>
<argument><argname>taxAmount </argname><argtype>String</argtype><argdescription>Name of input column. big integer</argdescription></argument>
<argument><argname>discountAmount</argname><argtype>String</argtype><argdescription>Name of input column. big integer</argdescription></argument>
<argument><argname>freightAmount</argname><argtype>String</argtype><argdescription>Name of input column. big integer</argdescription></argument>
<argument><argname>insuranceAmountLocal</argname><argtype>String</argtype><argdescription>Name of input column. big integer</argdescription></argument>
<argument><argname>countryExemptionAmount</argname><argtype>String</argtype><argdescription>Name of input column. big integer</argdescription></argument>
<argument><argname>territoryExemptionAmount</argname><argtype>String</argtype><argdescription>Name of input column. big integer</argdescription></argument>
<argument><argname>provinceExemptionAmount</argname><argtype>String</argtype><argdescription>Name of input column. big integer</argdescription></argument>
<argument><argname>countyExemptionAmount</argname><argtype>String</argtype><argdescription>Name of input column. big integer</argdescription></argument>
<argument><argname>cityExemptionAmount</argname><argtype>String</argtype><argdescription>Name of input column. big integer</argdescription></argument>
<argument><argname>districtExemptionAmount</argname><argtype>String</argtype><argdescription>Name of input column. big integer</argdescription></argument>
<argument><argname>secondaryProvinceExemptionAmount</argname><argtype>String</argtype><argdescription>Name of input column. big integer</argdescription></argument>
<argument><argname>secondaryCountyExemptionAmount</argname><argtype>String</argtype><argdescription>Name of input column. big integer</argdescription></argument>
<argument><argname>secondaryCityExemptionAmount</argname><argtype>String</argtype><argdescription>Name of input column. big integer</argdescription></argument>
<argument><argname>insuranceAmountForeign</argname><argtype>String</argtype><argdescription>Name of input column. big integer</argdescription></argument>
<argument><argname>shippingAmountForeign</argname><argtype>String</argtype><argdescription>Name of input column. big integer</argdescription></argument>
<argument><argname>contractAmount</argname><argtype>String</argtype><argdescription>Name of input column. big integer</argdescription></argument>
<argument><argname>installAmount</argname><argtype>String</argtype><argdescription>Name of input column. big integer</argdescription></argument>
<argument><argname>taxSelParm </argname><argtype>String</argtype><argdescription> Name of input column. integer where 1 = Jurisdiction determination only where 2 (or space) = Calculation only where 3 = Jurisdiction determination + calculation </argdescription></argument>
<argument><argname>calculatedAmountCountry</argname><argtype>String</argtype><argdescription> Name of output column. big integer</argdescription></argument>
<argument><argname>calculatedAmountTerritory</argname><argtype>String</argtype><argdescription>Name of output column.  big integer</argdescription></argument>
<argument><argname>calculatedAmountProvince</argname><argtype>String</argtype><argdescription>Name of output column.  big integer</argdescription></argument>
<argument><argname>calculatedAmountCounty</argname><argtype>String</argtype><argdescription>Name of output column.  big integer</argdescription></argument>
<argument><argname>calculatedAmountCity</argname><argtype>String</argtype><argdescription>Name of output column.  big integer</argdescription></argument>
<argument><argname>secondaryAmountProvince</argname><argtype>String</argtype><argdescription>Name of output column.  big integer</argdescription></argument>
<argument><argname>secondaryAmountCounty</argname><argtype>String</argtype><argdescription>Name of output column.  big integer</argdescription></argument>
<argument><argname>secondaryAmountCity</argname><argtype>String</argtype><argdescription>Name of output column.  big integer</argdescription></argument>
<argument><argname>calculatedAmountDistrict</argname><argtype>String</argtype><argdescription>Name of output column.  big integer</argdescription></argument>
<argument><argname>generalCompletionCode</argname><argtype>String</argtype><argdescription>Name of output column.</argdescription></argument>
<argument><argname>generalCompletionCodeDescription</argname><argtype>String</argtype><argdescription>Name of output column.</argdescription></argument>
	
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value default="true">parallel</value>
            <value>sequential</value>
            <optional>true</optional>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
                <inputdescription>The records to check the sorting order of.</inputdescription>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
		<outputdescription>
			Contains the output columns for taxes.
			The arguments specified determine the names
			for the output columns.
		</outputdescription>
                <outputnumber>0</outputnumber>
            </output>
            <output>
                <outputname>error</outputname>
		<outputdescription>
			If an error occurred looking up the tax, this
			output port contains the columns
			"wGeneralErrorCode" and "wGeneralErrorCodeDescription".
		</outputdescription>
                <outputnumber>1</outputnumber>
            </output>
        </outputs>
        <example>
<!--
<pre>
<font color="#0000AA">

a: import_queue[queueName="xyz"];

inputConvert: expr[program="CREATE PROCEDURE c
         @wCompanyID               NVARCHAR 
         @wShipFromCountryCode     NVARCHAR
         @wShipFromProvinceCode    NVARCHAR
         @wShipFromCity            NVARCHAR
         @wShipFromPostalCode      NVARCHAR
         @wDestinationCountryCode  NVARCHAR
         @wDestinationProvinceCode NVARCHAR
         @wDestinationCity         NVARCHAR
         @wDestinationPostalCode   NVARCHAR
         @wPOOCountryCode          NVARCHAR
         @wPOOProvinceCode         NVARCHAR
         @wPOOCity                 NVARCHAR
         @wPOOPostalCode           NVARCHAR
         @wPOACountryCode          NVARCHAR
         @wPOAProvinceCode         NVARCHAR
         @wPOACity                 NVARCHAR
         @wPOAPostalCode           NVARCHAR
         @CompanyID                VARCHAR OUTPUT 
         @ShipFromCountryCode      VARCHAR OUTPUT
         @ShipFromProvinceCode     VARCHAR OUTPUT
         @ShipFromCity             VARCHAR OUTPUT
         @ShipFromPostalCode       VARCHAR OUTPUT
         @DestinationCountryCode   VARCHAR OUTPUT
         @DestinationProvinceCode  VARCHAR OUTPUT
         @DestinationCity          VARCHAR OUTPUT
         @DestinationPostalCode    VARCHAR OUTPUT
         @POOCountryCode           VARCHAR OUTPUT
         @POOProvinceCode          VARCHAR OUTPUT
         @POOCity                  VARCHAR OUTPUT
         @POOPostalCode            VARCHAR OUTPUT
         @POACountryCode           VARCHAR OUTPUT
         @POAProvinceCode          VARCHAR OUTPUT
         @POACity                  VARCHAR OUTPUT
         @POAPostalCode            VARCHAR OUTPUT
       AS
         SET @CompanyID = CAST(@wCompanyID AS VARCHAR) 
         SET @ShipFromCountryCode = CAST(@wShipFromCountryCode AS VARCHAR)
         SET @ShipFromProvinceCode = CAST(@wShipFromProvinceCode AS VARCHAR)
         SET @ShipFromCity = CAST(@wShipFromCity AS VARCHAR)
         SET @ShipFromPostalCode = CAST(@wShipFromPostalCode AS VARCHAR)
         SET @DestinationCountryCode = CAST(@wDestinationCountryCode AS VARCHAR)
         SET @DestinationProvinceCode = CAST(@wDestinationProvinceCode AS VARCHAR)
         SET @DestinationCity = CAST(@wDestinationCity AS VARCHAR)
         SET @DestinationPostalCode = CAST(@wDestinationPostalCode AS VARCHAR)
         SET @POOCountryCode = CAST(@wPOOCountryCode AS VARCHAR)
         SET @POOProvinceCode = CAST(@wPOOProvinceCode AS VARCHAR)
         SET @POOCity = CAST(@wPOOCity AS VARCHAR)
         SET @POOPostalCode = CAST(@wPOOPostalCode AS VARCHAR)
         SET @POACountryCode = CAST(@wPOACountryCode AS VARCHAR)
         SET @POAProvinceCode = CAST(@wPOAProvinceCode AS VARCHAR)
         SET @POACity = CAST(@wPOACity AS VARCHAR)
         SET @POAPostalCode = CAST(@wPOAPostalCode AS VARCHAR)
         "];

taxware: taxware[
         companyID           =   "CompanyID",
         shipFromCountryCode =   "ShipFromCountryCode",
         shipFromProvinceCode=   "ShipFromProvinceCode",
         shipFromCity=           "ShipFromCity",
         shipFromPostalCode=     "ShipFromPostalCode",
         destinationCountryCode= "DestinationCountryCode", 
         destinationProvinceCode="DestinationProvinceCode",
         destinationCity=        "DestinationCity",
         destinationPostalCode=  "DestinationPostalCode",
         pooCountryCode=         "POOCountryCode", 
         pooProvinceCode=        "POOProvinceCode",
         pooCity=                "POOCity",
         pooPostalCode=          "POOPostalCode",
         poaCountryCode=         "POACountryCode",
         poaProvinceCode=        "POAProvinceCode",
         poaCity=                "POACity",
         poaPostalCode=          "POAPostalCode",
         lineItemAmount=         "TaxAmount",
         taxSelParm=             "TaxSelParm",
         calculatedAmountCountry="FederalTax",
         calculatedAmountTerritory="TerritoryTax",
         calculatedAmountProvince="StateTax",
         calculatedAmountCounty=  "CountyTax",
         calculatedAmountCity=    "CityTax",
         generalCompletionCode=   "GeneralErrorCode",
         generalCompletionCodeDescription="GeneralErrorCodeDescription"
       ];

bProj: project[
         column="CityTax", 
         column="FederalTax", 
         column="CountyTax", 
         column="StateTax", 
         column="TerritoryTax"]; 

b: export_queue[queueName="abc"];

errorConvert: expr[program="CREATE PROCEDURE p 
         @GeneralErrorCode             VARCHAR
         @GeneralErrorCodeDescription  VARCHAR
         @wGeneralErrorCode            NVARCHAR OUTPUT
         @wGeneralErrorCodeDescription NVARCHAR OUTPUT
       AS
         SET @wGeneralErrorCode = 
                CAST(@GeneralErrorCode AS NVARCHAR)
         SET @wGeneralErrorCodeDescription = 
                CAST(@GeneralErrorCodeDescription AS NVARCHAR)"];

cProj: project[column="wGeneralErrorCode", 
               column="wGeneralErrorCodeDescription"];

c: export_queue[queueName="{2}"];

a -> inputConvert -> taxware;

taxware(0)-> bProj -> b;

taxware(1)-> errorConvert -> cProj -> c;

</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Union All Operator</displayname>
        <description>
          Given multiple inputs all have the same columns,
          creates a single output that is the union of the inputs.
          The operator does not eliminate duplicates.
        </description>
        <metraflowname>union_all</metraflowname>
        <aliasname>union_all</aliasname>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <inputunbounded singlename="true">
                <inputname>input</inputname>
                <inputnumber>*</inputnumber>
            </inputunbounded>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
        <example>
<!--
An example:
<pre>
<font color="#0000AA">
i1: generate [
  program = 
    "CREATE PROCEDURE gen @a INTEGER @b INTEGER 
     AS
       SET @a = CAST(@@RECORDCOUNT AS INTEGER)
       SET @b = CAST(@@RECORDCOUNT AS INTEGER)",
  numRecords = 4];

i2: generate [
  program = 
    "CREATE PROCEDURE gen @a INTEGER @b INTEGER 
     AS
       SET @a = 10 - CAST(@@RECORDCOUNT AS INTEGER)
       SET @b = 10 - CAST(@@RECORDCOUNT AS INTEGER)",
  numRecords = 4];

u: union_all [];
p1: print [numToPrint=8];
dn1:devNull;

i1 -> u(0);
i2 -> u(1);
u -> p1 -> dn1;
</font>
</pre>
The output:
<pre>
<font color="#0000AA">
a:0, b:0
a:1, b:1
a:2, b:2
a:3, b:3
a:10, b:10
a:9, b:9
a:8, b:8
a:7, b:7
</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Unroll Operator</displayname>
        <description>
          Takes input in which one of the columns
          indicates the number of times the row should be 
          repeated in the output.  The output is constructed
          by taking the input row and repeating it the
          specified number of times.  The column indicating
          the number of repeat times is also in the output, but the value
          of the column contains an iteration count
          of the repeated rows.
        </description>
        <metraflowname>unroll</metraflowname>
        <argument>
            <argname>count</argname>
            <argtype>String</argtype>
            <argdescription>Name of a column in the input whose value specifies the number of copies requested for a given record. The type of this
              row must be INTEGER.  On output this column will contain the 0-based index of the duplicate created.</argdescription>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
        <example>
<!--
An example:
<pre>
<font color="#0000AA">
g: generate [program = 
                "CREATE PROCEDURE gen @a INTEGER 
                                      @b INTEGER
                                      @replicateTimes INTEGER
                 AS SET @a = 1 + CAST(@@RECORDCOUNT AS INTEGER)
                    SET @b = 10 - CAST(@@RECORDCOUNT AS INTEGER)
                    SET @replicateTimes = 1 + CAST(@@RECORDCOUNT AS INTEGER)",
             numRecords = 3];

u: unroll[count="replicateTimes"];

p: print[numToPrint=100];

d: devNull;

g -> u -> p -> d;
</font>
</pre>
The output:
<pre>
<font color="#0000AA">
a:1, b:10, replicateTimes:0
a:2, b:9, replicateTimes:0
a:2, b:9, replicateTimes:1
a:3, b:8, replicateTimes:0
a:3, b:8, replicateTimes:1
a:3, b:8, replicateTimes:2

</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Un-nest Operator</displayname>
        <description>
This operator is used to un-group children records
that were previously grouped with parent records. 
This is known as unnesting.  In a record of this sort,
the children of the parent are expressed as sublists
with in the parent.  See the example below.
The result of nesting is that a single record is flattened,
eliminating the sublist, into multiple records -- one record
for each child.  To distinquish
the parent fields from the children fields, the parent
fields are given a prefix.
        </description>       
        <metraflowname>unnest</metraflowname>
        <argument>
            <argname>prefix</argname>
            <argdescription>A prefix to preprend to parent fields.
            </argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>recordName</argname>
            <argdescription>Name of the children sublist record.
            </argdescription>
            <argtype>String</argtype>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputnumber>0</outputnumber>
            </output>
        </outputs>
        <example>
<!--
This is an example:
<pre>
<font color="#0000AA">

readData: import[filename="test_sort_nest.data",
          format="myRec (
               ConferenceID    text_delimited_base10_int32(delimiter='|'),
               ConferenceAcct  text_delimited_base10_int32(delimiter='|'),
               ChildID         text_delimited_base10_int32(delimiter='|'),
               NumMinutes      text_delimited_base10_int32(delimiter=crlf))",
          mode="sequential"];

printInput: print[label="Input:   ", numToPrint=10];

readData -> printInput;

nest: sort_nest[key="ConferenceID",
                recordName="children",
                parentKey="ConferenceID",
                parentKey="ConferenceAcct",
                alwaysUpdateParent=true];

printInput -> nest;

printNestOutput: print[label="Input After Nesting:   ", numToPrint=10];

nest -> printNestOutput;

unnest: unnest[prefix="parent",
               recordName="children"];

printNestOutput -> unnest;

printUnnestOutput: print[label="After Unnesting:   ", numToPrint=10];

unnest -> printUnnestOutput;

devNull[];

printUnnestOutput -> devNull;
</font>
</pre>
The output is:
<pre>
<font color="#0000AA">
Input:   ConferenceID:100, ConferenceAcct:1000, ChildID:1, NumMinutes:10
Input:   ConferenceID:100, ConferenceAcct:1000, ChildID:2, NumMinutes:11
Input:   ConferenceID:100, ConferenceAcct:1000, ChildID:3, NumMinutes:9
Input:   ConferenceID:200, ConferenceAcct:2000, ChildID:1, NumMinutes:5
Input:   ConferenceID:200, ConferenceAcct:2000, ChildID:2, NumMinutes:6
Input After Nesting:   ConferenceID:100, ConferenceAcct:1000, children:[
    [ChildID:1, NumMinutes:10], 
    [ChildID:2, NumMinutes:11], 
    [ChildID:3, NumMinutes:9]
]
Input After Nesting:   ConferenceID:200, ConferenceAcct:2000, children:[
    [ChildID:1, NumMinutes:5], 
    [ChildID:2, NumMinutes:6]
]
After Unnesting:   parent.ConferenceID:100, parent.ConferenceAcct:1000, ChildID:1, NumMinutes:10
After Unnesting:   parent.ConferenceID:100, parent.ConferenceAcct:1000, ChildID:2, NumMinutes:11
After Unnesting:   parent.ConferenceID:100, parent.ConferenceAcct:1000, ChildID:3, NumMinutes:9
After Unnesting:   parent.ConferenceID:200, parent.ConferenceAcct:2000, ChildID:1, NumMinutes:5
After Unnesting:   parent.ConferenceID:200, parent.ConferenceAcct:2000, ChildID:2, NumMinutes:6

</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Usage Interval Resolution</displayname>
        <description>
          Given an account ID and a timestamp, this operator determines 
          the usage interval.  The operator expects to be given the fields: 
          Usage.AccountID, Usage.Timestamp and Usage.IntervalID.
          Usage.AccountID must contain the account ID and 
          Usage.Timestamp must contain the timestamp to evaluate.
          The operator will set the field Usage.IntervalID
          to the determined interval.  If not acceptable
          interval is found, then Usage.IntervalID is not set.
          The selected interval must meet these conditions: 
          (1) the interval is open (or is soft-closed and input
          field _IsSoftOverride is TRUE) and (2) the timestamp
          is less than the interval end time.  From all acceptable
          intervals, the operator selects the interval with the 
          minimum effective date (or if the effective date is null,
          then the start time).  NOTE: to use this operator, 
          you must use the statement: include "UsageIntervalResolution.mfs"
          at the beginning of your script.
          This operator branches the dataflow.
          If there are no errors, then the dataflow continues
          to "output" port.  If there is an error, the dataflows
          continues to "error" port.
        </description>
        <metraflowname>usageIntervalResolution</metraflowname>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
                <inputfield>
                  <inputfieldname>Usage.AccountID</inputfieldname>
                  <inputfielddescription>The account ID</inputfielddescription>
                </inputfield>
                <inputfield>
                  <inputfieldname>Usage.Timestamp</inputfieldname>
                  <inputfielddescription>The time of the usage event</inputfielddescription>
                </inputfield>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputfield>
                  <outputfieldname>Usage.IntervalID</outputfieldname>
                  <outputfielddescription>The usage interval.  Not set
                                         If no interval is found.
                  </outputfielddescription>
                </outputfield>
                <outputfield>
                  <outputfieldname>Usage.IntervalStartTime</outputfieldname>
                  <outputfielddescription>
                  </outputfielddescription>
                </outputfield>
                <outputfield>
                  <outputfieldname>Usage.IntervalEndTime</outputfieldname>
                  <outputfielddescription>
                  </outputfielddescription>
                </outputfield>
                <outputfield>
                  <outputfieldname>Usage.IntervalEffectiveStartTime</outputfieldname>
                  <outputfielddescription>
                  </outputfielddescription>
                </outputfield>
                <outputnumber>0</outputnumber>
            </output>
            <output>
                <outputname>error</outputname>
                <outputdescription>
                  If an error occurs, the dataflow
                  continues out this port rather than
                  port 0 ("output").
                </outputdescription>
                <outputnumber>1</outputnumber>
            </output>
        </outputs>
        <example>
<!--
An example:
<pre>
<font color="#0000AA">
include "UsageIntervalResolution.mfs"

g: generate [
        program =
        "CREATE PROCEDURE gen @Usage.AccountID INTEGER OUTPUT
                              @Usage.Timestamp DATETIME OUTPUT
                              @Usage.IntervalID INTEGER OUTPUT
        AS
        SET @Usage.AccountID = 123
        SET @Usage.Timestamp = CAST('2 SEP 2010' AS DATETIME)",
        numRecords = 1];


u: usageIntervalResolution[];
p1: print[];
p2: print[];
d1: devNull[];
d2: devNull[];

g -> u;
u("output") -> p1 -> d1;
u("error")  -> p2 -> d2;

</font>
</pre>
Sample output:
<pre>
<font color="#0000AA">
Usage.AccountID:123, 
Usage.Timestamp:9/2/2010, 
Usage.IntervalID:975306782,
_IsSoftOverride:FALSE, 
_ErrorCode:NULL, 
_ErrorString:NULL, 
_Plugin:NULL, 
_Module:NULL

</font>
</pre>
Example error output:
<pre>
<font color="#0000AA">
Usage.AccountID:123888, 
Usage.Timestamp:9/2/2010, 
Usage.IntervalID:NULL, 
_IsSoftOverride:FALSE, 
tmpID:0, 
_ErrorCode:-517996507, 
_ErrorString:Could not find the next open usage interval for account 123888 based on a transaction time of 9/2/2010, 
_Plugin:usageIntervalResolution, 
_Module:usageIntervalResolution

</font>
</pre>
-->
        </example>
    </operator>
    <operator>
        <displayname>Write Product View</displayname>
        <description>
          Writes the given information into the named
          product view and t_acc_usage tables.
          The product view name is identified through the
          "productView" parameter. The product view name
          identifies the associated product view table 
          (example: t_pv_songdownloads).
          This operator writes to both the product view table 
          and to t_acc_usage.
          The data being written comes from the input port.
          The input port must contain a Usage record.
          The input port must also contains all the other fields 
          that make up the product view.
          The data to be inserted must conform to the contraints
          on both the t_acc_usage table and the t_pv_ table.
      If you are writing a multipoint record (the parent, or a child), 
      you must use the "multipoint" argument.  See below for a
      description.
          If there are no errors, then the dataflow continues
          to "output" port.  If there is an error, the dataflows
          continues to "error" port.
        </description>
        <metraflowname>writeProductView</metraflowname>
        <argument>
            <argname>productView</argname>
            <argtype>String</argtype>
            <argdescription>Name of a product view. The product view name
              should exist in table t_prod_view.  The t_prod_view
              defines the name of the table where the product view
              information will be stored (for example: t_pv_songdownloads).
            </argdescription>
        </argument>
        <argument>
            <argname>mode</argname>
            <argtype>String</argtype>
            <argdescription>Controls whether the operator executes in parallel or not.</argdescription>
            <value>parallel</value>
            <value>sequential</value>
            <optional>true</optional>
            <default>parallel</default>
        </argument>
        <argument>
            <argname>multipoint</argname>
            <argtype>String</argtype>
        <argdescription>
            If you are writing a singlepoint record, then
            you should not use this argument.
            If you are writing a multipoint/parent record,
            then you must: (1) before calling this operator,
            generate a unique session ID (id_sess) that is
            used to link the parent to the child, (2) set
            variable parentID to this value and make sure that
            this flows into this operator, (3)
            specify multipoint="parent" in this operator call.
            If you are writing a multipoint/child record,
            then you must: (1) set variable parentID to the
            session ID (id_sess) of the parent and make sure that
            this flows into this operator, (2) specify
            multipoint="child" in this operator call.
        </argdescription>
        <argvalue><argvaluename>child</argvaluename></argvalue>
        <argvalue><argvaluename>parent</argvaluename></argvalue>
        <argvalue><argvaluename>none</argvaluename></argvalue>
            <optional>true</optional>
            <default>none</default>
        </argument>
        <inputs>
            <input>
                <inputname>input</inputname>
                <inputnumber>0</inputnumber>
                <inputfield>
                  <inputfieldname>*</inputfieldname>
                  <inputfielddescription>
          The operator expects to be given 
the values for the columns
in the product view table (t_pv_...) that are required (not
permitted to be null).
Also the operator must be given
                  </inputfielddescription>
                </inputfield>
                <inputfield>
                  <inputfieldname>Usage</inputfieldname>
                  <inputfielddescription>
                    Contains information describing the
                    usage interval.  This is typically
                    filled in by using the operator
                    usageResolution.
                  </inputfielddescription>
                </inputfield>
            </input>
        </inputs>
        <outputs>
            <output>
                <outputname>output</outputname>
                <outputdescription>
              </outputdescription>
                <outputnumber>0</outputnumber>
            </output>
            <output>
                <outputname>error</outputname>
                <outputdescription>
                  If an error occurs, the dataflow
                  continues out this port rather than
                  port 0 ("output").
                </outputdescription>
                <outputnumber>1</outputnumber>
            </output>
        </outputs>
        <example>
<!--
See <a href="#usageRecord">Usage Record</a> for more details
about the usage record.
<p/>
A singlepoint example:
<pre>
<font color="#0000AA">
g: generate [
    program = 
    "CREATE PROCEDURE gen       @PayingAccountID         INTEGER  OUTPUT
                              @Timestamp               DATETIME OUTPUT
                              @PriceableItemInstanceID INTEGER  OUTPUT
                              @PriceableItemTemplateID INTEGER  OUTPUT
                              @ProductOfferingID       INTEGER  OUTPUT
                              @AccountID               INTEGER  OUTPUT
                              @SessionID               BINARY   OUTPUT
                              @Amount                  DECIMAL  OUTPUT
                              @Currency                NVARCHAR OUTPUT
                              @FedTax                  DECIMAL  OUTPUT
                              @StateTax                DECIMAL  OUTPUT
                              @CountyTax               DECIMAL  OUTPUT
                              @LocalTax                DECIMAL  OUTPUT
                              @OtherTax                DECIMAL  OUTPUT
                              @IntervalID              INTEGER  OUTPUT
                              @SubscriptionEntity      INTEGER  OUTPUT
                              @CollectionID            BINARY   OUTPUT
                              @TotalSongs              DECIMAL  OUTPUT
    AS
        SET @PayingAccountID = 123
        SET @AccountID = 123
        SET @IntervalID = 975306782
        SET @Amount = 1000
        SET @Currency = N'USD'
        SET @Timestamp = CAST('2 SEP 2010' AS DATETIME)
        SET @TotalSongs = 5.0",
    numRecords = 1];

/* Create a Usage record */
c: rename[from= "PayingAccountID",         to="Usage.PayingAccountID",
          from= "Timestamp",               to="Usage.Timestamp",
          from= "PriceableItemInstanceID", to="Usage.PriceableItemInstanceID",
          from= "PriceableItemTemplateID", to="Usage.PriceableItemTemplateID",
          from= "ProductOfferingID",       to="Usage.ProductOfferingID",
          from= "AccountID",               to="Usage.AccountID",
          from= "SessionID",               to="Usage.SessionID",
          from= "Amount",                  to="Usage.Amount",
          from= "Currency",                to="Usage.Currency",
          from= "FedTax",                  to="Usage.FedTax",
          from= "StateTax",                to="Usage.StateTax",
          from= "CountyTax",               to="Usage.CountyTax",
          from= "LocalTax",                to="Usage.LocalTax",
          from= "OtherTax",                to="Usage.OtherTax",
          from= "IntervalID",              to="Usage.IntervalID",
          from= "SubscriptionEntity",      to="Usage.SubscriptionEntity",
          from= "CollectionID",            to="Usage.CollectionID"];

w: write_product_view[productView="metratech.com/songdownloads"];

p1: print[];
p2: print[];
d1: devNull[];
d2: devNull[];

g -> c -> w;
w("output") -> p1 -> d1;
w("error")  -> p2 -> d2;
</font>
</pre>
Example code you can use to create the parent session
ID when writing multipoint records.
<pre>
<font color="#0000AA">
createParentID: id_generator[id="parentID", 
                             sequence="id_sess", 
                             blockSize=1];
</font>
</pre>
-->
        </example>
    </operator>
</operators> 

