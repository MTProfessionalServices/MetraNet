header {
  #include "LogAdapter.h"
  #include "MTSQLParam.h"	
  #include "ScriptInterpreter.h"
  #include "MyAST.h"
  #include "DataflowException.h"
  #include "Workflow.h"
  #include "WorkflowInstruction.h"
  #include <stdexcept>
  #include <boost/lexical_cast.hpp>
  #include <boost/tuple/tuple.hpp>
  #include <boost/variant.hpp>
  #include <boost/format.hpp>
  #include <map>
}

options {
	language = "Cpp";
}

class DataflowTreeParser extends TreeParser;
options {
  importVocab=DataflowParser; // use vocab generated by lexer
  buildAST = true;
  defaultErrorHandler = false;
  ASTLabelType = "RefMyAST";
}

tokens 
{
  DELAYED_GENERATE;
}

{
private:
  /** Last error message (corresponds to mHasError) */
  MetraFlowLoggerPtr mLog;

  /** True if an error has occurred. */
  bool mHasError;

  /** Map of the symbol tables for the steps. */
  std::map<std::wstring, DataflowSymbolTable*>* mMapOfSymbolTables;

  /** 
   * Symbol table for operators in the main script. This symbol table
   * is in the mMapOfSymbolTables, but we use this variable for
   * convenience.
   */
  DataflowSymbolTable * mMainSymbolTable;

  /** Dictionary of defined composites. */
  CompositeDictionary *mCompositeDictionary;    

  /**
   * Active symbol table.  We may be storing operators
   * in (1) a symbol table associated with the main script,
   * (2) a symbol table associated with a step, or (3)
   * a symbol table associated with a composite.
   */
  DataflowSymbolTable *mActiveSymbolTable;

  /** The name of the file being parsed. Used for error reporting. */
  std::wstring mFilename;

  /**
   * The encoding of the file.  Defaults to locale codepage but may
   * overridden (e.g. to UTF8).
   */
  boost::int32_t mEncoding;

private:
  /** Convert the standard string to a wide-string */
  std::wstring ASCIIToWide(const std::string& str)
  {
    std::wstring wstr;
    ::ASCIIToWide(wstr, str.c_str(), -1, mEncoding);
    return wstr;
  }

  /**
   * Add the given operator name to the symbol table.
   * The operator maybe added to the symbol table for the
   * main script or maybe added to the symbol table for
   * a composite depending upon which symbol table is active.
   * Check if the given operator has already been defined.
   * If so, throw an exception.
   *
   * @param id  AST containing name of the operator
   */
  void addOperator(RefMyAST id)
  {
    DataflowSymbolTable *activeTable = mActiveSymbolTable;
    std::wstring name = ASCIIToWide(id->getText());
    if (activeTable->find(name) != activeTable->end())
    {
      throw DataflowRedefinedOperatorException(
              name,
              (*activeTable)[name].LineNumber,
              (*activeTable)[name].ColumnNumber,
              mFilename,
              id->getLine(),
              id->getColumn());
    }

    (*activeTable)[name] = DataflowSymbol();;
    (*activeTable)[name].LineNumber = id->getLine();
  }
  
public:
  virtual void program(ANTLR_USE_NAMESPACE(antlr)RefAST _t)
  {
    // Since we are exclusively using MyAST as the AST Type in
    // the AST tree built by DataflowParser and DataflowTreeParser, 
    // we can safely cast the RefAST to RefMyAST.
    // There may be a way to tell ANTLR that RefMyAST's are being
    // used rather that RefAST's to avoid this cast, but I
    // haven't found it.
    program((RefMyAST)_t);
  }

  /**
   * Set the map of step name to symbol table.
   * The symbol table is used for operators encountered
   * in the step or main script (rather than in composite definitions).
   * This should be called prior to invoking program().
   * This class does not own the symbol table.
   */
  void setSymbolTable(
            std::map<std::wstring, DataflowSymbolTable*>* mapOfSymbolTables)
  {
    // Default, there is always a default step.
    // Create a symbol table for this default step.
    std::map<std::wstring, DataflowSymbol> 
                    *symbolTable = new std::map<std::wstring, DataflowSymbol>;

    (*mapOfSymbolTables)[Workflow::DefaultStepName] = symbolTable;

    mMapOfSymbolTables = mapOfSymbolTables;
    mMainSymbolTable = symbolTable;
    mActiveSymbolTable = mMainSymbolTable;
  }

  /**
   * Set the composite dictionary.  This class does not own this
   * dictionary and is NOT responsible for freeing it.
   */
  void setCompositeDictionary(CompositeDictionary *dictionary)
  {
    mCompositeDictionary = dictionary;
  }  

  /** Set the name of the file being parsed. Used for error reporting. */
  void setFilename(const std::wstring &filename)
  {
    mFilename = filename;
  }

  /** Override the error and warning reporting */
  virtual void reportError(
                const ANTLR_USE_NAMESPACE(antlr)RecognitionException& ex)
  {
	  mLog->logError(ex.toString());
      mHasError = true;
  }

	/** Parser error-reporting function can be overridden in subclass */
  virtual void reportError(const ANTLR_USE_NAMESPACE(std)string& s)
  {
	  mLog->logError(s);
      mHasError = true;
  }

	/** Parser warning-reporting function can be overridden in subclass */
  virtual void reportWarning(const ANTLR_USE_NAMESPACE(std)string& s)
  {
	  mLog->logWarning(s);
  }

  void setLog(MetraFlowLoggerPtr log)
  {
	  mLog = log;
      mHasError = false;
  }

  bool getHasError()
  {
	return mHasError;
  }
  
  void setLog(Logger * log)
  {
  }

  std::vector<MTSQLParam> antlr::TreeParser::getParams(void)
  {
    return std::vector<MTSQLParam>();
  }

  /**
   * Set encoding of the parser.
   */
  void setEncoding(boost::int32_t encoding)
  {
    mEncoding = encoding;
  }

}


program
  :
  ((includeCompositeStatement (SEMI!)?)*
   (compositeDeclaration | stepDeclaration)* 
   (mainScript)?) EOF
  ;

mainScript
  :
  (dataFlowBody)
  (controlFlow)?
  ;

dataFlowBody
  :
  (
  accountResolutionStatement
  |
  broadcastStatement
  |
  collStatement
  |
  compositeStatement
  |
  copyStatement
  |
  devNullStatement
  | 
  exportStatement 
  |
  exportQueueStatement 
  |
  exprStatement
  |
  filterStatement
  |
  generateStatement
  |
  groupByStatement
  | 
  hashPartStatement 
  | 
  hashRunningTotalStatement 
  | 
  idGeneratorStatement 
  | 
  importStatement 
  | 
  importQueueStatement 
  | 
  innerHashJoinStatement 
  | 
  innerMergeJoinStatement 
  | 
  insertStatement 
  |
  loadErrorStatement 
  |
  loadUsageStatement 
  |
  longestPrefixMatchStatement 
  |
  md5Statement 
  |
  meterStatement 
  |
  multiHashJoinStatement 
  | 
  printStatement 
  |
  projectionStatement 
  |
  rangePartStatement 
  | 
  rateCalculationStatement 
  | 
  rateScheduleResolutionStatement 
  | 
  renameStatement 
  | 
  rightMergeAntiSemiJoinStatement 
  | 
  rightMergeSemiJoinStatement 
  | 
  rightOuterHashJoinStatement 
  | 
  rightOuterMergeJoinStatement 
  | 
  selectStatement 
  | 
  sequentialFileDeleteStatement 
  | 
  sequentialFileOutputStatement 
  | 
  sequentialFileRenameStatement 
  | 
  sequentialFileScanStatement 
  | 
  sessionSetBuilderStatement 
  | 
  sortStatement 
  | 
  sortGroupByStatement 
  | 
  sortMergeStatement 
  | 
  sortMergeCollStatement 
  | 
  sortNestStatement 
  | 
  sortOrderAssertStatement 
  | 
  sortRunningTotalStatement 
  | 
  sqlExecDirectStatement 
  | 
  subscriptionResolutionStatement 
  | 
  switchStatement 
  | 
  taxwareStatement 
  | 
  unionAllStatement 
  | 
  unnestStatement 
  | 
  unrollStatement 
  | 
  writeErrorStatement 
  | 
  writeProductViewStatement 
  | 
  edgeStatement 
  )*	
  ;

includeCompositeStatement
  :
  (INCLUDE_COMPOSITE filename:STRING_LITERAL)
  ;
  
compositeDeclaration
  {
    // We are processing a composite declaration.
    // We make a new symbol table to hold the operator definitions.
    // This will be stored as part of the composite definition.
    std::map<std::wstring, DataflowSymbol> *compositeSymbolTable =
      new std::map<std::wstring, DataflowSymbol>;

    // All operators that we encountered will be stored to this table.
    mActiveSymbolTable = compositeSymbolTable;
  }
  :
  #(OPERATOR compositeNameId:ID compositeParameters compositeBody)
  {
    // When we reach this point, we have finished parsing the composite.
    // Our symbol table is loaded with the encountered operators.
    // Save the symbol table underneath the composite definition.
    // Ownership of symbol table is given to the composite definition.
    // Update the symbol table input/output port counts to reflect
    // composite parameters.
    mCompositeDictionary->setSymbolTableAndUpdateForComposite(
                            ASCIIToWide(compositeNameId->getText()), compositeSymbolTable);

    // We are done processing the composite declaration.
    // We now assume we are processing script.
    mActiveSymbolTable = mMainSymbolTable;
  }
  ;

compositeParameters
  :
  (compositeParameterSpec)*;

compositeParameterSpec
  :
  (compositeParameterInputSpec | 
   compositeParameterOutputSpec |
   compositeArgSpec
  );

compositeParameterInputSpec
  :
  #(INPUT STRING_LITERAL IS operatorId:ID (NUM_INT | STRING_LITERAL))
  ;

compositeParameterOutputSpec
  :
  #(OUTPUT STRING_LITERAL IS operatorId:ID (NUM_INT | STRING_LITERAL))
  ;

compositeArgSpec
  :
  (compositeArgSpecString | compositeArgSpecInt | compositeArgSpecBool |
   compositeArgSpecSublist )
  ;

compositeArgSpecString
  :
  #(STRING_DECL DOLLAR_SIGN ID)
  ;

compositeArgSpecInt
  :
  #(INTEGER_DECL DOLLAR_SIGN ID)
  ;

compositeArgSpecBool
  :
  #(BOOLEAN_DECL DOLLAR_SIGN ID)
  ;

compositeArgSpecSublist
  :
  #(SUBLIST_DECL DOLLAR_SIGN ID)
  ;

compositeBody
  :
  (dataFlowBody)
  ;

stepDeclaration
  :
  #(STEP_DECL 
    id:ID 
    {
      // Create a map symbol for the operators in this step
      // and make this be the active symbol table.
      std::map<std::wstring, DataflowSymbol> 
                    *symbolTable = new std::map<std::wstring, DataflowSymbol>;

      (*mMapOfSymbolTables)[ASCIIToWide(#id->getText())] = symbolTable;
      mActiveSymbolTable = symbolTable;
    }
    stepBody)
    {
      // Now that we've finished with the step, set the symbol table
      // back to that of the main script.
      mActiveSymbolTable = mMainSymbolTable;
    }
  ;

stepBody
  :
  LPAREN
  (dataFlowBody)
  RPAREN
  ;

controlFlow
  : 
  STEPS_BEGIN
  controlFlowBody
  STEPS_END
  ;

controlFlowBody
  :
  (stepStatement | ifStatement) *
  ;

ifStatement
  :
  IF_BEGIN
  LPAREN
  ifPredicate
  RPAREN
  THEN
  controlFlowBody
  ( ELSE
    controlFlowBody )?
  IF_END
  ;

ifPredicate
  :
  (BANG)?
  (PREDICATE_DOES_FILE_EXIST |
   PREDICATE_IS_FILE_EMPTY )
  LPAREN ifArgument RPAREN
  ;

stepStatement
  :
  (id:STEP)
  ;

accountResolutionStatement
  :
  #(id:ACCOUNT_RESOLUTION (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

broadcastStatement
  :
  #(id:BROADCAST (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

collStatement
  :
  #(id:COLL (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

copyStatement
  :
  #(id:COPY (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

devNullStatement
  :
  #(id:DEVNULL (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

selectStatement
  :
  #(id:SELECT (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

sequentialFileDeleteStatement
  :
  #(id:SEQUENTIAL_FILE_DELETE (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

sequentialFileOutputStatement
  :
  #(id:SEQUENTIAL_FILE_OUTPUT (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

sequentialFileRenameStatement
  :
  #(id:SEQUENTIAL_FILE_RENAME (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

sequentialFileScanStatement
  :
  #(id:SEQUENTIAL_FILE_SCAN (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

exportStatement
  :
  #(id:EXPORT (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

exportQueueStatement
  :
  #(id:EXPORT_QUEUE (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

exprStatement
  :
  #(id:EXPR (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

filterStatement
  :
  #(id:FILTER (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

generateStatement
  :
  #(id:GENERATE (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  ) 
  {
    ## = #([DELAYED_GENERATE, "DELAYED_GENERATE"], ##);
  }
  ;

groupByStatement
  :
  #(id:GROUP_BY (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

hashPartStatement
  :
  #(id:HASHPART (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

hashRunningTotalStatement
  :
  #(id:HASH_RUNNING_TOTAL (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

idGeneratorStatement
  :
  #(id:ID_GENERATOR (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

importStatement
  :
  #(id:IMPORT (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

importQueueStatement
  :
  #(id:IMPORT_QUEUE (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

innerHashJoinStatement
  :
  #(id:INNER_HASH_JOIN (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

innerMergeJoinStatement
  :
  #(id:INNER_MERGE_JOIN (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

insertStatement
  :
  #(id:INSERT (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

loadErrorStatement
  :
  #(id:LOAD_ERROR (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

loadUsageStatement
  :
  #(id:LOAD_USAGE (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

longestPrefixMatchStatement
  :
  #(id:LONGEST_PREFIX_MATCH (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

md5Statement
  :
  #(id:MD5 (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

meterStatement
  :
  #(id:METER (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

multiHashJoinStatement
  :
  #(id:MULTI_HASH_JOIN (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

printStatement
  :
  #(id:PRINT (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

projectionStatement
  :
  #(id:PROJECTION (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

rangePartStatement
  :
  #(id:RANGEPART (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

rateCalculationStatement
  :
  #(id:RATE_CALCULATION (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

rateScheduleResolutionStatement
  :
  #(id:RATE_SCHEDULE_RESOLUTION (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

renameStatement
  :
  #(id:RENAME (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;


rightMergeAntiSemiJoinStatement 
  :
  #(id:RIGHT_MERGE_ANTI_SEMI_JOIN (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

rightMergeSemiJoinStatement 
  :
  #(id:RIGHT_MERGE_SEMI_JOIN (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

rightOuterHashJoinStatement
  :
  #(id:RIGHT_OUTER_HASH_JOIN (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

rightOuterMergeJoinStatement 
  :
  #(id:RIGHT_OUTER_MERGE_JOIN (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

sessionSetBuilderStatement
  :
  #(id:SESSION_SET_BUILDER (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

sortStatement
  :
  #(id:SORT (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

sortGroupByStatement
  :
  #(id:SORT_GROUP_BY (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

sortMergeStatement
  :
  #(id:SORTMERGE (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

sortMergeCollStatement
  :
  #(id:SORTMERGECOLL (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

sortNestStatement
  :
  #(id:SORT_NEST (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

sortOrderAssertStatement
  :
  #(id:SORT_ORDER_ASSERT (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

sortRunningTotalStatement
  :
  #(id:SORT_RUNNING_TOTAL (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

sqlExecDirectStatement
  :
  #(id:SQL_EXEC_DIRECT (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

subscriptionResolutionStatement
  :
  #(id:SUBSCRIPTION_RESOLUTION (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

switchStatement
  :
  #(id:SWITCH (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

taxwareStatement
  :
  #(id:TAXWARE (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

unionAllStatement
  :
  #(id:UNION_ALL (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

unnestStatement
  :
  #(id:UNNEST (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

unrollStatement
  :
  #(id:UNROLL (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

writeErrorStatement
  :
  #(id:WRITE_ERROR (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

writeProductViewStatement
  :
  #(id:WRITE_PRODUCT_VIEW (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

compositeStatement
  :
  #(id:COMPOSITE (COLON id2:ID)?
    (nodeArgument)*
    {
      addOperator(id);
    }
  )
  ;

nodeArgument
  :
  #(ID (nodeArgumentValue | argumentVariable))
  ;

nodeArgumentValue
  :
  NUM_INT
  |
  NUM_BIGINT
  |
  NUM_FLOAT
  |
  NUM_DECIMAL
  |
  STRING_LITERAL
  |
  TK_TRUE
  |
  TK_FALSE
  |
  (nodeArgument)+
  ;

argumentVariable
  :
  DOLLAR_SIGN ID
  ;

ifArgument
  :
  (ifArgumentValue | argumentVariable)
  ;

ifArgumentValue
  :
  STRING_LITERAL
  ;

edgeStatement
{
  boost::tuple<std::wstring, int, int> lhs; 
  //     tuple<operator name, line number, column number>
  boost::tuple<std::wstring, boost::variant<int,std::wstring>, int, int> rhs;
  //     tuple<operator name, <port int, port name>, line number, column number>
}
  :
  #(ARROW lhs=arrowOrRefStatement (arrowArguments)? (annotationArguments!)? rhs = nodeRefStatement) 
  {
    std::map<std::wstring,DataflowSymbol >::iterator leftIt(mActiveSymbolTable->find(lhs.get<0>()));
    std::map<std::wstring,DataflowSymbol >::iterator rightIt(mActiveSymbolTable->find(rhs.get<0>()));

    if (leftIt == mActiveSymbolTable->end())
      throw DataflowArrowUndefOperatorException(lhs.get<0>(),lhs.get<1>(), 
                                                lhs.get<2>(), mFilename);
    if (rightIt == mActiveSymbolTable->end())
      throw DataflowArrowUndefOperatorException(rhs.get<0>(),rhs.get<2>(), 
                                                rhs.get<3>(), mFilename);

    // Update the number of inputs and outputs.
    leftIt->second.NumOutputs += 1;
    rightIt->second.NumInputs += 1;
  }
  ;

// Returns tuple <operator name, line number, column number>
arrowOrRefStatement returns [boost::tuple<std::wstring, int, int > t]
{
  boost::tuple<std::wstring, int, int> lhs;
  //     tuple<operator name, line number, column number>
  boost::tuple<std::wstring, boost::variant<int,std::wstring>, int, int> rhs;
  //     tuple<operator name, <port int, port name>, line number, column number>
}
  :
  #(ARROW lhs=arrowOrRefStatement (arrowArguments)? (annotationArguments!)? rhs = nodeRefStatement) 
  {
    t = boost::tuple<std::wstring, int, int >(rhs.get<0>(), rhs.get<2>(), rhs.get<3>());

    std::map<std::wstring,DataflowSymbol >::iterator leftIt(mActiveSymbolTable->find(lhs.get<0>()));
    std::map<std::wstring,DataflowSymbol >::iterator rightIt(mActiveSymbolTable->find(rhs.get<0>()));

    if (leftIt == mActiveSymbolTable->end())
      throw DataflowArrowUndefOperatorException(lhs.get<0>(), lhs.get<1>(), 
                                                lhs.get<2>(), mFilename);
    if (rightIt == mActiveSymbolTable->end())
      throw DataflowArrowUndefOperatorException(rhs.get<0>(), rhs.get<2>(), 
                                                rhs.get<3>(), mFilename);

    // Update the number of inputs and outputs.
    leftIt->second.NumOutputs += 1;
    rightIt->second.NumInputs += 1;
  }
  |
  rhs = nodeRefStatement
  { 
    t = boost::tuple<std::wstring, int, int >(rhs.get<0>(), rhs.get<2>(), rhs.get<3>());
  }
  ;

arrowArguments
  :
  #(LBRACKET (nodeArgument)*)
  ;

annotationArguments
  :
  #(LCURLY (annotationArgument)*)
  ;

annotationArgument
  :
  #(ID ID)
  ;

// Returns a tuple of (operator name, portIndex/portName, operator line number, column number)
nodeRefStatement returns [boost::tuple<std::wstring, boost::variant<int,std::wstring>, int, int > t]
{
  std::wstring nodeName;
  int portIndex(0);
  std::wstring portName;
  int lineNumber;
  int columnNumber;
}
  :
  #(id:ID 
    {
      nodeName = ASCIIToWide(#id->getText());
      lineNumber = id->getLine();
      columnNumber = id->getColumn();
    }
          (i:NUM_INT 
           { 
             portIndex = boost::lexical_cast<int>(#i->getText()); 
           } 
           | 
           s:STRING_LITERAL 
           { 
             portName = ASCIIToWide(#s->getText().substr(1, #s->getText().size()-2));
           }
          )?
   )
  {
    if (portName.size() != 0)
    {
      t = boost::tuple<std::wstring, boost::variant<int,std::wstring>, int, int >(nodeName, portName, lineNumber, columnNumber);
    }
    else
    {
      t = boost::tuple<std::wstring, boost::variant<int,std::wstring>, int, int >(nodeName, portIndex, lineNumber, columnNumber);
    }
  }
  ;

