header {
  // Prevent inclusion of WinSock since ASIO uses WinSock2
  #define _WINSOCKAPI_
  #include "DatabaseSelect.h"
  #include "ScriptInterpreter.h"

  #include <boost/algorithm/string/predicate.hpp>
  #include <boost/lexical_cast.hpp>
  #include <boost/tuple/tuple.hpp>
  #include <boost/variant.hpp>
  #include <boost/format.hpp>
  #include <boost/filesystem/path.hpp>
  #include <boost/filesystem/fstream.hpp>

  #include <map>
  #include <iostream>
  #include <fstream>
}

options {
  language = "Cpp";
}

/**
 * This class is used to perform typecheck of a MetraFlow script.
 * Given an AST produced by DataFlowTreeParser (dataflow_analyze.g)
 * this class writes to standard output an annotated version
 * of the MetraFlow script show the datatype flowing across
 * edge statements (arrows).  This class is used after calling
 * DesignTimePlan::type_check() so that the annotator can access
 * metadata of the input and output ports.  
 *
 * Before calling the program() method to generate
 * the output, you must call setDesignTimePlan(), setSymbolTable(), and
 * setOutputFile().
 */
class DataflowAnnotator extends TreeParser;

options {
  importVocab = DataflowParser; // use vocab generated by parser
  buildAST = false;
  defaultErrorHandler = false;
}

{
private:
  MetraFlowLoggerPtr mLog;

  /** True if an ANTLR error occured during processing */
  bool mHasError;

  /** Contains a table of operation names and corresponding op information */
  std::map<std::string, DataflowSymbol> * mSymbol;

private:
  /** Convert given string to a wide string */
  std::wstring ASCIIToWide(const std::string& str)
  {
    std::wstring wstr;
    ::ASCIIToWide(wstr, str);
    return wstr;
  }    

  /**
   * Write to output the given parameter.
   *
   * @param parameterName  the AST token representing the parameter.
   * @param parameterValue the AST token containing the value of the parameter.
   */
  void outputArgument(ANTLR_USE_NAMESPACE(antlr) RefAST parameterName,
                      ANTLR_USE_NAMESPACE(antlr) RefAST parameterValue)
  {
    std::cout << parameterName->getText() << "=";
    std::cout << parameterValue->getText();
    if (parameterName->getNextSibling() != NULL)
    {
        std::cout << ", ";
    }
  }

  /**
   * Writes to output any syntax needed after the operation name
   * (like a left-bracket or not).
   *
   * @param opStatement  the AST token containing the statement.
   */
  void outputStatementOpen(ANTLR_USE_NAMESPACE(antlr) RefAST opStatement)
  {
    if (opStatement->getNumberOfChildren() > 0)
    {
      std::cout << "[";
    }
  }

  /**
   * Write to output any syntax need after the arguments
   * (like a right-bracket or not and an ending semi-colon.
   */
  void outputStatementClose(ANTLR_USE_NAMESPACE(antlr) RefAST opStatement)
  {
    if (opStatement->getNumberOfChildren() > 0)
    {
      std::cout << "]";
    }
    std::cout << ";\n";
  }

  /**
   * Write to output the metadata associated with the given port.
   * It is possible that the port will have no metadata (happens
   * if the MetraFlow script was not complete).
   */
  void outputPortMetadata(const boost::shared_ptr<Port> port)
  {
    if (port != NULL)
    {
      const RecordMetadata *metadata = port->GetMetadata();
      if (metadata != NULL)
      {
        std::cout << "{";

        for (int i=0; i<metadata->GetNumColumns(); i++)
        {
          DataAccessor *accessor = metadata->GetColumn(i);
          if (accessor == NULL)
          {
            mLog->logError("Encountered unexpected null in outputPortMetadata()");
            continue;
          }
          
          std::string utf8FieldName, utf8FieldType;
          ::WideStringToUTF8(accessor->GetName(), utf8FieldName);
          ::WideStringToUTF8(PhysicalFieldType::GetMTSQLDatatype(accessor), utf8FieldType);

          std::cout << utf8FieldName << " " << utf8FieldType;

          if (i != metadata->GetNumColumns()-1)
          {
            std::cout << ",";
          }
        }

        std::cout << "} ";
      }
    }
  }

public:

  ~DataflowAnnotator()
  {
  }

  /** Set the symbol table referencing operations used in the script. */
  void setSymbolTable(std::map<std::string, DataflowSymbol >& sym)
  {
    mSymbol = &sym;
  }

  /** Override the error and warning reporting */
  virtual void reportError(const ANTLR_USE_NAMESPACE(antlr)RecognitionException& ex)
  {
    mLog->logError(ex.toString());
    mHasError = true;
  }

  /** Parser error-reporting function can be overridden in subclass */
  virtual void reportError(const ANTLR_USE_NAMESPACE(std)string& s)
  {
    mLog->logError(s);
    mHasError = true;
  }

  /** Parser warning-reporting function can be overridden in subclass */
  virtual void reportWarning(const ANTLR_USE_NAMESPACE(std)string& s)
  {
    mLog->logWarning(s);
  }

  /** Set the log to use */
  void setLog(MetraFlowLoggerPtr log)
  {
    mLog = log;
    mHasError = false;
  }

  /** Did an ANTLR error occur during parsing? */
  bool getHasError()
  {
    return mHasError;
  }
  
  void setLog(Logger * log)
  {
  }

  std::vector<MTSQLParam> antlr::TreeParser::getParams(void)
  {
    return std::vector<MTSQLParam>();
  }
}


program
  :
  (
  broadcastStatement
  |
  collStatement
  |
  copyStatement
  |
  devNullStatement
  | 
  exportStatement 
  |
  exportQueueStatement 
  |
  exprStatement
  |
  filterStatement
  |
  delayedGenerateStatement
  |
  groupByStatement
  | 
  hashPartStatement
  | 
  hashRunningTotalStatement
  | 
  importStatement 
  | 
  importQueueStatement 
  | 
  innerHashJoinStatement 
  | 
  innerMergeJoinStatement 
  | 
  insertStatement 
  |
  meterStatement 
  |
  multiHashJoinStatement 
  | 
  printStatement 
  | 
  projectionStatement 
  | 
  renameStatement 
  | 
  rightMergeAntiSemiJoinStatement 
  | 
  rightMergeSemiJoinStatement 
  | 
  rightOuterHashJoinStatement 
  | 
  rightOuterMergeJoinStatement 
  | 
  selectStatement 
  | 
  sequentialFileOutputStatement 
  | 
  sequentialFileScanStatement 
  | 
  sortStatement 
  | 
  sortGroupByStatement 
  | 
  sortMergeStatement 
  | 
  sortMergeCollStatement 
  | 
  sqlExecDirectStatement 
  | 
  switchStatement 
  | 
  taxwareStatement 
  | 
  unionAllStatement 
  | 
  unrollStatement 
  | 
  edgeStatement 
  )*  
  ;

broadcastStatement
{
}
  :
  #(id:BROADCAST
    {
      std::cout << id->getText() << ": broadcast ";
      outputStatementOpen(#id);
    }

    (broadcastArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

broadcastArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

collStatement
{
}
  :
  #(id:COLL
    {
      std::cout << id->getText() << ": coll ";
      outputStatementOpen(#id);
    }
    (collArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

collArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

copyStatement
{
}
  :
  #(id:COPY
    {
      std::cout << id->getText() << ": copy;\n";
    }
  )
  ;

devNullStatement
{
}
  :
  #(id:DEVNULL
    {
      std::cout << id->getText() << ": devNull ";
      outputStatementOpen(#id);
    }
    (devNullArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

devNullArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

selectStatement
{
}
  :
  #(id:SELECT
    {
      std::cout << id->getText() << ": select ";
      outputStatementOpen(#id);
    }

    (selectArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

selectArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

exportStatement
{
}
  :
  #(id:EXPORT
    {
      std::cout << id->getText() << ": export";
      outputStatementOpen(#id);
    }
    (exportArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

exportArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

exportQueueStatement
{
}
  :
  #(id:EXPORT_QUEUE
    {
      std::cout << id->getText() << ": export_queue";
      outputStatementOpen(#id);
    }
    (exportQueueArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

exportQueueArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

exprStatement
{
}
  :
  #(id:EXPR
    {
      std::cout << id->getText() << ": expr";
      outputStatementOpen(#id);
    }
    (exprArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

exprArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

filterStatement
{
}
  :
  #(id:FILTER
    {
      std::cout << id->getText() << ": filter";
      outputStatementOpen(#id);
    }
    (filterArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

filterArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

delayedGenerateStatement
  :
  #(DELAYED_GENERATE g:GENERATE)
  {
    if ((*mSymbol)[g->getText()].NumInputs == 0)
    {
      generateStatement(g);
    }
    else
    {
      expressionGenerateStatement(g);
    }
  }
  ;

generateStatement
{
}
  :
  #(id:GENERATE
    {
      std::cout << id->getText() << ": generate";
      outputStatementOpen(#id);
    }
    (generateArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

generateArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

expressionGenerateStatement
{
}
  :
  #(id:GENERATE
    {
    }
    (expressionGenerateArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

expressionGenerateArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

groupByStatement
{
}
  :
  #(id:GROUP_BY
    {
      std::cout << id->getText() << ": group_by";
      outputStatementOpen(#id);
    }
    (groupByArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

groupByArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

hashPartStatement
{
}
  :
  #(id:HASHPART
    {
      std::cout << id->getText() << ": hash_part";
      outputStatementOpen(#id);
    }
    (hashPartArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

hashPartArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

hashRunningTotalStatement
{
  std::vector<std::wstring> groupByKeys;
}
  :
  #(id:HASH_RUNNING_TOTAL
    {
      std::cout << id->getText() << ": hash_running_total";
      outputStatementOpen(#id);
    }
    (hashRunningTotalArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

hashRunningTotalArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

importStatement
{
}
  :
  #(id:IMPORT
    {
      std::cout << id->getText() << ": import";
      outputStatementOpen(#id);
    }
    (importArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

importArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

importQueueStatement
{
}
  :
  #(id:IMPORT_QUEUE
    {
      std::cout << id->getText() << ": import_queue";
      outputStatementOpen(#id);
    }
    (importQueueArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

importQueueArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

innerHashJoinStatement
{
}
  :
  #(id:INNER_HASH_JOIN
    {
      std::cout << id->getText() << ": inner_hash_join";
      outputStatementOpen(#id);
    }
    (innerHashJoinArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

innerHashJoinArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

innerMergeJoinStatement
{
}
  :
  #(id:INNER_MERGE_JOIN
    {
      std::cout << id->getText() << ": inner_merge_join";
      outputStatementOpen(#id);
    }
    (innerMergeJoinArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

innerMergeJoinArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

insertStatement
{
}
  :
  #(id:INSERT
    {
      std::cout << id->getText() << ": insert";
      outputStatementOpen(#id);
    }
    (insertArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

insertArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

meterStatement
{
}
  :
  #(id:METER
    {
      std::cout << id->getText() << ": meter";
      outputStatementOpen(#id);
    }
    (meterArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

meterArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

multiHashJoinStatement
{
}
  :
  #(id:MULTI_HASH_JOIN
    {
      std::cout << id->getText() << ": multi_hash_join";
      outputStatementOpen(#id);
    }
    (multiHashJoinArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

multiHashJoinArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

printStatement
{
}
  :
  #(id:PRINT
    {
      std::cout << id->getText() << ": print ";
      outputStatementOpen(#id);
    }

    (printArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

printArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

projectionStatement
{
}
  :
  #(id:PROJECTION
    {
      std::cout << id->getText() << ": project";
      outputStatementOpen(#id);
    }
    (projectionArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

projectionArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

renameStatement
{
}
  :
  #(id:RENAME
    {
      std::cout << id->getText() << ": rename";
      outputStatementOpen(#id);
    }
    (renameArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

renameArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

rightMergeAntiSemiJoinStatement 
{
}
  :
  #(id:RIGHT_MERGE_ANTI_SEMI_JOIN
    {
      std::cout << id->getText() << ": right_merge_anti_semi_join";
      outputStatementOpen(#id);
    }
    (rightMergeAntiSemiJoinArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

rightMergeAntiSemiJoinArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

rightMergeSemiJoinStatement 
{
}
  :
  #(id:RIGHT_MERGE_SEMI_JOIN
    {
      std::cout << id->getText() << ": right_merge_semi_join";
      outputStatementOpen(#id);
    }
    (rightMergeSemiJoinArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

rightMergeSemiJoinArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

rightOuterHashJoinStatement
{
}
  :
  #(id:RIGHT_OUTER_HASH_JOIN
    {
      std::cout << id->getText() << ": right_outer_hash_join";
      outputStatementOpen(#id);
    }
    (rightOuterHashJoinArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

rightOuterHashJoinArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

rightOuterMergeJoinStatement 
{
}
  :
  #(id:RIGHT_OUTER_MERGE_JOIN
    {
      std::cout << id->getText() << ": right_outer_merge_join";
      outputStatementOpen(#id);
    }
    (rightOuterMergeJoinArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

rightOuterMergeJoinArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

sequentialFileOutputStatement
{
}
  :
  #(id:SEQUENTIAL_FILE_OUTPUT
    {
      std::cout << id->getText() << ": sequential_file_write";
      outputStatementOpen(#id);
    }
    (sequentialFileOutputArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

sequentialFileOutputArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

sequentialFileScanStatement
{
}
  :
  #(id:SEQUENTIAL_FILE_SCAN
    {
      std::cout << id->getText() << ": sequential_file_scan";
      outputStatementOpen(#id);
    }
    (sequentialFileScanArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

sequentialFileScanArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

sortStatement
{
}
  :
  #(id:SORT
    {
      std::cout << id->getText() << ": sort";
      outputStatementOpen(#id);
    }
    (sortArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

sortArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

sortGroupByStatement
{
}
  :
  #(id:SORT_GROUP_BY
    {
      std::cout << id->getText() << ": sort_group_by";
      outputStatementOpen(#id);
    }
    (sortGroupByArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

sortGroupByArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

sortMergeStatement
{
}
  :
  #(id:SORTMERGE
    {
      std::cout << id->getText() << ": sort_merge";
      outputStatementOpen(#id);
    }
    (sortMergeArgument)*
    {

    {
      outputStatementClose(#id);
    }
    }
  )
  ;

sortMergeArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

sortMergeCollStatement
{
}
  :
  #(id:SORTMERGECOLL
    {
      std::cout << id->getText() << ": sort_merge_col";
      outputStatementOpen(#id);
    }
    (sortMergeCollArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

sortMergeCollArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

sqlExecDirectStatement
{
}
  :
  #(id:SQL_EXEC_DIRECT
    {
      std::cout << id->getText() << ": sql_exec_direct";
      outputStatementOpen(#id);
    }
    (sqlExecDirectStatementList)*
    {
    }
    {
      std::cout << "];\n";
    }
  )
  ;

sqlExecDirectStatementList
{
}
  :
  #(id:ID 
    { 
      if (!boost::algorithm::iequals(#id->getText().c_str(), "statementlist")) 
        throw std::exception("Expected statementList");

      std::cout << "statementList=[";
    }
    (sqlExecDirectArgument)*
    {
      if (id->getNextSibling() != NULL)
        std::cout << ", ";
    }

  )
  ;

sqlExecDirectArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

switchStatement
{
}
  :
  #(id:SWITCH
    {
      std::cout << id->getText() << ": switch";
      outputStatementOpen(#id);
    }
    (switchArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

switchArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

taxwareStatement
{
}
  :
  #(id:TAXWARE
    {
      std::cout << id->getText() << ": taxware";
      outputStatementOpen(#id);
    }

    (taxwareArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

taxwareArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

unionAllStatement
{
}
  :
  #(id:UNION_ALL
    {
      std::cout << id->getText() << ": union_all";
      outputStatementOpen(#id);
    }
    (unionAllArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

unionAllArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

unrollStatement
{
}
  :
  #(id:UNROLL
    {
      std::cout << id->getText() << ": unroll";
      outputStatementOpen(#id);
    }
    (unrollArgument)*
    {
    }

    {
      outputStatementClose(#id);
    }
  )
  ;

unrollArgument
  :
  #(id:ID av:nodeArgumentValue) 
  {
    outputArgument(#id, #av);
  }
  ;

edgeStatement
{
  boost::tuple<std::string, boost::variant<int,std::string>, bool > lhs;
  boost::tuple<std::string, boost::variant<int,std::string>, bool > rhs;
  bool buffered = true;
  bool isBufferedArgPresent = false;
}
  :
  #(ARROW lhs=arrowOrRefStatement (buffered = arrowArguments
                                    {
                                      isBufferedArgPresent = true;
                                    }
                                  )? rhs = nodeRefStatement) 
  {
    std::cout << " -> ";

    // Optional buffered argument
    if (isBufferedArgPresent)
    {
      std::cout << "[buffered=";
      if (buffered)
        std::cout << "true] ";
      else
        std::cout << "false] ";
    }

    // We are going to use the left-hand side of the edge statement as the
    // source for the datatype of flowing over the arrow. We might not
    // be successful in obtaining the metadata since it depends on
    // on a properly constructed script.
    std::map<std::string,DataflowSymbol >::const_iterator leftIt(mSymbol->find(lhs.get<0>()));
    if (leftIt != mSymbol->end())
    {
      // Using the operation from in the symbol table, get the port identified
      // by the lhs (by number or name).
      boost::shared_ptr<Port> lhsPort (
                lhs.get<1>().which() == 0 ? 
        leftIt->second.Op->GetOutputPorts()[boost::get<int>(lhs.get<1>())] :
        leftIt->second.Op->GetOutputPorts()[ASCIIToWide(boost::get<std::string>(lhs.get<1>()))]);

      outputPortMetadata(lhsPort);
    }

    // Destination operation
    std::cout << rhs.get<0>();

    // Port name or index
    if (rhs.get<2>())
      std::cout << "(" << rhs.get<1>() << ")";
    
    std::cout << "\n";
  }
  ;

/** Returns tuple identifying port: <operation name, port index or port name, isPortNameSpecified> */
arrowOrRefStatement returns [boost::tuple<std::string, boost::variant<int,std::string>, bool >  rhs]
{
  boost::tuple<std::string, boost::variant<int,std::string>, bool > lhs;
  bool buffered = true;
  bool isBufferedArgPresent = false;
}
  :
  #(ARROW lhs=arrowOrRefStatement (buffered = arrowArguments)? rhs = nodeRefStatement) 
  {
    std::cout << " -> ";

    // Optional buffered argument
    if (isBufferedArgPresent)
    {
      std::cout << "[buffered=";
      if (buffered)
        std::cout << "true] ";
      else
        std::cout << "false] ";
    }

    std::map<std::string,DataflowSymbol >::const_iterator leftIt(mSymbol->find(lhs.get<0>()));
    if (leftIt != mSymbol->end())
    {
      boost::shared_ptr<Port> lhsPort (
                lhs.get<1>().which() == 0 ? 
        leftIt->second.Op->GetOutputPorts()[boost::get<int>(lhs.get<1>())] :
        leftIt->second.Op->GetOutputPorts()[ASCIIToWide(boost::get<std::string>(lhs.get<1>()))]);

      outputPortMetadata(lhsPort);
    }

    // Destination operation
    std::cout << rhs.get<0>();

    // Optional port name or index
    if (rhs.get<2>())
      std::cout << "(" << rhs.get<1>() << ")";
  }
  |
  rhs = nodeRefStatement
  {
    std::cout << rhs.get<0>();

    // if a node name or index was specified, echo it
    if (rhs.get<2>())
      std::cout << "(" << rhs.get<1>() << ")";
  }
  ;

/** Returns tuple identifying port: <operation name, port index or port name, isPortNameSpecified> */
nodeRefStatement returns [boost::tuple<std::string, boost::variant<int,std::string>, bool > t]
{
  std::string nodeName;
  int portIndex(0);
  std::string portName;
  bool isPortIndexSpecified(false);
}
  :
  #(id:ID (i:NUM_INT 
           { 
             portIndex = boost::lexical_cast<int>(#i->getText()); 
             isPortIndexSpecified = true;
           } 
           | 
           s:STRING_LITERAL 
           { 
             portName = #s->getText().substr(1, #s->getText().size()-2); 
           }
          )?
  )
  {
    if (portName.size() != 0)
    {
      t = boost::tuple<std::string, boost::variant<int,std::string>, bool >
                    (#id->getText(), portName, true);
    }
    else
    {
      t = boost::tuple<std::string, boost::variant<int,std::string>, bool >
                    (#id->getText(), portIndex, isPortIndexSpecified);
    }
  }
  ;

arrowArguments returns [bool buffered]
  :
  #(LBRACKET buffered = arrowBufferArgument) 
  ;

arrowBufferArgument returns [bool buffered]
{
  buffered = true;
}
  :
  #(id:ID av:nodeArgumentValue) 
  {
    if (boost::algorithm::iequals(#id->getText().c_str(), "buffered"))
    {
      if (av->getType() != TK_TRUE && av->getType() != TK_FALSE)
      {
        throw std::exception("'buffered' argument must be true/false");
      }
      buffered = av->getType() == TK_TRUE;
    }
  }
  ;

nodeArgumentValue
  :
  NUM_INT
  |
  NUM_BIGINT
  |
  NUM_FLOAT
  |
  NUM_DECIMAL
  |
  STRING_LITERAL
  |
  TK_TRUE
  |
  TK_FALSE
  ;

