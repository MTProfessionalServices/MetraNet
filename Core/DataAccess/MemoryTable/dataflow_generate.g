header { 
  // Prevent inclusion of WinSock since ASIO uses WinSock2
  #define _WINSOCKAPI_
  #include <map>
  #include <sstream>
  #include <boost/algorithm/string/predicate.hpp>
  #include <boost/lexical_cast.hpp>
  #include <boost/tuple/tuple.hpp>
  #include <boost/variant.hpp>
  #include <boost/format.hpp>
  #include <atlenc.h>
  #include "ArgEnvironment.h"
  #include "LogAdapter.h"
  #include "DatabaseSelect.h"
  #include "DesignTimeExpression.h"
  #include "DatabaseInsert.h"
  #include "DesignTimeExternalSort.h"
  #include "DesignTimeComposite.h"
  #include "DesignTimeCodeGeneratedComposite.h"
  #include "HashAggregate.h"
  #include "RecordParser.h"
  #include "SortMergeCollector.h"
  #include "Normalization.h"
  #include "MessageDigest.h"
  #include "SortRunningTotal.h"
  #include "Taxware.h"
  #include "DataFile.h"
  #include "LongestPrefixMatch.h"
  #include "MetraFlowQueue.h"
  #include "IdGeneratorOperator.h"
  #include "MTSQLParam.h"
  #include "ScriptInterpreter.h"
  #include "DatabaseMetering.h"
  #include "MyAST.h"
  #include "DataflowException.h"
  #include "CompositeDictionary.h"
  #include "OperatorArg.h"
  #include "Workflow.h"
  #include "WorkflowInstructionIf.h"
  #include "WorkflowInstructionStep.h"
  #include "WorkflowPredicate.h"
}

options {
	language = "Cpp";
}

class DataflowTreeGenerator extends TreeParser;
options {
	importVocab=DataflowParser; // use vocab generated by parser
	buildAST = false;
    defaultErrorHandler = false;
    ASTLabelType = "RefMyAST";
}
{
private:
  MetraFlowLoggerPtr mLog;
  bool mHasError;

  /** Map of the symbol tables for the steps. */
  std::map<std::wstring, DataflowSymbolTable*>* mMapOfSymbolTables;

  /** The workflow which holds the plans for all steps. */
  Workflow* mWorkflow;

  /** Symbol table for operators in the main script. */
  DataflowSymbolTable* mScriptSymbolTable;

  /** Design time plan for the main script */
  DesignTimePlan *mScriptPlan;

  /**
   * Active symbol table.  We may be storing operators
   * in mScriptSymbolTable, or we may be storing symbols in a temporary
   * table if we are analyzing a composite definition.
   */
  DataflowSymbolTable *mActiveSymbolTable;

  /**
   * Pointer to active design time plan.  We may working on the main script plan
   * or we may be working on a composite definition plan.
   */
  DesignTimePlan *mActivePlan;

  /** Name of the composite currently being parsed or empty string. */
  std::wstring mActiveCompositeName;

  /** True if a composite is actively being parsed. */
  bool mIsCompositeBeingParsed;

  /** 
   * Dictionary of defined composites. 
   * This dictionary was started during the parsing phase.
   * In this phase we add the design time plan to the definitions.
   */
  CompositeDictionary *mCompositeDictionary;

  /** The name of the file being parsed. Used for error reporting. */
  std::wstring mFilename;

  /**
   * The script interpreter used for expanding code generated composites 
   */
  DataflowScriptInterpreter * mScriptInterpreter;

  std::vector<Metering*> mMetering;
  std::vector<boost::shared_ptr<DatabaseMeteringStagingDatabase> > mDbs;

  /** Convert the standard string to a wide-string */
  std::wstring ASCIIToWide(const std::string& str)
  {
    std::wstring wstr;
    ::ASCIIToWide(wstr, str.c_str(), -1, mEncoding);
    return wstr;
  }

  /** 
   * Set the name of the given operation and add the
   * operator to the symbol table.  This should be redundant 
   * since the symbol entry was already created by 
   * dataflow_analyze.g and the line number of operator has 
   * been assigned.
   */
  void addToSymbolTable(DesignTimeOperator *op, RefMyAST id)
  {
    std::wstring wstrName;
    ::ASCIIToWide(wstrName, id->getText().c_str(), -1, mEncoding);
    op->SetName(wstrName);

    (*mActiveSymbolTable)[wstrName].Op = op;
  }

  /**
   * Form an operator argument. The caller of this method is 
   * responsible for freeing the returned argument pointer.
   *
   * @param name  argument name
   * @param value argument value
   */
  OperatorArg* formOperatorArg(RefMyAST name,
                               RefMyAST value)
  {
    OperatorArg *arg = NULL;

    if (value->getType() == STRING_LITERAL)
    {
      arg = new OperatorArg(ASCIIToWide(name->getText()), ASCIIToWide(value->getText()),
                            name->getLine(), name->getColumn(),
                            value->getLine(), value->getColumn(),
                            mFilename);
    }
    else if (value->getType() == TK_TRUE)
    {
      arg = new OperatorArg(ASCIIToWide(name->getText()), true,
                            name->getLine(), name->getColumn(),
                            value->getLine(), value->getColumn(),
                            mFilename);
    }
    else if (value->getType() == TK_FALSE)
    {
      arg = new OperatorArg(ASCIIToWide(name->getText()), false,
                            name->getLine(), name->getColumn(),
                            value->getLine(), value->getColumn(),
                            mFilename);
    }
    else if (value->getType() == NUM_INT)
    {
      boost::int32_t num(boost::lexical_cast<boost::int32_t>(value->getText()));
      arg = new OperatorArg(ASCIIToWide(name->getText()), num,
                            name->getLine(), name->getColumn(),
                            value->getLine(), value->getColumn(),
                            mFilename);
    }
    else
    {
      // This is unexpected -- there are no other types.
      throw DataflowInvalidArgumentException(
                            name->getLine(), name->getColumn(),
                            mFilename, L"", ASCIIToWide(name->getText()));
    }

    return arg;
  }

  /**
   * Check the values of the mode argument.  If not acceptable,
   * throw an expection (DataflowInvalidArgumentValueException).
   * Otherwise, set the mode of the operation.
   *
   * @param op        operator
   * @param name      ast holding the argument name
   * @param value     ast holding the argument value
   */
  void processModeParameter(DesignTimeOperator *op, RefMyAST name,
                            RefMyAST value)
  {
      if (value->getType() != STRING_LITERAL ||
          (!boost::algorithm::iequals("\"sequential\"", 
                                      value->getText().c_str()) && 
           !boost::algorithm::iequals("\"parallel\"", 
                                      value->getText().c_str())))
      {
        reportInvalidArgumentValue(op, name, value, 
                                   L"Expected \"sequential\" or \"parallel\"");
      }

      if (boost::algorithm::iequals("\"sequential\"", value->getText().c_str()))
      {
        op->SetMode(DesignTimeOperator::SEQUENTIAL);
      }
  }

  /**
   * Check the values of the collectionIDEncoded argument.  If not acceptable,
   * throw an expection (DataflowInvalidArgumentValueException).
   * Otherwise, set the collectionID of the meter operation.
   *
   * @param op        meter operator
   * @param id        ast holding the argument name
   * @param encoded   value to be used for encoded collection ID.
   *                  This should be a 16 bytes value encoded in base64.
   */
  void processCollectionIDEncodedParameter(
                            Metering *op, 
                            RefMyAST id,
                            std::string encoded)
  {
      BYTE decoded[32];
      int byteLength = 32;

      // Make sure we can decode the given string
      if (!Base64Decode(encoded.c_str(), encoded.size(), decoded, &byteLength))
      {
        reportInvalidArgument(op, id, 
                              L"Could not decode the base64 encoded string.");
      }

      // We expect that the decoded length is 16 bytes
      if (byteLength != 16)
      {
        reportInvalidArgument(op, id, 
                                  L"The decoded string was not 16 bytes long.");
      }

      // Shove the 16 bytes into a boost vector.
      std::vector<boost::uint8_t> val;
      for (int i=0; i<16; i++)
      {
        val.push_back((boost::uint8_t)(decoded[i]));
      }

      // Set this value in the meter operator.
      op->SetCollectionID(val);
  }

  /**
   * Report an incorrect argument value encountered in the script.
   *
   * @param op        operator
   * @param name      ast holding the argument name
   * @param value     ast holding the argument value
   * @param expected  a phrase explaining expected values (e.g. Expected a or b).
   */
  void reportInvalidArgumentValue(DesignTimeOperator *op, RefMyAST name,
                                   RefMyAST value, const std::wstring& expected)
  {
    throw DataflowInvalidArgumentValueException(value->getLine(),
                                                value->getColumn(),
                                                mFilename,
                                                op->GetName(),
                                                ASCIIToWide(name->getText()),
                                                ASCIIToWide(value->getText()),
                                                expected);
  }

  /**
   * Report an incorrect argument encountered in the script.
   *
   * @param op        operator
   * @param name      ast holding the argument name
   * @param reason    a phrase explaining the problem
   */
  void reportInvalidArgument(DesignTimeOperator *op, RefMyAST name,
                             const std::wstring& reason)
  {
    throw DataflowInvalidArgumentException(
                                       name->getLine(), name->getColumn(),
                                       mFilename,
                                       op->GetName(), reason);
  }

  /**
   * Report an operator with implausible arguments in the script.
   *
   * @param op        operator
   * @param id        the AST holding the operator
   * @param reason    a phrase explaining the problem
   */
  void reportInvalidArguments(DesignTimeOperator *op, RefMyAST id,
                              const std::wstring& reason)
  {
    throw DataflowInvalidArgumentsException(id->getLine(), id->getColumn(),
                                            mFilename, op->GetName(), reason);
  }

  /**
   * Report an internal error.
   *
   * @param reason   a phrase explaining the problem.
   */
  void reportInternalError(const std::wstring& reason, RefMyAST id)
  {
    std::wstringstream out;
    out << reason << L": \"" << ASCIIToWide(id->getText()) << L"\"";
    throw DataflowInternalErrorException(out.str());
  }

  /**
   * Verify that the referenced port exists.  If not,
   * throw an error.
   * 
   * @param ports        Collection of input or output ports of operator
   * @param portInfo     Tuple of <operator name, <port id, port name>, 
   *                            line number, column number>
   * @param isInputPort  true if this is an input port
   */
  void verifyPortExists(const PortCollection& ports,
                        boost::tuple<std::wstring, boost::variant<int,std::wstring>, int, int > portInfo,
                        bool isInput)
  {
    // Verify that the referenced port exists
    if (portInfo.get<1>().which() == 0 )
    {
      if (!ports.doesPortExist(boost::get<int>(portInfo.get<1>())))
      {
        throw DataflowUndefPortException(
                                  portInfo.get<0>(), L"", 
                                  boost::get<int>(portInfo.get<1>()),
                                  isInput, portInfo.get<2>(), 
                                  portInfo.get<3>(),
                                  mFilename);
      }
    }
    else
    {
      if (!ports.doesPortExist(boost::get<std::wstring>(portInfo.get<1>())))
      {
        throw DataflowUndefPortException(
                                  portInfo.get<0>(), 
                                  boost::get<std::wstring>(portInfo.get<1>()), 0,
                                  isInput, portInfo.get<2>(), portInfo.get<3>(),
                                  mFilename);
      }
    }
  }

  /**
   * Get the hex value corresponding to the given character.
   */
  boost::uint32_t GetHexValue(char c)
  {
    static boost::uint32_t lut[128];
    static bool init(false);
    if (!init)
    {
      for(int i=0; i<128; i++) lut[i]=0xffffffff;
      lut['0'] = 0;
      lut['1'] = 1;
      lut['2'] = 2;
      lut['3'] = 3;
      lut['4'] = 4;
      lut['5'] = 5;
      lut['6'] = 6;
      lut['7'] = 7;
      lut['8'] = 8;
      lut['9'] = 9;
      lut['a'] = lut['A'] = 10;
      lut['b'] = lut['B'] = 11;
      lut['c'] = lut['C'] = 12;
      lut['d'] = lut['D'] = 13;
      lut['e'] = lut['E'] = 14;
      lut['f'] = lut['F'] = 15;
      init = true;
    }

    if ((boost::int32_t) c < 0 || (boost::int32_t) c > 127) return 0xffffffff;
    return lut[c];
  }

  /**
   * The encoding of the file.  Defaults to locale codepage but may
   * overridden (e.g. to UTF8).
   */
  boost::int32_t mEncoding;

public:
  ~DataflowTreeGenerator()
  {
    for (std::vector<Metering*>::iterator it = mMetering.begin();
         it != mMetering.end();
         ++it)
    {
      delete *it;
    }
  }

  virtual void program(ANTLR_USE_NAMESPACE(antlr)RefAST _t)
  {
    // Since we are exclusively using MyAST as the AST Type in
    // the AST tree built by DataflowParser and DataflowTreeParser
    // we can safely cast the RefAST to RefMyAST.
    program((RefMyAST)_t);
  }

  /**
   * Set the map of step name to symbol table.
   * The symbol table is used for operators encountered
   * in the step (rather than in composite definitions).
   * This should be called prior to invoking program().
   * This class does not own the symbol table.
   */
  void setSymbolTable(
            std::map<std::wstring, DataflowSymbolTable*>* mapOfSymbolTables)
  {
    mMapOfSymbolTables = mapOfSymbolTables;
    mScriptSymbolTable = (*mapOfSymbolTables)[L"main"];
    mActiveSymbolTable = mScriptSymbolTable;
  }
  
  /**
   * Set the composite dictionary.  This class does not own this
   * dictionary and is NOT responsible for freeing it.
   */
  void setCompositeDictionary(CompositeDictionary *dictionary)
  {
    mCompositeDictionary = dictionary;
  }
  
  /** Set the name of the file being parsed. Used for error reporting. */
  void setFilename(const std::wstring &filename)
  {
    mFilename = filename;
  }

  void setScriptInterpreter(DataflowScriptInterpreter * scriptInterpreter)
  {
    mScriptInterpreter = scriptInterpreter;
  }
  
  /** Set the workflow */
  void setWorkflow(Workflow *workflow)
  {
    mWorkflow = workflow;
    mScriptPlan = workflow->getDesignTimePlan(Workflow::DefaultStepName);
    mActivePlan = mScriptPlan;
  }

  /**
   * Set encoding of the parser.
   */
  void setEncoding(boost::int32_t encoding)
  {
    mEncoding = encoding;
  }

	/** Override the error and warning reporting */
  virtual void reportError(const ANTLR_USE_NAMESPACE(antlr)RecognitionException& ex)
  {
	  mLog->logError(ex.toString());
    mHasError = true;
  }

	/** Parser error-reporting function can be overridden in subclass */
  virtual void reportError(const ANTLR_USE_NAMESPACE(std)string& s)
  {
	mLog->logError(s);
    mHasError = true;
  }

	/** Parser warning-reporting function can be overridden in subclass */
  virtual void reportWarning(const ANTLR_USE_NAMESPACE(std)string& s)
  {
	mLog->logWarning(s);
  }

  void setLog(MetraFlowLoggerPtr log)
  {
	  mLog = log;
    mHasError = false;
  }

  bool getHasError()
  {
	  return mHasError;
  }
  
  void setLog(Logger * log)
  {
  }

  std::vector<MTSQLParam> antlr::TreeParser::getParams(void)
  {
    return std::vector<MTSQLParam>();
  }
}

program
  :
  ((includeCompositeStatement (SEMI!)?)*
   (compositeDeclaration | stepDeclaration)* 
   (mainScript)?) EOF
  ;

mainScript
{
  mActiveCompositeName = L"";
  mIsCompositeBeingParsed = false;
}
  :
  (dataFlowBody)
  (controlFlow)?
  ;

dataFlowBody
  :
  (
  accountResolutionStatement
  |
  broadcastStatement
  |
  collStatement
  |
  compositeStatement
  |
  copyStatement
  |
  devNullStatement
  | 
  exportStatement 
  |
  exportQueueStatement 
  |
  exprStatement
  |
  filterStatement
  |
  delayedGenerateStatement
  |
  groupByStatement
  | 
  hashPartStatement
  | 
  hashRunningTotalStatement
  | 
  idGeneratorStatement 
  | 
  importStatement 
  | 
  importQueueStatement 
  | 
  innerHashJoinStatement 
  | 
  innerMergeJoinStatement 
  | 
  insertStatement 
  |
  loadErrorStatement
  |
  loadUsageStatement
  |
  longestPrefixMatchStatement 
  |
  md5Statement 
  |
  meterStatement 
  |
  multiHashJoinStatement 
  | 
  printStatement 
  | 
  projectionStatement 
  | 
  rangePartStatement 
  | 
  rateCalculationStatement 
  | 
  rateScheduleResolutionStatement 
  | 
  renameStatement 
  | 
  rightMergeAntiSemiJoinStatement 
  | 
  rightMergeSemiJoinStatement 
  | 
  rightOuterHashJoinStatement 
  | 
  rightOuterMergeJoinStatement 
  | 
  selectStatement 
  | 
  sequentialFileDeleteStatement 
  | 
  sequentialFileOutputStatement 
  | 
  sequentialFileRenameStatement 
  | 
  sequentialFileScanStatement 
  | 
  sessionSetBuilderStatement 
  | 
  sortStatement 
  | 
  sortGroupByStatement 
  | 
  sortMergeStatement 
  | 
  sortMergeCollStatement 
  | 
  sortNestStatement 
  | 
  sortOrderAssertStatement 
  | 
  sortRunningTotalStatement 
  | 
  sqlExecDirectStatement 
  |
  subscriptionResolutionStatement 
  | 
  switchStatement 
  | 
  taxwareStatement 
  | 
  unionAllStatement 
  | 
  unnestStatement 
  | 
  unrollStatement 
  | 
  writeErrorStatement 
  | 
  writeProductViewStatement 
  | 
  edgeStatement 
  )*	
  ;


includeCompositeStatement
  :
  (INCLUDE_COMPOSITE filename:STRING_LITERAL)
  ;
  
compositeDeclaration
  {
    std::map<std::wstring, DataflowSymbol> *compositeSymbolTable;

    // We create a new design plan for the composite and make this the
    // active plan.  We will later store this plan as part of the 
    // composite definition.
    DesignTimePlan* compositePlan = new DesignTimePlan();
    mActivePlan = compositePlan;
  }
  :
  #(OPERATOR 
    compositeNameId:ID 
    {
      std::wstring wCompositeName = ASCIIToWide(compositeNameId->getText());
      compositeSymbolTable = 
        mCompositeDictionary->getSymbolTable(wCompositeName);

      // All operators in the composite have already been stored
      // in this table during the dataflow_analyze.g stage.
      mActiveSymbolTable = compositeSymbolTable;
      mActiveCompositeName = wCompositeName;
      mIsCompositeBeingParsed = true;
    }
    compositeParameters 
    compositeBody)
  {
    // We reach this point when the composite definition has finished parsing.
    // Set the name of the plan to match the name of the composite.
    compositePlan->setName(ASCIIToWide(compositeNameId->getText()));

    // Set the plan of the composite.
    // Ownership of the plan is given to the composite definition.
    // This also performs any needed final bookkeeping of the definition.
    mCompositeDictionary->setDesignTimePlan(ASCIIToWide(compositeNameId->getText()),
                                            compositePlan);

    // We are done preparing the composite declaration.
    // We now assume we are processing script.
    mActiveSymbolTable = mScriptSymbolTable;
    mActivePlan = mScriptPlan;
    mActiveCompositeName = L"";
    mIsCompositeBeingParsed = false;
  }
  ;

compositeParameters
  :
  (compositeParameterSpec)*;

compositeParameterSpec
  :
  (compositeParameterInputSpec | 
   compositeParameterOutputSpec |
   compositeArgSpec
  );

compositeParameterInputSpec
  :
  #(INPUT STRING_LITERAL IS operatorId:ID (NUM_INT | STRING_LITERAL))
  ;

compositeParameterOutputSpec
  :
  #(OUTPUT STRING_LITERAL IS operatorId:ID (NUM_INT | STRING_LITERAL))
  ;

compositeArgSpec
  :
  (compositeArgSpecString | compositeArgSpecInt | compositeArgSpecBool |
   compositeArgSpecSublist )
  ;

compositeArgSpecString
  :
  #(STRING_DECL DOLLAR_SIGN ID)
  ;

compositeArgSpecInt
  :
  #(INTEGER_DECL DOLLAR_SIGN ID)
  ;

compositeArgSpecBool
  :
  #(BOOLEAN_DECL DOLLAR_SIGN ID)
  ;

compositeArgSpecSublist
  :
  #(SUBLIST_DECL DOLLAR_SIGN ID)
  ;

compositeBody
  :
  (dataFlowBody)
  ;

stepDeclaration
  :
  #(STEP_DECL 
    id:ID 
    {
      mActiveSymbolTable = (*mMapOfSymbolTables)[ASCIIToWide(#id->getText())];
      mActivePlan = new DesignTimePlan();
      mActivePlan->setName(ASCIIToWide(#id->getText()));
      mIsCompositeBeingParsed = false;
    }
    stepBody)
    {
      mWorkflow->setDesignTimePlan(ASCIIToWide(#id->getText()), mActivePlan);
      mActiveSymbolTable = mScriptSymbolTable;
      mActivePlan = mScriptPlan;
    }
  ;

stepBody
  :
  LPAREN
  (dataFlowBody)
  RPAREN
  ;

controlFlow
  : 
  STEPS_BEGIN
  controlFlowBody
  STEPS_END
  ;

controlFlowBody
  :
  (stepStatement | ifStatement) *
  ;

ifStatement
{
  WorkflowInstructionIf* ifInstruct = NULL;
  WorkflowInstructionJump* jumpInstruct = NULL;
  WorkflowPredicate* predicate = NULL;
  boost::int32_t ifNumber;
  boost::int32_t jumpNumber;
}
  :
  IF_BEGIN
    {
      ifInstruct = new WorkflowInstructionIf(mWorkflow, L"if");
      mWorkflow->addInstruction(ifInstruct);
      ifNumber = mWorkflow->getLastInstructionNumber();
    }
  LPAREN
  ifPredicate[&predicate]
    {
      ifInstruct->setPredicate(predicate);
    }
  RPAREN
  THEN
  controlFlowBody
  (  ELSE
     {
        // After executing the if-true body we need to jump over the else part
        // We'll set the jump amount later
        jumpInstruct = new WorkflowInstructionJump(mWorkflow, L"jump over else");
        mWorkflow->addInstruction(jumpInstruct);
        jumpNumber = mWorkflow->getLastInstructionNumber();

        // add an instruct that appears at the end of the if true body
        // to jump over else statement part.  We'll set jump amount later.
        ifInstruct->setNumberToJump(mWorkflow->getLastInstructionNumber() -
                                    ifNumber + 1);
     }
     controlFlowBody 
  )?
  IF_END
    {
      if (jumpInstruct)  // this is the else case
      {                  // after executing if true body, we jump over else part
        jumpInstruct->setNumberToJump(mWorkflow->getLastInstructionNumber() -
                                      jumpNumber + 1);
      }
      else
      {
        // this is the no-else if statement
        // if the predicate is not true, we jump over the if body
        ifInstruct->setNumberToJump(mWorkflow->getLastInstructionNumber() -
                                    ifNumber + 1);
      }
    }
  ;

ifArgument[WorkflowPredicate* predicate]
  :
  (id:STRING_LITERAL
    {
      // Pass the string (without opening and ending quotes) to the predicate
      std::string s = #id->getText();
      if (s.length() > 2)
      {
        predicate->setStringParameter(ASCIIToWide(s.substr(1, s.length()-2)));
      }
    }

  | DOLLAR_SIGN variableId:ID 
    {
      predicate->setVariableParameter(ASCIIToWide(#variableId->getText()));
    }
  )
  ;

ifPredicate[WorkflowPredicate** predicate]
  {
    WorkflowPredicateNot *notPredicate = NULL;
  }
  :
  (BANG
    {
      notPredicate = new WorkflowPredicateNot();
    }
  )?
  (doesFileExistPredicate[predicate] |
   isFileEmptyPredicate[predicate])
  {
    if (notPredicate)
    {
      notPredicate->setOperand(*predicate);
      *predicate = notPredicate;
    }
  }
  ;

doesFileExistPredicate[WorkflowPredicate** predicate]
  :
  (
    id:PREDICATE_DOES_FILE_EXIST 
    {
      *predicate = new WorkflowPredicateDoesFileExist();
    }
    LPAREN ifArgument[*predicate] RPAREN
  )
  ;

isFileEmptyPredicate[WorkflowPredicate** predicate]
  :
  (
    id:PREDICATE_IS_FILE_EMPTY 
    {
      *predicate = new WorkflowPredicateIsFileEmpty();
    }
    LPAREN ifArgument[*predicate] RPAREN
  )
  ;

operatorArgument[DesignTimeOperator * op]
{
  OperatorArg* opArgSubList = NULL;
}
  :
  #(id:ID 
    // A simple operator argument
    (av:nodeArgumentValue
        { 
          OperatorArg *arg = formOperatorArg(#id, av);

          if (mIsCompositeBeingParsed)
          {
            op->addPendingArg(arg);
          }
          else
          {
            op->handleUnresolvedArg(*arg);
            delete arg;
          }
        }

    // A sub-list of arguments
    | (operatorArgumentList[&opArgSubList])*
        {
          opArgSubList->setName(ASCIIToWide(#id->getText()),
                                #id->getLine(),
                                #id->getColumn());

          // If not in a composite
          if (mIsCompositeBeingParsed)
          {
            op->addPendingArg(opArgSubList);
          }
          else
          {
            op->handleUnresolvedArg(*opArgSubList);
            delete opArgSubList;
          }
        }

    // The following can be used by operators inside composites
    // to indicate that the operator argument
    // will be coming from an argument specified
    // for the composite.
    | DOLLAR_SIGN variableId:ID 
        { 
          if (mIsCompositeBeingParsed)
          {
            // Make sure that the referenced composite argument exists.
            if (!mCompositeDictionary->doesArgExist(mActiveCompositeName,
                                                    ASCIIToWide(#variableId->getText())))
            {
              throw (DataflowInvalidArgumentException(
                                            #variableId->getLine(),
                                            #variableId->getColumn(),
                                            mFilename,
                                            op->GetName(),
                                            ASCIIToWide(#variableId->getText())));
            }
          
            OperatorArgType argType = mCompositeDictionary->
                                            getArgType(mActiveCompositeName,
                                                       ASCIIToWide(#variableId->getText()));

            OperatorArg *arg = new OperatorArg(OPERATOR_ARG_TYPE_VARIABLE,
                                             ASCIIToWide(#variableId->getText()), 
                                             ASCIIToWide(#id->getText()),
                                             argType,
                                             #id->getLine(), #id->getColumn(),
                                             #variableId->getLine(), 
                                             #variableId->getColumn(),
                                             mFilename);
            op->addPendingArg(arg);
          }
          else
          {
            // We don't really know the type of argument to use.
            // We will assume a string.
            OperatorArg *arg = new OperatorArg(OPERATOR_ARG_TYPE_VARIABLE,
                                             ASCIIToWide(#variableId->getText()), 
                                             ASCIIToWide(#id->getText()),
                                             OPERATOR_ARG_TYPE_STRING,
                                             #id->getLine(), #id->getColumn(),
                                             #variableId->getLine(), 
                                             #variableId->getColumn(),
                                             mFilename);

            op->handleUnresolvedArg(*arg);
            delete arg;
          }
        }
    )
  )
  ;

operatorArgumentList[OperatorArg** opArgSubList]
  :
  #(id:ID 
    (av:nodeArgumentValue
        { 
          if ((*opArgSubList) == NULL)
          {
            *opArgSubList = new OperatorArg(OPERATOR_ARG_TYPE_SUBLIST);
          }

          OperatorArg *arg = formOperatorArg(#id, av);
          (*opArgSubList)->addSubListArg(*arg);
          delete arg;
        }
    )
  )
  ;

accountResolutionStatement
{
  DesignTimeAccountResolution * op(NULL);
}
  :
  #(id:ACCOUNT_RESOLUTION (COLON id2:ID)?
    {
      op = new DesignTimeAccountResolution(ASCIIToWide(#id->getText()));
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
      op->expand(*mScriptInterpreter);
    }
  )
  ;

broadcastStatement
{
  DesignTimeBroadcastPartitioner * op(NULL);
}
  :
  #(id:BROADCAST (COLON id2:ID)?
    {
      op = new DesignTimeBroadcastPartitioner();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

collStatement
{
  DesignTimeNondeterministicCollector * op(NULL);
}
  :
  #(id:COLL (COLON id2:ID)?
    {
      op = new DesignTimeNondeterministicCollector();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

copyStatement
{
  DesignTimeCopy * op(NULL);
}
  :
  #(id:COPY (COLON id2:ID)?
    {
      op = new DesignTimeCopy((*mActiveSymbolTable)[ASCIIToWide(id->getText())].NumOutputs);
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

devNullStatement
{
  DesignTimeDevNull * op(NULL);
}
  :
  #(id:DEVNULL (COLON id2:ID)?
    {
      op = new DesignTimeDevNull();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

selectStatement
{
  DesignTimeDatabaseSelect * op(NULL);
}
  :
  #(id:SELECT (COLON id2:ID)?
    {
      op = new DesignTimeDatabaseSelect();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

exportStatement
{
  DesignTimeRecordExporter* op(NULL);
}
  :
  #(id:EXPORT (COLON id2:ID)?
    {
      op = new DesignTimeRecordExporter();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

exportQueueStatement
{
  DesignTimeQueueExport* op(NULL);
}
  :
  #(id:EXPORT_QUEUE (COLON id2:ID)?
    {
      op = new DesignTimeQueueExport();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

exprStatement
{
  DesignTimeExpression * op(NULL);
}
  :
  #(id:EXPR (COLON id2:ID)?
    {
      op = new DesignTimeExpression();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

filterStatement
{
  DesignTimeFilter * op(NULL);
}
  :
  #(id:FILTER (COLON id2:ID)?
    {
      op = new DesignTimeFilter();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

delayedGenerateStatement
  :
  #(DELAYED_GENERATE g:GENERATE)
  {
    if ((*mActiveSymbolTable)[ASCIIToWide(g->getText())].NumInputs == 0)
    {
      generateStatement(g);
    }
    else
    {
      expressionGenerateStatement(g);
    }
  }
  ;

generateStatement
{
  DesignTimeGenerator * op(NULL);
}
  :
  #(id:GENERATE (COLON id2:ID)?
    {
      op = new DesignTimeGenerator();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

expressionGenerateStatement
{
  DesignTimeExpressionGenerator * op(NULL);
}
  :
  #(id:GENERATE (COLON id2:ID)?
    {
      op = new DesignTimeExpressionGenerator();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

groupByStatement
{
  DesignTimeHashGroupBy * op(NULL);
}
  :
  #(id:GROUP_BY (COLON id2:ID)?
    {
      op = new DesignTimeHashGroupBy((*mActiveSymbolTable)[ASCIIToWide(id->getText())].NumInputs);
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

hashPartStatement
{
  DesignTimeHashPartitioner * op(NULL);
}
  :
  #(id:HASHPART (COLON id2:ID)?
    {
      op = new DesignTimeHashPartitioner();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

hashRunningTotalStatement
{
  DesignTimeHashRunningAggregate * op(NULL);
}
  :
  #(id:HASH_RUNNING_TOTAL (COLON id2:ID)?
    {
      op = new DesignTimeHashRunningAggregate((*mActiveSymbolTable)[ASCIIToWide(id->getText())].NumInputs);
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

idGeneratorStatement
{
  DesignTimeIdGenerator* op(NULL);
}
  :
  #(id:ID_GENERATOR (COLON id2:ID)?
    {
      op = new DesignTimeIdGenerator();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

importStatement
{
  DesignTimeRecordImporter* op(NULL);
}
  :
  #(id:IMPORT (COLON id2:ID)?
    {
      op = new DesignTimeRecordImporter();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

importQueueStatement
{
  DesignTimeQueueImport* op(NULL);
}
  :
  #(id:IMPORT_QUEUE (COLON id2:ID)?
    {
      op = new DesignTimeQueueImport();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

innerHashJoinStatement
{
  DesignTimeHashJoin * op(NULL);
}
  :
  #(id:INNER_HASH_JOIN (COLON id2:ID)?
    {
      op = new DesignTimeHashJoin();
      addToSymbolTable(op, #id);
      op->SetProbeSpecificationType(
                    DesignTimeHashJoinProbeSpecification::INNER_JOIN);
    }
    (operatorArgument[op])*
    {
      int nInputs = (*mActiveSymbolTable)[ASCIIToWide(id->getText())].NumInputs;
      mActivePlan->push_back(op);
      op->CreatePorts(nInputs);

      // If we are not in a composite, then we have already processed
      // the arguments and mProbes is complete.  If we are in a composite,
      // we have to hold off on AddProbeSpecification() until the arguments
      // are processed.
      if (!mIsCompositeBeingParsed)
      {
        for (int i=0; i<nInputs-1; i++)
        {
          op->AddProbeSpecification(i);
        }
      }
    }
  )
  ;

innerMergeJoinStatement
{
  DesignTimeSortMergeJoin * op(NULL);
}
  :
  #(id:INNER_MERGE_JOIN (COLON id2:ID)?
    {
      op = new DesignTimeSortMergeJoin();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

insertStatement
{
  DesignTimeDatabaseInsert * op(NULL);
}
  :
  #(id:INSERT (COLON id2:ID)?
    {
      op = new DesignTimeDatabaseInsert();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

loadErrorStatement
{
  DesignTimeLoadError * op(NULL);
}
  :
  #(id:LOAD_ERROR (COLON id2:ID)?
    {
      op = new DesignTimeLoadError(ASCIIToWide(#id->getText()));
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
      op->expand(*mScriptInterpreter);
    }
  )
  ;

loadUsageStatement
{
  DesignTimeUsageLoader * op(NULL);
}
  :
  #(id:LOAD_USAGE (COLON id2:ID)?
    {
      op = new DesignTimeUsageLoader(ASCIIToWide(#id->getText()));
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
      op->expand(*mScriptInterpreter);
    }
  )
  ;

longestPrefixMatchStatement
{
  DesignTimeLongestPrefixMatch * op = NULL;;
}
  :
  #(id:LONGEST_PREFIX_MATCH (COLON id2:ID)?
    {
      op = new DesignTimeLongestPrefixMatch();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

md5Statement
{
  DesignTimeMD5Hash * op = NULL;;
}
  :
  #(id:MD5 (COLON id2:ID)?
    {
      op = new DesignTimeMD5Hash();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

meterStatement
{
  Metering * op;
  boost::shared_ptr<DatabaseMeteringStagingDatabase> db;
  std::vector<std::wstring> services;
  std::vector<std::wstring> keys;
}
  :
  #(id:METER (COLON id2:ID)?
    {
      op = new Metering();
      op->SetIsOutputPortNeeded((*mActiveSymbolTable)[ASCIIToWide(id->getText())].NumOutputs > 0);
      addToSymbolTable(op, #id);
      mMetering.push_back(op);
    }
    (meterArgument[op,services,keys])*
    {
      op->SetServices(services);
      op->SetKeys(keys);
      db = boost::shared_ptr<DatabaseMeteringStagingDatabase> (new DatabaseMeteringStagingDatabase(services, DatabaseMeteringStagingDatabase::STREAMING));
      op->Generate(*mActivePlan, db);
      mDbs.push_back(db);
    }
  )
  ;

meterArgument[Metering * op, std::vector<std::wstring>& services, std::vector<std::wstring>& keys]
  :
  #(id:ID 
   (av:nodeArgumentValue
  {
    if (boost::algorithm::iequals(#id->getText().c_str(), "service"))
    {
      if (av->getType() != STRING_LITERAL)
      {
        reportInvalidArgumentValue(op, id, av, L"Expected a string.");
      }
      std::wstring wstrArg=ASCIIToWide(av->getText().substr(1, av->getText().size()-2));
      services.push_back(wstrArg);
    }
    else if (boost::algorithm::iequals(#id->getText().c_str(), "key"))
    {
      if (av->getType() != STRING_LITERAL)
      {
        reportInvalidArgumentValue(op, id, av, L"Expected a string.");
      }
      std::wstring wstrArg=ASCIIToWide(av->getText().substr(1, av->getText().size()-2));
      keys.push_back(wstrArg);
    }
    else if (boost::algorithm::iequals(#id->getText().c_str(), "stageOnly"))
    {
      if (av->getType() != TK_TRUE && av->getType() != TK_FALSE)
      {
        reportInvalidArgumentValue(op, id, av, L"Expected true or false.");
      }
      op->SetStageOnly(av->getType() == TK_TRUE);
    }
    else if (boost::algorithm::iequals(#id->getText().c_str(), "targetCommitSize"))
    {
      if (av->getType() != NUM_INT)
      {
        reportInvalidArgumentValue(op, id, av, L"Expected an integer.");
      }
      boost::int32_t val(boost::lexical_cast<boost::int32_t>(av->getText()));
      op->SetTargetCommitSize(val);
    }
    else if (boost::algorithm::iequals(#id->getText().c_str(), "targetMessageSize"))
    {
      if (av->getType() != NUM_INT)
      {
        reportInvalidArgumentValue(op, id, av, L"Expected an integer.");
      }
      boost::int32_t val(boost::lexical_cast<boost::int32_t>(av->getText()));
      op->SetTargetMessageSize(val);
    }
    else if (boost::algorithm::iequals(#id->getText().c_str(), "collectionID"))
    {
      if (av->getType() != NUM_INT ||
          av->getText().size() != 34 ||
          av->getText().substr(0,2) != std::string("0x"))
      {
        reportInvalidArgumentValue(op, id, av, L"Expected a binary(16) value.");
      }
      std::vector<boost::uint8_t> val;
      for(std::size_t idx=2; idx<34; idx+=2)
      {
        boost::uint32_t tmp1 = GetHexValue(av->getText()[idx]);
        if (tmp1 > 15) 
        {
          reportInvalidArgumentValue(op, id, av, L"Expected a binary(16) value.");
        }

        boost::uint32_t tmp2 = GetHexValue(av->getText()[idx+1]);
        if (tmp2 > 15) 
        {
          reportInvalidArgumentValue(op, id, av, L"Expected a binary(16) value.");
        }
        val.push_back((boost::uint8_t)((tmp1<<4) + tmp2));
      }
      op->SetCollectionID(val);
    }

    else if (boost::algorithm::iequals(id->getText().c_str(), 
             "collectionIDEncoded"))
    {
      if (av->getType() != STRING_LITERAL)
      {
        reportInvalidArgumentValue(op, id, av, L"Expected a string.");
      }

      std::string encoded = av->getText().substr(1, av->getText().size()-2);

      processCollectionIDEncodedParameter(op, id, encoded);
    }

    else if (boost::algorithm::iequals(#id->getText().c_str(), "generateSummaryTable"))
    {
      if (av->getType() != TK_TRUE && av->getType() != TK_FALSE)
      {
        reportInvalidArgumentValue(op, id, av, L"Expected true or false.");
      }
      op->SetGenerateSummaryTable(av->getType() == TK_TRUE);
    }

    else if (boost::algorithm::iequals(#id->getText().c_str(), "areEnumsBeingUsed"))
    {
      if (av->getType() != TK_TRUE && av->getType() != TK_FALSE)
      {
        reportInvalidArgumentValue(op, id, av, L"Expected true or false.");
      }
      op->SetAreEnumsBeingUsed(av->getType() == TK_TRUE);
    }
    else if (boost::algorithm::iequals(#id->getText().c_str(), "mode"))
    {
      processModeParameter(op, id, av);
    }
    else if (boost::algorithm::iequals(#id->getText().c_str(), "isAuthorizationNeeded"))
    {
      if (av->getType() != TK_TRUE && av->getType() != TK_FALSE)
      {
        reportInvalidArgumentValue(op, id, av, L"Expected true or false.");
      }
      op->SetIsAuthNeeded(av->getType() == TK_TRUE);
    }
    else
    {
      throw (DataflowInvalidArgumentException(
                                            #id->getLine(),
                                            #id->getColumn(),
                                            mFilename,
                                            op->GetName(),
                                            ASCIIToWide(#id->getText())));
    }
  }

  | DOLLAR_SIGN variableId:ID 
  {
    // We only support the use of the $<name> argument for the 
    // encoded collection ID.
    if (!boost::algorithm::iequals(#id->getText().c_str(), 
                                   "collectionIDEncoded"))
    {
      reportInvalidArgument(op, id, 
                   L"You can only use the $variable for collectionIDEncoded.");
    }

    // Get the environment so we know how to convert this
    // $<name> into a string value.
    ArgEnvironment *env = ArgEnvironment::getActiveEnvironment();
    std::wstring wideStr = env->getValue(ASCIIToWide(#variableId->getText()));
    std::string encoded;
    ::WideStringToUTF8(wideStr, encoded);
    
    processCollectionIDEncodedParameter(op, id, encoded);
  }
  )
  )
  ;

multiHashJoinStatement
{
  DesignTimeHashJoin * op(NULL);
}
  :
  #(id:MULTI_HASH_JOIN (COLON id2:ID)?
    {
      op = new DesignTimeHashJoin();
      addToSymbolTable(op, #id);
      op->SetIsMultiHashJoin();
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);

      int nInputs = (*mActiveSymbolTable)[ASCIIToWide(id->getText())].NumInputs;
      op->CreatePorts(nInputs);

      // If we are not in a composite, then we have already processed
      // the arguments and mProbes is complete.  If we are in a composite,
      // we have to hold off on AddProbeSpecification() until the arguments
      // are processed.
      if (!mIsCompositeBeingParsed)
      {
        for (int i=0; i<nInputs-1; i++)
        {
          op->AddProbeSpecification(i);
        }
      }
    }
  )
  ;

printStatement
{
  DesignTimePrint * op(NULL);
}
  :
  #(id:PRINT (COLON id2:ID)?
    {
      op = new DesignTimePrint();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      (mActivePlan)->push_back(op);
    }
  )
  ;

projectionStatement
{
  DesignTimeProjection * op(NULL);
}
  :
  #(id:PROJECTION (COLON id2:ID)?
    {
      op = new DesignTimeProjection();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

rangePartStatement
{
  DesignTimeRangePartitioner * op(NULL);
}
  :
  #(id:RANGEPART (COLON id2:ID)?
    {
      op = new DesignTimeRangePartitioner();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

rateCalculationStatement
{
  DesignTimeRateCalculation * op(NULL);
}
  :
  #(id:RATE_CALCULATION (COLON id2:ID)?
    {
      op = new DesignTimeRateCalculation(ASCIIToWide(#id->getText()));
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
      op->expand(*mScriptInterpreter);
    }
  )
  ;

rateScheduleResolutionStatement
{
  DesignTimeRateScheduleResolution * op(NULL);
}
  :
  #(id:RATE_SCHEDULE_RESOLUTION (COLON id2:ID)?
    {
      op = new DesignTimeRateScheduleResolution(ASCIIToWide(#id->getText()));
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
      op->expand(*mScriptInterpreter);
    }
  )
  ;

renameStatement
{
  DesignTimeRename * op(NULL);
  std::vector<std::wstring> from;
  std::vector<std::wstring> to;
}
  :
  #(id:RENAME (COLON id2:ID)?
    {
      op = new DesignTimeRename();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
      op->handleToFromArgs();
    }
  )
  ;

rightMergeAntiSemiJoinStatement 
{
  DesignTimeSortMergeJoin * op(NULL);
}
  :
  #(id:RIGHT_MERGE_ANTI_SEMI_JOIN (COLON id2:ID)?
    {
      op = new DesignTimeSortMergeJoin();
      addToSymbolTable(op, #id);
      op->SetJoinType(DesignTimeSortMergeJoin::RIGHT_ANTI_SEMI);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

rightMergeSemiJoinStatement 
{
  DesignTimeSortMergeJoin * op(NULL);
}
  :
  #(id:RIGHT_MERGE_SEMI_JOIN (COLON id2:ID)?
    {
      op = new DesignTimeSortMergeJoin();
      addToSymbolTable(op, #id);
      op->SetJoinType(DesignTimeSortMergeJoin::RIGHT_SEMI);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

rightOuterHashJoinStatement
{
  DesignTimeHashJoin * op(NULL);
  DesignTimeHashJoinProbeSpecification spec;
}
  :
  #(id:RIGHT_OUTER_HASH_JOIN (COLON id2:ID)?
    {
      op = new DesignTimeHashJoin();
      addToSymbolTable(op, #id);
      op->SetProbeSpecificationType(
                    DesignTimeHashJoinProbeSpecification::RIGHT_OUTER);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);

      int nInputs = (*mActiveSymbolTable)[ASCIIToWide(id->getText())].NumInputs;
      op->CreatePorts(nInputs);
      for(int i=0; i<nInputs-1; i++)
      {
        op->AddProbeSpecification(i);
      }
    }
  )
  ;

rightOuterMergeJoinStatement 
{
  DesignTimeSortMergeJoin * op(NULL);
}
  :
  #(id:RIGHT_OUTER_MERGE_JOIN (COLON id2:ID)?
    {
      op = new DesignTimeSortMergeJoin();
      addToSymbolTable(op, #id);
      op->SetJoinType(DesignTimeSortMergeJoin::RIGHT_OUTER);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

sequentialFileDeleteStatement
{
  DesignTimeDataFileDelete * op(NULL);
}
  :
  #(id:SEQUENTIAL_FILE_DELETE (COLON id2:ID)?
    {
      op = new DesignTimeDataFileDelete();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

sequentialFileOutputStatement
{
  DesignTimeDataFileExport * op(NULL);
}
  :
  #(id:SEQUENTIAL_FILE_OUTPUT (COLON id2:ID)?
    {
      op = new DesignTimeDataFileExport();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

sequentialFileRenameStatement
{
  DesignTimeDataFileRename * op(NULL);
}
  :
  #(id:SEQUENTIAL_FILE_RENAME (COLON id2:ID)?
    {
      op = new DesignTimeDataFileRename();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

sequentialFileScanStatement
{
  DesignTimeDataFileScan * op(NULL);
}
  :
  #(id:SEQUENTIAL_FILE_SCAN (COLON id2:ID)?
    {
      op = new DesignTimeDataFileScan();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

sessionSetBuilderStatement
{
  DesignTimeSessionSetBuilder * op(NULL);
}
  :
  #(id:SESSION_SET_BUILDER (COLON id2:ID)?
    {
      op = new DesignTimeSessionSetBuilder((*mActiveSymbolTable)[ASCIIToWide(id->getText())].NumInputs);
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

sortStatement
{
  DesignTimeExternalSort * op(NULL);
}
  :
  #(id:SORT (COLON id2:ID)?
    {
      op = new DesignTimeExternalSort();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

sortGroupByStatement
{
  DesignTimeSortGroupBy * op(NULL);
}
  :
  #(id:SORT_GROUP_BY (COLON id2:ID)?
    {
      op = new DesignTimeSortGroupBy();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

sortMergeStatement
{
  DesignTimeSortMerge * op(NULL);
}
  :
  #(id:SORTMERGE (COLON id2:ID)?
    {
      op = new DesignTimeSortMerge((*mActiveSymbolTable)[ASCIIToWide(id->getText())].NumInputs);
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

sortMergeCollStatement
{
  DesignTimeSortMergeCollector * op(NULL);
}
  :
  #(id:SORTMERGECOLL (COLON id2:ID)?
    {
      op = new DesignTimeSortMergeCollector();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

sortNestStatement
{
  DesignTimeSortNest * op(NULL);
}
  :
  #(id:SORT_NEST (COLON id2:ID)?
    {
      op = new DesignTimeSortNest();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

sortOrderAssertStatement
{
  DesignTimeAssertSortOrder * op(NULL);
}
  :
  #(id:SORT_ORDER_ASSERT (COLON id2:ID)?
    {
      op = new DesignTimeAssertSortOrder();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

sortRunningTotalStatement
{
  DesignTimeSortRunningAggregate * op(NULL);
}
  :
  #(id:SORT_RUNNING_TOTAL (COLON id2:ID)?
    {
      op = new DesignTimeSortRunningAggregate((*mActiveSymbolTable)[ASCIIToWide(id->getText())].NumInputs);
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

sqlExecDirectStatement
{
  DesignTimeTransactionalInstall * op(NULL);
}
  :
  #(id:SQL_EXEC_DIRECT (COLON id2:ID)?
    {
      op = new DesignTimeTransactionalInstall((*mActiveSymbolTable)[ASCIIToWide(id->getText())].NumInputs - 1);
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

subscriptionResolutionStatement
{
  DesignTimeSubscriptionResolution * op(NULL);
}
  :
  #(id:SUBSCRIPTION_RESOLUTION (COLON id2:ID)?
    {
      op = new DesignTimeSubscriptionResolution(ASCIIToWide(#id->getText()));
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
      op->expand(*mScriptInterpreter);
    }
  )
  ;

switchStatement
{
  DesignTimeSwitch * op(NULL);
}
  :
  #(id:SWITCH (COLON id2:ID)?
    {
      op = new DesignTimeSwitch((*mActiveSymbolTable)[ASCIIToWide(id->getText())].NumOutputs);
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

taxwareStatement
{
  DesignTimeTaxware * op(NULL);
}
  :
  #(id:TAXWARE (COLON id2:ID)?
    {
      op = new DesignTimeTaxware();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

unionAllStatement
{
  DesignTimeUnionAll * op(NULL);
}
  :
  #(id:UNION_ALL (COLON id2:ID)?
    {
      op = new DesignTimeUnionAll((*mActiveSymbolTable)[ASCIIToWide(id->getText())].NumInputs);
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

unnestStatement
{
  DesignTimeUnnest * op(NULL);
}
  :
  #(id:UNNEST (COLON id2:ID)?
    {
      op = new DesignTimeUnnest();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

unrollStatement
{
  DesignTimeUnroll * op(NULL);
}
  :
  #(id:UNROLL (COLON id2:ID)?
    {
      op = new DesignTimeUnroll();
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
    }
  )
  ;

writeErrorStatement
{
  DesignTimeWriteError * op(NULL);
}
  :
  #(id:WRITE_ERROR (COLON id2:ID)?
    {
      op = new DesignTimeWriteError(ASCIIToWide(#id->getText()),
                                    (*mActiveSymbolTable)[ASCIIToWide(id->getText())].NumInputs);
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
      op->expand(*mScriptInterpreter);
    }
  )
  ;

writeProductViewStatement
{
  DesignTimeWriteProductView * op(NULL);
}
  :
  #(id:WRITE_PRODUCT_VIEW (COLON id2:ID)?
    {
      op = new DesignTimeWriteProductView(ASCIIToWide(#id->getText()));
      addToSymbolTable(op, #id);
    }
    (operatorArgument[op])*
    {
      mActivePlan->push_back(op);
      op->expand(*mScriptInterpreter);
    }
  )
  ;

stepStatement
{
  std::wstring stepName;
}
  :
  #(id:STEP 
    {
      stepName = ASCIIToWide(#id->getText());
    }
  )
  {
    WorkflowInstructionStep* instruction = 
      new WorkflowInstructionStep(mWorkflow, stepName, stepName);
    mWorkflow->addInstruction(instruction);
  }
  ;
  
compositeStatement
{
  DesignTimeComposite * op(NULL);
  std::wstring defnName;
  const CompositeDefinition* definition;
}
  :
  #(id:COMPOSITE 
    {
      defnName = ASCIIToWide(#id->getText());
    }
    (COLON id2:ID
      {
        defnName = ASCIIToWide(#id2->getText());
      }
    )?
    {
      definition = mCompositeDictionary->getDefinition(defnName.c_str());

      // We should never encounter undefined composite at this point.
      if (definition == NULL)
      {
        reportInternalError(L"Encountered unknown composite.", id);
      }

      op = new DesignTimeComposite(
                    definition,
                    (*mActiveSymbolTable)[ASCIIToWide(id->getText())].NumInputs,
                    (*mActiveSymbolTable)[ASCIIToWide(id->getText())].NumOutputs);
      addToSymbolTable(op, #id);      
    }                                
    (compositeArgument[definition, op])*        
    {
      mActivePlan->push_back(op);
    }
  )
  ;

compositeArgument[const CompositeDefinition* defn,
                  DesignTimeComposite *op]
{
  OperatorArg* opArgSubList = NULL;
}
  :
  #(id:ID 
    {
          // Make sure that the referenced composite argument exists.
          if (!defn->doesArgExist(ASCIIToWide(#id->getText())))
          {
            throw (DataflowInvalidArgumentException(
                                            #id->getLine(),
                                            #id->getColumn(),
                                            mFilename,
                                            op->GetName(),
                                            ASCIIToWide(#id->getText())));
          }
          
    }

    (av:nodeArgumentValue
        { 
          OperatorArg *arg = formOperatorArg(#id, av);

          // The DesignTimeComposite is given ownership of the pointer.
          op->addArg(arg);
        }

    // A sub-list of arguments
    | (operatorArgumentList[&opArgSubList])*
        {
          opArgSubList->setName(ASCIIToWide(#id->getText()),
                                #id->getLine(),
                                #id->getColumn());
          // The DesignTimeComposite is given ownership of the pointer.
          op->addArg(opArgSubList);
        }

    // A variable
   | DOLLAR_SIGN variableId:ID 
        { 
          OperatorArgType argType = defn->getArgType(ASCIIToWide(#id->getText()));

          OperatorArg *arg = new OperatorArg(OPERATOR_ARG_TYPE_VARIABLE,
                                             ASCIIToWide(#id->getText()), 
                                             ASCIIToWide(#variableId->getText()),
                                             argType,
                                             #variableId->getLine(), 
                                             #variableId->getColumn(),
                                             #id->getLine(), 
                                             #id->getColumn(),
                                             mFilename);

          op->addArg(arg);
        }
    )
  )
  ;

nodeArgumentValue
  :
  NUM_INT
  |
  NUM_BIGINT
  |
  NUM_FLOAT
  |
  NUM_DECIMAL
  |
  STRING_LITERAL
  |
  TK_TRUE
  |
  TK_FALSE
  ;

edgeStatement
{
  //     tuple<operator name, <port id, port name>, line number, column number>
  boost::tuple<std::wstring, boost::variant<int,std::wstring>, int, int > lhs;
  boost::tuple<std::wstring, boost::variant<int,std::wstring>, int, int > rhs;
  bool buffered = true;
}
  :
  #(ARROW lhs=arrowOrRefStatement (buffered = arrowArguments)? rhs = nodeRefStatement) 
  {
    std::map<std::wstring,DataflowSymbol >::const_iterator leftIt(mActiveSymbolTable->find(lhs.get<0>()));
    std::map<std::wstring,DataflowSymbol >::const_iterator rightIt(mActiveSymbolTable->find(rhs.get<0>()));

    // Verify that the referenced operator exists
    if (leftIt == mActiveSymbolTable->end())
      throw DataflowArrowUndefOperatorException(lhs.get<0>(), lhs.get<2>(), 
                                                lhs.get<3>(), mFilename);
    if (rightIt == mActiveSymbolTable->end())
      throw DataflowArrowUndefOperatorException(rhs.get<0>(), rhs.get<2>(), 
                                                lhs.get<3>(), mFilename);

    // Verify that the referenced ports exists
    verifyPortExists(leftIt->second.Op->GetOutputPorts(), lhs, false);
    verifyPortExists(rightIt->second.Op->GetInputPorts(), rhs, true);

    boost::shared_ptr<Port> lhsPort (
                lhs.get<1>().which() == 0 ? 
		leftIt->second.Op->GetOutputPorts()[boost::get<int>(lhs.get<1>())] :
		leftIt->second.Op->GetOutputPorts()[boost::get<std::wstring>(lhs.get<1>())]);

    boost::shared_ptr<Port> rhsPort (
                rhs.get<1>().which() == 0 ? 
		rightIt->second.Op->GetInputPorts()[boost::get<int>(rhs.get<1>())] :
		rightIt->second.Op->GetInputPorts()[boost::get<std::wstring>(rhs.get<1>())]);

    mActivePlan->push_back(new DesignTimeChannel(lhsPort, rhsPort, buffered));
  }
  ;

// Returns tuple<operator name, <port id, port name>, line number, column number>
arrowOrRefStatement returns [boost::tuple<std::wstring, boost::variant<int,std::wstring>, int, int >  rhs]
{
  boost::tuple<std::wstring, boost::variant<int,std::wstring>, int, int > lhs;
  bool buffered = true;
}
  :
  #(ARROW lhs=arrowOrRefStatement (buffered = arrowArguments)? rhs = nodeRefStatement) 
  {
    std::map<std::wstring,DataflowSymbol >::const_iterator leftIt(mActiveSymbolTable->find(lhs.get<0>()));
    std::map<std::wstring,DataflowSymbol >::const_iterator rightIt(mActiveSymbolTable->find(rhs.get<0>()));

    // Verify operator exists
    if (leftIt == mActiveSymbolTable->end())
      throw DataflowArrowUndefOperatorException(lhs.get<0>(), lhs.get<2>(), 
                                                lhs.get<3>(), mFilename);
    if (rightIt == mActiveSymbolTable->end())
      throw DataflowArrowUndefOperatorException(rhs.get<0>(), rhs.get<2>(), 
                                                lhs.get<3>(), mFilename);

    // Verify that the referenced ports exists
    verifyPortExists(leftIt->second.Op->GetOutputPorts(), lhs, false);
    verifyPortExists(rightIt->second.Op->GetInputPorts(), rhs, true);

    boost::shared_ptr<Port> lhsPort (
                lhs.get<1>().which() == 0 ? 
		leftIt->second.Op->GetOutputPorts()[boost::get<int>(lhs.get<1>())] :
		leftIt->second.Op->GetOutputPorts()[boost::get<std::wstring>(lhs.get<1>())]);

    boost::shared_ptr<Port> rhsPort (
                rhs.get<1>().which() == 0 ? 
		rightIt->second.Op->GetInputPorts()[boost::get<int>(rhs.get<1>())] :
		rightIt->second.Op->GetInputPorts()[boost::get<std::wstring>(rhs.get<1>())]);

    mActivePlan->push_back(new DesignTimeChannel(lhsPort, rhsPort, buffered));
  }
  |
  rhs = nodeRefStatement
  ;

// Returns tuple<operator name, <port id, port name>, line number, column number>
nodeRefStatement returns [boost::tuple<std::wstring, boost::variant<int,std::wstring>, int, int > t]
{
  std::wstring nodeName;
  int portIndex(0);
  std::wstring portName;
  int lineNumber;
  int columnNumber;
}
  :
  #(id:ID 
    {
      nodeName = ASCIIToWide(#id->getText());
      lineNumber = id->getLine();
      columnNumber = id->getColumn();
    }
        (i:NUM_INT 
           { 
             portIndex = boost::lexical_cast<int>(#i->getText()); 
           } 
           | 
           s:STRING_LITERAL 
           { 
             portName = ASCIIToWide(#s->getText().substr(1, #s->getText().size()-2));
           }
          )?
  )
  {
    if (portName.size() != 0)
    {
      t = boost::tuple<std::wstring, boost::variant<int,std::wstring>, int, int >(nodeName, portName, lineNumber, columnNumber);
    }
    else
    {
      t = boost::tuple<std::wstring, boost::variant<int,std::wstring>, int, int >(nodeName, portIndex, lineNumber, columnNumber);
    }
  }
  ;

arrowArguments returns [bool buffered]
  :
  #(LBRACKET buffered = arrowBufferArgument) 
  ;

arrowBufferArgument returns [bool buffered]
{
  buffered = true;
}
  :
  #(id:ID av:nodeArgumentValue) 
  {
    if (boost::algorithm::iequals(#id->getText().c_str(), "buffered"))
    {
      if (av->getType() != TK_TRUE && av->getType() != TK_FALSE)
      {
        throw DataflowInvalidArrowArgumentValueException(
                id->getLine(), id->getColumn(), mFilename,
                ASCIIToWide(id->getText()), ASCIIToWide(av->getText()), L"Expected true or false.");
      }
      buffered = av->getType() == TK_TRUE;
    }
  }
  ;


