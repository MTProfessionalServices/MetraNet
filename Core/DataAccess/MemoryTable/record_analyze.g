header {
  #include "LogAdapter.h"
  #include "MTSQLParam.h"
  #include "RecognitionException.hpp"
  #include "ImportFunction.h"
  #include <map>
  #include <boost/format.hpp>
}
options {
	language = "Cpp";
}
class RecordFormatTreeParser extends TreeParser;
options {
	importVocab=RecordFormatParser; // use vocab generated by lexer
    defaultErrorHandler = false;
}

{
private:
  MetraFlowLoggerPtr mLog;
  bool mHasError;
  std::map<std::string, ANTLR_USE_NAMESPACE(antlr)RefAST> mTypeDefinitions;

  Record_Metadata_Builder * mBuilder;

public:
	// Override the error and warning reporting
  virtual void reportError(const ANTLR_USE_NAMESPACE(antlr)RecognitionException& ex)
  {
	mLog->logError(ex.toString());
    mHasError = true;
  }

	/** Parser error-reporting function can be overridden in subclass */
  virtual void reportError(const ANTLR_USE_NAMESPACE(std)string& s)
  {
	mLog->logError(s);
    mHasError = true;
  }

	/** Parser warning-reporting function can be overridden in subclass */
  virtual void reportWarning(const ANTLR_USE_NAMESPACE(std)string& s)
  {
	mLog->logWarning(s);
  }
 
  void setBuilder(Record_Metadata_Builder * builder)
  {
    mBuilder = builder;
  }

  void setLog(MetraFlowLoggerPtr log)
  {
	mLog = log;
    mHasError = false;
  }

  bool getHasError()
  {
	return mHasError;
  }
  
  void setLog(Logger * log)
  {
  }

  std::vector<MTSQLParam> antlr::TreeParser::getParams(void)
  {
    return std::vector<MTSQLParam>();
  }
}

program
  :
  #(ID (typeDefinition)* recordDefinition)
  ;

typeDefinition
  :
  #(td:TYPE_DEFINITION ts:TYPE_SPECIFICATION) 
  {
    // TODO: Warn if multiple definitions.
    mTypeDefinitions[#td->getText()] = #ts;
  }
  ;

recordDefinition
  :
  #(RECORD_DEFINITION (fieldDefinition)+)
  ;

typeSpecification [const std::wstring& fieldName]
{
  bool isRequired=true;
}
  :
  #(ts:TYPE_SPECIFICATION (typeParameter[isRequired])*
  {
    try
    {
      mBuilder->add_field(fieldName, #ts->getText(), isRequired);
    }
    catch(std::exception& ex)
    {
      reportError(ex.what());
      throw antlr::RecognitionException("Invalid importer specification");
    }
  }  
  )
  ;

typeParameter [bool& isRequired]
  :
  #(tp:TYPE_PARAMETER 
  {
    if (#tp->getText() == "null_value")
    {
      isRequired = false;
    }
  }
  (STRING_LITERAL | ID))
  ;

fieldDefinition
{
  std::wstring wstrFieldName;
}
  :
  #(fd:FIELD_DEFINITION 
  { 
    ::ASCIIToWide(wstrFieldName, #fd->getText()); 
  }
  (
  tr:TYPE_REFERENCE 
  {
    std::map<std::string, antlr::RefAST>::iterator it = mTypeDefinitions.find(#tr->getText());
    if (it == mTypeDefinitions.end())
    {
      throw std::runtime_error((boost::format("Undefined type reference: %1%") % #tr->getText()).str());
    }
    typeSpecification(it->second,wstrFieldName);
  }
  |
  typeSpecification[wstrFieldName]
  ))
  ;

