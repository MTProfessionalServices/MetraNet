header {
  #include "LogAdapter.h"
  #include "MTSQLParam.h"
  #include "RecognitionException.hpp"
  #include "ImportFunction.h"
  #include <map>
  #include <boost/format.hpp>
}
options {
	language = "Cpp";
}
class RecordFormatGenerator extends TreeParser;
options {
	importVocab=RecordFormatParser; // use vocab generated by lexer
    defaultErrorHandler = false;
}

{
private:
  MetraFlowLoggerPtr mLog;
  bool mHasError;
  std::map<std::string, ANTLR_USE_NAMESPACE(antlr)RefAST> mTypeDefinitions;

  Import_Function_Builder * mBuilder;

public:
	// Override the error and warning reporting
  virtual void reportError(const ANTLR_USE_NAMESPACE(antlr)RecognitionException& ex)
  {
	mLog->logError(ex.toString());
    mHasError = true;
  }

	/** Parser error-reporting function can be overridden in subclass */
  virtual void reportError(const ANTLR_USE_NAMESPACE(std)string& s)
  {
	mLog->logError(s);
    mHasError = true;
  }

	/** Parser warning-reporting function can be overridden in subclass */
  virtual void reportWarning(const ANTLR_USE_NAMESPACE(std)string& s)
  {
	mLog->logWarning(s);
  }
 
  void setBuilder(Import_Function_Builder * builder)
  {
    mBuilder = builder;
  }

  void setLog(MetraFlowLoggerPtr log)
  {
	mLog = log;
    mHasError = false;
  }

  bool getHasError()
  {
	return mHasError;
  }
  
  void setLog(Logger * log)
  {
  }

  std::vector<MTSQLParam> antlr::TreeParser::getParams(void)
  {
    return std::vector<MTSQLParam>();
  }
}

program
  :
  #(ID (typeDefinition)* recordDefinition)
  ;

typeDefinition
  :
  #(td:TYPE_DEFINITION ts:TYPE_SPECIFICATION) 
  {
    // TODO: Warn if multiple definitions.
    mTypeDefinitions[#td->getText()] = #ts;
  }
  ;

recordDefinition
  :
  #(RECORD_DEFINITION (fieldDefinition)+)
  ;

typeSpecification [const std::wstring& fieldName]
{
  bool isRequired=true;
  std::string nullValue;
  std::string delimiter;
  std::string enum_space;
  std::string enum_type;
  std::string true_value;
  std::string false_value;
}
  :
  #(ts:TYPE_SPECIFICATION (typeParameter[isRequired, nullValue, delimiter, enum_space, enum_type, true_value, false_value])*
  {
    mBuilder->add_base_type(fieldName, #ts->getText(), isRequired, nullValue, delimiter, enum_space, enum_type, true_value, false_value);
  }  
  )
  ;

typeParameter [bool& isRequired, std::string& nullValue, std::string& delimiter, std::string& enum_space, std::string& enum_type, std::string& true_value, std::string& false_value]
  :
  #(tp:TYPE_PARAMETER (sl:STRING_LITERAL 
  {
    if (#tp->getText() == "null_value")
    {
      isRequired = false;
      nullValue = #sl->getText().substr(1, #sl->getText().size()-2);
    }
    else if (#tp->getText() == "delimiter")
    {
      delimiter = #sl->getText().substr(1, #sl->getText().size()-2);
    }
    else if (#tp->getText() == "enum_space" ||
             #tp->getText() == "enumspace")
    {
      enum_space = #sl->getText().substr(1, #sl->getText().size()-2);
    }
    else if (#tp->getText() == "enum_type" ||
             #tp->getText() == "enumtype")
    {
      enum_type = #sl->getText().substr(1, #sl->getText().size()-2);
    }
    else if (#tp->getText() == "true_value" ||
             #tp->getText() == "truevalue")
    {
      true_value = #sl->getText().substr(1, #sl->getText().size()-2);
    }
    else if (#tp->getText() == "false_value" ||
             #tp->getText() == "falsevalue")
    {
      false_value = #sl->getText().substr(1, #sl->getText().size()-2);
    }
  }
  |
  id:ID
  {
    if (#tp->getText() == "delimiter" && #id->getText() == "crlf")
    {
      delimiter = "\r\n";
    }
    else if (#tp->getText() == "delimiter" && #id->getText() == "newline")
    {
      delimiter = "\n";
    }
    else 
    {
      throw std::runtime_error("delimiter must be a string or one of the constants: crlf, newline");
    }
  }
  )
  )
  ;

fieldDefinition
{
  std::wstring wstrFieldName;
}
  :
  #(fd:FIELD_DEFINITION 
  { 
    ::ASCIIToWide(wstrFieldName, #fd->getText()); 
  }
  (
  tr:TYPE_REFERENCE 
  {
    std::map<std::string, antlr::RefAST>::iterator it = mTypeDefinitions.find(#tr->getText());
    if (it == mTypeDefinitions.end())
    {
      throw std::runtime_error((boost::format("Undefined type reference: %1%") % #tr->getText()).str());
    }
    typeSpecification(it->second,wstrFieldName);
  }
  |
  typeSpecification[wstrFieldName]
  ))
  ;

