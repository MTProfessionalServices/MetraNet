ANTLR-generated file resulting from grammar .\expandedmtsql_parser_oracle.g
Diagnostic output

Terence Parr, MageLang Institute
with John Lilley, Empathy Software
ANTLR Version 2.7.1; 1996,1997

*** Header Action.
This action will appear at the top of all generated files.
	
	#include "MTSQLInterpreter.h"
	#include "RecognitionException.hpp"
	#include "ASTPair.hpp"
	#include "ASTFactory.hpp"
	#include "MTSQLParser.hpp"
	
*** End of Header Action


*** Parser Preamble Action.
This action will appear before the declaration of your parser class:
	
*** End of Parser Preamble Action

*** Your parser class is called 'MTSQLOracleParser' and is a subclass of 'LLkParser'.

*** User-defined parser class members:
These are the member declarations that you defined for your class:
	
	private:
	Logger* mLog;
	bool mHasError;
	
	public:
	
		// Override the error and warning reporting
	virtual void reportError(const ANTLR_USE_NAMESPACE(antlr)RecognitionException& ex)
	{
		mLog->logError(ex.toString());
	mHasError = true;
	}
	
		/** Parser error-reporting function can be overridden in subclass */
	virtual void reportError(const ANTLR_USE_NAMESPACE(std)string& s)
	{
		mLog->logError(s);
	mHasError = true;
	}
	
		/** Parser warning-reporting function can be overridden in subclass */
	virtual void reportWarning(const ANTLR_USE_NAMESPACE(std)string& s)
	{
		mLog->logWarning(s);
	}
	
	void setLog(Logger * log)
	{
		mLog = log;
	mHasError = false;
	}
	
	bool getHasError()
	{
		return mHasError;
	}
	
*** End of user-defined parser class members

*** Parser rules:
	
	
	*** Parser Rule: sql92_joinedTable
		Access: protected
		Return value: none
		Init action: 
		std::string joinType = "INNER";
		
		Start of an alternative block.
			The lookahead set for this block is:
				{ LPAREN, ID }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LPAREN, ID }
			is matched.
			Rule Reference: sql92_tableReference
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							"CROSS", "FULL", "INNER", "JOIN", "LEFT", 
							"RIGHT"
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "FULL", "INNER", "JOIN", "LEFT", "RIGHT" }
						is matched.
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ "FULL", "INNER", "JOIN", "LEFT", "RIGHT" }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ "FULL", "INNER", "JOIN", "LEFT", "RIGHT" }
								is matched.
								Start of alternative block.
									Start of an alternative block.
										The lookahead set for this block is:
											{ "FULL", "INNER", "JOIN", "LEFT", "RIGHT" }
										This block has multiple alternatives:
											
											Alternate(1) will be taken IF:
											The lookahead set: 
												{ "FULL", "INNER", "LEFT", "RIGHT" }
											is matched.
											Start of alternative block.
												Start of an alternative block.
													The lookahead set for this block is:
														{ "FULL", "INNER", "LEFT", "RIGHT" }
													This block has multiple alternatives:
														
														Alternate(1) will be taken IF:
														The lookahead set: 
															{ "INNER" }
														is matched.
														Match token TK_INNER
														ACTION: joinType = "INNER";
														
														Otherwise, Alternate(2) will be taken IF:
														The lookahead set: 
															{ "FULL", "LEFT", "RIGHT" }
														is matched.
														Start of alternative block.
															Start of an alternative block.
																The lookahead set for this block is:
																	{ "FULL", "LEFT", "RIGHT" }
																This block has multiple alternatives:
																	
																	Alternate(1) will be taken IF:
																	The lookahead set: 
																		{ "FULL" }
																	is matched.
																	Match token TK_FULL
																	ACTION: joinType = "FULL OUTER";
																	
																	Otherwise, Alternate(2) will be taken IF:
																	The lookahead set: 
																		{ "LEFT" }
																	is matched.
																	Match token TK_LEFT
																	ACTION: joinType = "LEFT OUTER";
																	
																	Otherwise, Alternate(3) will be taken IF:
																	The lookahead set: 
																		{ "RIGHT" }
																	is matched.
																	Match token TK_RIGHT
																	ACTION: joinType = "RIGHT OUTER";
																	
																	OTHERWISE, a NoViableAlt exception will be thrown
																	
																End of alternatives
															End of alternative block.
														Start of alternative block.
															Start of an alternative block.
																The lookahead set for this block is:
																	{ "JOIN", "OUTER", ID }
																This block has multiple alternatives:
																	
																	Alternate(1) will be taken IF:
																	The lookahead set: 
																		{ "OUTER" }
																	is matched.
																	Match token TK_OUTER
																	
																	Otherwise, Alternate(2) will be taken IF:
																	The lookahead set: 
																		{ "JOIN", ID }
																	is matched.
																	
																	OTHERWISE, a NoViableAlt exception will be thrown
																	
																End of alternatives
															End of alternative block.
														
														OTHERWISE, a NoViableAlt exception will be thrown
														
													End of alternatives
												End of alternative block.
											Start of alternative block.
												Start of an alternative block.
													The lookahead set for this block is:
														{ "JOIN", ID }
													This block has multiple alternatives:
														
														Alternate(1) will be taken IF:
														The lookahead set: 
															{ ID }
														is matched.
														Match token ID, label=id
														ACTION: 
														joinType += " ";
														char buf[512];
														sprintf(buf, "SQL Server style join hints are not supported on Oracle, ignoring. (%s)!",  #id->getText().c_str());
														reportWarning(string(buf));
														
														
														Otherwise, Alternate(2) will be taken IF:
														The lookahead set: 
															{ "JOIN" }
														is matched.
														
														OTHERWISE, a NoViableAlt exception will be thrown
														
													End of alternatives
												End of alternative block.
											
											Otherwise, Alternate(2) will be taken IF:
											The lookahead set: 
												{ "JOIN" }
											is matched.
											
											OTHERWISE, a NoViableAlt exception will be thrown
											
										End of alternatives
									End of alternative block.
								Match token TK_JOIN
								ACTION: ##->setText(joinType + " JOIN");
								Rule Reference: sql92_joinedTable
								Rule Reference: sql92_joinCriteria
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "CROSS" }
						is matched.
						Match token TK_CROSS
						ACTION: joinType = "CROSS JOIN";
						Match token TK_JOIN
						ACTION: ##->setType(CROSS_JOIN); ##->setText(joinType);
						Rule Reference: sql92_tableReference
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
				"ELSE", "END", "GROUP", "IF", "ON", "ORDER", 
				"PRINT", "RAISERROR", "RETURN", "SELECT", "SET", "UNION", 
				"WHERE", "WHILE", COMMA, RPAREN, SEMI
			 }
	*** End Parser Rule: sql92_joinedTable
	
	
	*** Parser Rule: sql92_tableReference
		Access: protected
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				k==1: {LPAREN, ID }
				k==2: {
					EOF, "AS", "BEGIN", "BREAK", "CONTINUE", 
					"CROSS", "DECLARE", "ELSE", "END", "FULL", "GROUP", 
					"IF", "INNER", "JOIN", "LEFT", "ON", "ORDER", 
					"PRINT", "RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", 
					"UNION", "WHERE", "WHILE", "WITH", COMMA, LPAREN, 
					RPAREN, SEMI, ID, TK_FOR
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ ID }
				is matched.
				Match token ID
				ACTION: ##->setType(TABLE_REF);
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ 
								EOF, "AS", "BEGIN", "BREAK", "CONTINUE", 
								"CROSS", "DECLARE", "ELSE", "END", "FULL", "GROUP", 
								"IF", "INNER", "JOIN", "LEFT", "ON", "ORDER", 
								"PRINT", "RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", 
								"UNION", "WHERE", "WHILE", "WITH", COMMA, RPAREN, 
								SEMI, ID, TK_FOR
							 }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ "AS", ID }
							is matched.
							Start of alternative block.
								Start of an alternative block.
									The lookahead set for this block is:
										{ "AS", ID }
									This block has multiple alternatives:
										
										Alternate(1) will be taken IF:
										The lookahead set: 
											{ "AS" }
										is matched.
										Match token TK_AS
										
										Otherwise, Alternate(2) will be taken IF:
										The lookahead set: 
											{ ID }
										is matched.
										
										OTHERWISE, a NoViableAlt exception will be thrown
										
									End of alternatives
								End of alternative block.
							Match token ID, label=alias
							ACTION: #alias->setType(ALIAS);
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ 
									EOF, "BEGIN", "BREAK", "CONTINUE", "CROSS", 
									"DECLARE", "ELSE", "END", "FULL", "GROUP", "IF", 
									"INNER", "JOIN", "LEFT", "ON", "ORDER", "PRINT", 
									"RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", "UNION", 
									"WHERE", "WHILE", "WITH", COMMA, RPAREN, SEMI, 
									TK_FOR
								 }
							is matched.
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ 
								EOF, "BEGIN", "BREAK", "CONTINUE", "CROSS", 
								"DECLARE", "ELSE", "END", "FULL", "GROUP", "IF", 
								"INNER", "JOIN", "LEFT", "ON", "ORDER", "PRINT", 
								"RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", "UNION", 
								"WHERE", "WHILE", "WITH", COMMA, RPAREN, SEMI, 
								TK_FOR
							 }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ "WITH" }
							is matched.
							Rule Reference: sql92_tableHint
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ 
									EOF, "BEGIN", "BREAK", "CONTINUE", "CROSS", 
									"DECLARE", "ELSE", "END", "FULL", "GROUP", "IF", 
									"INNER", "JOIN", "LEFT", "ON", "ORDER", "PRINT", 
									"RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", "UNION", 
									"WHERE", "WHILE", COMMA, RPAREN, SEMI, TK_FOR
								 }
							is matched.
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ 
								EOF, "BEGIN", "BREAK", "CONTINUE", "CROSS", 
								"DECLARE", "ELSE", "END", "FULL", "GROUP", "IF", 
								"INNER", "JOIN", "LEFT", "ON", "ORDER", "PRINT", 
								"RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", "UNION", 
								"WHERE", "WHILE", COMMA, RPAREN, SEMI, TK_FOR
							 }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ TK_FOR }
							is matched.
							Rule Reference: oracle_for_update_of_hint
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ 
									EOF, "BEGIN", "BREAK", "CONTINUE", "CROSS", 
									"DECLARE", "ELSE", "END", "FULL", "GROUP", "IF", 
									"INNER", "JOIN", "LEFT", "ON", "ORDER", "PRINT", 
									"RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", "UNION", 
									"WHERE", "WHILE", COMMA, RPAREN, SEMI
								 }
							is matched.
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					k==1: {LPAREN }
					k==2: {"SELECT" }
				is matched.
				Match token LPAREN
				ACTION: ##->setType(DERIVED_TABLE);
				Rule Reference: sql92_selectStatement
				Match token RPAREN
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ "AS", ID }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ "AS" }
							is matched.
							Match token TK_AS
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ ID }
							is matched.
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				Match token ID, label=alias2
				ACTION: #alias2->setType(ALIAS);
				
				Otherwise, Alternate(3) will be taken IF:
				The lookahead set: 
					k==1: {LPAREN }
					k==2: {LPAREN, ID }
				is matched.
				Match token LPAREN
				ACTION: ##->setType(GROUPED_JOIN);
				Rule Reference: sql92_joinedTable
				Match token RPAREN
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "CROSS", 
				"DECLARE", "ELSE", "END", "FULL", "GROUP", "IF", 
				"INNER", "JOIN", "LEFT", "ON", "ORDER", "PRINT", 
				"RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", "UNION", 
				"WHERE", "WHILE", COMMA, RPAREN, SEMI
			 }
	*** End Parser Rule: sql92_tableReference
	
	
	*** Parser Rule: sql92_joinCriteria
		Access: protected
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "ON" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "ON" }
			is matched.
			Match token TK_ON
			Rule Reference: sql92_weakExpression
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "CROSS", 
				"DECLARE", "ELSE", "END", "FULL", "GROUP", "IF", 
				"INNER", "JOIN", "LEFT", "ON", "ORDER", "PRINT", 
				"RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", "UNION", 
				"WHERE", "WHILE", COMMA, RPAREN, SEMI
			 }
	*** End Parser Rule: sql92_joinCriteria
	
	
	*** Parser Rule: sql92_tableHint
		Access: protected
		Return value: none
		Init action: 
		std::string tableHint = "";
		
		Start of an alternative block.
			The lookahead set for this block is:
				{ "WITH" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "WITH" }
			is matched.
			Match token TK_WITH, label=id
			Match token LPAREN
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ "INDEX", ID }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ ID }
						is matched.
						Match token ID
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "INDEX" }
						is matched.
						Match token TK_INDEX
						Match token LPAREN
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ ID, NUM_INT }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ ID }
									is matched.
									Match token ID
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ NUM_INT }
									is matched.
									Match token NUM_INT
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Start ZERO-OR-MORE (...)+ block:
							Start of an alternative block.
								The lookahead set for this block is:
									{ COMMA }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ COMMA }
								is matched.
								Match token COMMA
								Start of alternative block.
									Start of an alternative block.
										The lookahead set for this block is:
											{ ID, NUM_INT }
										This block has multiple alternatives:
											
											Alternate(1) will be taken IF:
											The lookahead set: 
												{ ID }
											is matched.
											Match token ID
											
											Otherwise, Alternate(2) will be taken IF:
											The lookahead set: 
												{ NUM_INT }
											is matched.
											Match token NUM_INT
											
											OTHERWISE, a NoViableAlt exception will be thrown
											
										End of alternatives
									End of alternative block.
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						Match token RPAREN
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ "INDEX", ID }
							This block has multiple alternatives:
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ ID }
								is matched.
								Match token ID
								
								Otherwise, Alternate(2) will be taken IF:
								The lookahead set: 
									{ "INDEX" }
								is matched.
								Match token TK_INDEX
								Match token LPAREN
								Start of alternative block.
									Start of an alternative block.
										The lookahead set for this block is:
											{ ID, NUM_INT }
										This block has multiple alternatives:
											
											Alternate(1) will be taken IF:
											The lookahead set: 
												{ ID }
											is matched.
											Match token ID
											
											Otherwise, Alternate(2) will be taken IF:
											The lookahead set: 
												{ NUM_INT }
											is matched.
											Match token NUM_INT
											
											OTHERWISE, a NoViableAlt exception will be thrown
											
										End of alternatives
									End of alternative block.
								Start ZERO-OR-MORE (...)+ block:
									Start of an alternative block.
										The lookahead set for this block is:
											{ COMMA }
										This block has a single alternative
										
										Alternate(1) will be taken IF:
										The lookahead set: 
											{ COMMA }
										is matched.
										Match token COMMA
										Start of alternative block.
											Start of an alternative block.
												The lookahead set for this block is:
													{ ID, NUM_INT }
												This block has multiple alternatives:
													
													Alternate(1) will be taken IF:
													The lookahead set: 
														{ ID }
													is matched.
													Match token ID
													
													Otherwise, Alternate(2) will be taken IF:
													The lookahead set: 
														{ NUM_INT }
													is matched.
													Match token NUM_INT
													
													OTHERWISE, a NoViableAlt exception will be thrown
													
												End of alternatives
											End of alternative block.
										
										OTHERWISE, a NoViableAlt exception will be thrown
										
									End of alternative block.
								End ZERO-OR-MORE block.
								Match token RPAREN
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternatives
						End of alternative block.
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Match token RPAREN
			ACTION: 
			char buf[512];
			sprintf(buf, "SQL Server style locking hints are not supported on Oracle, ignoring!");
			reportWarning(string(buf));
			
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "CROSS", 
				"DECLARE", "ELSE", "END", "FULL", "GROUP", "IF", 
				"INNER", "JOIN", "LEFT", "ON", "ORDER", "PRINT", 
				"RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", "UNION", 
				"WHERE", "WHILE", COMMA, RPAREN, SEMI, TK_FOR
			 }
	*** End Parser Rule: sql92_tableHint
	
	
	*** Parser Rule: oracle_for_update_of_hint
		Access: protected
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ TK_FOR }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ TK_FOR }
			is matched.
			Match token TK_FOR
			Match token TK_UPDATE
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							EOF, "BEGIN", "BREAK", "CONTINUE", "CROSS", 
							"DECLARE", "ELSE", "END", "FULL", "GROUP", "IF", 
							"INNER", "JOIN", "LEFT", "ON", "ORDER", "PRINT", 
							"RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", "UNION", 
							"WHERE", "WHILE", COMMA, RPAREN, SEMI, TK_OF
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ TK_OF }
						is matched.
						Match token TK_OF
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ 
								EOF, "BEGIN", "BREAK", "CONTINUE", "CROSS", 
								"DECLARE", "ELSE", "END", "FULL", "GROUP", "IF", 
								"INNER", "JOIN", "LEFT", "ON", "ORDER", "PRINT", 
								"RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", "UNION", 
								"WHERE", "WHILE", COMMA, RPAREN, SEMI
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "CROSS", 
				"DECLARE", "ELSE", "END", "FULL", "GROUP", "IF", 
				"INNER", "JOIN", "LEFT", "ON", "ORDER", "PRINT", 
				"RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", "UNION", 
				"WHERE", "WHILE", COMMA, RPAREN, SEMI
			 }
	*** End Parser Rule: oracle_for_update_of_hint
	
	
	*** Parser Rule: sql92_selectStatement
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "SELECT" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "SELECT" }
			is matched.
			Rule Reference: sql92_queryExpression
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ "UNION" }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ "UNION" }
					is matched.
					Match token TK_UNION
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ "ALL", "SELECT" }
							This block has multiple alternatives:
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ "ALL" }
								is matched.
								Match token TK_ALL
								
								Otherwise, Alternate(2) will be taken IF:
								The lookahead set: 
									{ "SELECT" }
								is matched.
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternatives
						End of alternative block.
					Rule Reference: sql92_queryExpression
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
							"ELSE", "END", "IF", "ORDER", "PRINT", "RAISERROR", 
							"RETURN", "SELECT", "SET", "WHILE", RPAREN, SEMI
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "ORDER" }
						is matched.
						Match token TK_ORDER
						Match token TK_BY
						Rule Reference: sql92_orderByExpression
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ 
								EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
								"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
								"SELECT", "SET", "WHILE", RPAREN, SEMI
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
				"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
				"SELECT", "SET", "WHILE", RPAREN, SEMI
			 }
	*** End Parser Rule: sql92_selectStatement
	
	
	*** Parser Rule: program
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "CREATE" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "CREATE" }
			is matched.
			Match token TK_CREATE
			Match token TK_PROCEDURE
			Match token ID
			Rule Reference: programArgList
			Match token TK_AS
			Rule Reference: statementList
			Match token EOF
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {EOF }
	*** End Parser Rule: program
	
	
	*** Parser Rule: programArgList
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "AS", LOCALVAR }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "AS", LOCALVAR }
			is matched.
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ LOCALVAR }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ LOCALVAR }
					is matched.
					Rule Reference: programArgDecl
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ "AS", COMMA, LOCALVAR }
							This block has multiple alternatives:
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ COMMA }
								is matched.
								Match token COMMA
								
								Otherwise, Alternate(2) will be taken IF:
								The lookahead set: 
									{ "AS", LOCALVAR }
								is matched.
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternatives
						End of alternative block.
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {"AS" }
	*** End Parser Rule: programArgList
	
	
	*** Parser Rule: statementList
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
					"IF", "PRINT", "RAISERROR", "RETURN", "SELECT", "SET", 
					"WHILE"
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
					"IF", "PRINT", "RAISERROR", "RETURN", "SELECT", "SET", 
					"WHILE"
				 }
			is matched.
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							"BEGIN", "BREAK", "CONTINUE", "DECLARE", "IF", 
							"PRINT", "RAISERROR", "RETURN", "SELECT", "SET", "WHILE"
						 }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ 
							"BEGIN", "BREAK", "CONTINUE", "DECLARE", "IF", 
							"PRINT", "RAISERROR", "RETURN", "SELECT", "SET", "WHILE"
						 }
					is matched.
					Rule Reference: statement
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			ACTION: ## = #([SCOPE, "SCOPE"], ##);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {EOF }
	*** End Parser Rule: statementList
	
	
	*** Parser Rule: programArgDecl
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ LOCALVAR }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LOCALVAR }
			is matched.
			Match token LOCALVAR, label=lv
			Rule Reference: builtInType
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ "AS", "OUTPUT", COMMA, LOCALVAR }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "OUTPUT" }
						is matched.
						Match token TK_OUTPUT, label=ou
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "AS", COMMA, LOCALVAR }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: ## = #([TK_DECLARE, "DECLARE"], lv, bit, ou);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {"AS", COMMA, LOCALVAR }
	*** End Parser Rule: programArgDecl
	
	
	*** Parser Rule: builtInType
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"BIGINT", "BOOLEAN", "DATETIME", "DECIMAL", "DOUBLE", 
					"ENUM", "INTEGER", "NVARCHAR", "TIME", "VARCHAR"
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"BIGINT", "BOOLEAN", "DATETIME", "DECIMAL", "DOUBLE", 
					"ENUM", "INTEGER", "NVARCHAR", "TIME", "VARCHAR"
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							"BIGINT", "BOOLEAN", "DATETIME", "DECIMAL", "DOUBLE", 
							"ENUM", "INTEGER", "NVARCHAR", "TIME", "VARCHAR"
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "INTEGER" }
						is matched.
						Match token TK_INTEGER, label=i
						ACTION: #i->setType(BUILTIN_TYPE);
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "DOUBLE" }
						is matched.
						Match token TK_DOUBLE, label=dbl
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										EOF, "AS", "BEGIN", "BREAK", "CONTINUE", 
										"DECLARE", "ELSE", "END", "IF", "OUTPUT", "PRECISION", 
										"PRINT", "RAISERROR", "RETURN", "SELECT", "SET", "WHILE", 
										COMMA, RPAREN, SEMI, LOCALVAR
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ "PRECISION" }
									is matched.
									Match token TK_PRECISION
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ 
											EOF, "AS", "BEGIN", "BREAK", "CONTINUE", 
											"DECLARE", "ELSE", "END", "IF", "OUTPUT", "PRINT", 
											"RAISERROR", "RETURN", "SELECT", "SET", "WHILE", COMMA, 
											RPAREN, SEMI, LOCALVAR
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						ACTION: #dbl->setType(BUILTIN_TYPE);
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ "VARCHAR" }
						is matched.
						Match token TK_VARCHAR, label=str
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										EOF, "AS", "BEGIN", "BREAK", "CONTINUE", 
										"DECLARE", "ELSE", "END", "IF", "OUTPUT", "PRINT", 
										"RAISERROR", "RETURN", "SELECT", "SET", "WHILE", COMMA, 
										LPAREN, RPAREN, SEMI, LOCALVAR
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ LPAREN }
									is matched.
									Match token LPAREN
									Match token NUM_INT
									Match token RPAREN
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ 
											EOF, "AS", "BEGIN", "BREAK", "CONTINUE", 
											"DECLARE", "ELSE", "END", "IF", "OUTPUT", "PRINT", 
											"RAISERROR", "RETURN", "SELECT", "SET", "WHILE", COMMA, 
											RPAREN, SEMI, LOCALVAR
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						ACTION: #str->setType(BUILTIN_TYPE);
						
						Otherwise, Alternate(4) will be taken IF:
						The lookahead set: 
							{ "NVARCHAR" }
						is matched.
						Match token TK_NVARCHAR, label=wstr
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										EOF, "AS", "BEGIN", "BREAK", "CONTINUE", 
										"DECLARE", "ELSE", "END", "IF", "OUTPUT", "PRINT", 
										"RAISERROR", "RETURN", "SELECT", "SET", "WHILE", COMMA, 
										LPAREN, RPAREN, SEMI, LOCALVAR
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ LPAREN }
									is matched.
									Match token LPAREN
									Match token NUM_INT
									Match token RPAREN
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ 
											EOF, "AS", "BEGIN", "BREAK", "CONTINUE", 
											"DECLARE", "ELSE", "END", "IF", "OUTPUT", "PRINT", 
											"RAISERROR", "RETURN", "SELECT", "SET", "WHILE", COMMA, 
											RPAREN, SEMI, LOCALVAR
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						ACTION: #wstr->setType(BUILTIN_TYPE);
						
						Otherwise, Alternate(5) will be taken IF:
						The lookahead set: 
							{ "DECIMAL" }
						is matched.
						Match token TK_DECIMAL, label=dec
						ACTION: #dec->setType(BUILTIN_TYPE);
						
						Otherwise, Alternate(6) will be taken IF:
						The lookahead set: 
							{ "BOOLEAN" }
						is matched.
						Match token TK_BOOLEAN, label=b
						ACTION: #b->setType(BUILTIN_TYPE);
						
						Otherwise, Alternate(7) will be taken IF:
						The lookahead set: 
							{ "DATETIME" }
						is matched.
						Match token TK_DATETIME, label=dt
						ACTION: #dt->setType(BUILTIN_TYPE);
						
						Otherwise, Alternate(8) will be taken IF:
						The lookahead set: 
							{ "TIME" }
						is matched.
						Match token TK_TIME, label=tm
						ACTION: #tm->setType(BUILTIN_TYPE);
						
						Otherwise, Alternate(9) will be taken IF:
						The lookahead set: 
							{ "ENUM" }
						is matched.
						Match token TK_ENUM, label=en
						ACTION: #en->setType(BUILTIN_TYPE);
						
						Otherwise, Alternate(10) will be taken IF:
						The lookahead set: 
							{ "BIGINT" }
						is matched.
						Match token TK_BIGINT, label=bi
						ACTION: #bi->setType(BUILTIN_TYPE);
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AS", "BEGIN", "BREAK", "CONTINUE", 
				"DECLARE", "ELSE", "END", "IF", "OUTPUT", "PRINT", 
				"RAISERROR", "RETURN", "SELECT", "SET", "WHILE", COMMA, 
				RPAREN, SEMI, LOCALVAR
			 }
	*** End Parser Rule: builtInType
	
	
	*** Parser Rule: statement
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"BEGIN", "BREAK", "CONTINUE", "DECLARE", "IF", 
					"PRINT", "RAISERROR", "RETURN", "SELECT", "SET", "WHILE"
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"BEGIN", "BREAK", "CONTINUE", "DECLARE", "IF", 
					"PRINT", "RAISERROR", "RETURN", "SELECT", "SET", "WHILE"
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							"BEGIN", "BREAK", "CONTINUE", "DECLARE", "IF", 
							"PRINT", "RAISERROR", "RETURN", "SELECT", "SET", "WHILE"
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "SET" }
						is matched.
						Rule Reference: setStatement
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
										"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
										"SELECT", "SET", "WHILE", SEMI
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ SEMI }
									is matched.
									Match token SEMI
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ 
											EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
											"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
											"SELECT", "SET", "WHILE"
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "DECLARE" }
						is matched.
						Rule Reference: variableDeclaration
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
										"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
										"SELECT", "SET", "WHILE", SEMI
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ SEMI }
									is matched.
									Match token SEMI
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ 
											EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
											"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
											"SELECT", "SET", "WHILE"
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ "PRINT" }
						is matched.
						Rule Reference: printStatement
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
										"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
										"SELECT", "SET", "WHILE", SEMI
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ SEMI }
									is matched.
									Match token SEMI
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ 
											EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
											"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
											"SELECT", "SET", "WHILE"
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						
						Otherwise, Alternate(4) will be taken IF:
						The lookahead set: 
							{ "IF" }
						is matched.
						Rule Reference: ifStatement
						
						Otherwise, Alternate(5) will be taken IF:
						The lookahead set: 
							{ "BEGIN" }
						is matched.
						Rule Reference: statementBlock
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
										"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
										"SELECT", "SET", "WHILE", SEMI
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ SEMI }
									is matched.
									Match token SEMI
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ 
											EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
											"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
											"SELECT", "SET", "WHILE"
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						
						Otherwise, Alternate(6) will be taken IF:
						The lookahead set: 
							{ "RETURN" }
						is matched.
						Match token TK_RETURN
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										EOF, "BEGIN", "BREAK", "CASE", "CAST", 
										"CONTINUE", "DECLARE", "ELSE", "END", "FALSE", "IF", 
										"NOT", "NULL", "PRINT", "RAISERROR", "RETURN", "SELECT", 
										"SET", "TRUE", "WHILE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, 
										LPAREN, MINUS, PLUS, SEMI, STRING_LITERAL, ENUM_LITERAL, 
										WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ 
											"CASE", "CAST", "FALSE", "NOT", "NULL", 
											"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
											PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
											LOCALVAR, NUM_INT
										 }
									is matched.
									Rule Reference: expression
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ 
											EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
											"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
											"SELECT", "SET", "WHILE", SEMI
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
										"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
										"SELECT", "SET", "WHILE", SEMI
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ SEMI }
									is matched.
									Match token SEMI
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ 
											EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
											"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
											"SELECT", "SET", "WHILE"
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						
						Otherwise, Alternate(7) will be taken IF:
						The lookahead set: 
							{ "BREAK" }
						is matched.
						Match token TK_BREAK
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
										"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
										"SELECT", "SET", "WHILE", SEMI
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ SEMI }
									is matched.
									Match token SEMI
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ 
											EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
											"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
											"SELECT", "SET", "WHILE"
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						
						Otherwise, Alternate(8) will be taken IF:
						The lookahead set: 
							{ "CONTINUE" }
						is matched.
						Match token TK_CONTINUE
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
										"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
										"SELECT", "SET", "WHILE", SEMI
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ SEMI }
									is matched.
									Match token SEMI
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ 
											EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
											"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
											"SELECT", "SET", "WHILE"
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						
						Otherwise, Alternate(9) will be taken IF:
						The lookahead set: 
							{ "RAISERROR" }
						is matched.
						Match token TK_RAISERROR
						Match token LPAREN
						Rule Reference: expression
						ACTION: ##->setType(RAISERROR1);
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ COMMA, RPAREN }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ COMMA }
									is matched.
									Match token COMMA
									Rule Reference: expression
									ACTION: ##->setType(RAISERROR2);
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ RPAREN }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Match token RPAREN
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
										"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
										"SELECT", "SET", "WHILE", SEMI
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ SEMI }
									is matched.
									Match token SEMI
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ 
											EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
											"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
											"SELECT", "SET", "WHILE"
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						
						Otherwise, Alternate(10) will be taken IF:
						The lookahead set: 
							{ "WHILE" }
						is matched.
						Rule Reference: whileStatement
						
						Otherwise, Alternate(11) will be taken IF:
						The lookahead set: 
							{ "SELECT" }
						is matched.
						Rule Reference: sql92_selectStatement
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
										"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
										"SELECT", "SET", "WHILE", SEMI
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ SEMI }
									is matched.
									Match token SEMI
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ 
											EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
											"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
											"SELECT", "SET", "WHILE"
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
				"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
				"SELECT", "SET", "WHILE"
			 }
	*** End Parser Rule: statement
	
	
	*** Parser Rule: setStatement
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "SET" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "SET" }
			is matched.
			Match token TK_SET, label=set
			ACTION: #set->setType(ASSIGN);
			Match token LOCALVAR
			Match token EQUALS
			Rule Reference: expression
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
				"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
				"SELECT", "SET", "WHILE", SEMI
			 }
	*** End Parser Rule: setStatement
	
	
	*** Parser Rule: variableDeclaration
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "DECLARE" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "DECLARE" }
			is matched.
			Match token TK_DECLARE
			Match token LOCALVAR
			Rule Reference: builtInType
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
				"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
				"SELECT", "SET", "WHILE", SEMI
			 }
	*** End Parser Rule: variableDeclaration
	
	
	*** Parser Rule: printStatement
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "PRINT" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "PRINT" }
			is matched.
			Match token TK_PRINT
			Rule Reference: expression
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
				"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
				"SELECT", "SET", "WHILE", SEMI
			 }
	*** End Parser Rule: printStatement
	
	
	*** Parser Rule: ifStatement
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "IF" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "IF" }
			is matched.
			Match token TK_IF, label=i
			ACTION: #i->setType(IFTHENELSE);
			Rule Reference: expression
			Rule Reference: delayedStatement
			Start of alternative block.
				Warning: This alternative block is non-deterministic
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {
							EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
							"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
							"SELECT", "SET", "WHILE"
						 }
						k==2: {
							EOF, "ALL", "AVG", "BEGIN", "BREAK", 
							"CASE", "CAST", "CONTINUE", "COUNT", "DECLARE", "DISTINCT", 
							"ELSE", "END", "EXISTS", "FALSE", "IF", "MAX", 
							"MIN", "NOT", "NULL", "PRINT", "RAISERROR", "RETURN", 
							"SELECT", "SET", "SUM", "TRUE", "WHILE", NUM_DECIMAL, 
							NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, SEMI, 
							STAR, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
							LOCALVAR, NUM_INT
						 }
						k==3: {
							EOF, "AND", "ALL", "AS", "AVG", 
							"BEGIN", "BETWEEN", "BIGINT", "BOOLEAN", "BREAK", "CASE", 
							"CAST", "CONTINUE", "COUNT", "DATETIME", "DECLARE", "DECIMAL", 
							"DISTINCT", "DOUBLE", "ELSE", "END", "ENUM", "EXISTS", 
							"FALSE", "FROM", "IF", "IN", "INTO", "INTEGER", 
							"IS", "LIKE", "MAX", "MIN", "NOT", "NULL", 
							"NVARCHAR", "OR", "PRINT", "RAISERROR", "RETURN", "SELECT", 
							"SET", "SUM", "TIME", "TRUE", "VARCHAR", "WHEN", 
							"WHILE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, AMPERSAND, EQUALS, 
							NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, GTEQ, 
							MODULO, CARET, COMMA, DOT, LPAREN, MINUS, 
							PIPE, PLUS, SEMI, SLASH, STAR, STRING_LITERAL, 
							ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							k==1: {"ELSE" }
							k==2: {
								"BEGIN", "BREAK", "CONTINUE", "DECLARE", "IF", 
								"PRINT", "RAISERROR", "RETURN", "SELECT", "SET", "WHILE"
							 }
							k==3: {
								EOF, "ALL", "AVG", "BEGIN", "BREAK", 
								"CASE", "CAST", "CONTINUE", "COUNT", "DECLARE", "DISTINCT", 
								"ELSE", "END", "EXISTS", "FALSE", "IF", "MAX", 
								"MIN", "NOT", "NULL", "PRINT", "RAISERROR", "RETURN", 
								"SELECT", "SET", "SUM", "TRUE", "WHILE", NUM_DECIMAL, 
								NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, SEMI, 
								STAR, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
								LOCALVAR, NUM_INT
							 }
						is matched.
						Match token TK_ELSE
						Rule Reference: delayedStatement
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							k==1: {
								EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
								"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
								"SELECT", "SET", "WHILE"
							 }
							k==2: {
								EOF, "ALL", "AVG", "BEGIN", "BREAK", 
								"CASE", "CAST", "CONTINUE", "COUNT", "DECLARE", "DISTINCT", 
								"ELSE", "END", "EXISTS", "FALSE", "IF", "MAX", 
								"MIN", "NOT", "NULL", "PRINT", "RAISERROR", "RETURN", 
								"SELECT", "SET", "SUM", "TRUE", "WHILE", NUM_DECIMAL, 
								NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, SEMI, 
								STAR, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
								LOCALVAR, NUM_INT
							 }
							k==3: {
								EOF, "AND", "ALL", "AS", "AVG", 
								"BEGIN", "BETWEEN", "BIGINT", "BOOLEAN", "BREAK", "CASE", 
								"CAST", "CONTINUE", "COUNT", "DATETIME", "DECLARE", "DECIMAL", 
								"DISTINCT", "DOUBLE", "ELSE", "END", "ENUM", "EXISTS", 
								"FALSE", "FROM", "IF", "IN", "INTO", "INTEGER", 
								"IS", "LIKE", "MAX", "MIN", "NOT", "NULL", 
								"NVARCHAR", "OR", "PRINT", "RAISERROR", "RETURN", "SELECT", 
								"SET", "SUM", "TIME", "TRUE", "VARCHAR", "WHEN", 
								"WHILE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, AMPERSAND, EQUALS, 
								NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, GTEQ, 
								MODULO, CARET, COMMA, DOT, LPAREN, MINUS, 
								PIPE, PLUS, SEMI, SLASH, STAR, STRING_LITERAL, 
								ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
				"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
				"SELECT", "SET", "WHILE"
			 }
	*** End Parser Rule: ifStatement
	
	
	*** Parser Rule: statementBlock
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "BEGIN" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "BEGIN" }
			is matched.
			Match token TK_BEGIN, label=b
			ACTION: #b->setType(SLIST);
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							"BEGIN", "BREAK", "CONTINUE", "DECLARE", "IF", 
							"PRINT", "RAISERROR", "RETURN", "SELECT", "SET", "WHILE"
						 }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ 
							"BEGIN", "BREAK", "CONTINUE", "DECLARE", "IF", 
							"PRINT", "RAISERROR", "RETURN", "SELECT", "SET", "WHILE"
						 }
					is matched.
					Rule Reference: statement
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Match token TK_END
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
				"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
				"SELECT", "SET", "WHILE", SEMI
			 }
	*** End Parser Rule: statementBlock
	
	
	*** Parser Rule: expression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"CASE", "CAST", "FALSE", "NOT", "NULL", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"CASE", "CAST", "FALSE", "NOT", "NULL", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							"CASE", "CAST", "FALSE", "NOT", "NULL", 
							"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
							PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
							LOCALVAR, NUM_INT
						 }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ 
							"CASE", "CAST", "FALSE", "NOT", "NULL", 
							"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
							PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
							LOCALVAR, NUM_INT
						 }
					is matched.
					Rule Reference: weakExpression
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			ACTION: #expression = #(#[EXPR, "EXPR"], #expression);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AS", "BEGIN", "BREAK", "CONTINUE", 
				"DECLARE", "ELSE", "END", "IF", "PRINT", "RAISERROR", 
				"RETURN", "SELECT", "SET", "WHILE", COMMA, RPAREN, 
				SEMI
			 }
	*** End Parser Rule: expression
	
	
	*** Parser Rule: whileStatement
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "WHILE" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "WHILE" }
			is matched.
			Match token TK_WHILE, label=w
			ACTION: #w->setType(WHILE);
			Rule Reference: expression
			Rule Reference: delayedStatement
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
				"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
				"SELECT", "SET", "WHILE"
			 }
	*** End Parser Rule: whileStatement
	
	
	*** Parser Rule: localQueryVarList
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ LOCALVAR }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LOCALVAR }
			is matched.
			Rule Reference: localQueryVar
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: localQueryVar
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			ACTION: ## = #([ARRAY, "ARRAY"], ##);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {EOF }
	*** End Parser Rule: localQueryVarList
	
	
	*** Parser Rule: localQueryVar
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ LOCALVAR }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LOCALVAR }
			is matched.
			Match token LOCALVAR, label=lv
			ACTION: ## = #([ASSIGN_QUERY, "ASSIGN_QUERY"], ##);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {EOF, COMMA }
	*** End Parser Rule: localQueryVar
	
	
	*** Parser Rule: foo
		Access: protected
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					EOF, "AND", "ALL", "ANY", "AS", 
					"ASC", "AVG", "BETWEEN", "BIGINT", "BOOLEAN", "BY", 
					"CASE", "CAST", "CHAR", "COUNT", "CREATE", "CROSS", 
					"DATETIME", "DECIMAL", "DESC", "DISTINCT", "DOUBLE", "ENUM", 
					"EXISTS", "FALSE", "FROM", "FULL", "GROUP", "HAVING", 
					"IN", "INDEX", "INNER", "INTO", "INTEGER", "IS", 
					"JOIN", "KEY", "LEFT", "LIKE", "MAX", "MIN", 
					"NOT", "NULL", "NVARCHAR", "ON", "OR", "ORDER", 
					"OUTER", "OUTPUT", "PRECISION", "PROCEDURE", "RIGHT", "SOME", 
					"SUM", "THEN", "TIME", "TRUE", "UNION", "VARCHAR", 
					"WHEN", "WHERE", "WITH", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, 
					AMPERSAND, EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, 
					GT, GTEQ, MODULO, SL_COMMENT, ML_COMMENT, CARET, 
					COMMA, DOT, LPAREN, RPAREN, MINUS, PIPE, 
					PLUS, SLASH, STAR, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, 
					TILDE, WS, ID, NUM_INT, EXPONENT, FLOAT_SUFFIX, 
					BIGINT_SUFFIX, HEX_DIGIT, ALIAS, ARRAY, ASSIGN, ASSIGN_QUERY, 
					BAND, BNOT, BOR, BXOR, BUILTIN_TYPE, CROSS_JOIN, 
					DELAYED_STMT, DERIVED_TABLE, DIVIDE, ELIST, EXPR, GROUPED_JOIN, 
					IDENT, IFTHENELSE, ISNULL, LAND, LNOT, LOR, 
					METHOD_CALL, MODULUS, QUERY, QUERYPARAM, QUERYSTRING, RAISERROR1, 
					RAISERROR2, SCALAR_SUBQUERY, SCOPE, SEARCHED_CASE, SELECT_LIST, SIMPLE_CASE, 
					SIMPLE_WHEN, SLIST, TABLE_REF, TIMES, UNARY_MINUS, UNARY_PLUS, 
					WHILE, TK_FOR, TK_UPDATE, TK_OF
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					EOF, "AND", "ALL", "ANY", "AS", 
					"ASC", "AVG", "BETWEEN", "BIGINT", "BOOLEAN", "BY", 
					"CASE", "CAST", "CHAR", "COUNT", "CREATE", "CROSS", 
					"DATETIME", "DECIMAL", "DESC", "DISTINCT", "DOUBLE", "ENUM", 
					"EXISTS", "FALSE", "FROM", "FULL", "GROUP", "HAVING", 
					"IN", "INDEX", "INNER", "INTO", "INTEGER", "IS", 
					"JOIN", "KEY", "LEFT", "LIKE", "MAX", "MIN", 
					"NOT", "NULL", "NVARCHAR", "ON", "OR", "ORDER", 
					"OUTER", "OUTPUT", "PRECISION", "PROCEDURE", "RIGHT", "SOME", 
					"SUM", "THEN", "TIME", "TRUE", "UNION", "VARCHAR", 
					"WHEN", "WHERE", "WITH", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, 
					AMPERSAND, EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, 
					GT, GTEQ, MODULO, SL_COMMENT, ML_COMMENT, CARET, 
					COMMA, DOT, LPAREN, RPAREN, MINUS, PIPE, 
					PLUS, SLASH, STAR, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, 
					TILDE, WS, ID, NUM_INT, EXPONENT, FLOAT_SUFFIX, 
					BIGINT_SUFFIX, HEX_DIGIT, ALIAS, ARRAY, ASSIGN, ASSIGN_QUERY, 
					BAND, BNOT, BOR, BXOR, BUILTIN_TYPE, CROSS_JOIN, 
					DELAYED_STMT, DERIVED_TABLE, DIVIDE, ELIST, EXPR, GROUPED_JOIN, 
					IDENT, IFTHENELSE, ISNULL, LAND, LNOT, LOR, 
					METHOD_CALL, MODULUS, QUERY, QUERYPARAM, QUERYSTRING, RAISERROR1, 
					RAISERROR2, SCALAR_SUBQUERY, SCOPE, SEARCHED_CASE, SELECT_LIST, SIMPLE_CASE, 
					SIMPLE_WHEN, SLIST, TABLE_REF, TIMES, UNARY_MINUS, UNARY_PLUS, 
					WHILE, TK_FOR, TK_UPDATE, TK_OF
				 }
			is matched.
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							"AND", "ALL", "ANY", "AS", "ASC", 
							"AVG", "BETWEEN", "BIGINT", "BOOLEAN", "BY", "CASE", 
							"CAST", "CHAR", "COUNT", "CREATE", "CROSS", "DATETIME", 
							"DECIMAL", "DESC", "DISTINCT", "DOUBLE", "ENUM", "EXISTS", 
							"FALSE", "FROM", "FULL", "GROUP", "HAVING", "IN", 
							"INDEX", "INNER", "INTO", "INTEGER", "IS", "JOIN", 
							"KEY", "LEFT", "LIKE", "MAX", "MIN", "NOT", 
							"NULL", "NVARCHAR", "ON", "OR", "ORDER", "OUTER", 
							"OUTPUT", "PRECISION", "PROCEDURE", "RIGHT", "SOME", "SUM", 
							"THEN", "TIME", "TRUE", "UNION", "VARCHAR", "WHEN", 
							"WHERE", "WITH", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, AMPERSAND, 
							EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, 
							GTEQ, MODULO, SL_COMMENT, ML_COMMENT, CARET, COMMA, 
							DOT, LPAREN, RPAREN, MINUS, PIPE, PLUS, 
							SLASH, STAR, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, 
							WS, ID, NUM_INT, EXPONENT, FLOAT_SUFFIX, BIGINT_SUFFIX, 
							HEX_DIGIT, ALIAS, ARRAY, ASSIGN, ASSIGN_QUERY, BAND, 
							BNOT, BOR, BXOR, BUILTIN_TYPE, CROSS_JOIN, DELAYED_STMT, 
							DERIVED_TABLE, DIVIDE, ELIST, EXPR, GROUPED_JOIN, IDENT, 
							IFTHENELSE, ISNULL, LAND, LNOT, LOR, METHOD_CALL, 
							MODULUS, QUERY, QUERYPARAM, QUERYSTRING, RAISERROR1, RAISERROR2, 
							SCALAR_SUBQUERY, SCOPE, SEARCHED_CASE, SELECT_LIST, SIMPLE_CASE, SIMPLE_WHEN, 
							SLIST, TABLE_REF, TIMES, UNARY_MINUS, UNARY_PLUS, WHILE, 
							TK_FOR, TK_UPDATE, TK_OF
						 }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ 
							"AND", "ALL", "ANY", "AS", "ASC", 
							"AVG", "BETWEEN", "BIGINT", "BOOLEAN", "BY", "CASE", 
							"CAST", "CHAR", "COUNT", "CREATE", "CROSS", "DATETIME", 
							"DECIMAL", "DESC", "DISTINCT", "DOUBLE", "ENUM", "EXISTS", 
							"FALSE", "FROM", "FULL", "GROUP", "HAVING", "IN", 
							"INDEX", "INNER", "INTO", "INTEGER", "IS", "JOIN", 
							"KEY", "LEFT", "LIKE", "MAX", "MIN", "NOT", 
							"NULL", "NVARCHAR", "ON", "OR", "ORDER", "OUTER", 
							"OUTPUT", "PRECISION", "PROCEDURE", "RIGHT", "SOME", "SUM", 
							"THEN", "TIME", "TRUE", "UNION", "VARCHAR", "WHEN", 
							"WHERE", "WITH", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, AMPERSAND, 
							EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, 
							GTEQ, MODULO, SL_COMMENT, ML_COMMENT, CARET, COMMA, 
							DOT, LPAREN, RPAREN, MINUS, PIPE, PLUS, 
							SLASH, STAR, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, 
							WS, ID, NUM_INT, EXPONENT, FLOAT_SUFFIX, BIGINT_SUFFIX, 
							HEX_DIGIT, ALIAS, ARRAY, ASSIGN, ASSIGN_QUERY, BAND, 
							BNOT, BOR, BXOR, BUILTIN_TYPE, CROSS_JOIN, DELAYED_STMT, 
							DERIVED_TABLE, DIVIDE, ELIST, EXPR, GROUPED_JOIN, IDENT, 
							IFTHENELSE, ISNULL, LAND, LNOT, LOR, METHOD_CALL, 
							MODULUS, QUERY, QUERYPARAM, QUERYSTRING, RAISERROR1, RAISERROR2, 
							SCALAR_SUBQUERY, SCOPE, SEARCHED_CASE, SELECT_LIST, SIMPLE_CASE, SIMPLE_WHEN, 
							SLIST, TABLE_REF, TIMES, UNARY_MINUS, UNARY_PLUS, WHILE, 
							TK_FOR, TK_UPDATE, TK_OF
						 }
					is matched.
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ 
									"AND", "ALL", "ANY", "AS", "ASC", 
									"AVG", "BETWEEN", "BIGINT", "BOOLEAN", "BY", "CASE", 
									"CAST", "CHAR", "COUNT", "CREATE", "CROSS", "DATETIME", 
									"DECIMAL", "DESC", "DISTINCT", "DOUBLE", "ENUM", "EXISTS", 
									"FALSE", "FROM", "FULL", "GROUP", "HAVING", "IN", 
									"INDEX", "INNER", "INTO", "INTEGER", "IS", "JOIN", 
									"KEY", "LEFT", "LIKE", "MAX", "MIN", "NOT", 
									"NULL", "NVARCHAR", "ON", "OR", "ORDER", "OUTER", 
									"OUTPUT", "PRECISION", "PROCEDURE", "RIGHT", "SOME", "SUM", 
									"THEN", "TIME", "TRUE", "UNION", "VARCHAR", "WHEN", 
									"WHERE", "WITH", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, AMPERSAND, 
									EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, 
									GTEQ, MODULO, SL_COMMENT, ML_COMMENT, CARET, COMMA, 
									DOT, LPAREN, RPAREN, MINUS, PIPE, PLUS, 
									SLASH, STAR, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, 
									WS, ID, NUM_INT, EXPONENT, FLOAT_SUFFIX, BIGINT_SUFFIX, 
									HEX_DIGIT, ALIAS, ARRAY, ASSIGN, ASSIGN_QUERY, BAND, 
									BNOT, BOR, BXOR, BUILTIN_TYPE, CROSS_JOIN, DELAYED_STMT, 
									DERIVED_TABLE, DIVIDE, ELIST, EXPR, GROUPED_JOIN, IDENT, 
									IFTHENELSE, ISNULL, LAND, LNOT, LOR, METHOD_CALL, 
									MODULUS, QUERY, QUERYPARAM, QUERYSTRING, RAISERROR1, RAISERROR2, 
									SCALAR_SUBQUERY, SCOPE, SEARCHED_CASE, SELECT_LIST, SIMPLE_CASE, SIMPLE_WHEN, 
									SLIST, TABLE_REF, TIMES, UNARY_MINUS, UNARY_PLUS, WHILE, 
									TK_FOR, TK_UPDATE, TK_OF
								 }
							This block has multiple alternatives:
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ LOCALVAR }
								is matched.
								Match token LOCALVAR
								
								Otherwise, Alternate(2) will be taken IF:
								The lookahead set: 
									{ "SET" }
								is matched.
								Match token TK_SET
								
								Otherwise, Alternate(3) will be taken IF:
								The lookahead set: 
									{ "SELECT" }
								is matched.
								Match token TK_SELECT
								
								Otherwise, Alternate(4) will be taken IF:
								The lookahead set: 
									{ "PRINT" }
								is matched.
								Match token TK_PRINT
								
								Otherwise, Alternate(5) will be taken IF:
								The lookahead set: 
									{ "DECLARE" }
								is matched.
								Match token TK_DECLARE
								
								Otherwise, Alternate(6) will be taken IF:
								The lookahead set: 
									{ "IF" }
								is matched.
								Match token TK_IF
								
								Otherwise, Alternate(7) will be taken IF:
								The lookahead set: 
									{ "BEGIN" }
								is matched.
								Match token TK_BEGIN
								
								Otherwise, Alternate(8) will be taken IF:
								The lookahead set: 
									{ "END" }
								is matched.
								Match token TK_END
								
								Otherwise, Alternate(9) will be taken IF:
								The lookahead set: 
									{ "ELSE" }
								is matched.
								Match token TK_ELSE
								
								Otherwise, Alternate(10) will be taken IF:
								The lookahead set: 
									{ "RETURN" }
								is matched.
								Match token TK_RETURN
								
								Otherwise, Alternate(11) will be taken IF:
								The lookahead set: 
									{ "BREAK" }
								is matched.
								Match token TK_BREAK
								
								Otherwise, Alternate(12) will be taken IF:
								The lookahead set: 
									{ "CONTINUE" }
								is matched.
								Match token TK_CONTINUE
								
								Otherwise, Alternate(13) will be taken IF:
								The lookahead set: 
									{ "WHILE" }
								is matched.
								Match token TK_WHILE
								
								Otherwise, Alternate(14) will be taken IF:
								The lookahead set: 
									{ "RAISERROR" }
								is matched.
								Match token TK_RAISERROR
								
								Otherwise, Alternate(15) will be taken IF:
								The lookahead set: 
									{ SEMI }
								is matched.
								Match token SEMI
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternatives
						End of alternative block.
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {EOF }
	*** End Parser Rule: foo
	
	
	*** Parser Rule: delayedStatement
		Access: protected
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"BEGIN", "BREAK", "CONTINUE", "DECLARE", "IF", 
					"PRINT", "RAISERROR", "RETURN", "SELECT", "SET", "WHILE"
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"BEGIN", "BREAK", "CONTINUE", "DECLARE", "IF", 
					"PRINT", "RAISERROR", "RETURN", "SELECT", "SET", "WHILE"
				 }
			is matched.
			Rule Reference: statement
			ACTION: ## = #([DELAYED_STMT, "DELAYED_STMT"], ##);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
				"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
				"SELECT", "SET", "WHILE"
			 }
	*** End Parser Rule: delayedStatement
	
	
	*** Parser Rule: weakExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"CASE", "CAST", "FALSE", "NOT", "NULL", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"CASE", "CAST", "FALSE", "NOT", "NULL", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			is matched.
			Rule Reference: conjunctiveExpression
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ "OR" }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ "OR" }
					is matched.
					Match token TK_OR, label=lor
					ACTION: 
										#lor->setType(LOR); 
									
					Rule Reference: conjunctiveExpression
					ACTION: 
										// Put an EXPR on top of rhs to allow runtime optimization of deferred execution
										// when lhs is true
										#conj = #([EXPR, "EXPR"], conj); 
										astFactory.addASTChild(currentAST, #conj);
									
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AS", "BEGIN", "BREAK", "CONTINUE", 
				"DECLARE", "ELSE", "END", "IF", "PRINT", "RAISERROR", 
				"RETURN", "SELECT", "SET", "THEN", "WHEN", "WHILE", 
				COMMA, RPAREN, SEMI
			 }
	*** End Parser Rule: weakExpression
	
	
	*** Parser Rule: conjunctiveExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"CASE", "CAST", "FALSE", "NOT", "NULL", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"CASE", "CAST", "FALSE", "NOT", "NULL", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			is matched.
			Rule Reference: negatedExpression
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ "AND" }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ "AND" }
					is matched.
					Match token TK_AND, label=land
					ACTION: #land->setType(LAND);
					Rule Reference: negatedExpression
					ACTION: 
							// Put an EXPR on top of rhs to allow runtime optimization of deferred execution when lhs is false
							#neg = #([EXPR, "EXPR"], neg); 
							astFactory.addASTChild(currentAST, #neg); 
						
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AS", "BEGIN", "BREAK", "CONTINUE", 
				"DECLARE", "ELSE", "END", "IF", "OR", "PRINT", 
				"RAISERROR", "RETURN", "SELECT", "SET", "THEN", "WHEN", 
				"WHILE", COMMA, RPAREN, SEMI
			 }
	*** End Parser Rule: conjunctiveExpression
	
	
	*** Parser Rule: negatedExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"CASE", "CAST", "FALSE", "NOT", "NULL", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"CASE", "CAST", "FALSE", "NOT", "NULL", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			is matched.
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ "NOT" }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ "NOT" }
					is matched.
					Match token TK_NOT, label=lnot
					ACTION: #lnot->setType(LNOT);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Rule Reference: isNullExpression
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "BEGIN", "BREAK", 
				"CONTINUE", "DECLARE", "ELSE", "END", "IF", "OR", 
				"PRINT", "RAISERROR", "RETURN", "SELECT", "SET", "THEN", 
				"WHEN", "WHILE", COMMA, RPAREN, SEMI
			 }
	*** End Parser Rule: negatedExpression
	
	
	*** Parser Rule: isNullExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"CASE", "CAST", "FALSE", "NULL", "TRUE", 
					NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, 
					STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, 
					NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"CASE", "CAST", "FALSE", "NULL", "TRUE", 
					NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, 
					STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, 
					NUM_INT
				 }
			is matched.
			Rule Reference: bitwiseExpression
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							EOF, "AND", "AS", "BEGIN", "BREAK", 
							"CONTINUE", "DECLARE", "ELSE", "END", "IF", "IS", 
							"OR", "PRINT", "RAISERROR", "RETURN", "SELECT", "SET", 
							"THEN", "WHEN", "WHILE", COMMA, RPAREN, SEMI
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "IS" }
						is matched.
						Match token TK_IS, label=isnull
						ACTION: #isnull->setType(ISNULL);
						Match token TK_NULL
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ 
								EOF, "AND", "AS", "BEGIN", "BREAK", 
								"CONTINUE", "DECLARE", "ELSE", "END", "IF", "OR", 
								"PRINT", "RAISERROR", "RETURN", "SELECT", "SET", "THEN", 
								"WHEN", "WHILE", COMMA, RPAREN, SEMI
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "BEGIN", "BREAK", 
				"CONTINUE", "DECLARE", "ELSE", "END", "IF", "OR", 
				"PRINT", "RAISERROR", "RETURN", "SELECT", "SET", "THEN", 
				"WHEN", "WHILE", COMMA, RPAREN, SEMI
			 }
	*** End Parser Rule: isNullExpression
	
	
	*** Parser Rule: bitwiseExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"CASE", "CAST", "FALSE", "NULL", "TRUE", 
					NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, 
					STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, 
					NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"CASE", "CAST", "FALSE", "NULL", "TRUE", 
					NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, 
					STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, 
					NUM_INT
				 }
			is matched.
			Rule Reference: conditionalExpression
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ AMPERSAND, CARET, PIPE }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ AMPERSAND, CARET, PIPE }
					is matched.
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ AMPERSAND, CARET, PIPE }
							This block has multiple alternatives:
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ CARET }
								is matched.
								Match token CARET, label=bxor
								ACTION: #bxor->setType(BXOR);
								
								Otherwise, Alternate(2) will be taken IF:
								The lookahead set: 
									{ PIPE }
								is matched.
								Match token PIPE, label=bor
								ACTION: #bor->setType(BOR);
								
								Otherwise, Alternate(3) will be taken IF:
								The lookahead set: 
									{ AMPERSAND }
								is matched.
								Match token AMPERSAND, label=band
								ACTION: #band->setType(BAND);
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternatives
						End of alternative block.
					Rule Reference: conditionalExpression
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "BEGIN", "BREAK", 
				"CONTINUE", "DECLARE", "ELSE", "END", "IF", "IS", 
				"OR", "PRINT", "RAISERROR", "RETURN", "SELECT", "SET", 
				"THEN", "WHEN", "WHILE", COMMA, RPAREN, SEMI
			 }
	*** End Parser Rule: bitwiseExpression
	
	
	*** Parser Rule: conditionalExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"CASE", "CAST", "FALSE", "NULL", "TRUE", 
					NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, 
					STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, 
					NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"CASE", "CAST", "FALSE", "NULL", "TRUE", 
					NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, 
					STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, 
					NUM_INT
				 }
			is matched.
			Rule Reference: additiveExpression
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							EOF, "AND", "AS", "BEGIN", "BREAK", 
							"CONTINUE", "DECLARE", "ELSE", "END", "IF", "IS", 
							"LIKE", "OR", "PRINT", "RAISERROR", "RETURN", "SELECT", 
							"SET", "THEN", "WHEN", "WHILE", AMPERSAND, EQUALS, 
							NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, GTEQ, 
							CARET, COMMA, RPAREN, PIPE, SEMI
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ 
								EOF, "AND", "AS", "BEGIN", "BREAK", 
								"CONTINUE", "DECLARE", "ELSE", "END", "IF", "IS", 
								"OR", "PRINT", "RAISERROR", "RETURN", "SELECT", "SET", 
								"THEN", "WHEN", "WHILE", AMPERSAND, EQUALS, NOTEQUALS, 
								NOTEQUALS2, LTN, LTEQ, GT, GTEQ, CARET, 
								COMMA, RPAREN, PIPE, SEMI
							 }
						is matched.
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										EOF, "AND", "AS", "BEGIN", "BREAK", 
										"CONTINUE", "DECLARE", "ELSE", "END", "IF", "IS", 
										"OR", "PRINT", "RAISERROR", "RETURN", "SELECT", "SET", 
										"THEN", "WHEN", "WHILE", AMPERSAND, EQUALS, NOTEQUALS, 
										NOTEQUALS2, LTN, LTEQ, GT, GTEQ, CARET, 
										COMMA, RPAREN, PIPE, SEMI
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ 
											EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, 
											GT, GTEQ
										 }
									is matched.
									Start of alternative block.
										Start of an alternative block.
											The lookahead set for this block is:
												{ 
													EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, 
													GT, GTEQ
												 }
											This block has multiple alternatives:
												
												Alternate(1) will be taken IF:
												The lookahead set: 
													{ EQUALS }
												is matched.
												Match token EQUALS
												
												Otherwise, Alternate(2) will be taken IF:
												The lookahead set: 
													{ GT }
												is matched.
												Match token GT
												
												Otherwise, Alternate(3) will be taken IF:
												The lookahead set: 
													{ LTN }
												is matched.
												Match token LTN
												
												Otherwise, Alternate(4) will be taken IF:
												The lookahead set: 
													{ GTEQ }
												is matched.
												Match token GTEQ
												
												Otherwise, Alternate(5) will be taken IF:
												The lookahead set: 
													{ LTEQ }
												is matched.
												Match token LTEQ
												
												Otherwise, Alternate(6) will be taken IF:
												The lookahead set: 
													{ NOTEQUALS }
												is matched.
												Match token NOTEQUALS
												
												Otherwise, Alternate(7) will be taken IF:
												The lookahead set: 
													{ NOTEQUALS2 }
												is matched.
												Match token NOTEQUALS2, label=neq
												ACTION: #neq->setType(NOTEQUALS);
												
												OTHERWISE, a NoViableAlt exception will be thrown
												
											End of alternatives
										End of alternative block.
									Rule Reference: additiveExpression
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ 
											EOF, "AND", "AS", "BEGIN", "BREAK", 
											"CONTINUE", "DECLARE", "ELSE", "END", "IF", "IS", 
											"OR", "PRINT", "RAISERROR", "RETURN", "SELECT", "SET", 
											"THEN", "WHEN", "WHILE", AMPERSAND, CARET, COMMA, 
											RPAREN, PIPE, SEMI
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "LIKE" }
						is matched.
						Match token TK_LIKE
						Rule Reference: additiveExpression
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "BEGIN", "BREAK", 
				"CONTINUE", "DECLARE", "ELSE", "END", "IF", "IS", 
				"OR", "PRINT", "RAISERROR", "RETURN", "SELECT", "SET", 
				"THEN", "WHEN", "WHILE", AMPERSAND, CARET, COMMA, 
				RPAREN, PIPE, SEMI
			 }
	*** End Parser Rule: conditionalExpression
	
	
	*** Parser Rule: additiveExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"CASE", "CAST", "FALSE", "NULL", "TRUE", 
					NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, 
					STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, 
					NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"CASE", "CAST", "FALSE", "NULL", "TRUE", 
					NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, 
					STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, 
					NUM_INT
				 }
			is matched.
			Rule Reference: multiplicativeExpression
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ MINUS, PLUS }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ MINUS, PLUS }
					is matched.
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ MINUS, PLUS }
							This block has multiple alternatives:
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ PLUS }
								is matched.
								Match token PLUS
								
								Otherwise, Alternate(2) will be taken IF:
								The lookahead set: 
									{ MINUS }
								is matched.
								Match token MINUS
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternatives
						End of alternative block.
					Rule Reference: multiplicativeExpression
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "BEGIN", "BREAK", 
				"CONTINUE", "DECLARE", "ELSE", "END", "IF", "IS", 
				"LIKE", "OR", "PRINT", "RAISERROR", "RETURN", "SELECT", 
				"SET", "THEN", "WHEN", "WHILE", AMPERSAND, EQUALS, 
				NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, GTEQ, 
				CARET, COMMA, RPAREN, PIPE, SEMI
			 }
	*** End Parser Rule: additiveExpression
	
	
	*** Parser Rule: multiplicativeExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"CASE", "CAST", "FALSE", "NULL", "TRUE", 
					NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, 
					STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, 
					NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"CASE", "CAST", "FALSE", "NULL", "TRUE", 
					NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, 
					STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, 
					NUM_INT
				 }
			is matched.
			Rule Reference: unaryExpression
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ MODULO, SLASH, STAR }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ MODULO, SLASH, STAR }
					is matched.
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ MODULO, SLASH, STAR }
							This block has multiple alternatives:
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ STAR }
								is matched.
								Match token STAR, label=m
								ACTION: #m->setType(TIMES);
								
								Otherwise, Alternate(2) will be taken IF:
								The lookahead set: 
									{ SLASH }
								is matched.
								Match token SLASH, label=d
								ACTION: #d->setType(DIVIDE);
								
								Otherwise, Alternate(3) will be taken IF:
								The lookahead set: 
									{ MODULO }
								is matched.
								Match token MODULO, label=mod
								ACTION: #mod->setType(MODULUS);
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternatives
						End of alternative block.
					Rule Reference: unaryExpression
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "BEGIN", "BREAK", 
				"CONTINUE", "DECLARE", "ELSE", "END", "IF", "IS", 
				"LIKE", "OR", "PRINT", "RAISERROR", "RETURN", "SELECT", 
				"SET", "THEN", "WHEN", "WHILE", AMPERSAND, EQUALS, 
				NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, GTEQ, 
				CARET, COMMA, RPAREN, MINUS, PIPE, PLUS, 
				SEMI
			 }
	*** End Parser Rule: multiplicativeExpression
	
	
	*** Parser Rule: unaryExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"CASE", "CAST", "FALSE", "NULL", "TRUE", 
					NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, 
					STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, 
					NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"CASE", "CAST", "FALSE", "NULL", "TRUE", 
					NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, 
					STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, 
					NUM_INT
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							"CASE", "CAST", "FALSE", "NULL", "TRUE", 
							NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, 
							STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, 
							NUM_INT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ PLUS }
						is matched.
						Match token PLUS, label=up
						ACTION: #up->setType(UNARY_PLUS);
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ MINUS }
						is matched.
						Match token MINUS, label=um
						ACTION: #um->setType(UNARY_MINUS);
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ TILDE }
						is matched.
						Match token TILDE, label=bnot
						ACTION: #bnot->setType(BNOT);
						
						Otherwise, Alternate(4) will be taken IF:
						The lookahead set: 
							{ 
								"CASE", "CAST", "FALSE", "NULL", "TRUE", 
								NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, STRING_LITERAL, ENUM_LITERAL, 
								WSTRING_LITERAL, ID, LOCALVAR, NUM_INT
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Rule Reference: postfixExpression
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "BEGIN", "BREAK", 
				"CONTINUE", "DECLARE", "ELSE", "END", "IF", "IS", 
				"LIKE", "OR", "PRINT", "RAISERROR", "RETURN", "SELECT", 
				"SET", "THEN", "WHEN", "WHILE", AMPERSAND, EQUALS, 
				NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, GTEQ, 
				MODULO, CARET, COMMA, RPAREN, MINUS, PIPE, 
				PLUS, SEMI, SLASH, STAR
			 }
	*** End Parser Rule: unaryExpression
	
	
	*** Parser Rule: postfixExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"CASE", "CAST", "FALSE", "NULL", "TRUE", 
					NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, STRING_LITERAL, ENUM_LITERAL, 
					WSTRING_LITERAL, ID, LOCALVAR, NUM_INT
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ 
						"FALSE", "NULL", "TRUE", NUM_DECIMAL, NUM_FLOAT, 
						NUM_BIGINT, LPAREN, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, ID, 
						LOCALVAR, NUM_INT
					 }
				is matched.
				Rule Reference: primaryExpression
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ 
								EOF, "AND", "AS", "BEGIN", "BREAK", 
								"CONTINUE", "DECLARE", "ELSE", "END", "IF", "IS", 
								"LIKE", "OR", "PRINT", "RAISERROR", "RETURN", "SELECT", 
								"SET", "THEN", "WHEN", "WHILE", AMPERSAND, EQUALS, 
								NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, GTEQ, 
								MODULO, CARET, COMMA, LPAREN, RPAREN, MINUS, 
								PIPE, PLUS, SEMI, SLASH, STAR
							 }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ LPAREN }
							is matched.
							Match token LPAREN, label=lp
							ACTION: #lp->setType(METHOD_CALL);
							Rule Reference: argList
							Match token RPAREN
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ 
									EOF, "AND", "AS", "BEGIN", "BREAK", 
									"CONTINUE", "DECLARE", "ELSE", "END", "IF", "IS", 
									"LIKE", "OR", "PRINT", "RAISERROR", "RETURN", "SELECT", 
									"SET", "THEN", "WHEN", "WHILE", AMPERSAND, EQUALS, 
									NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, GTEQ, 
									MODULO, CARET, COMMA, RPAREN, MINUS, PIPE, 
									PLUS, SEMI, SLASH, STAR
								 }
							is matched.
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ "CAST" }
				is matched.
				Rule Reference: castExpression
				
				Otherwise, Alternate(3) will be taken IF:
				The lookahead set: 
					{ "CASE" }
				is matched.
				Rule Reference: caseExpression
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "BEGIN", "BREAK", 
				"CONTINUE", "DECLARE", "ELSE", "END", "IF", "IS", 
				"LIKE", "OR", "PRINT", "RAISERROR", "RETURN", "SELECT", 
				"SET", "THEN", "WHEN", "WHILE", AMPERSAND, EQUALS, 
				NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, GTEQ, 
				MODULO, CARET, COMMA, RPAREN, MINUS, PIPE, 
				PLUS, SEMI, SLASH, STAR
			 }
	*** End Parser Rule: postfixExpression
	
	
	*** Parser Rule: primaryExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"FALSE", "NULL", "TRUE", NUM_DECIMAL, NUM_FLOAT, 
					NUM_BIGINT, LPAREN, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, ID, 
					LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"FALSE", "NULL", "TRUE", NUM_DECIMAL, NUM_FLOAT, 
					NUM_BIGINT, LPAREN, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, ID, 
					LOCALVAR, NUM_INT
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							"FALSE", "NULL", "TRUE", NUM_DECIMAL, NUM_FLOAT, 
							NUM_BIGINT, LPAREN, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, ID, 
							LOCALVAR, NUM_INT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ NUM_INT }
						is matched.
						Match token NUM_INT
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ NUM_BIGINT }
						is matched.
						Match token NUM_BIGINT
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ NUM_FLOAT }
						is matched.
						Match token NUM_FLOAT
						
						Otherwise, Alternate(4) will be taken IF:
						The lookahead set: 
							{ NUM_DECIMAL }
						is matched.
						Match token NUM_DECIMAL
						
						Otherwise, Alternate(5) will be taken IF:
						The lookahead set: 
							{ STRING_LITERAL }
						is matched.
						Match token STRING_LITERAL, label=sl
						ACTION: 
										// Strip of the leading single quote and the trailing single quote
										#sl->setText(#sl->getText().substr(1, #sl->getText().length()-2)); 
									
						
						Otherwise, Alternate(6) will be taken IF:
						The lookahead set: 
							{ WSTRING_LITERAL }
						is matched.
						Match token WSTRING_LITERAL, label=wsl
						ACTION: 
										// Strip of the leading single quote and N and the trailing single quote
										#wsl->setText(#wsl->getText().substr(2, #wsl->getText().length()-3)); 
									
						
						Otherwise, Alternate(7) will be taken IF:
						The lookahead set: 
							{ ENUM_LITERAL }
						is matched.
						Match token ENUM_LITERAL, label=el
						ACTION: 
										// Strip of the leading and the trailing delimeters
										#el->setText(#el->getText().substr(1, #el->getText().length()-2)); 
									
						
						Otherwise, Alternate(8) will be taken IF:
						The lookahead set: 
							{ "TRUE" }
						is matched.
						Match token TK_TRUE
						
						Otherwise, Alternate(9) will be taken IF:
						The lookahead set: 
							{ "FALSE" }
						is matched.
						Match token TK_FALSE
						
						Otherwise, Alternate(10) will be taken IF:
						The lookahead set: 
							{ ID }
						is matched.
						Match token ID
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										EOF, "AND", "AS", "BEGIN", "BREAK", 
										"CONTINUE", "DECLARE", "ELSE", "END", "IF", "IS", 
										"LIKE", "OR", "PRINT", "RAISERROR", "RETURN", "SELECT", 
										"SET", "THEN", "WHEN", "WHILE", AMPERSAND, EQUALS, 
										NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, GTEQ, 
										MODULO, CARET, COMMA, DOT, LPAREN, RPAREN, 
										MINUS, PIPE, PLUS, SEMI, SLASH, STAR
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ DOT }
									is matched.
									Match token DOT
									Match token ID
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ 
											EOF, "AND", "AS", "BEGIN", "BREAK", 
											"CONTINUE", "DECLARE", "ELSE", "END", "IF", "IS", 
											"LIKE", "OR", "PRINT", "RAISERROR", "RETURN", "SELECT", 
											"SET", "THEN", "WHEN", "WHILE", AMPERSAND, EQUALS, 
											NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, GTEQ, 
											MODULO, CARET, COMMA, LPAREN, RPAREN, MINUS, 
											PIPE, PLUS, SEMI, SLASH, STAR
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						
						Otherwise, Alternate(11) will be taken IF:
						The lookahead set: 
							{ LOCALVAR }
						is matched.
						Match token LOCALVAR
						
						Otherwise, Alternate(12) will be taken IF:
						The lookahead set: 
							{ "NULL" }
						is matched.
						Match token TK_NULL
						
						Otherwise, Alternate(13) will be taken IF:
						The lookahead set: 
							{ LPAREN }
						is matched.
						Match token LPAREN
						Rule Reference: expression
						Match token RPAREN
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "BEGIN", "BREAK", 
				"CONTINUE", "DECLARE", "ELSE", "END", "IF", "IS", 
				"LIKE", "OR", "PRINT", "RAISERROR", "RETURN", "SELECT", 
				"SET", "THEN", "WHEN", "WHILE", AMPERSAND, EQUALS, 
				NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, GTEQ, 
				MODULO, CARET, COMMA, LPAREN, RPAREN, MINUS, 
				PIPE, PLUS, SEMI, SLASH, STAR
			 }
	*** End Parser Rule: primaryExpression
	
	
	*** Parser Rule: argList
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"CASE", "CAST", "FALSE", "NOT", "NULL", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, RPAREN, 
					MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, 
					ID, LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"CASE", "CAST", "FALSE", "NOT", "NULL", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, RPAREN, 
					MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, 
					ID, LOCALVAR, NUM_INT
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							"CASE", "CAST", "FALSE", "NOT", "NULL", 
							"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, RPAREN, 
							MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, 
							ID, LOCALVAR, NUM_INT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ 
								"CASE", "CAST", "FALSE", "NOT", "NULL", 
								"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
								PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
								LOCALVAR, NUM_INT
							 }
						is matched.
						Rule Reference: expressionList
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ RPAREN }
						is matched.
						ACTION: #argList = #[ELIST, "ELIST"];
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN }
	*** End Parser Rule: argList
	
	
	*** Parser Rule: castExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "CAST" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "CAST" }
			is matched.
			Match token TK_CAST
			Match token LPAREN
			Rule Reference: expression
			Match token TK_AS
			Rule Reference: builtInType
			Match token RPAREN
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "BEGIN", "BREAK", 
				"CONTINUE", "DECLARE", "ELSE", "END", "IF", "IS", 
				"LIKE", "OR", "PRINT", "RAISERROR", "RETURN", "SELECT", 
				"SET", "THEN", "WHEN", "WHILE", AMPERSAND, EQUALS, 
				NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, GTEQ, 
				MODULO, CARET, COMMA, RPAREN, MINUS, PIPE, 
				PLUS, SEMI, SLASH, STAR
			 }
	*** End Parser Rule: castExpression
	
	
	*** Parser Rule: caseExpression
		Access: protected
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				k==1: {"CASE" }
				k==2: {
					"CASE", "CAST", "FALSE", "NOT", "NULL", 
					"TRUE", "WHEN", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, 
					MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, 
					ID, LOCALVAR, NUM_INT
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					k==1: {"CASE" }
					k==2: {"WHEN" }
				is matched, AND the syntactic predicate:
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ "CASE" }
							This block has a single alternative
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ "CASE" }
							is matched.
							Match token TK_CASE
							Match token TK_WHEN
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternative block.
				is matched.
				Match token TK_CASE, label=simple
				ACTION: #simple->setType(SIMPLE_CASE);
				Start ONE-OR-MORE (...)+ block:
					Start of an alternative block.
						The lookahead set for this block is:
							{ "WHEN" }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "WHEN" }
						is matched.
						Rule Reference: whenExpression, arguments = true
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				End ONE-OR-MORE block.
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ "ELSE", "END" }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ "ELSE" }
							is matched.
							Rule Reference: elseExpression
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ "END" }
							is matched.
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				Match token TK_END
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					k==1: {"CASE" }
					k==2: {
						"CASE", "CAST", "FALSE", "NOT", "NULL", 
						"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
						PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
						LOCALVAR, NUM_INT
					 }
				is matched.
				Match token TK_CASE, label=search
				ACTION: #search->setType(SEARCHED_CASE);
				Rule Reference: weakExpression
				Start ONE-OR-MORE (...)+ block:
					Start of an alternative block.
						The lookahead set for this block is:
							{ "WHEN" }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "WHEN" }
						is matched.
						Rule Reference: whenExpression, arguments = false
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				End ONE-OR-MORE block.
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ "ELSE", "END" }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ "ELSE" }
							is matched.
							Rule Reference: elseExpression
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ "END" }
							is matched.
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				Match token TK_END
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "BEGIN", "BREAK", 
				"CONTINUE", "DECLARE", "ELSE", "END", "IF", "IS", 
				"LIKE", "OR", "PRINT", "RAISERROR", "RETURN", "SELECT", 
				"SET", "THEN", "WHEN", "WHILE", AMPERSAND, EQUALS, 
				NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, GTEQ, 
				MODULO, CARET, COMMA, RPAREN, MINUS, PIPE, 
				PLUS, SEMI, SLASH, STAR
			 }
	*** End Parser Rule: caseExpression
	
	
	*** Parser Rule: whenExpression
		Access: protected
		Return value: none
		Arguments: bool simple
		Start of an alternative block.
			The lookahead set for this block is:
				{ "WHEN" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "WHEN" }
			is matched.
			Match token TK_WHEN, label=tkw
			ACTION: if(simple) #tkw->setType(SIMPLE_WHEN);
			Rule Reference: weakExpression
			Match token TK_THEN
			Rule Reference: weakExpression
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {"ELSE", "END", "WHEN" }
	*** End Parser Rule: whenExpression
	
	
	*** Parser Rule: elseExpression
		Access: protected
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "ELSE" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "ELSE" }
			is matched.
			Match token TK_ELSE
			Rule Reference: weakExpression
			ACTION: #elseExpression = #([EXPR, "EXPR"], elseExpression);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {"END" }
	*** End Parser Rule: elseExpression
	
	
	*** Parser Rule: expressionList
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"CASE", "CAST", "FALSE", "NOT", "NULL", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"CASE", "CAST", "FALSE", "NOT", "NULL", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			is matched.
			Rule Reference: expression
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: expression
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			ACTION: #expressionList = #(#[ELIST,"ELIST"], expressionList);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN }
	*** End Parser Rule: expressionList
	
	
	*** Parser Rule: sql92_queryExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "SELECT" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "SELECT" }
			is matched.
			Rule Reference: sql92_querySpecification
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
				"ELSE", "END", "IF", "ORDER", "PRINT", "RAISERROR", 
				"RETURN", "SELECT", "SET", "UNION", "WHILE", RPAREN, 
				SEMI
			 }
	*** End Parser Rule: sql92_queryExpression
	
	
	*** Parser Rule: sql92_orderByExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"AVG", "CASE", "CAST", "COUNT", "FALSE", 
					"MAX", "MIN", "NULL", "SUM", "TRUE", NUM_DECIMAL, 
					NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, STRING_LITERAL, 
					ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"AVG", "CASE", "CAST", "COUNT", "FALSE", 
					"MAX", "MIN", "NULL", "SUM", "TRUE", NUM_DECIMAL, 
					NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, STRING_LITERAL, 
					ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
				 }
			is matched.
			Rule Reference: sql92_additiveExpression
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							EOF, "ASC", "BEGIN", "BREAK", "CONTINUE", 
							"DECLARE", "DESC", "ELSE", "END", "IF", "PRINT", 
							"RAISERROR", "RETURN", "SELECT", "SET", "WHILE", COMMA, 
							RPAREN, SEMI
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "ASC" }
						is matched.
						Match token TK_ASC
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "DESC" }
						is matched.
						Match token TK_DESC
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ 
								EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
								"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
								"SELECT", "SET", "WHILE", COMMA, RPAREN, SEMI
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: sql92_additiveExpression
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ 
									EOF, "ASC", "BEGIN", "BREAK", "CONTINUE", 
									"DECLARE", "DESC", "ELSE", "END", "IF", "PRINT", 
									"RAISERROR", "RETURN", "SELECT", "SET", "WHILE", COMMA, 
									RPAREN, SEMI
								 }
							This block has multiple alternatives:
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ "ASC" }
								is matched.
								Match token TK_ASC
								
								Otherwise, Alternate(2) will be taken IF:
								The lookahead set: 
									{ "DESC" }
								is matched.
								Match token TK_DESC
								
								Otherwise, Alternate(3) will be taken IF:
								The lookahead set: 
									{ 
										EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
										"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
										"SELECT", "SET", "WHILE", COMMA, RPAREN, SEMI
									 }
								is matched.
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternatives
						End of alternative block.
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
				"ELSE", "END", "IF", "PRINT", "RAISERROR", "RETURN", 
				"SELECT", "SET", "WHILE", RPAREN, SEMI
			 }
	*** End Parser Rule: sql92_orderByExpression
	
	
	*** Parser Rule: sql92_additiveExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"AVG", "CASE", "CAST", "COUNT", "FALSE", 
					"MAX", "MIN", "NULL", "SUM", "TRUE", NUM_DECIMAL, 
					NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, STRING_LITERAL, 
					ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"AVG", "CASE", "CAST", "COUNT", "FALSE", 
					"MAX", "MIN", "NULL", "SUM", "TRUE", NUM_DECIMAL, 
					NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, STRING_LITERAL, 
					ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
				 }
			is matched.
			Rule Reference: sql92_multiplicativeExpression
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ MINUS, PLUS }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ MINUS, PLUS }
					is matched.
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ MINUS, PLUS }
							This block has multiple alternatives:
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ PLUS }
								is matched.
								Match token PLUS
								
								Otherwise, Alternate(2) will be taken IF:
								The lookahead set: 
									{ MINUS }
								is matched.
								Match token MINUS
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternatives
						End of alternative block.
					Rule Reference: sql92_multiplicativeExpression
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "ASC", "BEGIN", 
				"BETWEEN", "BREAK", "CONTINUE", "CROSS", "DECLARE", "DESC", 
				"ELSE", "END", "FROM", "FULL", "GROUP", "HAVING", 
				"IF", "IN", "INNER", "INTO", "IS", "JOIN", 
				"LEFT", "LIKE", "NOT", "ON", "OR", "ORDER", 
				"PRINT", "RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", 
				"THEN", "UNION", "WHEN", "WHERE", "WHILE", AMPERSAND, 
				EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, 
				GTEQ, CARET, COMMA, RPAREN, PIPE, SEMI, 
				ID
			 }
	*** End Parser Rule: sql92_additiveExpression
	
	
	*** Parser Rule: sql92_querySpecification
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "SELECT" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "SELECT" }
			is matched.
			Match token TK_SELECT
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							"ALL", "AVG", "CASE", "CAST", "COUNT", 
							"DISTINCT", "EXISTS", "FALSE", "MAX", "MIN", "NOT", 
							"NULL", "SUM", "TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, 
							LPAREN, MINUS, PLUS, STAR, STRING_LITERAL, ENUM_LITERAL, 
							WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "ALL" }
						is matched.
						Match token TK_ALL
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "DISTINCT" }
						is matched.
						Match token TK_DISTINCT
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ 
								"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
								"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
								"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
								PLUS, STAR, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, 
								ID, LOCALVAR, NUM_INT
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Rule Reference: sql92_selectList
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ "FROM", "INTO" }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "INTO" }
						is matched.
						Rule Reference: sql92_intoList
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "FROM" }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Rule Reference: sql92_fromSpecification
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
							"ELSE", "END", "GROUP", "IF", "ORDER", "PRINT", 
							"RAISERROR", "RETURN", "SELECT", "SET", "UNION", "WHERE", 
							"WHILE", RPAREN, SEMI
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "WHERE" }
						is matched.
						Rule Reference: sql92_whereClause
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ 
								EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
								"ELSE", "END", "GROUP", "IF", "ORDER", "PRINT", 
								"RAISERROR", "RETURN", "SELECT", "SET", "UNION", "WHILE", 
								RPAREN, SEMI
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
							"ELSE", "END", "GROUP", "IF", "ORDER", "PRINT", 
							"RAISERROR", "RETURN", "SELECT", "SET", "UNION", "WHILE", 
							RPAREN, SEMI
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "GROUP" }
						is matched.
						Rule Reference: sql92_groupByClause
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ 
								EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
								"ELSE", "END", "IF", "ORDER", "PRINT", "RAISERROR", 
								"RETURN", "SELECT", "SET", "UNION", "WHILE", RPAREN, 
								SEMI
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
				"ELSE", "END", "IF", "ORDER", "PRINT", "RAISERROR", 
				"RETURN", "SELECT", "SET", "UNION", "WHILE", RPAREN, 
				SEMI
			 }
	*** End Parser Rule: sql92_querySpecification
	
	
	*** Parser Rule: sql92_selectList
		Access: protected
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STAR, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, 
					ID, LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STAR, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, 
					ID, LOCALVAR, NUM_INT
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
							"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
							"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
							PLUS, STAR, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, 
							ID, LOCALVAR, NUM_INT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ STAR }
						is matched.
						Match token STAR
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ 
								"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
								"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
								"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
								PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
								LOCALVAR, NUM_INT
							 }
						is matched.
						Rule Reference: sql92_aliasedExpression
						Start ZERO-OR-MORE (...)+ block:
							Start of an alternative block.
								The lookahead set for this block is:
									{ COMMA }
								This block has a single alternative
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ COMMA }
								is matched.
								Match token COMMA
								Rule Reference: sql92_aliasedExpression
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternative block.
						End ZERO-OR-MORE block.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			ACTION: ## = #([SELECT_LIST, "SELECT_LIST"], ##);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {"FROM", "INTO" }
	*** End Parser Rule: sql92_selectList
	
	
	*** Parser Rule: sql92_intoList
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "INTO" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "INTO" }
			is matched.
			Match token TK_INTO
			Match token LOCALVAR
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Match token LOCALVAR
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {"FROM" }
	*** End Parser Rule: sql92_intoList
	
	
	*** Parser Rule: sql92_fromSpecification
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "FROM" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "FROM" }
			is matched.
			Match token TK_FROM
			Rule Reference: sql92_tableReferenceList
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
				"ELSE", "END", "GROUP", "IF", "ORDER", "PRINT", 
				"RAISERROR", "RETURN", "SELECT", "SET", "UNION", "WHERE", 
				"WHILE", RPAREN, SEMI
			 }
	*** End Parser Rule: sql92_fromSpecification
	
	
	*** Parser Rule: sql92_whereClause
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "WHERE" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "WHERE" }
			is matched.
			Match token TK_WHERE
			Rule Reference: sql92_weakExpression
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
				"ELSE", "END", "GROUP", "IF", "ORDER", "PRINT", 
				"RAISERROR", "RETURN", "SELECT", "SET", "UNION", "WHILE", 
				RPAREN, SEMI
			 }
	*** End Parser Rule: sql92_whereClause
	
	
	*** Parser Rule: sql92_groupByClause
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "GROUP" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "GROUP" }
			is matched.
			Match token TK_GROUP
			Match token TK_BY
			Rule Reference: sql92_groupByExpressionList
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
							"ELSE", "END", "HAVING", "IF", "ORDER", "PRINT", 
							"RAISERROR", "RETURN", "SELECT", "SET", "UNION", "WHILE", 
							RPAREN, SEMI
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "HAVING" }
						is matched.
						Match token TK_HAVING
						Rule Reference: sql92_weakExpression
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ 
								EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
								"ELSE", "END", "IF", "ORDER", "PRINT", "RAISERROR", 
								"RETURN", "SELECT", "SET", "UNION", "WHILE", RPAREN, 
								SEMI
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
				"ELSE", "END", "IF", "ORDER", "PRINT", "RAISERROR", 
				"RETURN", "SELECT", "SET", "UNION", "WHILE", RPAREN, 
				SEMI
			 }
	*** End Parser Rule: sql92_groupByClause
	
	
	*** Parser Rule: sql92_tableReferenceList
		Access: protected
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ LPAREN, ID }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ LPAREN, ID }
			is matched.
			Rule Reference: sql92_joinedTable
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: sql92_joinedTable
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
				"ELSE", "END", "GROUP", "IF", "ORDER", "PRINT", 
				"RAISERROR", "RETURN", "SELECT", "SET", "UNION", "WHERE", 
				"WHILE", RPAREN, SEMI
			 }
	*** End Parser Rule: sql92_tableReferenceList
	
	
	*** Parser Rule: sql92_weakExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			is matched.
			Rule Reference: sql92_conjunctiveExpression
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ "OR" }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ "OR" }
					is matched.
					Match token TK_OR, label=lor
					ACTION: 
										#lor->setType(LOR); 
									
					Rule Reference: sql92_conjunctiveExpression
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AS", "BEGIN", "BREAK", "CONTINUE", 
				"CROSS", "DECLARE", "ELSE", "END", "FROM", "FULL", 
				"GROUP", "IF", "INNER", "INTO", "JOIN", "LEFT", 
				"ON", "ORDER", "PRINT", "RAISERROR", "RETURN", "RIGHT", 
				"SELECT", "SET", "THEN", "UNION", "WHEN", "WHERE", 
				"WHILE", COMMA, RPAREN, SEMI, ID
			 }
	*** End Parser Rule: sql92_weakExpression
	
	
	*** Parser Rule: sql92_groupByExpressionList
		Access: protected
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"AVG", "CASE", "CAST", "COUNT", "FALSE", 
					"MAX", "MIN", "NULL", "SUM", "TRUE", NUM_DECIMAL, 
					NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, STRING_LITERAL, 
					ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"AVG", "CASE", "CAST", "COUNT", "FALSE", 
					"MAX", "MIN", "NULL", "SUM", "TRUE", NUM_DECIMAL, 
					NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, STRING_LITERAL, 
					ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
				 }
			is matched.
			Rule Reference: sql92_additiveExpression
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: sql92_additiveExpression
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "BEGIN", "BREAK", "CONTINUE", "DECLARE", 
				"ELSE", "END", "HAVING", "IF", "ORDER", "PRINT", 
				"RAISERROR", "RETURN", "SELECT", "SET", "UNION", "WHILE", 
				RPAREN, SEMI
			 }
	*** End Parser Rule: sql92_groupByExpressionList
	
	
	*** Parser Rule: sql92_aliasedExpression
		Access: protected
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			is matched.
			Rule Reference: sql92_expression
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ "AS", "FROM", "INTO", COMMA, ID }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "AS", ID }
						is matched.
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ "AS", ID }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ "AS" }
									is matched.
									Match token TK_AS
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ ID }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Match token ID, label=id
						ACTION: #id->setType(ALIAS);
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "FROM", "INTO", COMMA }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {"FROM", "INTO", COMMA }
	*** End Parser Rule: sql92_aliasedExpression
	
	
	*** Parser Rule: sql92_expression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
							"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
							"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
							PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
							LOCALVAR, NUM_INT
						 }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ 
							"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
							"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
							"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
							PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
							LOCALVAR, NUM_INT
						 }
					is matched.
					Rule Reference: sql92_weakExpression
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			ACTION: #sql92_expression = #(#[EXPR, "EXPR"], #sql92_expression);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				"AS", "FROM", "INTO", COMMA, RPAREN, 
				ID
			 }
	*** End Parser Rule: sql92_expression
	
	
	*** Parser Rule: sql92_markedAdditiveExpression
		Access: protected
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"AVG", "CASE", "CAST", "COUNT", "FALSE", 
					"MAX", "MIN", "NULL", "SUM", "TRUE", NUM_DECIMAL, 
					NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, STRING_LITERAL, 
					ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"AVG", "CASE", "CAST", "COUNT", "FALSE", 
					"MAX", "MIN", "NULL", "SUM", "TRUE", NUM_DECIMAL, 
					NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, STRING_LITERAL, 
					ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
				 }
			is matched.
			Rule Reference: sql92_additiveExpression
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {EOF }
	*** End Parser Rule: sql92_markedAdditiveExpression
	
	
	*** Parser Rule: sql92_conjunctiveExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			is matched.
			Rule Reference: sql92_negatedExpression
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ "AND" }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ "AND" }
					is matched.
					Match token TK_AND, label=land
					ACTION: #land->setType(LAND);
					Rule Reference: sql92_negatedExpression
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AS", "BEGIN", "BREAK", "CONTINUE", 
				"CROSS", "DECLARE", "ELSE", "END", "FROM", "FULL", 
				"GROUP", "IF", "INNER", "INTO", "JOIN", "LEFT", 
				"ON", "OR", "ORDER", "PRINT", "RAISERROR", "RETURN", 
				"RIGHT", "SELECT", "SET", "THEN", "UNION", "WHEN", 
				"WHERE", "WHILE", COMMA, RPAREN, SEMI, ID
			 }
	*** End Parser Rule: sql92_conjunctiveExpression
	
	
	*** Parser Rule: sql92_negatedExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			is matched.
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ "NOT" }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ "NOT" }
					is matched.
					Match token TK_NOT, label=lnot
					ACTION: #lnot->setType(LNOT);
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			Rule Reference: sql92_isNullExpression
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "BEGIN", "BREAK", 
				"CONTINUE", "CROSS", "DECLARE", "ELSE", "END", "FROM", 
				"FULL", "GROUP", "IF", "INNER", "INTO", "JOIN", 
				"LEFT", "ON", "OR", "ORDER", "PRINT", "RAISERROR", 
				"RETURN", "RIGHT", "SELECT", "SET", "THEN", "UNION", 
				"WHEN", "WHERE", "WHILE", COMMA, RPAREN, SEMI, 
				ID
			 }
	*** End Parser Rule: sql92_negatedExpression
	
	
	*** Parser Rule: sql92_isNullExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NULL", "SUM", "TRUE", 
					NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, 
					STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, 
					NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NULL", "SUM", "TRUE", 
					NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, 
					STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, 
					NUM_INT
				 }
			is matched.
			Rule Reference: sql92_bitwiseExpression
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							EOF, "AND", "AS", "BEGIN", "BREAK", 
							"CONTINUE", "CROSS", "DECLARE", "ELSE", "END", "FROM", 
							"FULL", "GROUP", "IF", "INNER", "INTO", "IS", 
							"JOIN", "LEFT", "ON", "OR", "ORDER", "PRINT", 
							"RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", "THEN", 
							"UNION", "WHEN", "WHERE", "WHILE", COMMA, RPAREN, 
							SEMI, ID
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "IS" }
						is matched.
						Match token TK_IS, label=isnull
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ "NOT", "NULL" }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ "NOT" }
									is matched.
									Match token TK_NOT
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ "NULL" }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Match token TK_NULL
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ 
								EOF, "AND", "AS", "BEGIN", "BREAK", 
								"CONTINUE", "CROSS", "DECLARE", "ELSE", "END", "FROM", 
								"FULL", "GROUP", "IF", "INNER", "INTO", "JOIN", 
								"LEFT", "ON", "OR", "ORDER", "PRINT", "RAISERROR", 
								"RETURN", "RIGHT", "SELECT", "SET", "THEN", "UNION", 
								"WHEN", "WHERE", "WHILE", COMMA, RPAREN, SEMI, 
								ID
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "BEGIN", "BREAK", 
				"CONTINUE", "CROSS", "DECLARE", "ELSE", "END", "FROM", 
				"FULL", "GROUP", "IF", "INNER", "INTO", "JOIN", 
				"LEFT", "ON", "OR", "ORDER", "PRINT", "RAISERROR", 
				"RETURN", "RIGHT", "SELECT", "SET", "THEN", "UNION", 
				"WHEN", "WHERE", "WHILE", COMMA, RPAREN, SEMI, 
				ID
			 }
	*** End Parser Rule: sql92_isNullExpression
	
	
	*** Parser Rule: sql92_bitwiseExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NULL", "SUM", "TRUE", 
					NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, 
					STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, 
					NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NULL", "SUM", "TRUE", 
					NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, 
					STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, 
					NUM_INT
				 }
			is matched.
			Rule Reference: sql92_conditionalExpression
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ AMPERSAND, CARET, PIPE }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ AMPERSAND, CARET, PIPE }
					is matched.
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ AMPERSAND, CARET, PIPE }
							This block has multiple alternatives:
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ CARET }
								is matched.
								Match token CARET, label=bxor
								ACTION: #bxor->setType(BXOR);
								
								Otherwise, Alternate(2) will be taken IF:
								The lookahead set: 
									{ PIPE }
								is matched.
								Match token PIPE, label=bor
								ACTION: #bor->setType(BOR);
								
								Otherwise, Alternate(3) will be taken IF:
								The lookahead set: 
									{ AMPERSAND }
								is matched.
								Match token AMPERSAND, label=band
								ACTION: #band->setType(BAND);
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternatives
						End of alternative block.
					Rule Reference: sql92_conditionalExpression
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "BEGIN", "BREAK", 
				"CONTINUE", "CROSS", "DECLARE", "ELSE", "END", "FROM", 
				"FULL", "GROUP", "IF", "INNER", "INTO", "IS", 
				"JOIN", "LEFT", "ON", "OR", "ORDER", "PRINT", 
				"RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", "THEN", 
				"UNION", "WHEN", "WHERE", "WHILE", COMMA, RPAREN, 
				SEMI, ID
			 }
	*** End Parser Rule: sql92_bitwiseExpression
	
	
	*** Parser Rule: sql92_conditionalExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NULL", "SUM", "TRUE", 
					NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, 
					STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, 
					NUM_INT
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ 
						"AVG", "CASE", "CAST", "COUNT", "FALSE", 
						"MAX", "MIN", "NULL", "SUM", "TRUE", NUM_DECIMAL, 
						NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, STRING_LITERAL, 
						ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
					 }
				is matched.
				Rule Reference: sql92_additiveExpression
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ 
								EOF, "AND", "AS", "BEGIN", "BETWEEN", 
								"BREAK", "CONTINUE", "CROSS", "DECLARE", "ELSE", "END", 
								"FROM", "FULL", "GROUP", "IF", "IN", "INNER", 
								"INTO", "IS", "JOIN", "LEFT", "LIKE", "NOT", 
								"ON", "OR", "ORDER", "PRINT", "RAISERROR", "RETURN", 
								"RIGHT", "SELECT", "SET", "THEN", "UNION", "WHEN", 
								"WHERE", "WHILE", AMPERSAND, EQUALS, NOTEQUALS, NOTEQUALS2, 
								LTN, LTEQ, GT, GTEQ, CARET, COMMA, 
								RPAREN, PIPE, SEMI, ID
							 }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ 
									EOF, "AND", "AS", "BEGIN", "BREAK", 
									"CONTINUE", "CROSS", "DECLARE", "ELSE", "END", "FROM", 
									"FULL", "GROUP", "IF", "INNER", "INTO", "IS", 
									"JOIN", "LEFT", "ON", "OR", "ORDER", "PRINT", 
									"RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", "THEN", 
									"UNION", "WHEN", "WHERE", "WHILE", AMPERSAND, EQUALS, 
									NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, GTEQ, 
									CARET, COMMA, RPAREN, PIPE, SEMI, ID
								 }
							is matched.
							Start of alternative block.
								Start of an alternative block.
									The lookahead set for this block is:
										{ 
											EOF, "AND", "AS", "BEGIN", "BREAK", 
											"CONTINUE", "CROSS", "DECLARE", "ELSE", "END", "FROM", 
											"FULL", "GROUP", "IF", "INNER", "INTO", "IS", 
											"JOIN", "LEFT", "ON", "OR", "ORDER", "PRINT", 
											"RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", "THEN", 
											"UNION", "WHEN", "WHERE", "WHILE", AMPERSAND, EQUALS, 
											NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, GTEQ, 
											CARET, COMMA, RPAREN, PIPE, SEMI, ID
										 }
									This block has multiple alternatives:
										
										Alternate(1) will be taken IF:
										The lookahead set: 
											{ 
												EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, 
												GT, GTEQ
											 }
										is matched.
										Start of alternative block.
											Start of an alternative block.
												The lookahead set for this block is:
													{ 
														EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, 
														GT, GTEQ
													 }
												This block has multiple alternatives:
													
													Alternate(1) will be taken IF:
													The lookahead set: 
														{ EQUALS }
													is matched.
													Match token EQUALS
													
													Otherwise, Alternate(2) will be taken IF:
													The lookahead set: 
														{ GT }
													is matched.
													Match token GT
													
													Otherwise, Alternate(3) will be taken IF:
													The lookahead set: 
														{ LTN }
													is matched.
													Match token LTN
													
													Otherwise, Alternate(4) will be taken IF:
													The lookahead set: 
														{ GTEQ }
													is matched.
													Match token GTEQ
													
													Otherwise, Alternate(5) will be taken IF:
													The lookahead set: 
														{ LTEQ }
													is matched.
													Match token LTEQ
													
													Otherwise, Alternate(6) will be taken IF:
													The lookahead set: 
														{ NOTEQUALS }
													is matched.
													Match token NOTEQUALS
													
													Otherwise, Alternate(7) will be taken IF:
													The lookahead set: 
														{ NOTEQUALS2 }
													is matched.
													Match token NOTEQUALS2, label=neq
													ACTION: #neq->setType(NOTEQUALS);
													
													OTHERWISE, a NoViableAlt exception will be thrown
													
												End of alternatives
											End of alternative block.
										Rule Reference: sql92_additiveExpression
										
										Otherwise, Alternate(2) will be taken IF:
										The lookahead set: 
											{ 
												EOF, "AND", "AS", "BEGIN", "BREAK", 
												"CONTINUE", "CROSS", "DECLARE", "ELSE", "END", "FROM", 
												"FULL", "GROUP", "IF", "INNER", "INTO", "IS", 
												"JOIN", "LEFT", "ON", "OR", "ORDER", "PRINT", 
												"RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", "THEN", 
												"UNION", "WHEN", "WHERE", "WHILE", AMPERSAND, CARET, 
												COMMA, RPAREN, PIPE, SEMI, ID
											 }
										is matched.
										
										OTHERWISE, a NoViableAlt exception will be thrown
										
									End of alternatives
								End of alternative block.
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ "BETWEEN", "IN", "LIKE", "NOT" }
							is matched.
							Start of alternative block.
								Start of an alternative block.
									The lookahead set for this block is:
										{ "BETWEEN", "IN", "LIKE", "NOT" }
									This block has multiple alternatives:
										
										Alternate(1) will be taken IF:
										The lookahead set: 
											{ "NOT" }
										is matched.
										Match token TK_NOT
										
										Otherwise, Alternate(2) will be taken IF:
										The lookahead set: 
											{ "BETWEEN", "IN", "LIKE" }
										is matched.
										
										OTHERWISE, a NoViableAlt exception will be thrown
										
									End of alternatives
								End of alternative block.
							Start of alternative block.
								Start of an alternative block.
									The lookahead set for this block is:
										{ "BETWEEN", "IN", "LIKE" }
									This block has multiple alternatives:
										
										Alternate(1) will be taken IF:
										The lookahead set: 
											{ "LIKE" }
										is matched.
										Match token TK_LIKE
										Rule Reference: sql92_additiveExpression
										
										Otherwise, Alternate(2) will be taken IF:
										The lookahead set: 
											{ "BETWEEN" }
										is matched.
										Match token TK_BETWEEN
										Rule Reference: sql92_additiveExpression
										Match token TK_AND
										Rule Reference: sql92_additiveExpression
										
										Otherwise, Alternate(3) will be taken IF:
										The lookahead set: 
											{ "IN" }
										is matched.
										Match token TK_IN
										Match token LPAREN
										Start of alternative block.
											Start of an alternative block.
												The lookahead set for this block is:
													{ 
														"AVG", "CASE", "CAST", "COUNT", "FALSE", 
														"MAX", "MIN", "NULL", "SELECT", "SUM", "TRUE", 
														NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, 
														STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, 
														NUM_INT
													 }
												This block has multiple alternatives:
													
													Alternate(1) will be taken IF:
													The lookahead set: 
														{ "SELECT" }
													is matched.
													Rule Reference: sql92_selectStatement
													
													Otherwise, Alternate(2) will be taken IF:
													The lookahead set: 
														{ 
															"AVG", "CASE", "CAST", "COUNT", "FALSE", 
															"MAX", "MIN", "NULL", "SUM", "TRUE", NUM_DECIMAL, 
															NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, STRING_LITERAL, 
															ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
														 }
													is matched.
													Rule Reference: sql92_additiveExpression
													Start ZERO-OR-MORE (...)+ block:
														Start of an alternative block.
															The lookahead set for this block is:
																{ COMMA }
															This block has a single alternative
															
															Alternate(1) will be taken IF:
															The lookahead set: 
																{ COMMA }
															is matched.
															Match token COMMA
															Rule Reference: sql92_additiveExpression
															
															OTHERWISE, a NoViableAlt exception will be thrown
															
														End of alternative block.
													End ZERO-OR-MORE block.
													
													OTHERWISE, a NoViableAlt exception will be thrown
													
												End of alternatives
											End of alternative block.
										Match token RPAREN
										
										OTHERWISE, a NoViableAlt exception will be thrown
										
									End of alternatives
								End of alternative block.
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ "EXISTS" }
				is matched.
				Match token TK_EXISTS
				Match token LPAREN
				Rule Reference: sql92_selectStatement
				Match token RPAREN
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "BEGIN", "BREAK", 
				"CONTINUE", "CROSS", "DECLARE", "ELSE", "END", "FROM", 
				"FULL", "GROUP", "IF", "INNER", "INTO", "IS", 
				"JOIN", "LEFT", "ON", "OR", "ORDER", "PRINT", 
				"RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", "THEN", 
				"UNION", "WHEN", "WHERE", "WHILE", AMPERSAND, CARET, 
				COMMA, RPAREN, PIPE, SEMI, ID
			 }
	*** End Parser Rule: sql92_conditionalExpression
	
	
	*** Parser Rule: sql92_multiplicativeExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"AVG", "CASE", "CAST", "COUNT", "FALSE", 
					"MAX", "MIN", "NULL", "SUM", "TRUE", NUM_DECIMAL, 
					NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, STRING_LITERAL, 
					ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"AVG", "CASE", "CAST", "COUNT", "FALSE", 
					"MAX", "MIN", "NULL", "SUM", "TRUE", NUM_DECIMAL, 
					NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, STRING_LITERAL, 
					ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
				 }
			is matched.
			Rule Reference: sql92_unaryExpression
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ MODULO, SLASH, STAR }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ MODULO, SLASH, STAR }
					is matched.
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ MODULO, SLASH, STAR }
							This block has multiple alternatives:
								
								Alternate(1) will be taken IF:
								The lookahead set: 
									{ STAR }
								is matched.
								Match token STAR, label=m
								ACTION: #m->setType(TIMES);
								
								Otherwise, Alternate(2) will be taken IF:
								The lookahead set: 
									{ SLASH }
								is matched.
								Match token SLASH, label=d
								ACTION: #d->setType(DIVIDE);
								
								Otherwise, Alternate(3) will be taken IF:
								The lookahead set: 
									{ MODULO }
								is matched.
								Match token MODULO, label=mod
								ACTION: #mod->setType(MODULUS);
								
								OTHERWISE, a NoViableAlt exception will be thrown
								
							End of alternatives
						End of alternative block.
					Rule Reference: sql92_unaryExpression
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "ASC", "BEGIN", 
				"BETWEEN", "BREAK", "CONTINUE", "CROSS", "DECLARE", "DESC", 
				"ELSE", "END", "FROM", "FULL", "GROUP", "HAVING", 
				"IF", "IN", "INNER", "INTO", "IS", "JOIN", 
				"LEFT", "LIKE", "NOT", "ON", "OR", "ORDER", 
				"PRINT", "RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", 
				"THEN", "UNION", "WHEN", "WHERE", "WHILE", AMPERSAND, 
				EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, 
				GTEQ, CARET, COMMA, RPAREN, MINUS, PIPE, 
				PLUS, SEMI, ID
			 }
	*** End Parser Rule: sql92_multiplicativeExpression
	
	
	*** Parser Rule: sql92_unaryExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"AVG", "CASE", "CAST", "COUNT", "FALSE", 
					"MAX", "MIN", "NULL", "SUM", "TRUE", NUM_DECIMAL, 
					NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, STRING_LITERAL, 
					ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"AVG", "CASE", "CAST", "COUNT", "FALSE", 
					"MAX", "MIN", "NULL", "SUM", "TRUE", NUM_DECIMAL, 
					NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, STRING_LITERAL, 
					ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							"AVG", "CASE", "CAST", "COUNT", "FALSE", 
							"MAX", "MIN", "NULL", "SUM", "TRUE", NUM_DECIMAL, 
							NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, PLUS, STRING_LITERAL, 
							ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ PLUS }
						is matched.
						Match token PLUS, label=up
						ACTION: #up->setType(UNARY_PLUS);
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ MINUS }
						is matched.
						Match token MINUS, label=um
						ACTION: #um->setType(UNARY_MINUS);
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ TILDE }
						is matched.
						Match token TILDE, label=bnot
						ACTION: #bnot->setType(BNOT);
						
						Otherwise, Alternate(4) will be taken IF:
						The lookahead set: 
							{ 
								"AVG", "CASE", "CAST", "COUNT", "FALSE", 
								"MAX", "MIN", "NULL", "SUM", "TRUE", NUM_DECIMAL, 
								NUM_FLOAT, NUM_BIGINT, LPAREN, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, 
								ID, LOCALVAR, NUM_INT
							 }
						is matched.
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			Rule Reference: sql92_postfixExpression
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "ASC", "BEGIN", 
				"BETWEEN", "BREAK", "CONTINUE", "CROSS", "DECLARE", "DESC", 
				"ELSE", "END", "FROM", "FULL", "GROUP", "HAVING", 
				"IF", "IN", "INNER", "INTO", "IS", "JOIN", 
				"LEFT", "LIKE", "NOT", "ON", "OR", "ORDER", 
				"PRINT", "RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", 
				"THEN", "UNION", "WHEN", "WHERE", "WHILE", AMPERSAND, 
				EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, 
				GTEQ, MODULO, CARET, COMMA, RPAREN, MINUS, 
				PIPE, PLUS, SEMI, SLASH, STAR, ID
			 }
	*** End Parser Rule: sql92_unaryExpression
	
	
	*** Parser Rule: sql92_postfixExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"AVG", "CASE", "CAST", "COUNT", "FALSE", 
					"MAX", "MIN", "NULL", "SUM", "TRUE", NUM_DECIMAL, 
					NUM_FLOAT, NUM_BIGINT, LPAREN, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, 
					ID, LOCALVAR, NUM_INT
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					{ 
						"FALSE", "NULL", "TRUE", NUM_DECIMAL, NUM_FLOAT, 
						NUM_BIGINT, LPAREN, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, ID, 
						LOCALVAR, NUM_INT
					 }
				is matched.
				Rule Reference: sql92_primaryExpression
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ 
								EOF, "AND", "AS", "ASC", "BEGIN", 
								"BETWEEN", "BREAK", "CONTINUE", "CROSS", "DECLARE", "DESC", 
								"ELSE", "END", "FROM", "FULL", "GROUP", "HAVING", 
								"IF", "IN", "INNER", "INTO", "IS", "JOIN", 
								"LEFT", "LIKE", "NOT", "ON", "OR", "ORDER", 
								"PRINT", "RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", 
								"THEN", "UNION", "WHEN", "WHERE", "WHILE", AMPERSAND, 
								EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, 
								GTEQ, MODULO, CARET, COMMA, LPAREN, RPAREN, 
								MINUS, PIPE, PLUS, SEMI, SLASH, STAR, 
								ID
							 }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ LPAREN }
							is matched.
							Match token LPAREN, label=lp
							ACTION: #lp->setType(METHOD_CALL);
							Rule Reference: sql92_argList
							Match token RPAREN
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ 
									EOF, "AND", "AS", "ASC", "BEGIN", 
									"BETWEEN", "BREAK", "CONTINUE", "CROSS", "DECLARE", "DESC", 
									"ELSE", "END", "FROM", "FULL", "GROUP", "HAVING", 
									"IF", "IN", "INNER", "INTO", "IS", "JOIN", 
									"LEFT", "LIKE", "NOT", "ON", "OR", "ORDER", 
									"PRINT", "RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", 
									"THEN", "UNION", "WHEN", "WHERE", "WHILE", AMPERSAND, 
									EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, 
									GTEQ, MODULO, CARET, COMMA, RPAREN, MINUS, 
									PIPE, PLUS, SEMI, SLASH, STAR, ID
								 }
							is matched.
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					{ "COUNT" }
				is matched.
				Match token TK_COUNT
				Match token LPAREN
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ 
								"ALL", "AVG", "CASE", "CAST", "COUNT", 
								"DISTINCT", "EXISTS", "FALSE", "MAX", "MIN", "NOT", 
								"NULL", "SUM", "TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, 
								LPAREN, MINUS, PLUS, STAR, STRING_LITERAL, ENUM_LITERAL, 
								WSTRING_LITERAL, TILDE, ID, LOCALVAR, NUM_INT
							 }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ STAR }
							is matched.
							Match token STAR
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ 
									"ALL", "AVG", "CASE", "CAST", "COUNT", 
									"DISTINCT", "EXISTS", "FALSE", "MAX", "MIN", "NOT", 
									"NULL", "SUM", "TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, 
									LPAREN, MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, 
									TILDE, ID, LOCALVAR, NUM_INT
								 }
							is matched.
							Start of alternative block.
								Start of an alternative block.
									The lookahead set for this block is:
										{ 
											"ALL", "AVG", "CASE", "CAST", "COUNT", 
											"DISTINCT", "EXISTS", "FALSE", "MAX", "MIN", "NOT", 
											"NULL", "SUM", "TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, 
											LPAREN, MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, 
											TILDE, ID, LOCALVAR, NUM_INT
										 }
									This block has multiple alternatives:
										
										Alternate(1) will be taken IF:
										The lookahead set: 
											{ "DISTINCT" }
										is matched.
										Match token TK_DISTINCT
										
										Otherwise, Alternate(2) will be taken IF:
										The lookahead set: 
											{ "ALL" }
										is matched.
										Match token TK_ALL
										
										Otherwise, Alternate(3) will be taken IF:
										The lookahead set: 
											{ 
												"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
												"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
												"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
												PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
												LOCALVAR, NUM_INT
											 }
										is matched.
										
										OTHERWISE, a NoViableAlt exception will be thrown
										
									End of alternatives
								End of alternative block.
							Rule Reference: sql92_expression
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				Match token RPAREN
				
				Otherwise, Alternate(3) will be taken IF:
				The lookahead set: 
					{ "AVG" }
				is matched.
				Match token TK_AVG
				Match token LPAREN
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ 
								"ALL", "AVG", "CASE", "CAST", "COUNT", 
								"DISTINCT", "EXISTS", "FALSE", "MAX", "MIN", "NOT", 
								"NULL", "SUM", "TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, 
								LPAREN, MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, 
								TILDE, ID, LOCALVAR, NUM_INT
							 }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ 
								"ALL", "AVG", "CASE", "CAST", "COUNT", 
								"DISTINCT", "EXISTS", "FALSE", "MAX", "MIN", "NOT", 
								"NULL", "SUM", "TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, 
								LPAREN, MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, 
								TILDE, ID, LOCALVAR, NUM_INT
							 }
						is matched.
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										"ALL", "AVG", "CASE", "CAST", "COUNT", 
										"DISTINCT", "EXISTS", "FALSE", "MAX", "MIN", "NOT", 
										"NULL", "SUM", "TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, 
										LPAREN, MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, 
										TILDE, ID, LOCALVAR, NUM_INT
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ "DISTINCT" }
									is matched.
									Match token TK_DISTINCT
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ "ALL" }
									is matched.
									Match token TK_ALL
									
									Otherwise, Alternate(3) will be taken IF:
									The lookahead set: 
										{ 
											"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
											"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
											"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
											PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
											LOCALVAR, NUM_INT
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Rule Reference: sql92_expression
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				Match token RPAREN
				
				Otherwise, Alternate(4) will be taken IF:
				The lookahead set: 
					{ "MAX" }
				is matched.
				Match token TK_MAX
				Match token LPAREN
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ 
								"ALL", "AVG", "CASE", "CAST", "COUNT", 
								"DISTINCT", "EXISTS", "FALSE", "MAX", "MIN", "NOT", 
								"NULL", "SUM", "TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, 
								LPAREN, MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, 
								TILDE, ID, LOCALVAR, NUM_INT
							 }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ 
								"ALL", "AVG", "CASE", "CAST", "COUNT", 
								"DISTINCT", "EXISTS", "FALSE", "MAX", "MIN", "NOT", 
								"NULL", "SUM", "TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, 
								LPAREN, MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, 
								TILDE, ID, LOCALVAR, NUM_INT
							 }
						is matched.
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										"ALL", "AVG", "CASE", "CAST", "COUNT", 
										"DISTINCT", "EXISTS", "FALSE", "MAX", "MIN", "NOT", 
										"NULL", "SUM", "TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, 
										LPAREN, MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, 
										TILDE, ID, LOCALVAR, NUM_INT
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ "DISTINCT" }
									is matched.
									Match token TK_DISTINCT
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ "ALL" }
									is matched.
									Match token TK_ALL
									
									Otherwise, Alternate(3) will be taken IF:
									The lookahead set: 
										{ 
											"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
											"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
											"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
											PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
											LOCALVAR, NUM_INT
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Rule Reference: sql92_expression
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				Match token RPAREN
				
				Otherwise, Alternate(5) will be taken IF:
				The lookahead set: 
					{ "MIN" }
				is matched.
				Match token TK_MIN
				Match token LPAREN
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ 
								"ALL", "AVG", "CASE", "CAST", "COUNT", 
								"DISTINCT", "EXISTS", "FALSE", "MAX", "MIN", "NOT", 
								"NULL", "SUM", "TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, 
								LPAREN, MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, 
								TILDE, ID, LOCALVAR, NUM_INT
							 }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ 
								"ALL", "AVG", "CASE", "CAST", "COUNT", 
								"DISTINCT", "EXISTS", "FALSE", "MAX", "MIN", "NOT", 
								"NULL", "SUM", "TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, 
								LPAREN, MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, 
								TILDE, ID, LOCALVAR, NUM_INT
							 }
						is matched.
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										"ALL", "AVG", "CASE", "CAST", "COUNT", 
										"DISTINCT", "EXISTS", "FALSE", "MAX", "MIN", "NOT", 
										"NULL", "SUM", "TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, 
										LPAREN, MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, 
										TILDE, ID, LOCALVAR, NUM_INT
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ "DISTINCT" }
									is matched.
									Match token TK_DISTINCT
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ "ALL" }
									is matched.
									Match token TK_ALL
									
									Otherwise, Alternate(3) will be taken IF:
									The lookahead set: 
										{ 
											"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
											"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
											"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
											PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
											LOCALVAR, NUM_INT
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Rule Reference: sql92_expression
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				Match token RPAREN
				
				Otherwise, Alternate(6) will be taken IF:
				The lookahead set: 
					{ "SUM" }
				is matched.
				Match token TK_SUM
				Match token LPAREN
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ 
								"ALL", "AVG", "CASE", "CAST", "COUNT", 
								"DISTINCT", "EXISTS", "FALSE", "MAX", "MIN", "NOT", 
								"NULL", "SUM", "TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, 
								LPAREN, MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, 
								TILDE, ID, LOCALVAR, NUM_INT
							 }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ 
								"ALL", "AVG", "CASE", "CAST", "COUNT", 
								"DISTINCT", "EXISTS", "FALSE", "MAX", "MIN", "NOT", 
								"NULL", "SUM", "TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, 
								LPAREN, MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, 
								TILDE, ID, LOCALVAR, NUM_INT
							 }
						is matched.
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										"ALL", "AVG", "CASE", "CAST", "COUNT", 
										"DISTINCT", "EXISTS", "FALSE", "MAX", "MIN", "NOT", 
										"NULL", "SUM", "TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, 
										LPAREN, MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, 
										TILDE, ID, LOCALVAR, NUM_INT
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ "DISTINCT" }
									is matched.
									Match token TK_DISTINCT
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ "ALL" }
									is matched.
									Match token TK_ALL
									
									Otherwise, Alternate(3) will be taken IF:
									The lookahead set: 
										{ 
											"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
											"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
											"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
											PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
											LOCALVAR, NUM_INT
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						Rule Reference: sql92_expression
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				Match token RPAREN
				
				Otherwise, Alternate(7) will be taken IF:
				The lookahead set: 
					{ "CAST" }
				is matched.
				Rule Reference: sql92_castExpression
				
				Otherwise, Alternate(8) will be taken IF:
				The lookahead set: 
					{ "CASE" }
				is matched.
				Rule Reference: sql92_caseExpression
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "ASC", "BEGIN", 
				"BETWEEN", "BREAK", "CONTINUE", "CROSS", "DECLARE", "DESC", 
				"ELSE", "END", "FROM", "FULL", "GROUP", "HAVING", 
				"IF", "IN", "INNER", "INTO", "IS", "JOIN", 
				"LEFT", "LIKE", "NOT", "ON", "OR", "ORDER", 
				"PRINT", "RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", 
				"THEN", "UNION", "WHEN", "WHERE", "WHILE", AMPERSAND, 
				EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, 
				GTEQ, MODULO, CARET, COMMA, RPAREN, MINUS, 
				PIPE, PLUS, SEMI, SLASH, STAR, ID
			 }
	*** End Parser Rule: sql92_postfixExpression
	
	
	*** Parser Rule: sql92_primaryExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"FALSE", "NULL", "TRUE", NUM_DECIMAL, NUM_FLOAT, 
					NUM_BIGINT, LPAREN, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, ID, 
					LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"FALSE", "NULL", "TRUE", NUM_DECIMAL, NUM_FLOAT, 
					NUM_BIGINT, LPAREN, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, ID, 
					LOCALVAR, NUM_INT
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						k==1: {
							"FALSE", "NULL", "TRUE", NUM_DECIMAL, NUM_FLOAT, 
							NUM_BIGINT, LPAREN, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, ID, 
							LOCALVAR, NUM_INT
						 }
						k==2: {
							EOF, "AND", "AS", "ASC", "AVG", 
							"BEGIN", "BETWEEN", "BREAK", "CASE", "CAST", "CONTINUE", 
							"COUNT", "CROSS", "DECLARE", "DESC", "ELSE", "END", 
							"EXISTS", "FALSE", "FROM", "FULL", "GROUP", "HAVING", 
							"IF", "IN", "INNER", "INTO", "IS", "JOIN", 
							"LEFT", "LIKE", "MAX", "MIN", "NOT", "NULL", 
							"ON", "OR", "ORDER", "PRINT", "RAISERROR", "RETURN", 
							"RIGHT", "SELECT", "SET", "SUM", "THEN", "TRUE", 
							"UNION", "WHEN", "WHERE", "WHILE", NUM_DECIMAL, NUM_FLOAT, 
							NUM_BIGINT, AMPERSAND, EQUALS, NOTEQUALS, NOTEQUALS2, LTN, 
							LTEQ, GT, GTEQ, MODULO, CARET, COMMA, 
							DOT, LPAREN, RPAREN, MINUS, PIPE, PLUS, 
							SEMI, SLASH, STAR, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, 
							TILDE, ID, LOCALVAR, NUM_INT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ NUM_INT }
						is matched.
						Match token NUM_INT
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ NUM_BIGINT }
						is matched.
						Match token NUM_BIGINT
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ NUM_FLOAT }
						is matched.
						Match token NUM_FLOAT
						
						Otherwise, Alternate(4) will be taken IF:
						The lookahead set: 
							{ NUM_DECIMAL }
						is matched.
						Match token NUM_DECIMAL
						
						Otherwise, Alternate(5) will be taken IF:
						The lookahead set: 
							{ STRING_LITERAL }
						is matched.
						Match token STRING_LITERAL, label=sl
						
						Otherwise, Alternate(6) will be taken IF:
						The lookahead set: 
							{ ENUM_LITERAL }
						is matched.
						Match token ENUM_LITERAL, label=el
						ACTION: 
										// Strip of the leading and the trailing delimeters.  Store the
						// FQN.  This will be converted to an integer during semantic analysis.
										#el->setText(#el->getText().substr(1, #el->getText().length()-2)); 
									
						
						Otherwise, Alternate(7) will be taken IF:
						The lookahead set: 
							{ WSTRING_LITERAL }
						is matched.
						Match token WSTRING_LITERAL, label=wsl
						
						Otherwise, Alternate(8) will be taken IF:
						The lookahead set: 
							{ "TRUE" }
						is matched.
						Match token TK_TRUE
						
						Otherwise, Alternate(9) will be taken IF:
						The lookahead set: 
							{ "FALSE" }
						is matched.
						Match token TK_FALSE
						
						Otherwise, Alternate(10) will be taken IF:
						The lookahead set: 
							{ ID }
						is matched.
						Match token ID
						Start of alternative block.
							Start of an alternative block.
								The lookahead set for this block is:
									{ 
										EOF, "AND", "AS", "ASC", "BEGIN", 
										"BETWEEN", "BREAK", "CONTINUE", "CROSS", "DECLARE", "DESC", 
										"ELSE", "END", "FROM", "FULL", "GROUP", "HAVING", 
										"IF", "IN", "INNER", "INTO", "IS", "JOIN", 
										"LEFT", "LIKE", "NOT", "ON", "OR", "ORDER", 
										"PRINT", "RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", 
										"THEN", "UNION", "WHEN", "WHERE", "WHILE", AMPERSAND, 
										EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, 
										GTEQ, MODULO, CARET, COMMA, DOT, LPAREN, 
										RPAREN, MINUS, PIPE, PLUS, SEMI, SLASH, 
										STAR, ID
									 }
								This block has multiple alternatives:
									
									Alternate(1) will be taken IF:
									The lookahead set: 
										{ DOT }
									is matched.
									Match token DOT
									Match token ID
									
									Otherwise, Alternate(2) will be taken IF:
									The lookahead set: 
										{ 
											EOF, "AND", "AS", "ASC", "BEGIN", 
											"BETWEEN", "BREAK", "CONTINUE", "CROSS", "DECLARE", "DESC", 
											"ELSE", "END", "FROM", "FULL", "GROUP", "HAVING", 
											"IF", "IN", "INNER", "INTO", "IS", "JOIN", 
											"LEFT", "LIKE", "NOT", "ON", "OR", "ORDER", 
											"PRINT", "RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", 
											"THEN", "UNION", "WHEN", "WHERE", "WHILE", AMPERSAND, 
											EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, 
											GTEQ, MODULO, CARET, COMMA, LPAREN, RPAREN, 
											MINUS, PIPE, PLUS, SEMI, SLASH, STAR, 
											ID
										 }
									is matched.
									
									OTHERWISE, a NoViableAlt exception will be thrown
									
								End of alternatives
							End of alternative block.
						
						Otherwise, Alternate(11) will be taken IF:
						The lookahead set: 
							{ LOCALVAR }
						is matched.
						Match token LOCALVAR
						
						Otherwise, Alternate(12) will be taken IF:
						The lookahead set: 
							{ "NULL" }
						is matched.
						Match token TK_NULL
						
						Otherwise, Alternate(13) will be taken IF:
						The lookahead set: 
							k==1: {LPAREN }
							k==2: {
								"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
								"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
								"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
								PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
								LOCALVAR, NUM_INT
							 }
						is matched.
						Match token LPAREN
						Rule Reference: sql92_expression
						Match token RPAREN
						
						Otherwise, Alternate(14) will be taken IF:
						The lookahead set: 
							k==1: {LPAREN }
							k==2: {"SELECT" }
						is matched.
						Match token LPAREN, label=lp
						Rule Reference: sql92_selectStatement
						Match token RPAREN
						ACTION: #lp->setType(SCALAR_SUBQUERY);
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "ASC", "BEGIN", 
				"BETWEEN", "BREAK", "CONTINUE", "CROSS", "DECLARE", "DESC", 
				"ELSE", "END", "FROM", "FULL", "GROUP", "HAVING", 
				"IF", "IN", "INNER", "INTO", "IS", "JOIN", 
				"LEFT", "LIKE", "NOT", "ON", "OR", "ORDER", 
				"PRINT", "RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", 
				"THEN", "UNION", "WHEN", "WHERE", "WHILE", AMPERSAND, 
				EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, 
				GTEQ, MODULO, CARET, COMMA, LPAREN, RPAREN, 
				MINUS, PIPE, PLUS, SEMI, SLASH, STAR, 
				ID
			 }
	*** End Parser Rule: sql92_primaryExpression
	
	
	*** Parser Rule: sql92_argList
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, RPAREN, 
					MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, 
					ID, LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, RPAREN, 
					MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, 
					ID, LOCALVAR, NUM_INT
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
							"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
							"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, RPAREN, 
							MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, 
							ID, LOCALVAR, NUM_INT
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ 
								"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
								"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
								"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
								PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
								LOCALVAR, NUM_INT
							 }
						is matched.
						Rule Reference: sql92_expressionList
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ RPAREN }
						is matched.
						ACTION: #sql92_argList = #[ELIST, "ELIST"];
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN }
	*** End Parser Rule: sql92_argList
	
	
	*** Parser Rule: sql92_castExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "CAST" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "CAST" }
			is matched.
			Match token TK_CAST
			Match token LPAREN
			Rule Reference: sql92_expression
			Match token TK_AS
			Rule Reference: sql92_builtInType
			Match token RPAREN
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "ASC", "BEGIN", 
				"BETWEEN", "BREAK", "CONTINUE", "CROSS", "DECLARE", "DESC", 
				"ELSE", "END", "FROM", "FULL", "GROUP", "HAVING", 
				"IF", "IN", "INNER", "INTO", "IS", "JOIN", 
				"LEFT", "LIKE", "NOT", "ON", "OR", "ORDER", 
				"PRINT", "RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", 
				"THEN", "UNION", "WHEN", "WHERE", "WHILE", AMPERSAND, 
				EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, 
				GTEQ, MODULO, CARET, COMMA, RPAREN, MINUS, 
				PIPE, PLUS, SEMI, SLASH, STAR, ID
			 }
	*** End Parser Rule: sql92_castExpression
	
	
	*** Parser Rule: sql92_caseExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				k==1: {"CASE" }
				k==2: {
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
					"TRUE", "WHEN", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, 
					MINUS, PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, 
					ID, LOCALVAR, NUM_INT
				 }
			This block has multiple alternatives:
				
				Alternate(1) will be taken IF:
				The lookahead set: 
					k==1: {"CASE" }
					k==2: {"WHEN" }
				is matched, AND the syntactic predicate:
					Start of alternative block.
						Start of an alternative block.
							The lookahead set for this block is:
								{ "CASE" }
							This block has a single alternative
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ "CASE" }
							is matched.
							Match token TK_CASE
							Match token TK_WHEN
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternative block.
				is matched.
				Match token TK_CASE, label=simple
				ACTION: #simple->setType(SIMPLE_CASE);
				Start ONE-OR-MORE (...)+ block:
					Start of an alternative block.
						The lookahead set for this block is:
							{ "WHEN" }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "WHEN" }
						is matched.
						Rule Reference: sql92_whenExpression, arguments = true
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				End ONE-OR-MORE block.
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ "ELSE", "END" }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ "ELSE" }
							is matched.
							Rule Reference: sql92_elseExpression
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ "END" }
							is matched.
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				Match token TK_END
				
				Otherwise, Alternate(2) will be taken IF:
				The lookahead set: 
					k==1: {"CASE" }
					k==2: {
						"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
						"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
						"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
						PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
						LOCALVAR, NUM_INT
					 }
				is matched.
				Match token TK_CASE, label=search
				ACTION: #search->setType(SEARCHED_CASE);
				Rule Reference: sql92_weakExpression
				Start ONE-OR-MORE (...)+ block:
					Start of an alternative block.
						The lookahead set for this block is:
							{ "WHEN" }
						This block has a single alternative
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "WHEN" }
						is matched.
						Rule Reference: sql92_whenExpression, arguments = false
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternative block.
				End ONE-OR-MORE block.
				Start of alternative block.
					Start of an alternative block.
						The lookahead set for this block is:
							{ "ELSE", "END" }
						This block has multiple alternatives:
							
							Alternate(1) will be taken IF:
							The lookahead set: 
								{ "ELSE" }
							is matched.
							Rule Reference: sql92_elseExpression
							
							Otherwise, Alternate(2) will be taken IF:
							The lookahead set: 
								{ "END" }
							is matched.
							
							OTHERWISE, a NoViableAlt exception will be thrown
							
						End of alternatives
					End of alternative block.
				Match token TK_END
				
				OTHERWISE, a NoViableAlt exception will be thrown
				
			End of alternatives
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {
				EOF, "AND", "AS", "ASC", "BEGIN", 
				"BETWEEN", "BREAK", "CONTINUE", "CROSS", "DECLARE", "DESC", 
				"ELSE", "END", "FROM", "FULL", "GROUP", "HAVING", 
				"IF", "IN", "INNER", "INTO", "IS", "JOIN", 
				"LEFT", "LIKE", "NOT", "ON", "OR", "ORDER", 
				"PRINT", "RAISERROR", "RETURN", "RIGHT", "SELECT", "SET", 
				"THEN", "UNION", "WHEN", "WHERE", "WHILE", AMPERSAND, 
				EQUALS, NOTEQUALS, NOTEQUALS2, LTN, LTEQ, GT, 
				GTEQ, MODULO, CARET, COMMA, RPAREN, MINUS, 
				PIPE, PLUS, SEMI, SLASH, STAR, ID
			 }
	*** End Parser Rule: sql92_caseExpression
	
	
	*** Parser Rule: sql92_whenExpression
		Access: public
		Return value: none
		Arguments: bool isSimple
		Start of an alternative block.
			The lookahead set for this block is:
				{ "WHEN" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "WHEN" }
			is matched.
			Match token TK_WHEN, label=tkw
			ACTION: if (isSimple) #tkw->setType(SIMPLE_WHEN);
			Rule Reference: sql92_weakExpression
			Match token TK_THEN
			Rule Reference: sql92_weakExpression
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {"ELSE", "END", "WHEN" }
	*** End Parser Rule: sql92_whenExpression
	
	
	*** Parser Rule: sql92_elseExpression
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ "ELSE" }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ "ELSE" }
			is matched.
			Match token TK_ELSE
			Rule Reference: sql92_weakExpression
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {"END" }
	*** End Parser Rule: sql92_elseExpression
	
	
	*** Parser Rule: sql92_builtInType
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"BIGINT", "CHAR", "DATETIME", "DECIMAL", "DOUBLE", 
					"INTEGER", "NVARCHAR", "VARCHAR"
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"BIGINT", "CHAR", "DATETIME", "DECIMAL", "DOUBLE", 
					"INTEGER", "NVARCHAR", "VARCHAR"
				 }
			is matched.
			Start of alternative block.
				Start of an alternative block.
					The lookahead set for this block is:
						{ 
							"BIGINT", "CHAR", "DATETIME", "DECIMAL", "DOUBLE", 
							"INTEGER", "NVARCHAR", "VARCHAR"
						 }
					This block has multiple alternatives:
						
						Alternate(1) will be taken IF:
						The lookahead set: 
							{ "INTEGER" }
						is matched.
						Match token TK_INTEGER, label=i
						ACTION: #i->setType(BUILTIN_TYPE);
						
						Otherwise, Alternate(2) will be taken IF:
						The lookahead set: 
							{ "CHAR" }
						is matched.
						Match token TK_CHAR, label=chr
						Match token LPAREN
						Match token NUM_INT
						Match token RPAREN
						ACTION: #chr->setType(BUILTIN_TYPE);
						
						Otherwise, Alternate(3) will be taken IF:
						The lookahead set: 
							{ "DOUBLE" }
						is matched.
						Match token TK_DOUBLE, label=dbl
						Match token TK_PRECISION
						ACTION: #dbl->setType(BUILTIN_TYPE);
						
						Otherwise, Alternate(4) will be taken IF:
						The lookahead set: 
							{ "VARCHAR" }
						is matched.
						Match token TK_VARCHAR, label=str
						Match token LPAREN
						Match token NUM_INT
						Match token RPAREN
						ACTION: #str->setType(BUILTIN_TYPE);
						
						Otherwise, Alternate(5) will be taken IF:
						The lookahead set: 
							{ "NVARCHAR" }
						is matched.
						Match token TK_NVARCHAR, label=wstr
						Match token LPAREN
						Match token NUM_INT
						Match token RPAREN
						ACTION: #wstr->setType(BUILTIN_TYPE);
						
						Otherwise, Alternate(6) will be taken IF:
						The lookahead set: 
							{ "DECIMAL" }
						is matched.
						Match token TK_DECIMAL, label=dec
						Match token LPAREN
						Match token NUM_INT
						Match token RPAREN
						ACTION: #dec->setType(BUILTIN_TYPE);
						
						Otherwise, Alternate(7) will be taken IF:
						The lookahead set: 
							{ "DATETIME" }
						is matched.
						Match token TK_DATETIME, label=dt
						ACTION: #dt->setType(BUILTIN_TYPE);
						
						Otherwise, Alternate(8) will be taken IF:
						The lookahead set: 
							{ "BIGINT" }
						is matched.
						Match token TK_BIGINT, label=bi
						ACTION: #bi->setType(BUILTIN_TYPE);
						
						OTHERWISE, a NoViableAlt exception will be thrown
						
					End of alternatives
				End of alternative block.
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN }
	*** End Parser Rule: sql92_builtInType
	
	
	*** Parser Rule: sql92_expressionList
		Access: public
		Return value: none
		Start of an alternative block.
			The lookahead set for this block is:
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			This block has a single alternative
			
			Alternate(1) will be taken IF:
			The lookahead set: 
				{ 
					"AVG", "CASE", "CAST", "COUNT", "EXISTS", 
					"FALSE", "MAX", "MIN", "NOT", "NULL", "SUM", 
					"TRUE", NUM_DECIMAL, NUM_FLOAT, NUM_BIGINT, LPAREN, MINUS, 
					PLUS, STRING_LITERAL, ENUM_LITERAL, WSTRING_LITERAL, TILDE, ID, 
					LOCALVAR, NUM_INT
				 }
			is matched.
			Rule Reference: sql92_expression
			Start ZERO-OR-MORE (...)+ block:
				Start of an alternative block.
					The lookahead set for this block is:
						{ COMMA }
					This block has a single alternative
					
					Alternate(1) will be taken IF:
					The lookahead set: 
						{ COMMA }
					is matched.
					Match token COMMA
					Rule Reference: sql92_expression
					
					OTHERWISE, a NoViableAlt exception will be thrown
					
				End of alternative block.
			End ZERO-OR-MORE block.
			ACTION: #sql92_expressionList = #(#[ELIST,"ELIST"], sql92_expressionList);
			
			OTHERWISE, a NoViableAlt exception will be thrown
			
		End of alternative block.
		Default error-handling will be generated, which catches all
		parser exceptions and consumes tokens until the follow-set is seen.
		The follow set for this rule is:
			k==1: {RPAREN }
	*** End Parser Rule: sql92_expressionList

*** End of parser rules

*** End of parser
