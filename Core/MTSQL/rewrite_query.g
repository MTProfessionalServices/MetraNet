header {
#include "RuntimeValue.h"
#include "Environment.h"
#include "MTSQLAST.h"
#include "MTSQLException.h"
#include "MTSQLSemanticException.h"
#include "antlr/SemanticException.hpp"
#include <stdio.h>
}
options {
	language = "Cpp";
}
class RewriteTreeParser extends TreeParser;
options {
	importVocab=MTSQLTreeParser; // use vocab generated by tree parser
	buildAST = true;
  analyzerDebug = false;
    defaultErrorHandler = false;
}
{
  static int getType(std::string name)
  {
	if(name == "INTEGER") return RuntimeValue::TYPE_INTEGER;
	if(name == "BIGINT") return RuntimeValue::TYPE_BIGINTEGER;
	if(name == "DOUBLE") return RuntimeValue::TYPE_DOUBLE;
	if(name == "VARCHAR") return RuntimeValue::TYPE_STRING;
	if(name == "NVARCHAR") return RuntimeValue::TYPE_WSTRING;
	if(name == "DECIMAL") return RuntimeValue::TYPE_DECIMAL;
	if(name == "BOOLEAN") return RuntimeValue::TYPE_BOOLEAN;
	if(name == "DATETIME") return RuntimeValue::TYPE_DATETIME;
	if(name == "TIME") return RuntimeValue::TYPE_TIME;
	if(name == "ENUM") return RuntimeValue::TYPE_ENUM;
	throw MTSQLInternalErrorException(__FILE__, __LINE__, "Unknown type");
  }

  public:  virtual void initialize(const std::string& tempTableName, const std::string& tagName)
  {
    mNextAlias = 0;
    // Trim whitespace of the beginning and end of the table name.
    std::string::size_type fpos = tempTableName.find_first_not_of("\n\t\r ");
    if(fpos == std::string::npos) throw MTSQLInternalErrorException(__FILE__, __LINE__, "Argument table name must be non-empty");
    std::string::size_type lpos = tempTableName.find_last_not_of("\n\t\r ");
    if(lpos == std::string::npos) throw MTSQLInternalErrorException(__FILE__, __LINE__, "Argument table name must be non-empty");
    mTempTableName = tempTableName.substr(fpos, lpos-fpos+1);
    // Append the uniquifying tag (e.g. pluginname_hostname)
    mTempTableName += "_";
    mTempTableName += tagName;
  }
  private: int mNextAlias;
  private: std::stack<int> mNesting;
  private: std::string getCurrentAlias()
  {
    char buf[32];
    sprintf(buf, "%d", mNesting.top());
    return std::string("tmp") + std::string(buf);
  }

  private: std::string mTempTableName;
  public: virtual std::string getTempTableName()
  {
    return mTempTableName;
  }
  public: bool isTempTable()
  {
    // If the first non-whitespace character is # then
    // we have a temp table (SQL Server only).
    return getTempTableName()[0] == '#' ? true : false;
  }

  private: void pushNestingLevel()
  {
    mNesting.push(mNextAlias++);
  }
  private: void popNestingLevel()
  {
    mNesting.pop();
  }

  // 
  private: ANTLR_USE_NAMESPACE(antlr)RefAST mWhereClause;
  private: void pushWhereClause(ANTLR_USE_NAMESPACE(antlr)RefAST ast)
  {
    if(mWhereClause == ANTLR_USE_NAMESPACE(antlr)RefAST(NULL))
    {
      mWhereClause = ast;
    }
    else
    {
      mWhereClause = #([LAND, " AND "], mWhereClause, ast);
    }
  }

  private: ANTLR_USE_NAMESPACE(antlr)RefAST getWhereClause()
  {
    return mWhereClause;
  }
 
  private: void clearWhereClause()
  {
    mWhereClause = ANTLR_USE_NAMESPACE(antlr)RefAST(NULL);
  }

  private: map<int, int> mAggregateCount;
  private: void incrementAggregateCount()
  {
    mAggregateCount[mNesting.top()]++;
  }
  private: int getAggregateCount()
  {
    return mAggregateCount[mNesting.top()];
  }

  private: map<int, int> mSelectListExprCount;
  private: void incrementSelectListExprCount()
  {
    mSelectListExprCount[mNesting.top()]++;
  }
  private: int getSelectListExprCount()
  {
    return mSelectListExprCount[mNesting.top()];
  }

  // Variable Management (symbol tables are needed for datatypes)
  public: void setEnvironment(Environment * env)
  {
    mEnv = env;
  }
  private: Environment* mEnv;
  private: std::map<std::string, VarEntryPtr> mVariables;

  private: void referenceVariable(RefMTSQLAST ast)
  {
    if(mVariables.find(ast->getText()) == mVariables.end())
    {
      VarEntryPtr vep = mEnv->lookupVar(ast->getText());
      if (VarEntryPtr() == vep) throw MTSQLSemanticException("Undefined Variable: " + ast->getText(), ast);
      mVariables[ast->getText()] = vep;
    }
  }

  public: std::vector<std::string> getVariables()
  {
    std::vector<std::string> v;
    for(std::map<std::string, VarEntryPtr>::iterator it = mVariables.begin(); it != mVariables.end(); it++)
    {
      v.push_back(it->first);
    }
    return v;
  }

  private: std::string getType(int type)
  {
    switch(type)
    {
       case RuntimeValue::TYPE_INTEGER:
       return "INTEGER";
       case RuntimeValue::TYPE_BIGINTEGER:
       return "BIGINT";
       case RuntimeValue::TYPE_DOUBLE:
       return "DOUBLE PRECISION";
       case RuntimeValue::TYPE_STRING:
       return "VARCHAR(256)";
       case RuntimeValue::TYPE_WSTRING:
       return "NVARCHAR(256)";
       case RuntimeValue::TYPE_DECIMAL:
       return "DECIMAL(22,10)";
       case RuntimeValue::TYPE_BOOLEAN:
       return "CHAR(1)";
       case RuntimeValue::TYPE_DATETIME:
       return "DATETIME";
       case RuntimeValue::TYPE_TIME:
       return "DATETIME";
       case RuntimeValue::TYPE_ENUM:
       return "INTEGER";
       default:
       throw MTSQLInternalErrorException(__FILE__, __LINE__, "Unknown type");
    }
  }

  private: std::string getTempColumn(const std::string& param)
  {
    // Remove the leading @ and then tack on some stuff that
    // will be unique for the temp table (we don't want to have
    // temp table columns with the same name as base tables because
    // this would force us to create aliases for base tables).
    return param.substr(1, param.length()-1) + "$#";
  }

  private: std::vector<VarEntryPtr> mOutputVariables;
  private: void pushOutput(ANTLR_USE_NAMESPACE(antlr)RefAST ast)
  {
    VarEntryPtr vep = mEnv->lookupVar(((RefMTSQLAST) ast)->getText());
    mOutputVariables.push_back(vep);
  }
  public: virtual void getTempTable(std::string& buf, std::string& insert, std::vector<VarEntryPtr>& params, std::vector<VarEntryPtr>& outputs)
  {
    outputs = mOutputVariables;
    std::string values;
    buf.append("if object_id('");
    if(isTempTable()) buf.append("tempdb..");
    buf.append(getTempTableName() + "') is not null\n  DROP TABLE " + getTempTableName());
    buf.append("\nCREATE TABLE " + getTempTableName() +  " (");
    insert.append("INSERT INTO " + getTempTableName() +  " (");
    values.append(" VALUES (");
    int pos = 0;
    for(std::map<std::string, VarEntryPtr>::iterator it = mVariables.begin(); it != mVariables.end(); it++ )
    {
      if(pos != 0)
      {
        buf.append(", ");
        insert.append(", ");
        values.append(", ");
      }
      params.push_back(it->second);
      buf.append(getTempColumn(it->first));
      buf.append(" ");
      buf.append(getType(it->second->getType()));
      insert.append(getTempColumn(it->first));
	    char buf2 [32];
	    sprintf(buf2, "%%%%%d%%%%", pos);
      values.append(buf2);
      pos++;
    }
    if(pos > 0)
    {
      buf.append(", ");
    }
    buf.append("requestid INTEGER NOT NULL PRIMARY KEY");
    buf.append(")");
  
    insert.append(")");
    values.append(")");
    insert.append(values);
  }
  
  private: Logger* mLog;
  public: virtual void setLog(Logger * log)
  {
	  mLog = log;
  }
  
  private: vector<MTSQLParam> mParams;
  public: virtual vector<MTSQLParam> getParams() 
	{
		return mParams;
	}
	
	virtual void initASTFactory( ANTLR_USE_NAMESPACE(antlr)ASTFactory& factory )
  {
    initializeASTFactory(factory);
  }
}

mtsql_selectStatement
  :
  #(QUERY sql92_selectStatement mtsql_paramList mtsql_intoList) 
  ;

mtsql_paramList
  :
  #(ARRAY (INTEGER_GETMEM|DECIMAL_GETMEM|DOUBLE_GETMEM|STRING_GETMEM|WSTRING_GETMEM|BOOLEAN_GETMEM|DATETIME_GETMEM|TIME_GETMEM|ENUM_GETMEM|BIGINT_GETMEM)*)
  ;

mtsql_intoList
  :
  #(TK_INTO (mtsql_intoVarRef)+)
  ;

mtsql_intoVarRef
  :
  #(INTEGER_SETMEM_QUERY LOCALVAR) { pushOutput(#LOCALVAR); }
  |
  #(BIGINT_SETMEM_QUERY LOCALVAR) { pushOutput(#LOCALVAR); }
  |
  #(DECIMAL_SETMEM_QUERY LOCALVAR) { pushOutput(#LOCALVAR); }
  |
  #(DOUBLE_SETMEM_QUERY LOCALVAR) { pushOutput(#LOCALVAR); }
  |
  #(STRING_SETMEM_QUERY LOCALVAR) { pushOutput(#LOCALVAR); }
  |
  #(WSTRING_SETMEM_QUERY LOCALVAR) { pushOutput(#LOCALVAR); }
  |
  #(BOOLEAN_SETMEM_QUERY LOCALVAR) { pushOutput(#LOCALVAR); }
  |
  #(DATETIME_SETMEM_QUERY LOCALVAR) { pushOutput(#LOCALVAR); }
  |
  #(TIME_SETMEM_QUERY LOCALVAR) { pushOutput(#LOCALVAR); }
  |
  #(ENUM_SETMEM_QUERY LOCALVAR) { pushOutput(#LOCALVAR); }
  ;

sql92_selectStatement
  :
  sql92_querySpecification (TK_UNION (TK_ALL)? sql92_querySpecification)* 
  (TK_ORDER TK_BY sql92_orderByExpression { throw MTSQLSemanticException("ORDER BY not supported in batch queries", (RefMTSQLAST)##); })?
  ;

sql92_orderByExpression
  :
	sql92_expr (TK_ASC | TK_DESC)? (COMMA sql92_expr (TK_ASC | TK_DESC)? )*
  ;

sql92_querySpecification
  :
  {
    bool hasWhere = false;
    bool hasGroupBy = false;
    bool allAggregates = false;
    pushNestingLevel();
  }
  #(TK_SELECT (TK_ALL | TK_DISTINCT)?
    sql92_selectList
    {
      if (getAggregateCount() == getSelectListExprCount())
        allAggregates = true;
    }
    sql92_fromClause 
    (w:sql92_whereClause { hasWhere = true; })? 
    {
      if(getWhereClause() != ANTLR_USE_NAMESPACE(antlr)RefAST(NULL))
      {
        getASTFactory()->addASTChild(currentAST, #([TK_WHERE, " WHERE "], getWhereClause()));
        clearWhereClause();
      }
    }
    (sql92_groupByClause { hasGroupBy = true; })?
    {
      // adds an implicit GROUP BY for queries that don't have their own (CR10840)
      if (!hasGroupBy && allAggregates)
      {
        std::string aliasedColumn = getCurrentAlias() + ".requestid ";
        getASTFactory()->addASTChild(currentAST, #([TK_GROUP, " GROUP "], [TK_BY, " BY "], ([ID, aliasedColumn])));
      }
    }
  )
  {
    popNestingLevel();
  }
  ;

sql92_selectList
  :
  #(SELECT_LIST 
            (
                STAR { incrementSelectListExprCount(); } 
                |
                sql92_expression { incrementSelectListExprCount(); } (ALIAS)? 
                    (COMMA sql92_expression { incrementSelectListExprCount(); } (ALIAS)? )*
            )
  {
    std::string aliasedColumn = getCurrentAlias() + ".requestid ";
    getASTFactory()->addASTChild(currentAST, #([COMMA, ", "]));
    getASTFactory()->addASTChild(currentAST, #([EXPR, "EXPR"], ([ID, aliasedColumn], ##)));
  }
  )
  ;

sql92_fromClause
  :
  #(TK_FROM sql92_tableSpecification (COMMA sql92_tableSpecification)*
  {
    std::string alias = getCurrentAlias() + " WITH(READCOMMITTED) ";
    std::string table = getTempTableName() + " ";
    getASTFactory()->addASTChild(currentAST, #([COMMA, ", "]));
    getASTFactory()->addASTChild(currentAST, #([TABLE_REF, table], ([ALIAS, alias], ##))); 
  }
  )
  ;

sql92_nestedSelectStatement
  :
  #(TK_SELECT (TK_ALL | TK_DISTINCT)? sql92_nestedSelectList sql92_nestedFromClause (sql92_whereClause)? (sql92_nestedGroupByClause)?)
  ;

sql92_nestedSelectList
  :
  #(SELECT_LIST 
            (
                STAR { incrementSelectListExprCount(); } 
                |
                sql92_expression { incrementSelectListExprCount(); } (ALIAS)? 
                    (COMMA sql92_expression { incrementSelectListExprCount(); } (ALIAS)? )*
            )
   )
  ;

sql92_nestedFromClause
  :
  #(TK_FROM sql92_tableSpecification (COMMA sql92_tableSpecification)*)
  ;

sql92_tableSpecification
  :
  // We must handle the case of forced join order.
  // Example:
  // SELECT * FROM t_A INNER JOIN t_B LEFT OUTER JOIN t_C ON t_B.id_c=t_C.id_c AND t_C.foo=@foo ON t_A.id_b=t_B.id_b
  //
  // The trick here is that one has a nested scope with the join between t_B and t_C
  // and they cannot be correlated subqueries.  Therefore, we need to introduce the temp table
  // at the inner "scope":
  // SELECT * FROM t_A INNER JOIN #tmp_args tmp1 CROSS JOIN t_B LEFT OUTER JOIN t_C ON t_B.id_c=t_C.id_c AND t_C.foo=tmp1.foo ON t_A.id_b=t_B.id_b
  // Note the syntactic consideration here; since we are using SQL-92 JOIN syntax, we
  // have to specify a CROSS JOIN to get the temp table in the right place!
  #(TK_JOIN sql92_tableSpecification sql92_tableSpecification sql92_joinCriteria)
  |
  #(TABLE_REF (ALIAS)? (sql92_tableHint)?)
  |
  #(CROSS_JOIN sql92_tableSpecification sql92_tableSpecification)
  |
  // Grouped joins represent the syntatic class of joins that are regrouped with parentheses
  // (e.g. a CROSS JOIN (b CROSS JOIN c)).  These are only necessary with CROSS JOIN, but they
  // may also be used with other JOIN specifications.
  #(GROUPED_JOIN sql92_tableSpecification RPAREN)
  |
  // Derived tables are nested queries but they cannot be correlated subqueries (unlike IN,EXISTS, etc.).
  // As such, they cannot reference columns in the argument table from their containing
  // context.  They need to have their own copy of the argument table
  // against which parameters are bound.  Furthermore, the use of the
  // argument table within the derived table needs to be made consistent
  // with the argument table in the containing context via a join on the
  // requestid columns.
  // Example:
  // SELECT a.col1, foo.col3 FROM a INNER JOIN
  // (SELECT b.col2, c.col3 FROM b INNER JOIN c ON b.col4=c.col4 WHERE c.col5=@input) foo ON foo.col2=a.col2
  //
  // should be transformed to:
  //
  // SELECT a.col1, foo.col3, tmp0.requestid FROM a INNER JOIN
  // (SELECT b.col2, c.col3, tmp1.requestid FROM b INNER JOIN c ON b.col4=c.col4, #tmp_args tmp1 WHERE c.col5=tmp1.input) foo ON foo.col2=a.col2,
  // #tmp_args tmp0
  // WHERE
  // foo.requestid=tmp0.requestid
  //
  #(DERIVED_TABLE sql92_selectStatement RPAREN ALIAS 
  {
    // Use the current alias and the alias of the derived table to create the
    // join criteria.  This needs to be saved until later processing of the 
    // WHERE clause of the "containing" context.
    std::string innerColumn = #ALIAS->getText() + "." + "requestid ";
    std::string outerColumn = getCurrentAlias() + "." + "requestid ";
    ANTLR_USE_NAMESPACE(antlr)RefAST ast = #([EQUALS,"= "], [ID, innerColumn], [ID, outerColumn]);
    pushWhereClause(ast);
  }
  )
  ;

sql92_tableHint
  :
  #(TK_WITH LPAREN (ID | TK_INDEX LPAREN (ID | NUM_INT) (COMMA (ID | NUM_INT))* RPAREN)
                   (COMMA (ID | TK_INDEX LPAREN (ID | NUM_INT) (COMMA (ID | NUM_INT))* RPAREN))*
            RPAREN)
  ;

sql92_joinCriteria
  :
  #(TK_ON sql92_logicalExpression)
  ;

sql92_whereClause!
  :
  #(w:TK_WHERE s:sql92_searchCondition)
  {
    if(getWhereClause() != ANTLR_USE_NAMESPACE(antlr)RefAST(NULL))
    {
      ## = #(w, ([LAND, " AND "], getWhereClause(), s));
      clearWhereClause();
    }
    else
    {
      ## = #(w, s);
    }
  }
  ;

// For an "outermost" group by, we need to add the request to the group by variables.
sql92_groupByClause
  :
  #(TK_GROUP TK_BY sql92_expr (COMMA sql92_expr)*
  {
    std::string aliasedColumn = getCurrentAlias() + ".requestid ";
    getASTFactory()->addASTChild(currentAST, #([COMMA, ", "]));
    getASTFactory()->addASTChild(currentAST, #([ID, aliasedColumn]));
  }
  (TK_HAVING sql92_searchCondition)?)  
  ;

sql92_nestedGroupByClause
  :
  #(TK_GROUP TK_BY sql92_expr (COMMA sql92_expr)* (TK_HAVING sql92_searchCondition)?)  
  ;

sql92_searchCondition
  :
  sql92_logicalExpression
  ;

sql92_elist 
	:
	#(ELIST (sql92_expression (COMMA sql92_expression)*)?)
	;

sql92_expression
  :
  #(EXPR sql92_expr)
  ;

sql92_logicalExpression
  :
	// Comparison
	#(EQUALS sql92_expr sql92_expr) 
	| #(GT sql92_expr sql92_expr) 
	| #(GTEQ sql92_expr sql92_expr) 
	| #(LTN sql92_expr sql92_expr) 
	| #(LTEQ sql92_expr sql92_expr) 
	| #(NOTEQUALS sql92_expr sql92_expr) 	
  |
  #(TK_LIKE sql92_expr (TK_NOT)? sql92_expr)
  |
  #(TK_IS sql92_expr (TK_NOT)? TK_NULL)
  |
  #(TK_BETWEEN sql92_expr (TK_NOT)? sql92_expr TK_AND sql92_expr)
  |
  #(TK_EXISTS (TK_NOT)? LPAREN sql92_nestedSelectStatement RPAREN)
  |  
  #(TK_IN sql92_expr (TK_NOT)? LPAREN (sql92_nestedSelectStatement | sql92_expr (COMMA sql92_expr)*) RPAREN)
	// Logical
	| #(LAND sql92_logicalExpression sql92_logicalExpression) 
	| #(LNOT sql92_logicalExpression) 
	| #(LOR sql92_logicalExpression sql92_logicalExpression) 
	| #(LPAREN sql92_hackExpression RPAREN) 
  ;

protected
sql92_hackExpression
  :
  // The need for this is an artifact of some inconsistency in how
  // expressions are handled in the tree parsers and the parser.
  // In the parser, arithmetic expressions are a special case of 
  // logical expressions whereas in the tree parsers, logical and arithmetic
  // expressions are totally distinct.  However, the use of the construct
  // LPAREN expr RPAREN is handled in the parser and therefore treats 
  // logical and arithmetic expressions the same way.
  #(EXPR sql92_logicalExpression)
  ;

sql92_expr
  :
	// Expression sequence
	// Bitwise
	#(BAND sql92_expr sql92_expr) 
	| #(BNOT sql92_expr) 
	| #(BOR sql92_expr sql92_expr) 
	| #(BXOR sql92_expr sql92_expr) 
	// Arithmetic
	| #(MINUS sql92_expr sql92_expr) 
	| #(MODULUS sql92_expr sql92_expr) 
	| #(DIVIDE sql92_expr sql92_expr) 
	| #(PLUS sql92_expr sql92_expr) 
	| #(TIMES sql92_expr sql92_expr)  
	| #(UNARY_MINUS sql92_expr)  
	| #(UNARY_PLUS sql92_expr) 
    | #(TK_CAST LPAREN sql92_expression TK_AS sql92_builtInType RPAREN)
    | sql92_aggregateExpression { incrementAggregateCount(); }
    | #(SIMPLE_CASE (sql92_simpleWhenExpression)+ (sql92_elseExpression)? TK_END)
    | #(SEARCHED_CASE sql92_expr (sql92_whenExpression)+ (sql92_elseExpression)? TK_END)
	// Expression
	| sql92_primaryExpression 
;

protected
sql92_aggregateExpression
  :
  #(TK_COUNT LPAREN (STAR | (TK_ALL | TK_DISTINCT)? sql92_expression) RPAREN)
  | #(TK_AVG LPAREN ((TK_ALL | TK_DISTINCT)? sql92_expression) RPAREN)
  | #(TK_MAX LPAREN ((TK_ALL | TK_DISTINCT)? sql92_expression) RPAREN)
  | #(TK_MIN LPAREN ((TK_ALL | TK_DISTINCT)? sql92_expression) RPAREN)
  | #(TK_SUM LPAREN ((TK_ALL | TK_DISTINCT)? sql92_expression) RPAREN)
;

protected
sql92_whenExpression
  :
  #(TK_WHEN sql92_expr TK_THEN sql92_expr)
  ;

protected
sql92_simpleWhenExpression
  :
  #(SIMPLE_WHEN sql92_logicalExpression TK_THEN sql92_expr)
  ;

protected 
sql92_elseExpression
  :
  #(TK_ELSE sql92_expr)
  ;

sql92_builtInType
   :
   #(BUILTIN_TYPE (TK_PRECISION)? (LPAREN NUM_INT (COMMA NUM_INT)? RPAREN)?)
   ;

sql92_primaryExpression 
	:
	#(ID (DOT ID)?)
	| NUM_INT
	| NUM_BIGINT
	| NUM_FLOAT
	| NUM_DECIMAL
	| STRING_LITERAL
	| WSTRING_LITERAL
	| #(METHOD_CALL ID sql92_elist RPAREN) 
	| lv:LOCALVAR
        {
          referenceVariable((RefMTSQLAST) #lv);
          #lv->setType(ID);
          #lv->setText(getCurrentAlias() + "." + getTempColumn(#lv->getText()));
        }
	| INTEGER_GETMEM 
	| BIGINT_GETMEM 
	| DOUBLE_GETMEM 
	| DECIMAL_GETMEM 
	| BOOLEAN_GETMEM 
	| STRING_GETMEM 
	| WSTRING_GETMEM 
    | #(LPAREN sql92_expression RPAREN)
    | #(SCALAR_SUBQUERY sql92_nestedSelectStatement RPAREN)
	;

program
	:
	(typeDeclaration)* 
	#(SCOPE { mEnv->beginScope(); } 
	  statementList { mEnv->endScope(); }
	)
	;

statementList
	: (statement)*
	;

statement
	:
	setStatement 
	|
	typeDeclaration
	|
    stringPrintStatement
	|
    wstringPrintStatement
    |
	seq
    |
	ifStatement
    |
	listOfStatements
    |
	returnStatement
	| 
    breakStatement
	| 
    continueStatement
	| 
    whileStatement
  |
    raiserrorStringStatement
  |
    raiserrorWStringStatement
  |
    raiserrorIntegerStatement
  |
    raiserror2StringStatement
  |
    raiserror2WStringStatement
  |
  mtsql_selectStatement
	;

typeDeclaration
	:
	#(TK_DECLARE var:LOCALVAR ty:BUILTIN_TYPE) 
	{ 
			
		mEnv->insertVar(
		var->getText(), 
		VarEntry::create(getType(ty->getText()), mEnv->allocateVariable(var->getText(), getType(ty->getText())), mEnv->getCurrentLevel())); 
	}
	;

setStatement 
	:
	#(INTEGER_SETMEM varAddress expression) 
	| #(BIGINT_SETMEM varAddress expression) 
	| #(DOUBLE_SETMEM varAddress expression) 
	| #(DECIMAL_SETMEM varAddress expression) 
	| #(BOOLEAN_SETMEM varAddress expression) 
	| #(STRING_SETMEM varAddress expression) 
	| #(WSTRING_SETMEM varAddress expression) 
	| #(DATETIME_SETMEM varAddress expression) 
	| #(TIME_SETMEM varAddress expression) 
	| #(ENUM_SETMEM varAddress expression) 
	;

varAddress 
	:
	l:LOCALVAR 
	;

stringPrintStatement
	:
	#(STRING_PRINT expr)
	;

wstringPrintStatement
	:
	#(WSTRING_PRINT expr)
	;

seq
	:
	#(SEQUENCE statement statement)
	;

queryStatement
    :
    #(QUERY 
	localParamList 
    queryString 
    localQueryVarList 
    )
	;

queryString 
{
}
	:
	#(QUERYSTRING (.)+)
    ;

localQueryVarList
    :
	setmemQuery
	;
	
setmemQuery
    :
    #(ARRAY  ( 
	#(INTEGER_SETMEM_QUERY varAddress) 
	| #(BIGINT_SETMEM_QUERY varAddress) 
	| #(DOUBLE_SETMEM_QUERY varAddress) 
	| #(DECIMAL_SETMEM_QUERY varAddress) 
	| #(BOOLEAN_SETMEM_QUERY varAddress) 
	| #(STRING_SETMEM_QUERY varAddress) 
	| #(WSTRING_SETMEM_QUERY varAddress) 
	| #(DATETIME_SETMEM_QUERY varAddress) 
	| #(TIME_SETMEM_QUERY varAddress) 
	| #(ENUM_SETMEM_QUERY varAddress) 
	  )*
	)
    ;

localParamList 
    :
    #(ARRAY (primaryExpression)*)
    ;

ifStatement
    :
	#(IFTHENELSE expression delayedStatement (delayedStatement)? )
    ;

delayedStatement
	:
	#(DELAYED_STMT statement)
	;

listOfStatements
	:
	#(SLIST (statement)*)
	;

returnStatement
	:
	#(TK_RETURN (expression)?)
	;

breakStatement
	:
	TK_BREAK 
    ;

continueStatement
	:
	TK_CONTINUE
    ;

whileStatement
	:
	#(WHILE expression delayedStatement) 
    ;

raiserrorIntegerStatement
	:
	#(RAISERRORINTEGER expression) 
    ;

raiserrorStringStatement
	:
	#(RAISERRORSTRING expression) 
    ;

raiserrorWStringStatement
	:
	#(RAISERRORWSTRING expression) 
    ;

raiserror2StringStatement
	:
	#(RAISERROR2STRING expression expression) 
    ;

raiserror2WStringStatement
	:
	#(RAISERROR2WSTRING expression expression) 
    ;

elist 
	:
	#(ELIST (expression (COMMA expression)*)?)
	;

expression
	:
	#(EXPR expr) 
	;

expr 
	:
	// Bitwise
	#(BAND expr expr) 
	| #(BNOT expr) 
	| #(BOR expr expr) 
	| #(BXOR expr expr) 
	// Logical
	| #(LAND expr expr) 
	| #(LOR expr expr) 
	| #(LNOT expr) 
	// Comparison
	| #(EQUALS expr expr) 
	| #(GT expr expr) 
	| #(GTEQ expr expr) 
	| #(LTN expr expr) 
	| #(LTEQ expr expr) 
	| #(NOTEQUALS expr expr) 
  // null checking
	| #(ISNULL expr) 
	// String operators
	| #(STRING_PLUS expr expr) 
	| #(WSTRING_PLUS expr expr) 
	| #(STRING_LIKE expr expr) 
	| #(WSTRING_LIKE expr expr) 
	// Arithmetic
	| #(INTEGER_MINUS expr expr) 
	| #(INTEGER_DIVIDE expr expr) 
	| #(INTEGER_PLUS expr expr) 
	| #(INTEGER_TIMES expr expr)  
	| #(INTEGER_UNARY_MINUS expr)  
	| #(BIGINT_MINUS expr expr) 
	| #(BIGINT_DIVIDE expr expr) 
	| #(BIGINT_PLUS expr expr) 
	| #(BIGINT_TIMES expr expr)  
	| #(BIGINT_UNARY_MINUS expr)  
	| #(DOUBLE_MINUS expr expr) 
	| #(DOUBLE_DIVIDE expr expr) 
	| #(DOUBLE_PLUS expr expr) 
	| #(DOUBLE_TIMES expr expr)  
	| #(DOUBLE_UNARY_MINUS expr)  
	| #(DECIMAL_MINUS expr expr) 
	| #(DECIMAL_DIVIDE expr expr) 
	| #(DECIMAL_PLUS expr expr) 
	| #(DECIMAL_TIMES expr expr)  
	| #(DECIMAL_UNARY_MINUS expr)  
	| #(INTEGER_MODULUS expr expr) 
	| #(BIGINT_MODULUS expr expr) 
	// Expression
	| 
	#(IFBLOCK ( ifThenElse )+ 
		)
	| #(ESEQ statement expr)
    | #(CAST_TO_INTEGER expression) 
    | #(CAST_TO_BIGINT expression) 
    | #(CAST_TO_DOUBLE expression) 
    | #(CAST_TO_DECIMAL expression) 
    | #(CAST_TO_STRING expression) 
    | #(CAST_TO_WSTRING expression) 
    | #(CAST_TO_BOOLEAN expression) 
    | #(CAST_TO_DATETIME expression) 
    | #(CAST_TO_TIME expression)
    | #(CAST_TO_ENUM expression) 
	| primaryExpression 
	;

ifThenElse 
	: #(IFEXPR conditional) 
	| expression 
	;


conditional
{
}
	:
	expr expr
	;

primaryExpression
	:
	NUM_INT 
	| NUM_BIGINT
	| NUM_FLOAT 
	| NUM_DECIMAL 
	| STRING_LITERAL 
	| WSTRING_LITERAL 
	| ENUM_LITERAL 
	| TK_TRUE 
	| TK_FALSE 
	| TK_NULL 
	| #(METHOD_CALL ID elist RPAREN) 
	| INTEGER_GETMEM 
	| BIGINT_GETMEM 
	| DOUBLE_GETMEM 
	| DECIMAL_GETMEM 
	| BOOLEAN_GETMEM 
	| STRING_GETMEM 
	| WSTRING_GETMEM 
	| DATETIME_GETMEM 
	| TIME_GETMEM 
	| ENUM_GETMEM 
    | expression
	;
