<?xml version="1.0" encoding="utf-8"?>
<MetraFlowScript>
    <Name>RecurringChargeGenerateEvents</Name>
    <Description>Generates recurring charge, credit and correction events.</Description>
    <Parameters>
        <Parameter>
            <Name>TEMP_DIR</Name>
            <SyntaxCheckValue>C:\Temp</SyntaxCheckValue>
            <Description>Directory in which to store sort run files for sort run files.</Description>
        </Parameter>
        <Parameter>
            <Name>MINIUMUM_TIME</Name>
            <SyntaxCheckValue>2000-01-01 00:00:00</SyntaxCheckValue>
            <Description>Bound on how far back time we consider for the corrections process.</Description>
        </Parameter>
    </Parameters>
    <Script>
      <![CDATA[
individual_charge_accounts:select[baseQuery="select 
s.id_sub s_id_sub,
s.vt_start s_dt_start,
s.vt_end s_dt_end,
dbo.mtendofday(s.vt_end) s_dt_end1,
s.id_acc o_id_acc,
dbo.MTMinDate() o_vt_start,
dbo.MTMaxDate() o_vt_end,
dbo.MTMinDate() o_tt_start,
dbo.MTMaxDate() o_tt_end,
plm.id_pi_instance, 
plm.id_pi_template,
plm.id_pi_type,
plm.id_po,
r.b_advance as b_advance_raw,
r.b_prorate_on_activate as b_prorate_on_activate_raw,
r.b_prorate_instantly as b_prorate_instantly_raw,
r.b_prorate_on_deactivate as b_prorate_on_deactivate_raw,
r.b_fixed_proration_length,
r.id_usage_cycle,
r.id_cycle_type,
r.tx_cycle_mode,
r.n_rating_type
from 
tmp_rc_payees t
inner join t_sub s on t.np_id_payee=s.id_acc
inner join t_pl_map plm on plm.id_po=s.id_po
inner join t_recur r on r.id_prop=plm.id_pi_instance
where
plm.id_paramtable is null
AND
(
  s.id_group is NULL
)
AND
{fn mod(t.np_id_payee, %%NUMPARTITIONS%%)} = %%PARTITION%%",
partitionConstraint="Database"];

per_participant_charge_accounts:select[baseQuery="select 
s.id_sub s_id_sub,
gsm.vt_start s_dt_start,
gsm.vt_end s_dt_end,
dbo.mtendofday(gsm.vt_end) s_dt_end1,
gsm.id_acc o_id_acc,
dbo.MTMinDate() o_vt_start,
dbo.MTMaxDate() o_vt_end,
dbo.MTMinDate() o_tt_start,
dbo.MTMaxDate() o_tt_end,
plm.id_pi_instance, 
plm.id_pi_template,
plm.id_pi_type,
plm.id_po,
r.b_advance as b_advance_raw,
r.b_prorate_on_activate as b_prorate_on_activate_raw,
r.b_prorate_instantly as b_prorate_instantly_raw,
r.b_prorate_on_deactivate as b_prorate_on_deactivate_raw,
r.b_fixed_proration_length,
r.id_usage_cycle,
r.id_cycle_type,
r.tx_cycle_mode,
r.n_rating_type
from 
tmp_rc_payees t
inner join t_gsubmember gsm on t.np_id_payee=gsm.id_acc
inner join t_sub s on gsm.id_group=s.id_group
inner join t_pl_map plm on plm.id_po=s.id_po
inner join t_recur r on r.id_prop=plm.id_pi_instance
where
plm.id_paramtable is null
AND
(
  r.b_charge_per_participant = 'Y'
)
AND
{fn mod(t.np_id_payee, %%NUMPARTITIONS%%)} = %%PARTITION%%",
partitionConstraint="Database"];

per_subscription_charge_accounts:select[baseQuery="select 
s.id_sub s_id_sub,
s.vt_start s_dt_start,
s.vt_end s_dt_end,
dbo.mtendofday(s.vt_end) s_dt_end1,
grm.id_acc o_id_acc,
grm.vt_start o_vt_start,
grm.vt_end o_vt_end,
grm.tt_start o_tt_start,
grm.tt_end o_tt_end,
plm.id_pi_instance, 
plm.id_pi_template,
plm.id_pi_type,
plm.id_po,
r.b_advance as b_advance_raw,
r.b_prorate_on_activate as b_prorate_on_activate_raw,
r.b_prorate_instantly as b_prorate_instantly_raw,
r.b_prorate_on_deactivate as b_prorate_on_deactivate_raw,
r.b_fixed_proration_length,
r.id_usage_cycle,
r.id_cycle_type,
r.tx_cycle_mode,
r.n_rating_type
from 
tmp_rc_payees t
inner join t_gsub_recur_map grm on t.np_id_payee=grm.id_acc 
inner join t_sub s on grm.id_group=s.id_group 
inner join t_pl_map plm on plm.id_po=s.id_po
inner join t_recur r on r.id_prop=plm.id_pi_instance and grm.id_prop=r.id_prop
where
plm.id_paramtable is null
AND
r.b_charge_per_participant = 'N'
AND
{fn mod(t.np_id_payee, %%NUMPARTITIONS%%)} = %%PARTITION%%",
partitionConstraint="Database"];

charge_accounts_union:union_all[partitionConstraint="Database"];

charge_accounts_part:hashpart[key="o_id_acc",
partitionConstraint="Database"];

charge_accounts_coll:coll[];

charge_accounts:expr[program="CREATE PROCEDURE p 
@b_advance_raw VARCHAR @b_prorate_on_activate_raw VARCHAR @b_prorate_instantly_raw VARCHAR @b_prorate_on_deactivate_raw VARCHAR
@b_advance BOOLEAN OUTPUT @b_prorate_on_activate BOOLEAN OUTPUT @b_prorate_on_deactivate BOOLEAN OUTPUT
AS
SET @b_advance = CASE WHEN @b_advance_raw = 'Y' THEN TRUE ELSE FALSE END
SET @b_prorate_on_activate = CASE WHEN @b_prorate_on_activate_raw = 'Y' THEN TRUE ELSE FALSE END
SET @b_prorate_instantly = CASE WHEN @b_prorate_instantly_raw = 'Y' THEN TRUE ELSE FALSE END
SET @b_prorate_on_deactivate = CASE WHEN @b_prorate_on_deactivate_raw = 'Y' THEN TRUE ELSE FALSE END"];
 
individual_charge_accounts -> charge_accounts_union(0);
per_participant_charge_accounts -> charge_accounts_union(1);
per_subscription_charge_accounts -> charge_accounts_union(2);
charge_accounts_union -> charge_accounts_part -> charge_accounts_coll -> charge_accounts;

paying_accounts_select:sequential_file_scan[filename="%%TEMP_DIR%%\rc_payment_redirection_%1%.mfd"];

paying_accounts:rename[from="np_id_payer", to="p_id_payer",
from="np_id_payee", to="p_id_payee",
from="np_vt_start", to="p_vt_start",
from="np_vt_end", to="p_vt_end",
from="np_tt_start", to="p_tt_start",
from="np_tt_end", to="p_tt_end"];

paying_accounts_select -> paying_accounts;

billing_intervals_0:sequential_file_scan[filename="%%TEMP_DIR%%\rc_billing_intervals_%1%.mfd"];

charge_accounts_sort:sort[key="o_id_acc", temp_dir="%%TEMP_DIR%%", allowedMemory=10000000];

charge_accounts -> charge_accounts_sort;

paying_accounts_part:hashpart[key="p_id_payee"];
paying_accounts(0) -> paying_accounts_part;
paying_accounts_coll:coll[];
paying_accounts_part -> paying_accounts_coll;
paying_accounts_sort:sort[key="p_id_payee", temp_dir="%%TEMP_DIR%%", allowedMemory=10000000];
paying_accounts_coll -> paying_accounts_sort;

join_payers:inner_merge_join[rightKey="p_id_payee", leftKey="o_id_acc",
residual="CREATE FUNCTION r (
@o_vt_start DATETIME @o_vt_end DATETIME 
@p_vt_start DATETIME @p_vt_end DATETIME) RETURNS BOOLEAN
AS
RETURN @o_vt_start <= @p_vt_end AND @p_vt_start <= @o_vt_end" ];

charge_accounts_sort -> join_payers("left");
paying_accounts_sort -> join_payers("right");

-- TODO: doing the payer join before charge join may avoid a repartitioning step
join_payers_part:hashpart[key="p_id_payer"];
join_payers_coll:coll[];
join_payers_sort:sort[key="p_id_payer", temp_dir="%%TEMP_DIR%%", allowedMemory=10000000];

join_intervals:inner_merge_join[leftKey="b_id_payer", rightKey="p_id_payer"];

billing_intervals_0 -> join_intervals("left");
join_payers -> join_payers_part -> join_payers_coll -> join_payers_sort -> join_intervals("right");

next_intervals:select[baseQuery="SELECT id_cycle as nb_id_cycle, dt_start as nb_dt_start, dt_end as nb_dt_end 
FROM t_pc_interval
WHERE
{fn mod(id_interval, %%NUMPARTITIONS%%)} = %%PARTITION%%
AND
dt_end > {ts '%%MINIMUM_TIME%%'}"];

next_intervals_part:broadcast[];
next_intervals_coll:coll[];

join_intervals_expr:expr[program="
CREATE PROCEDURE p @b_dt_end DATETIME @b_dt_end_plus_1 DATETIME OUTPUT
AS
SET @b_dt_end_plus_1 = CAST(CAST(CAST(@b_dt_end AS DOUBLE PRECISION)+5.0E-01 AS INTEGER) AS DATETIME)"];

-- TODO: I think we can filter this select on intervals that start within the last calendar year
--join_next_intervals:inner_hash_join[
--tableKey="nb_id_cycle", tableKey="nb_dt_start", 
--probeKey="b_id_cycle", probeKey="b_dt_end_plus_1"];
join_next_intervals:inner_hash_join[
tableKey="nb_id_cycle", 
probeKey="b_id_cycle", 
residual="
CREATE FUNCTION r (@nb_dt_start DATETIME @b_dt_end DATETIME) RETURNS BOOLEAN
AS
RETURN @nb_dt_start = dateadd('s',1,@b_dt_end)"];

next_intervals -> next_intervals_part -> next_intervals_coll -> join_next_intervals("table");
join_intervals -> join_intervals_expr -> join_next_intervals("probe(0)");

calculate_rc_cycle_cycles:select[baseQuery="SELECT id_usage_cycle,
uc.id_cycle_type,
uc.day_of_month,
uc.day_of_week,
uc.first_day_of_month,
uc.second_day_of_month,
uc.start_day,
uc.start_month,
uc.start_year,
uct.n_proration_length
FROM
t_usage_cycle uc
inner join t_usage_cycle_type uct on uc.id_cycle_type=uct.id_cycle_type",
mode="sequential"];

calculate_rc_cycle_cycles_part:broadcast[mode="sequential"];

calculate_rc_cycle_cycles -> calculate_rc_cycle_cycles_part;

calculate_rc_cycle_cycles_copy:copy[];

calculate_rc_cycle_cycles_part -> calculate_rc_cycle_cycles_copy;

cycle_info_rename_for_bill_cycle:rename[
from="id_usage_cycle", to="b_id_cycle_tmp",
from="id_cycle_type", to="b_id_cycle_type",
from="day_of_month", to="b_day_of_month",
from="day_of_week", to="b_day_of_week",
from="first_day_of_month", to="b_first_day_of_month",
from="second_day_of_month", to="b_second_day_of_month",
from="start_day", to="b_start_day",
from="start_month", to="b_start_month",
from="start_year", to="b_start_year",
from="n_proration_length", to="b_n_proration_length"];

calculate_rc_cycle_cycles_copy(0) -> cycle_info_rename_for_bill_cycle;

calculate_rc_cycle_bill_cycle_info:inner_hash_join[tableKey="b_id_cycle_tmp", probeKey="b_id_cycle"];

cycle_info_rename_for_bill_cycle -> calculate_rc_cycle_bill_cycle_info("table");
join_next_intervals -> calculate_rc_cycle_bill_cycle_info("probe(0)");

cycle_info_rename_for_rc_cycle:rename[
from="id_usage_cycle", to="charge_id_cycle",
from="id_cycle_type", to="charge_id_cycle_type",
from="day_of_month", to="charge_day_of_month",
from="day_of_week", to="charge_day_of_week",
from="first_day_of_month", to="charge_first_day_of_month",
from="second_day_of_month", to="charge_second_day_of_month",
from="start_day", to="charge_start_day",
from="start_month", to="charge_start_month",
from="start_year", to="charge_start_year",
from="n_proration_length", to="charge_n_proration_length"];

calculate_rc_cycle_cycles_copy(1) -> cycle_info_rename_for_rc_cycle;

cycle_info_rename_for_fixed_cycle:rename[
from="id_usage_cycle", to="fixed_id_cycle",
from="id_cycle_type", to="fixed_id_cycle_type"];

calculate_rc_cycle_cycles_copy(2) -> cycle_info_rename_for_fixed_cycle;

cycle_info_project_for_fixed_cycle:projection[
column="fixed_id_cycle",
column="fixed_id_cycle_type"];

cycle_info_rename_for_fixed_cycle -> cycle_info_project_for_fixed_cycle;

cycle_info_resolve_fixed_cycle_type:right_outer_hash_join[probeKey="id_usage_cycle", tableKey="fixed_id_cycle"];

cycle_info_project_for_fixed_cycle -> cycle_info_resolve_fixed_cycle_type("table");
calculate_rc_cycle_bill_cycle_info -> cycle_info_resolve_fixed_cycle_type("probe(0)");

-- Make sure we have a valid id_cycle_type.  This won't be set in the Fixed and BCR unconstrained
-- cases.  In the fixed case the cycle is coming from the recurring charge and we get the cycle
-- type from that.  In the BCR cases we are using the customers bill cycle for charges so we
-- get the cycle type from the cycle type of the bill.  In the EBCR and BCR constrained cases the
-- cycle type is specified on the offer.
set_fixed_cycle_cycle_type:expr[program="CREATE PROCEDURE p @tx_cycle_mode VARCHAR
@id_cycle_type INTEGER
@fixed_id_cycle_type INTEGER
@b_id_cycle_type INTEGER
AS
IF @tx_cycle_mode = 'Fixed'
  SET @id_cycle_type = @fixed_id_cycle_type
ELSE IF @tx_cycle_mode = 'BCR Unconstrained'
  SET @id_cycle_type = @b_id_cycle_type"];

cycle_info_resolve_fixed_cycle_type -> set_fixed_cycle_cycle_type;

calculate_rc_cycle:inner_hash_join[tableKey="charge_id_cycle_type", probeKey="id_cycle_type",
residual="
CREATE FUNCTION f 
(@tx_cycle_mode VARCHAR 
@id_usage_cycle INTEGER 
@id_cycle_type INTEGER 
@b_id_cycle INTEGER 
@b_id_cycle_type INTEGER 
@b_day_of_month INTEGER
@b_day_of_week INTEGER
@b_first_day_of_month INTEGER
@b_second_day_of_month INTEGER
@b_start_day INTEGER
@b_start_month INTEGER
@b_start_year INTEGER
@charge_id_cycle INTEGER
@charge_id_cycle_type INTEGER
@charge_day_of_month INTEGER
@charge_day_of_week INTEGER
@charge_first_day_of_month INTEGER
@charge_second_day_of_month INTEGER
@charge_start_day INTEGER
@charge_start_month INTEGER
@charge_start_year INTEGER
@s_dt_start DATETIME) RETURNS BOOLEAN
AS
RETURN
  CASE @tx_cycle_mode
       WHEN 'Fixed' THEN @id_usage_cycle=@charge_id_cycle
       WHEN 'BCR Constrained' THEN @b_id_cycle=@charge_id_cycle
       WHEN 'EBCR' THEN 
       CASE
         WHEN @id_cycle_type = @b_id_cycle_type THEN @b_id_cycle=@charge_id_cycle
         WHEN @id_cycle_type = 4 AND @b_id_cycle_type = 5 THEN ((@b_start_day+11)%7)+1 = @charge_day_of_week
         WHEN @id_cycle_type = 5 AND @b_id_cycle_type = 4 THEN @charge_start_year=2000 AND @charge_start_month=1 AND @charge_start_day=((@b_day_of_week+1)%7)+1
         WHEN @id_cycle_type = 1 AND (@b_id_cycle_type = 7 OR @b_id_cycle_type=8) THEN @charge_day_of_month=((@b_start_day + 29)%31)+1
         WHEN @id_cycle_type = 7 AND @b_id_cycle_type = 1 
         THEN @charge_start_month=((CASE WHEN @b_day_of_month=31 THEN month(@s_dt_start) + 1 ELSE month(@s_dt_start) END - 1) %3)+1 
              AND 
              -- Convert end day to start day.
              @charge_start_day=((@b_day_of_month + 1)%31)
         WHEN @id_cycle_type = 7 AND @b_id_cycle_type = 8 
         THEN @charge_start_month=((@b_start_month-1)%3) + 1
              AND 
              @charge_start_day=@b_start_day
         WHEN @id_cycle_type = 8 AND @b_id_cycle_type = 1 
         THEN @charge_start_month=CASE WHEN @b_day_of_month=31 THEN month(@s_dt_start) + 1 ELSE month(@s_dt_start) END
              AND 
              @charge_start_day=((@b_day_of_month + 1)%31)
         WHEN @id_cycle_type = 8 AND @b_id_cycle_type = 7
         THEN @charge_start_month=@b_start_month
              AND 
              @charge_start_day=@b_start_day
         ELSE FALSE 
       END
       ELSE FALSE
  END"];

cycle_info_rename_for_rc_cycle -> calculate_rc_cycle("table");
set_fixed_cycle_cycle_type -> calculate_rc_cycle("probe(0)");

-- If we are using a fixed proration cycle length then we get that from
-- the cycle type of the charge cycle just determined.
calculate_proration_length:expr[program="CREATE PROCEDURE p @b_fixed_proration_length VARCHAR
@charge_n_proration_length INTEGER
@n_proration_cycle_length INTEGER OUTPUT
AS
SET @n_proration_cycle_length = CASE WHEN 'Y'=@b_fixed_proration_length THEN @charge_n_proration_length ELSE 0 END"];

calculate_rc_cycle -> calculate_proration_length;

--  Advance Charge Rule: Process subscriptions that 
--   Begin prior to the beginning of the next interval 
--   End after the beginning of the next interval 
initial_candidates:filter[program="
CREATE FUNCTION f (@run_vt_start DATETIME
@b_dt_start DATETIME @b_dt_end DATETIME
@s_dt_start DATETIME @s_dt_end DATETIME
@p_tt_start DATETIME @p_tt_end DATETIME
@o_vt_start DATETIME
@o_tt_start DATETIME @o_tt_end DATETIME) RETURNS BOOLEAN
AS
RETURN @run_vt_start >= @p_tt_start AND @run_vt_start <= @p_tt_end
AND
@run_vt_start >= @o_tt_start AND @run_vt_start <= @o_tt_end
"];

calculate_proration_length -> initial_candidates;

rc_intervals:select[baseQuery="SELECT id_interval as pc_id_interval, id_cycle as pc_id_cycle, dt_start as pc_dt_start, dt_end as pc_dt_end FROM t_pc_interval
WHERE
{fn mod(id_interval, %%NUMPARTITIONS%%)} = %%PARTITION%%
AND
dt_end > {ts '%%MINIMUM_TIME%%'}"];

rc_intervals_part:broadcast[];
rc_intervals_coll:coll[];

--  Arrears Charge Rules:  
--   Recurring charge interval has non-empty intersection with subscription interval 
--   Subscription adjusted recurring charge interval ends in current interval 
--   Charge is billed by payer from history who is (valid time) effective 
--   at the end of the subscription adjusted recurring charge interval. 
--   Subscription adjusted recurring charge interval ends in the originating account effective interval 
initial_intervals:inner_hash_join[tableKey="pc_id_cycle", probeKey="charge_id_cycle",
residual="CREATE FUNCTION r (
@b_advance BOOLEAN
@pc_dt_start DATETIME @pc_dt_end DATETIME 
@b_dt_start DATETIME @b_dt_end DATETIME
@nb_dt_start DATETIME @nb_dt_end DATETIME
@s_dt_start DATETIME @s_dt_end DATETIME
@p_vt_start DATETIME @p_vt_end DATETIME
@o_vt_start DATETIME @o_vt_end DATETIME
@o_tt_start DATETIME
) RETURNS BOOLEAN
AS
DECLARE @subscription_adjusted_pc_dt_end DATETIME
SET @subscription_adjusted_pc_dt_end = CASE WHEN @pc_dt_end < @s_dt_end THEN @pc_dt_end ELSE @s_dt_end END
RETURN
(
@b_advance = FALSE
AND
@s_dt_start <= @pc_dt_end AND @pc_dt_start <= @s_dt_end
AND
@subscription_adjusted_pc_dt_end >= @b_dt_start AND @subscription_adjusted_pc_dt_end <= @b_dt_end
AND
@subscription_adjusted_pc_dt_end >= @p_vt_start AND @subscription_adjusted_pc_dt_end <= @p_vt_end
AND
@subscription_adjusted_pc_dt_end >= @o_vt_start AND @subscription_adjusted_pc_dt_end <= @o_vt_end
)
OR
(
@b_advance = TRUE
AND
(
  -- Initial charge
  (@pc_dt_start <= @b_dt_end AND @pc_dt_end >= @s_dt_start AND @pc_dt_start <= @s_dt_end AND
    (
      (@s_dt_start >= @b_dt_start AND @s_dt_start <= @b_dt_end)
      OR
      (@o_vt_start >= @b_dt_start AND @o_vt_start <= @b_dt_end  AND @o_tt_start >= @b_dt_start AND @o_tt_start <= @b_dt_end)
    )
  )
  OR
  -- Advance charge.  Note that this is NOT taking a subscription end date into consideration.
  (@s_dt_start <= @b_dt_end AND @s_dt_end > @b_dt_end AND @pc_dt_start >= @nb_dt_start AND @pc_dt_start <= @nb_dt_end
  )
)
AND
@pc_dt_end >= @p_vt_start AND @pc_dt_end <= @p_vt_end
AND
@pc_dt_end >= @o_vt_start AND @pc_dt_end <= @o_vt_end
)"];

rc_intervals -> rc_intervals_part -> rc_intervals_coll -> initial_intervals("table");
initial_candidates -> initial_intervals("probe(0)");

-- Tag charges as initial or advance
charge_type_tag:expr[program="
CREATE PROCEDURE p 
@b_advance BOOLEAN
@pc_dt_start DATETIME @pc_dt_end DATETIME 
@nb_dt_start DATETIME @nb_dt_end DATETIME
@charge_type NVARCHAR OUTPUT
AS
-- Note that N'Advance' here covers the case of cancellation charges when they are being calculated.
SET @charge_type = CASE 
WHEN @b_advance = FALSE THEN N'Arrears' 
WHEN (@pc_dt_start >= @nb_dt_start) THEN N'Advance' 
ELSE N'Initial' END"];

credit_branch:copy[];

initial_intervals -> charge_type_tag -> credit_branch;

all_charges:sequential_file_write[filename="%%TEMP_DIR%%\rc_all_charges_%1%.mfd"];

credit_branch(0) -> all_charges;
]]></Script>
</MetraFlowScript>
