using System;
using System.Collections.Generic;
using System.ServiceModel;
using System.Threading.Tasks;
using MetraTech.Core.Services.ClientProxies;
using MetraTech.Domain.Quoting;
using MetraTech.Interop.MTProductCatalog;
using MetraTech.TestCommon;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Diagnostics;

namespace MetraTech.Core.Services.Test.Quoting
{
  [TestClass]
  public class QuotingActivityServiceFunctionalTests
  {
    private static TestContext _testContext;
    #region Setup/Teardown

    [ClassInitialize]
    public static void InitTests(TestContext testContext)
    {
      _testContext = testContext;
      SharedTestCode.MakeSureServiceIsStarted("ActivityServices");
      SharedTestCode.MakeSureServiceIsStarted("Pipeline");
    }

    #endregion
    [TestMethod, MTFunctionalTest(TestAreas.Quoting)]
    public void T01QuotingServiceCreateQuote_IndividualSubscription_PositiveTest()
    {
      #region Prepare
      var testShortName = "Q_AS_Basic"; //Account name and perhaps others need a 'short' (less than 40 when combined with testRunUniqueIdentifier
      var testRunUniqueIdentifier = MetraTime.Now.ToString(); //Identifier to make this run unique

      var idAccountToQuoteFor = SharedTestCode.GetCorporateAccountToQuoteFor(testShortName, testRunUniqueIdentifier);

      // Create/Verify Product Offering Exists
      var pofConfiguration = new ProductOfferingFactoryConfiguration(_testContext.TestName, testRunUniqueIdentifier)
        {
          CountNRCs = 1,
          CountPairRCs = 1,
          CountPairUDRCs = 1
        };


      var productOffering = ProductOfferingFactory.Create(pofConfiguration);
      var idProductOfferingToQuoteFor = productOffering.ID;

      //Values to use for verification
      var numOfAccounts = 1;
      var expectedQuoteNRCsCount = pofConfiguration.CountNRCs * numOfAccounts;
      var expectedQuoteFlatRCsCount = pofConfiguration.CountPairRCs + (pofConfiguration.CountPairRCs * numOfAccounts);
      var expectedQuoteUDRCsCount = pofConfiguration.CountPairUDRCs + (pofConfiguration.CountPairUDRCs * numOfAccounts);

      decimal totalAmountForUDRC = 30;

      decimal expectedQuoteTotal = (expectedQuoteFlatRCsCount * pofConfiguration.RCAmount) +
                                   (expectedQuoteUDRCsCount * totalAmountForUDRC) +
                                   (expectedQuoteNRCsCount * pofConfiguration.NRCAmount);
      //decimal expectedQuoteTotalTax = expectedQuoteTotal * 0.05m + expectedQuoteTotal * 0.025m * 4;	//values from dummy stage to calculate taxes (TA818)
      decimal expectedQuoteTotalTax = 0;

      var expectedQuoteCurrency = "USD";

      #endregion

      #region Test and Verify

      var request = new QuoteRequest();
      request.Accounts.Add(idAccountToQuoteFor);
      request.ProductOfferings.Add(idProductOfferingToQuoteFor);
      request.QuoteIdentifier = "MyQuoteId-" + testShortName + "-1234";
      request.QuoteDescription = "Quote generated by Automated Test: " + _testContext.TestName;
      request.ReportParameters = new ReportParams()
        {
          PDFReport = QuotingTestScenarios.RunPDFGenerationForAllTestsByDefault
        };
      request.Localization = "en-US";
      request.SubscriptionParameters.UDRCValues = SharedTestCode.GetUDRCInstanceValuesSetToMiddleValues(productOffering);

      QuoteResponse response = null;

      var clientInvoked = false;
      try
      {
        response = SharedTestCodeQuoting.InvokeCreateQuote(request);
        clientInvoked = true;
      }
      catch (Exception ex)
      {
        Assert.Fail("QuotingService_CreateQuote_Client thrown an exception: " + ex.Message);
      }

      Assert.IsFalse(response.Status == QuoteStatus.Failed, response.FailedMessage);
      Assert.IsTrue(clientInvoked, "QuotingService_CreateQuote_Client didn't executed propely");
      Assert.AreEqual(expectedQuoteTotal, response.TotalAmount, "Wrong TotalAmount");
      Assert.AreEqual(expectedQuoteTotalTax, response.TotalTax, String.Format("Wrong TotalTax. Actual is {0}, but expected {1}", response.TotalTax, expectedQuoteTotalTax));
      Assert.AreEqual(expectedQuoteCurrency, response.Currency, "Wrong Currency");

      #endregion
    }
    [TestMethod, MTFunctionalTest(TestAreas.Quoting)]
    public void T02QuotingServiceCreateQuote_GroupSubscription_PositiveTest()
    {
      #region Prepare
      var testShortName = "Q_AS_GSub"; //Account name and perhaps others need a 'short' (less than 40 when combined with testRunUniqueIdentifier
      var testRunUniqueIdentifier = MetraTime.Now.ToString(); //Identifier to make this run unique

      // Create account #1 Corporate
      // Create account #1 Corporate payer
      var idAccountToQuoteFor = SharedTestCode.GetCorporateAccountToQuoteFor(testShortName, testRunUniqueIdentifier);

      // Create account #2 Department child
      testRunUniqueIdentifier = MetraTime.NowWithMilliSec;
      var idAccountToQuoteFor2 = SharedTestCode.GetDepartmentAccountToQuoteFor(testShortName, testRunUniqueIdentifier, idAccountToQuoteFor);

      // Create account #3 Department child
      testRunUniqueIdentifier = MetraTime.NowWithMilliSec;
      var idAccountToQuoteFor3 = SharedTestCode.GetDepartmentAccountToQuoteFor(testShortName, testRunUniqueIdentifier, idAccountToQuoteFor);

      // Create/Verify Product Offering Exists
      var pofConfiguration = new ProductOfferingFactoryConfiguration(testShortName, testRunUniqueIdentifier)
      {
        CountNRCs = 1,
        CountPairRCs = 1,
        CountPairUDRCs = 1
      };

      var productOffering = ProductOfferingFactory.Create(pofConfiguration);
      var idProductOfferingToQuoteFor = productOffering.ID;

      #endregion

      #region Test and Verify

      var request = new QuoteRequest();
      request.Accounts.Add(idAccountToQuoteFor);
      request.Accounts.Add(idAccountToQuoteFor2);
      request.Accounts.Add(idAccountToQuoteFor3);
      request.ProductOfferings.Add(idProductOfferingToQuoteFor);
      request.QuoteIdentifier = "MyQuoteId-" + testShortName + "-1234";
      request.QuoteDescription = "Quote generated by Automated Test: " + testShortName;
      request.ReportParameters = new ReportParams()
        {
          PDFReport = QuotingTestScenarios.RunPDFGenerationForAllTestsByDefault
        };
      request.EffectiveDate = MetraTime.Now;
      request.EffectiveEndDate = MetraTime.Now.AddDays(1);
      request.Localization = "en-US";
      request.SubscriptionParameters.UDRCValues = SharedTestCode.GetUDRCInstanceValuesSetToMiddleValues(productOffering);
      request.SubscriptionParameters.CorporateAccountId = idAccountToQuoteFor;
      request.SubscriptionParameters.IsGroupSubscription = true;

      var expectedQuoteCurrency = "USD";

      var numOfAccounts = request.Accounts.Count;
      var expectedQuoteNRCsCount = pofConfiguration.CountNRCs * numOfAccounts;
      var expectedQuoteFlatRCsCount = pofConfiguration.CountPairRCs + (pofConfiguration.CountPairRCs * numOfAccounts);
      var expectedQuoteUDRCsCount = pofConfiguration.CountPairUDRCs + (pofConfiguration.CountPairUDRCs * numOfAccounts);
      decimal totalAmountForUDRC = 30;
      var expectedQuoteTotal = (expectedQuoteFlatRCsCount * pofConfiguration.RCAmount) +
                      (expectedQuoteUDRCsCount * totalAmountForUDRC) +
                      (expectedQuoteNRCsCount * pofConfiguration.NRCAmount);

      QuoteResponse response = null;

      bool clientInvoked = false;
      try
      {
        response = SharedTestCodeQuoting.InvokeCreateQuote(request);
        clientInvoked = true;
      }
      catch (Exception ex)
      {
        Assert.Fail("QuotingService_CreateQuote_Client thrown an exception: " + ex.Message);
      }

      Assert.IsFalse(response.Status == QuoteStatus.Failed, response.FailedMessage);
      Assert.IsTrue(clientInvoked, "QuotingService_CreateQuote_Client didn't executed propely");
      Assert.AreEqual(expectedQuoteTotal, response.TotalAmount, "Wrong TotalAmount");
      //Assert.AreEqual(expectedQuoteTotalTax, response.TotalTax, String.Format("Wrong TotalTax. Actual is {0}, but expected {1}", response.TotalTax, expectedQuoteTotalTax));
      Assert.AreEqual(expectedQuoteCurrency, response.Currency, "Wrong Currency");

      #endregion
    }

    [TestMethod, MTFunctionalTest(TestAreas.Quoting)]
    public void T03QuotingServiceCreateQuote_TwoQuotesInParallel_PositiveTest()
    {
      var testShortName = "Q_AS_D_PO"; //Account name and perhaps others need a 'short' (less than 40 when combined with testRunUniqueIdentifier
      var testRunUniqueIdentifier = MetraTime.NowWithMilliSec.ToString(); //Identifier to make this run unique

      var idAccountToQuoteFor = SharedTestCode.GetCorporateAccountToQuoteFor(testShortName, testRunUniqueIdentifier);
      testRunUniqueIdentifier = MetraTime.NowWithMilliSec;
      var idAccountToQuoteFor2 = SharedTestCode.GetCorporateAccountToQuoteFor(testShortName, testRunUniqueIdentifier);

      // Create/Verify Product Offering Exists
      var pofConfiguration = new ProductOfferingFactoryConfiguration(_testContext.TestName, testRunUniqueIdentifier)
      {
        CountNRCs = 1,
        CountPairRCs = 1
      };
      var productOffering = ProductOfferingFactory.Create(pofConfiguration);
      var idProductOfferingToQuoteFor = productOffering.ID;

      testRunUniqueIdentifier = MetraTime.Now.ToString();

      pofConfiguration = new ProductOfferingFactoryConfiguration(_testContext.TestName, testRunUniqueIdentifier)
      {
        CountNRCs = 1,
        CountPairRCs = 1
      };
      productOffering = ProductOfferingFactory.Create(pofConfiguration);
      var idProductOfferingToQuoteFor2 = productOffering.ID;

      Parallel.Invoke(()
        => CreateAndVerifyQuote(idAccountToQuoteFor,
                                idProductOfferingToQuoteFor,
                                _testContext.TestName,
                                testShortName), ()
                        => CreateAndVerifyQuote(idAccountToQuoteFor2,
                                                idProductOfferingToQuoteFor2,
                                                 _testContext.TestName,
                                                testShortName));
    }

    [TestMethod, MTFunctionalTest(TestAreas.Quoting)]
    public void T04QuotingServiceCreateQuote_TwoQuotesInParallelWithSamePO_PositiveTest()
    {
      var testShortName = "Q_AS_S_PO"; //Account name and perhaps others need a 'short' (less than 40 when combined with testRunUniqueIdentifier
      var testRunUniqueIdentifier = MetraTime.NowWithMilliSec.ToString(); //Identifier to make this run unique

      var idAccountToQuoteFor = SharedTestCode.GetCorporateAccountToQuoteFor(testShortName, testRunUniqueIdentifier);
      testRunUniqueIdentifier = MetraTime.NowWithMilliSec;
      var idAccountToQuoteFor2 = SharedTestCode.GetCorporateAccountToQuoteFor(testShortName, testRunUniqueIdentifier);

      // Create/Verify Product Offering Exists
      var pofConfiguration = new ProductOfferingFactoryConfiguration(_testContext.TestName, testRunUniqueIdentifier)
        {
          CountNRCs = 1,
          CountPairRCs = 1
        };

      var productOffering = ProductOfferingFactory.Create(pofConfiguration);
      var idProductOfferingToQuoteFor = productOffering.ID;

      Parallel.Invoke(()
        => CreateAndVerifyQuote(idAccountToQuoteFor, idProductOfferingToQuoteFor,
                               _testContext.TestName, testShortName), ()
          => CreateAndVerifyQuote(idAccountToQuoteFor2, idProductOfferingToQuoteFor,
                                _testContext.TestName, testShortName));
    }


    [TestMethod, MTFunctionalTest(TestAreas.Quoting)]
    public void T05QuotingServiceCreateQuote_QuoteTwoTimesNonParallel_PositiveTest()
    {
      #region Prepare
      var testShortName = "Q_AS_2Qs"; //Account name and perhaps others need a 'short' (less than 40 when combined with testRunUniqueIdentifier
      var testRunUniqueIdentifier = MetraTime.Now.ToString(); //Identifier to make this run unique

      var idAccountToQuoteFor = SharedTestCode.GetCorporateAccountToQuoteFor(testShortName, testRunUniqueIdentifier);

      // Create/Verify Product Offering Exists
      var pofConfiguration = new ProductOfferingFactoryConfiguration(_testContext.TestName, testRunUniqueIdentifier)
        {
          CountNRCs = 1,
          CountPairRCs = 1
        };
      var productOffering = ProductOfferingFactory.Create(pofConfiguration);
      var idProductOfferingToQuoteFor = productOffering.ID;

      //Values to use for verification
      decimal expectedQuoteTotal = (pofConfiguration.CountPairRCs * pofConfiguration.RCAmount * 2) + (pofConfiguration.CountNRCs * pofConfiguration.NRCAmount);
      string expectedQuoteCurrency = "USD";

      #endregion

      #region Test and Verify

      var request = new QuoteRequest();
      request.Accounts.Add(idAccountToQuoteFor);
      request.ProductOfferings.Add(idProductOfferingToQuoteFor);
      request.QuoteIdentifier = "MyQuoteId-" + testShortName + "-1234";
      request.QuoteDescription = "Quote generated by Automated Test: " + _testContext.TestName;
      request.ReportParameters = new ReportParams()
        {
          PDFReport = QuotingTestScenarios.RunPDFGenerationForAllTestsByDefault
        };
      request.EffectiveDate = MetraTime.Now;
      request.EffectiveEndDate = MetraTime.Now;

      QuoteResponse response = null;

      var clientInvoked = false;
      try
      {
        response = SharedTestCodeQuoting.InvokeCreateQuote(request);
        clientInvoked = true;
      }
      catch (Exception ex)
      {
        Assert.Fail("QuotingService_CreateQuote_Client thrown an exception: " + ex.Message);
      }

      Assert.IsFalse(response.Status == QuoteStatus.Failed, response.FailedMessage);
      Assert.IsTrue(clientInvoked, "QuotingService_CreateQuote_Client didn't executed propely");
      Assert.AreEqual(expectedQuoteTotal, response.TotalAmount, "Wrong TotalAmount");
      Assert.AreEqual(expectedQuoteCurrency, response.Currency, "Wrong Currency");

      QuoteResponse response2 = null;

      clientInvoked = false;
      try
      {
        response2 = SharedTestCodeQuoting.InvokeCreateQuote(request);
        clientInvoked = true;
      }
      catch (Exception ex)
      {
        Assert.Fail("QuotingService_CreateQuote_Client thrown an exception: " + ex.Message);
      }

      Assert.IsFalse(response.Status == QuoteStatus.Failed, response.FailedMessage);
      Assert.IsTrue(clientInvoked, "QuotingService_CreateQuote_Client didn't executed propely");
      Assert.AreEqual(expectedQuoteTotal, response.TotalAmount, "Wrong TotalAmount");
      Assert.AreEqual(expectedQuoteCurrency, response.Currency, "Wrong Currency");

      Assert.AreEqual(response.TotalAmount, response2.TotalAmount, "Total amount was different on the second run");

      #endregion
    }

    /// <summary>
    /// TC_QICB_51
    /// </summary>
    [TestMethod, MTFunctionalTest(TestAreas.Quoting)]
    public void T06QuotingServiceCreateQuote_QuoteWithICBTwoTimesAsync_PositiveTest()
    {
      #region Prepare
      string testName = "QuotingActivityServiceGenerateQuoteWithICBTwoTimesAsync_PositiveTest";
      string testShortName = "TC_QICB_51"; //Account name and perhaps others need a 'short' (less than 40 when combined with testRunUniqueIdentifier
      string testRunUniqueIdentifier = MetraTime.Now.ToString(); //Identifier to make this run unique

      var idAccountToQuoteFor = SharedTestCode.GetCorporateAccountToQuoteFor(testShortName, testRunUniqueIdentifier);

      // Create/Verify Product Offerings Exists
      var pofConfiguration1 = new ProductOfferingFactoryConfiguration(testName, testRunUniqueIdentifier + "1")
      {
        CountNRCs = 0,
        CountPairRCs = 1,
        CountPairUDRCs = 0
      };

      var pofConfiguration2 = new ProductOfferingFactoryConfiguration(testName, testRunUniqueIdentifier + "2")
      {
        CountNRCs = 0,
        CountPairRCs = 1,
        CountPairUDRCs = 0
      };

      var productOffering1 = ProductOfferingFactory.Create(pofConfiguration1);
      var productOffering2 = ProductOfferingFactory.Create(pofConfiguration2);
      var idProductOfferingToQuoteFor1 = productOffering1.ID;
      var idProductOfferingToQuoteFor2 = productOffering2.ID;

      using (var client = new PriceListServiceClient())
      {
        if (client.ClientCredentials != null)
        {
          client.ClientCredentials.UserName.UserName = "su";
          client.ClientCredentials.UserName.Password = "su123";
        }

        var instances1 = productOffering1.GetPriceableItems();
        var instances2 = productOffering2.GetPriceableItems();

        var productOfferingFactory = new ProductOfferingFactory();
        productOfferingFactory.Initialize(testName, testRunUniqueIdentifier);

        var parameterTableFlatRc = productOfferingFactory.ProductCatalog.GetParamTableDefinitionByName(SharedTestCode.MetratechComFlatrecurringcharge);

        #region Set Allow ICB for PIs
        foreach (IMTPriceableItem possibleRC in instances1)
        {
          if (possibleRC.Kind == MTPCEntityType.PCENTITY_TYPE_RECURRING)
          {
            var piAndPTParameters = SharedTestCode.SetAllowICBForPI(possibleRC, client, productOffering1.ID, parameterTableFlatRc.ID, SharedTestCode.MetratechComFlatrecurringcharge);
            pofConfiguration1.PriceableItemsAndParameterTableForRc.Add(piAndPTParameters);
          }
        }

        foreach (IMTPriceableItem possibleRC in instances2)
        {
          if (possibleRC.Kind == MTPCEntityType.PCENTITY_TYPE_RECURRING)
          {
            var piAndPTParameters = SharedTestCode.SetAllowICBForPI(possibleRC, client, productOffering2.ID, parameterTableFlatRc.ID, SharedTestCode.MetratechComFlatrecurringcharge);
            pofConfiguration2.PriceableItemsAndParameterTableForRc.Add(piAndPTParameters);
          }
        }
        #endregion
      }

      var expectedQuoteTotal1 = 66.66m * 2;   //*2 because we generated RC per subscription and rep participant
      var expectedQuoteTotal2 = 66.66m * 2;

      #endregion

      #region Test and Verify

      #region Invoke CreateQuote for PO #1
      var request1 = new QuoteRequest();
      request1.Accounts.Add(idAccountToQuoteFor);
      request1.ProductOfferings.Add(idProductOfferingToQuoteFor1);
      request1.QuoteIdentifier = "MyQuoteId-" + testShortName + "-1234";
      request1.QuoteDescription = "Quote generated by Automated Test: " + testName;
      request1.ReportParameters = new ReportParams() { PDFReport = QuotingTestScenarios.RunPDFGenerationForAllTestsByDefault };
      request1.EffectiveDate = MetraTime.Now;
      request1.EffectiveEndDate = MetraTime.Now;


      #region Initialize ICB prices

      var quoteId = DateTime.Now.Millisecond;

      request1.IcbPrices = new List<IndividualPrice>();

      if (pofConfiguration1.PriceableItemsAndParameterTableForRc != null &&
          pofConfiguration1.PriceableItemsAndParameterTableForRc.Count > 0)
      {
        var chargeRate = new ChargesRate { Price = 66.66m };
        var qip = new IndividualPrice
        {
          ProductOfferingId = idProductOfferingToQuoteFor1,
          CurrentChargeType = ChargeType.RecurringCharge,
          ChargesRates = new List<ChargesRate> { chargeRate }
        };

        request1.IcbPrices.Add(qip);
      }

      #endregion

      QuoteResponse response1 = null;
      bool clientInvoked = false;
      try
      {
        response1 = SharedTestCodeQuoting.InvokeCreateQuote(request1);
        clientInvoked = true;
      }
      catch (Exception ex)
      {
        Assert.Fail("QuotingService_CreateQuote_Client thrown an exception: " + ex.Message);
      }

      Assert.IsFalse(response1.Status == QuoteStatus.Failed, response1.FailedMessage);
      Assert.IsTrue(clientInvoked, "QuotingService_CreateQuote_Client didn't executed propely");
      Assert.AreEqual(expectedQuoteTotal1, response1.TotalAmount, "Wrong TotalAmount");


      #region Assync call through delegate
      QuotingServiceClient qsc = new QuotingServiceClient();

      try
      {

        qsc.ClientCredentials.UserName.UserName = "su";
        qsc.ClientCredentials.UserName.Password = "su123";

        QuoteAsyncProcessingDelegate asynCall = QuoteAsyncProcessing;

        // Asynchronously invoke the Factorize method.
        IAsyncResult result = asynCall.BeginInvoke(qsc, request1, out response1, null, null);

        while (!result.IsCompleted)
        {
          // Do any work you can do before waiting.
          result.AsyncWaitHandle.WaitOne(1000, false);
        }
        result.AsyncWaitHandle.Close();

        Assert.IsFalse(response1.Status == QuoteStatus.Failed, response1.FailedMessage);
        Assert.AreEqual(expectedQuoteTotal1, response1.TotalAmount, "Wrong TotalAmount");

      }
      catch (Exception ex)
      {
        Assert.Fail("QuotingService_CreateQuote_Client thrown an exception: " + ex.Message);
      }
      finally
      {
        if (qsc.State != CommunicationState.Opened)
        {
          qsc.Abort();
        }
      }

      #endregion

      #endregion

      #region Invoke CreateQuote for PO #2

      #region Initialize ICB prices

      //backup ICBs for first request
      var ICBsReuest1Backup = request1.IcbPrices;

      request1.ProductOfferings.Clear();
      request1.ProductOfferings.Add(idProductOfferingToQuoteFor2);

      //ToDo: Verify. Maybe we can use previous request
      request1.IcbPrices = new List<IndividualPrice>();

      if (pofConfiguration1.PriceableItemsAndParameterTableForRc != null &&
          pofConfiguration1.PriceableItemsAndParameterTableForRc.Count > 0)
      {
        var chargeRate = new ChargesRate { Price = 66.66m };
        var qip = new IndividualPrice
        {
          ProductOfferingId = idProductOfferingToQuoteFor2,
          CurrentChargeType = ChargeType.RecurringCharge,
          ChargesRates = new List<ChargesRate> { chargeRate }
        };

        request1.IcbPrices.Add(qip);
      }

      #endregion

      QuoteResponse response2 = null;

      clientInvoked = false;
      try
      {
        response2 = SharedTestCodeQuoting.InvokeCreateQuote(request1);
        clientInvoked = true;
      }
      catch (Exception ex)
      {
        Assert.Fail("QuotingService_CreateQuote_Client thrown an exception: " + ex.Message);
      }

      Assert.IsFalse(response2.Status == QuoteStatus.Failed, response2.FailedMessage);
      Assert.IsTrue(clientInvoked, "QuotingService_CreateQuote_Client didn't executed propely");
      Assert.AreEqual(expectedQuoteTotal2, response2.TotalAmount, "Wrong TotalAmount");

      Assert.AreEqual(response2.TotalAmount, response2.TotalAmount, "Total amount was different on the second run");

      #region Assync call through delegate

      qsc = new QuotingServiceClient();

      try
      {
        qsc.ClientCredentials.UserName.UserName = "su";
        qsc.ClientCredentials.UserName.Password = "su123";

        QuoteAsyncProcessingDelegate asynCall = QuoteAsyncProcessing;

        // Asynchronously invoke the Factorize method.
        IAsyncResult result = asynCall.BeginInvoke(qsc, request1, out response2, null, null);

        while (!result.IsCompleted)
        {
          // Do any work you can do before waiting.
          result.AsyncWaitHandle.WaitOne(1000, false);
        }
        result.AsyncWaitHandle.Close();

        Assert.IsFalse(response1.Status == QuoteStatus.Failed, response2.FailedMessage);
        Assert.AreEqual(expectedQuoteTotal2, response2.TotalAmount, "Wrong TotalAmount");

      }
      catch (Exception ex)
      {
        Assert.Fail("QuotingService_CreateQuote_Client thrown an exception: " + ex.Message);
      }
      finally
      {
        if (qsc.State != CommunicationState.Opened)
        {
          qsc.Abort();
        }
      }

      #endregion

      #endregion



      #region Create Subscription for PO #2. Enter Custom Rates.

      MTSubscription subscription2 = null;
      MTPCAccount account2 = null;
      bool subscriptionForPO2Created = false;
      //bool ICBSForSubscription2Created = false;

      try
      {
        account2 = SharedTestCode.CurrentProductCatalog.GetAccount(idAccountToQuoteFor);

        var effDate = new MTPCTimeSpanClass
        {
          StartDate = request1.EffectiveDate,
          StartDateType = MTPCDateType.PCDATE_TYPE_ABSOLUTE
        };

        object modifiedDate = MetraTime.Now;
        subscription2 = account2.Subscribe(idProductOfferingToQuoteFor2, effDate, out modifiedDate);
        subscriptionForPO2Created = true;

        //SharedTestCode.ApplyIcbPricesToSubscription(idProductOfferingToQuoteFor2, subscription2.ID, request1.IcbPrices);
        //ICBSForSubscription2Created = true;

      }
      catch (Exception ex)
      {
        Assert.Fail("Creating subscription after quote failed with exception: " + ex);
      }
      finally
      {
        if (subscription2 != null)
        {
          account2.RemoveSubscription(subscription2.ID);
        }
      }

      #endregion

      #region Create Subscription for PO #1. Enter Custom Rates.

      request1.IcbPrices = ICBsReuest1Backup;

      MTSubscription subscription1 = null;
      MTPCAccount account1 = null;
      bool subscriptionForPO1Created = false;
      //bool ICBSForSubscription1Created = false;

      try
      {
        account1 = SharedTestCode.CurrentProductCatalog.GetAccount(idAccountToQuoteFor);

        var effDate = new MTPCTimeSpanClass
        {
          StartDate = request1.EffectiveDate,
          StartDateType = MTPCDateType.PCDATE_TYPE_ABSOLUTE
        };

        object modifiedDate = MetraTime.Now;
        subscription1 = account1.Subscribe(idProductOfferingToQuoteFor1, effDate, out modifiedDate);
        subscriptionForPO1Created = true;

        //SharedTestCode.ApplyIcbPricesToSubscription(idProductOfferingToQuoteFor1, subscription1.ID, request1.IcbPrices);
        //ICBSForSubscription1Created = true;

      }
      catch (Exception ex)
      {
        Assert.Fail("Creating subscription after quote failed with exception: " + ex);
      }
      finally
      {
        if (subscription1 != null)
        {
          account1.RemoveSubscription(subscription1.ID);
        }
      }

      Assert.IsTrue(subscriptionForPO1Created, "Subscription wasn't created for PO #1");
      Assert.IsTrue(subscriptionForPO2Created, "Subscription wasn't created for PO #2");
      //Assert.IsTrue(ICBSForSubscription1Created, "ICBS for subscription1 wasn't created");
      //Assert.IsTrue(ICBSForSubscription2Created, "ICBS for subscription1 wasn't created");

      #endregion

      #endregion
    }

    #region ignored tests
    //[TestMethod, MTFunctionalTest(TestAreas.Quoting), Ignore]
    public void QuotingServiceCreateQuote_TwoQuotesInParallelWithSamePOAndSameAcc_PositiveTest()
    {
      string testShortName = "Q_AS_S_PO"; //Account name and perhaps others need a 'short' (less than 40 when combined with testRunUniqueIdentifier
      string testRunUniqueIdentifier = MetraTime.NowWithMilliSec.ToString(); //Identifier to make this run unique

      CorporateAccountFactory corpAccountHolder = new CorporateAccountFactory(testShortName, testRunUniqueIdentifier);
      corpAccountHolder.Instantiate();

      Assert.IsNotNull(corpAccountHolder.Item._AccountID, "Unable to create account for test run");
      int idAccountToQuoteFor = (int)corpAccountHolder.Item._AccountID;

      // Create/Verify Product Offering Exists
      var pofConfiguration = new ProductOfferingFactoryConfiguration(_testContext.TestName, testRunUniqueIdentifier);

      pofConfiguration.CountNRCs = 1;
      pofConfiguration.CountPairRCs = 1;

      IMTProductOffering productOffering = ProductOfferingFactory.Create(pofConfiguration);
      Assert.IsNotNull(productOffering.ID, "Unable to create PO for test run");
      int idProductOfferingToQuoteFor = productOffering.ID;

      Parallel.Invoke(()
        => CreateAndVerifyQuote(idAccountToQuoteFor,
                                idProductOfferingToQuoteFor,
                                _testContext.TestName,
                                testShortName,
                                "The account is already subscribed"), ()
                  => CreateAndVerifyQuote(idAccountToQuoteFor,
                                         idProductOfferingToQuoteFor,
                                         _testContext.TestName,
                                         testShortName));
    }
    #endregion

    private delegate void QuoteAsyncProcessingDelegate(QuotingServiceClient quotingService, QuoteRequest req,
                                                       out QuoteResponse quoteResp);

    // Async processing which does not affect response
    private void QuoteAsyncProcessing(QuotingServiceClient quotingService, QuoteRequest req,
                                      out QuoteResponse quoteResp)
    {
      Trace.WriteLine("Begin Async Processing");
      quoteResp = null;
      try
      {

        quotingService.CreateQuote(req, out quoteResp);


      }
      finally
      {
        if (quotingService.State == CommunicationState.Opened)
        {
          quotingService.Close();
        }
        else
        {
          quotingService.Abort();
        }
      }

      Trace.WriteLine("Finished Async Processing");
    }

    #region Helpers


    /// <summary>
    /// Creates and verifies the created quote if failed message is not expected,
    /// otherwise checks that quote response status is failed and that the failed message
    /// contains the expected text
    /// </summary>
    /// <param name="idAccount">Account id to quote for</param>
    /// <param name="idPO">PO id to quote for</param>
    /// <param name="testName"></param>
    /// <param name="testShortName"></param>
    /// <param name="partialFailedMessage">Part of the failed message that is expected.
    /// Skip or set to null if the request is expected to pass and to be verified</param>
    /// <returns>Created and verified response</returns>
    private QuoteResponse CreateAndVerifyQuote(int idAccount, int idPO, string testName, string testShortName, string partialFailedMessage = null)
    {
      #region Prepare

      //Values to use for verification
      decimal expectedQuoteTotal = 19.95M * 2 + 9.95M;
      string expectedQuoteCurrency = "USD";

      #endregion

      #region Test and Verify

      var request = new QuoteRequest();
      request.Accounts.Add(idAccount);
      request.ProductOfferings.Add(idPO);
      request.QuoteIdentifier = "MyQuoteId-" + testShortName + "-1234";
      request.QuoteDescription = "Quote generated by Automated Test: " + testName;
      request.ReportParameters = new ReportParams() { PDFReport = QuotingTestScenarios.RunPDFGenerationForAllTestsByDefault };
      request.EffectiveDate = MetraTime.Now;
      request.EffectiveEndDate = MetraTime.Now.AddMonths(2);

      QuoteResponse response = null;

      bool clientInvoked = false;
      try
      {
        response = SharedTestCodeQuoting.InvokeCreateQuote(request);
        clientInvoked = true;
      }
      catch (Exception ex)
      {
        Assert.Fail("QuotingService_CreateQuote_Client thrown an exception: " + ex.Message);
      }

      if (partialFailedMessage == null)
      {
        Assert.IsFalse(response.Status == QuoteStatus.Failed, response.FailedMessage);
        Assert.IsTrue(clientInvoked, "QuotingService_CreateQuote_Client didn't executed propely");
        Assert.AreEqual(expectedQuoteTotal, response.TotalAmount, "Wrong TotalAmount");
        Assert.AreEqual(expectedQuoteCurrency, response.Currency, "Wrong Currency");
      }
      else
      {
        Assert.IsTrue(response.Status == QuoteStatus.Failed, "The quote response status was not failed");
        Assert.IsTrue(response.FailedMessage.Contains(partialFailedMessage), "The quote response message was incorrect");
      }

      #endregion

      return response;
    }
    #endregion
  }
}
