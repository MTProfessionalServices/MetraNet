using System;
using System.Collections.Generic;
using System.ServiceModel;
using System.Threading.Tasks;
using MetraTech.Core.Services.ClientProxies;
using MetraTech.Domain.Quoting;
using MetraTech.Interop.MTProductCatalog;
using MetraTech.TestCommon;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Diagnostics;

namespace MetraTech.Core.Services.Test.Quoting
{
    [TestClass]
    public class QuotingActivityServiceFunctionalTests
    {
        private static TestContext _testContext;
        #region Setup/Teardown

        [ClassInitialize]
        public static void InitTests(TestContext testContext)
        {
            _testContext = testContext;
            SharedTestCode.MakeSureServiceIsStarted("ActivityServices");
            SharedTestCode.MakeSureServiceIsStarted("Pipeline");
        }

        #endregion
        [TestMethod, MTFunctionalTest(TestAreas.Quoting)]
        public void QuotingServiceCreateQuote_BasicScenario_PositiveTest()
        {
            #region Prepare
            string testShortName = "Q_AS_Basic"; //Account name and perhaps others need a 'short' (less than 40 when combined with testRunUniqueIdentifier
            //string testDescription = @"";
            string testRunUniqueIdentifier = MetraTime.Now.ToString(); //Identifier to make this run unique

            // Create account
            CorporateAccountFactory corpAccountHolder = new CorporateAccountFactory(testShortName, testRunUniqueIdentifier);
            corpAccountHolder.Instantiate();

            Assert.IsNotNull(corpAccountHolder.Item._AccountID, "Unable to create account for test run");
            int idAccountToQuoteFor = (int)corpAccountHolder.Item._AccountID;

            // Create/Verify Product Offering Exists
            var pofConfiguration = new ProductOfferingFactoryConfiguration(_testContext.TestName, testRunUniqueIdentifier);

            pofConfiguration.CountNRCs = 1;
            pofConfiguration.CountPairRCs = 1; //????
            pofConfiguration.CountPairUDRCs = 1;


            IMTProductOffering productOffering = ProductOfferingFactory.Create(pofConfiguration);
            Assert.IsNotNull(productOffering.ID, "Unable to create PO for test run");
            int idProductOfferingToQuoteFor = productOffering.ID;

            //Values to use for verification
            int numOfAccounts = 1;
            int expectedQuoteNRCsCount = pofConfiguration.CountNRCs * numOfAccounts;
            int expectedQuoteFlatRCsCount = pofConfiguration.CountPairRCs + (pofConfiguration.CountPairRCs * numOfAccounts);
            int expectedQuoteUDRCsCount = pofConfiguration.CountPairUDRCs + (pofConfiguration.CountPairUDRCs * numOfAccounts);

            decimal totalAmountForUDRC = 30;

            decimal expectedQuoteTotal = (expectedQuoteFlatRCsCount * pofConfiguration.RCAmount) +
                                         (expectedQuoteUDRCsCount * totalAmountForUDRC) +
                                         (expectedQuoteNRCsCount * pofConfiguration.NRCAmount);
            //decimal expectedQuoteTotalTax = expectedQuoteTotal * 0.05m + expectedQuoteTotal * 0.025m * 4;	//values from dummy stage to calculate taxes (TA818)
            decimal expectedQuoteTotalTax = 0;

            string expectedQuoteCurrency = "USD";

            #endregion

            #region Test and Verify

            var request = new QuoteRequest();
            request.Accounts.Add(idAccountToQuoteFor);
            request.ProductOfferings.Add(idProductOfferingToQuoteFor);
            request.QuoteIdentifier = "MyQuoteId-" + testShortName + "-1234";
            request.QuoteDescription = "Quote generated by Automated Test: " + _testContext.TestName;
            request.ReportParameters = new ReportParams() { PDFReport = QuotingTestScenarios.RunPDFGenerationForAllTestsByDefault };
            request.Localization = "en-US";
            request.SubscriptionParameters.UDRCValues = SharedTestCode.GetUDRCInstanceValuesSetToMiddleValues(productOffering);
            
            QuoteResponse response = null;

            bool clientInvoked = false;
            try
            {
                response = SharedTestCodeQuoting.InvokeCreateQuote(request);
                clientInvoked = true;
            }
            catch (Exception ex)
            {
                Assert.Fail("QuotingService_CreateQuote_Client thrown an exception: " + ex.Message);
            }

            Assert.IsFalse(response.Status == QuoteStatus.Failed, response.FailedMessage);
            Assert.IsTrue(clientInvoked, "QuotingService_CreateQuote_Client didn't executed propely");
            Assert.AreEqual(expectedQuoteTotal, response.TotalAmount, "Wrong TotalAmount");
            Assert.AreEqual(expectedQuoteTotalTax, response.TotalTax, String.Format("Wrong TotalTax. Actual is {0}, but expected {1}", response.TotalTax, expectedQuoteTotalTax));
            Assert.AreEqual(expectedQuoteCurrency, response.Currency, "Wrong Currency");

            #endregion
        }

        [TestMethod, MTFunctionalTest(TestAreas.Quoting)]
        public void QuotingServiceCreateQuote_TwoQuotesInParallel_PositiveTest()
        {
            string testShortName = "Q_AS_D_PO"; //Account name and perhaps others need a 'short' (less than 40 when combined with testRunUniqueIdentifier
            string testRunUniqueIdentifier = MetraTime.NowWithMilliSec.ToString(); //Identifier to make this run unique

            // Create account #1
            CorporateAccountFactory corpAccountHolder = new CorporateAccountFactory(testShortName, testRunUniqueIdentifier);
            corpAccountHolder.Instantiate();

            Assert.IsNotNull(corpAccountHolder.Item._AccountID, "Unable to create account for test run");
            int idAccountToQuoteFor = (int)corpAccountHolder.Item._AccountID;

            // Create account #2
            testRunUniqueIdentifier = MetraTime.NowWithMilliSec;
            corpAccountHolder = new CorporateAccountFactory(testShortName, testRunUniqueIdentifier);
            corpAccountHolder.Instantiate();

            Assert.IsNotNull(corpAccountHolder.Item._AccountID, "Unable to create account for test run");
            int idAccountToQuoteFor2 = (int)corpAccountHolder.Item._AccountID;

            // Create/Verify Product Offering Exists
            var pofConfiguration = new ProductOfferingFactoryConfiguration(_testContext.TestName, testRunUniqueIdentifier);

            pofConfiguration.CountNRCs = 1;
            pofConfiguration.CountPairRCs = 1;

            IMTProductOffering productOffering = ProductOfferingFactory.Create(pofConfiguration);
            Assert.IsNotNull(productOffering.ID, "Unable to create PO for test run");
            int idProductOfferingToQuoteFor = productOffering.ID;

            testRunUniqueIdentifier = MetraTime.Now.ToString();
            pofConfiguration = new ProductOfferingFactoryConfiguration(_testContext.TestName, testRunUniqueIdentifier);

            pofConfiguration.CountNRCs = 1;
            pofConfiguration.CountPairRCs = 1;

            productOffering = ProductOfferingFactory.Create(pofConfiguration);
            Assert.IsNotNull(productOffering.ID, "Unable to create PO for test run");
            int idProductOfferingToQuoteFor2 = productOffering.ID;

            Parallel.Invoke(()
              => CreateAndVerifyQuote(idAccountToQuoteFor,
                                      idProductOfferingToQuoteFor,
                                      _testContext.TestName,
                                      testShortName), ()
                              => CreateAndVerifyQuote(idAccountToQuoteFor2,
                                                      idProductOfferingToQuoteFor2,
                                                       _testContext.TestName,
                                                      testShortName));
        }

        [TestMethod, MTFunctionalTest(TestAreas.Quoting)]
         public void QuotingServiceCreateQuote_TwoQuotesInParallelWithSamePO_PositiveTest()
        {
            string testShortName = "Q_AS_S_PO"; //Account name and perhaps others need a 'short' (less than 40 when combined with testRunUniqueIdentifier
            string testRunUniqueIdentifier = MetraTime.NowWithMilliSec.ToString(); //Identifier to make this run unique

            // Create account #1
            CorporateAccountFactory corpAccountHolder = new CorporateAccountFactory(testShortName, testRunUniqueIdentifier);
            corpAccountHolder.Instantiate();

            Assert.IsNotNull(corpAccountHolder.Item._AccountID, "Unable to create account for test run");
            int idAccountToQuoteFor = (int)corpAccountHolder.Item._AccountID;

            // Create account #2
            testRunUniqueIdentifier = MetraTime.NowWithMilliSec.ToString();
            corpAccountHolder = new CorporateAccountFactory(testShortName, testRunUniqueIdentifier);
            corpAccountHolder.Instantiate();

            Assert.IsNotNull(corpAccountHolder.Item._AccountID, "Unable to create account for test run");
            int idAccountToQuoteFor2 = (int)corpAccountHolder.Item._AccountID;

            // Create/Verify Product Offering Exists
            var pofConfiguration = new ProductOfferingFactoryConfiguration(_testContext.TestName, testRunUniqueIdentifier);

            pofConfiguration.CountNRCs = 1;
            pofConfiguration.CountPairRCs = 1;

            IMTProductOffering productOffering = ProductOfferingFactory.Create(pofConfiguration);
            Assert.IsNotNull(productOffering.ID, "Unable to create PO for test run");
            int idProductOfferingToQuoteFor = productOffering.ID;

            Parallel.Invoke(()
              => CreateAndVerifyQuote(idAccountToQuoteFor, idProductOfferingToQuoteFor,
                                     _testContext.TestName, testShortName), ()
                => CreateAndVerifyQuote(idAccountToQuoteFor2, idProductOfferingToQuoteFor,
                                      _testContext.TestName, testShortName));
        }

        [TestMethod, MTFunctionalTest(TestAreas.Quoting), Ignore]
        public void QuotingServiceCreateQuote_TwoQuotesInParallelWithSamePOAndSameAcc_PositiveTest()
        {
            string testShortName = "Q_AS_S_PO"; //Account name and perhaps others need a 'short' (less than 40 when combined with testRunUniqueIdentifier
            string testRunUniqueIdentifier = MetraTime.NowWithMilliSec.ToString(); //Identifier to make this run unique

            CorporateAccountFactory corpAccountHolder = new CorporateAccountFactory(testShortName, testRunUniqueIdentifier);
            corpAccountHolder.Instantiate();

            Assert.IsNotNull(corpAccountHolder.Item._AccountID, "Unable to create account for test run");
            int idAccountToQuoteFor = (int)corpAccountHolder.Item._AccountID;

            // Create/Verify Product Offering Exists
            var pofConfiguration = new ProductOfferingFactoryConfiguration(_testContext.TestName, testRunUniqueIdentifier);

            pofConfiguration.CountNRCs = 1;
            pofConfiguration.CountPairRCs = 1;

            IMTProductOffering productOffering = ProductOfferingFactory.Create(pofConfiguration);
            Assert.IsNotNull(productOffering.ID, "Unable to create PO for test run");
            int idProductOfferingToQuoteFor = productOffering.ID;

            Parallel.Invoke(()
              => CreateAndVerifyQuote(idAccountToQuoteFor,
                                      idProductOfferingToQuoteFor,
                                      _testContext.TestName,
                                      testShortName,
                                      "The account is already subscribed"), ()
                        => CreateAndVerifyQuote(idAccountToQuoteFor,
                                               idProductOfferingToQuoteFor,
                                               _testContext.TestName,
                                               testShortName));
        }


       [TestMethod, MTFunctionalTest(TestAreas.Quoting)]
        // TODO: Do we need the test, looks like it's the same as  
        public void QuotingServiceCreateQuote_QuoteTwoTimesNonParallel_PositiveTest()
        {
            #region Prepare
            string testShortName = "Q_AS_2Qs"; //Account name and perhaps others need a 'short' (less than 40 when combined with testRunUniqueIdentifier
            string testRunUniqueIdentifier = MetraTime.Now.ToString(); //Identifier to make this run unique

            // Create account
            CorporateAccountFactory corpAccountHolder = new CorporateAccountFactory(testShortName, testRunUniqueIdentifier);
            corpAccountHolder.Instantiate();

            Assert.IsNotNull(corpAccountHolder.Item._AccountID, "Unable to create account for test run");
            int idAccountToQuoteFor = (int)corpAccountHolder.Item._AccountID;

            // Create/Verify Product Offering Exists
            var pofConfiguration = new ProductOfferingFactoryConfiguration(_testContext.TestName, testRunUniqueIdentifier);

            pofConfiguration.CountNRCs = 1;
            pofConfiguration.CountPairRCs = 1;

            IMTProductOffering productOffering = ProductOfferingFactory.Create(pofConfiguration);
            Assert.IsNotNull(productOffering.ID, "Unable to create PO for test run");
            int idProductOfferingToQuoteFor = productOffering.ID;

            //Values to use for verification
            decimal expectedQuoteTotal = (pofConfiguration.CountPairRCs * pofConfiguration.RCAmount * 2) + (pofConfiguration.CountNRCs * pofConfiguration.NRCAmount);
            string expectedQuoteCurrency = "USD";

            #endregion

            #region Test and Verify

            var request = new QuoteRequest();
            request.Accounts.Add(idAccountToQuoteFor);
            request.ProductOfferings.Add(idProductOfferingToQuoteFor);
            request.QuoteIdentifier = "MyQuoteId-" + testShortName + "-1234";
            request.QuoteDescription = "Quote generated by Automated Test: " + _testContext.TestName;
            request.ReportParameters = new ReportParams() { PDFReport = QuotingTestScenarios.RunPDFGenerationForAllTestsByDefault };
            request.EffectiveDate = MetraTime.Now;
            request.EffectiveEndDate = MetraTime.Now;

            QuoteResponse response = null;

            bool clientInvoked = false;
            try
            {
                response = SharedTestCodeQuoting.InvokeCreateQuote(request);
                clientInvoked = true;
            }
            catch (Exception ex)
            {
                Assert.Fail("QuotingService_CreateQuote_Client thrown an exception: " + ex.Message);
            }

            Assert.IsFalse(response.Status == QuoteStatus.Failed, response.FailedMessage);
            Assert.IsTrue(clientInvoked, "QuotingService_CreateQuote_Client didn't executed propely");
            Assert.AreEqual(expectedQuoteTotal, response.TotalAmount, "Wrong TotalAmount");
            Assert.AreEqual(expectedQuoteCurrency, response.Currency, "Wrong Currency");

            QuoteResponse response2 = null;

            clientInvoked = false;
            try
            {
                response2 = SharedTestCodeQuoting.InvokeCreateQuote(request);
                clientInvoked = true;
            }
            catch (Exception ex)
            {
                Assert.Fail("QuotingService_CreateQuote_Client thrown an exception: " + ex.Message);
            }

            Assert.IsFalse(response.Status == QuoteStatus.Failed, response.FailedMessage);
            Assert.IsTrue(clientInvoked, "QuotingService_CreateQuote_Client didn't executed propely");
            Assert.AreEqual(expectedQuoteTotal, response.TotalAmount, "Wrong TotalAmount");
            Assert.AreEqual(expectedQuoteCurrency, response.Currency, "Wrong Currency");

            Assert.AreEqual(response.TotalAmount, response2.TotalAmount, "Total amount was different on the second run");

            #endregion
        }

       /// <summary>
       /// TC_QICB_51
       /// </summary>
       [TestMethod, MTFunctionalTest(TestAreas.Quoting)]
       public void QuotingServiceCreateQuote_QuoteWithICBTwoTimesAsync_PositiveTest()
       {
           #region Prepare
           string testName = "QuotingActivityServiceGenerateQuoteWithICBTwoTimesAsync_PositiveTest";
           string testShortName = "TC_QICB_51"; //Account name and perhaps others need a 'short' (less than 40 when combined with testRunUniqueIdentifier
           string testRunUniqueIdentifier = MetraTime.Now.ToString(); //Identifier to make this run unique

           // Create account
           CorporateAccountFactory corpAccountHolder = new CorporateAccountFactory(testShortName, testRunUniqueIdentifier);
           corpAccountHolder.Instantiate();

           Assert.IsNotNull(corpAccountHolder.Item._AccountID, "Unable to create account for test run");
           int idAccountToQuoteFor = (int)corpAccountHolder.Item._AccountID;

           // Create/Verify Product Offerings Exists
           var pofConfiguration1 = new ProductOfferingFactoryConfiguration(testName, testRunUniqueIdentifier + "1")
           {
               CountNRCs = 0,
               CountPairRCs = 1,
               CountPairUDRCs = 0
           };

           var pofConfiguration2 = new ProductOfferingFactoryConfiguration(testName, testRunUniqueIdentifier + "2")
           {
               CountNRCs = 0,
               CountPairRCs = 1,
               CountPairUDRCs = 0
           };

           var productOffering1 = ProductOfferingFactory.Create(pofConfiguration1);
           var productOffering2 = ProductOfferingFactory.Create(pofConfiguration2);
           int idProductOfferingToQuoteFor1 = productOffering1.ID;
           int idProductOfferingToQuoteFor2 = productOffering2.ID;

           using (var client = new PriceListServiceClient())
           {
               if (client.ClientCredentials != null)
               {
                   client.ClientCredentials.UserName.UserName = "su";
                   client.ClientCredentials.UserName.Password = "su123";
               }

               IMTCollection instances1 = productOffering1.GetPriceableItems();
               IMTCollection instances2 = productOffering2.GetPriceableItems();

               var productOfferingFactory = new ProductOfferingFactory();
               productOfferingFactory.Initialize(testName, testRunUniqueIdentifier);

               var parameterTableFlatRc = productOfferingFactory.ProductCatalog.GetParamTableDefinitionByName(SharedTestCode.MetratechComFlatrecurringcharge);

               #region Set Allow ICB for PIs
               foreach (IMTPriceableItem possibleRC in instances1)
               {
                   if (possibleRC.Kind == MTPCEntityType.PCENTITY_TYPE_RECURRING)
                   {
                       var piAndPTParameters = SharedTestCode.SetAllowICBForPI(possibleRC, client, productOffering1.ID, parameterTableFlatRc.ID, SharedTestCode.MetratechComFlatrecurringcharge);
                       pofConfiguration1.PriceableItemsAndParameterTableForRc.Add(piAndPTParameters);
                   }
               }

               foreach (IMTPriceableItem possibleRC in instances2)
               {
                   if (possibleRC.Kind == MTPCEntityType.PCENTITY_TYPE_RECURRING)
                   {
                       var piAndPTParameters = SharedTestCode.SetAllowICBForPI(possibleRC, client, productOffering2.ID, parameterTableFlatRc.ID, SharedTestCode.MetratechComFlatrecurringcharge);
                       pofConfiguration2.PriceableItemsAndParameterTableForRc.Add(piAndPTParameters);
                   }
               }
               #endregion
           }

           decimal expectedQuoteTotal1 = 66.66m * 2;   //*2 because we generated RC per subscription and rep participant
           decimal expectedQuoteTotal2 = 66.66m * 2;

           #endregion

           #region Test and Verify

           #region Invoke CreateQuote for PO #1
           var request1 = new QuoteRequest();
           request1.Accounts.Add(idAccountToQuoteFor);
           request1.ProductOfferings.Add(idProductOfferingToQuoteFor1);
           request1.QuoteIdentifier = "MyQuoteId-" + testShortName + "-1234";
           request1.QuoteDescription = "Quote generated by Automated Test: " + testName;
           request1.ReportParameters = new ReportParams() { PDFReport = QuotingTestScenarios.RunPDFGenerationForAllTestsByDefault };
           request1.EffectiveDate = MetraTime.Now;
           request1.EffectiveEndDate = MetraTime.Now;


           #region Initialize ICB prices

           var quoteId = DateTime.Now.Millisecond;

           request1.IcbPrices = new List<IndividualPrice>();

           if (pofConfiguration1.PriceableItemsAndParameterTableForRc != null &&
               pofConfiguration1.PriceableItemsAndParameterTableForRc.Count > 0)
           {
               var chargeRate = new ChargesRate { Price = 66.66m };
               var qip = new IndividualPrice
               {
                   ProductOfferingId = idProductOfferingToQuoteFor1,
                   CurrentChargeType = ChargeType.RecurringCharge,
                   ChargesRates = new List<ChargesRate> { chargeRate }
               };

               request1.IcbPrices.Add(qip);
           }

           #endregion

           QuoteResponse response1 = null;
           bool clientInvoked = false;
           try
           {
               response1 = SharedTestCodeQuoting.InvokeCreateQuote(request1);
               clientInvoked = true;
           }
           catch (Exception ex)
           {
               Assert.Fail("QuotingService_CreateQuote_Client thrown an exception: " + ex.Message);
           }

           Assert.IsFalse(response1.Status == QuoteStatus.Failed, response1.FailedMessage);
           Assert.IsTrue(clientInvoked, "QuotingService_CreateQuote_Client didn't executed propely");
           Assert.AreEqual(expectedQuoteTotal1, response1.TotalAmount, "Wrong TotalAmount");

           
           #region Assync call through delegate
               QuotingServiceClient qsc = new QuotingServiceClient();

               try
               {

                   qsc.ClientCredentials.UserName.UserName = "su";
                   qsc.ClientCredentials.UserName.Password = "su123";

                   QuoteAsyncProcessingDelegate asynCall = QuoteAsyncProcessing;

                   // Asynchronously invoke the Factorize method.
                   IAsyncResult result = asynCall.BeginInvoke(qsc, request1, out response1, null, null);

                   while (!result.IsCompleted)
                   {
                       // Do any work you can do before waiting.
                       result.AsyncWaitHandle.WaitOne(1000, false);
                   }
                   result.AsyncWaitHandle.Close();

                   Assert.IsFalse(response1.Status == QuoteStatus.Failed, response1.FailedMessage);
                   Assert.AreEqual(expectedQuoteTotal1, response1.TotalAmount, "Wrong TotalAmount");

               }
               catch (Exception ex)
               {
                   Assert.Fail("QuotingService_CreateQuote_Client thrown an exception: " + ex.Message);
               }
               finally
               {
                   if (qsc.State != CommunicationState.Opened)
                   {
                       qsc.Abort();
                   }
               }

           #endregion

           #endregion

           #region Invoke CreateQuote for PO #2

           #region Initialize ICB prices

           //backup ICBs for first request
           var ICBsReuest1Backup = request1.IcbPrices;

           request1.ProductOfferings.Clear();
           request1.ProductOfferings.Add(idProductOfferingToQuoteFor2);

           //ToDo: Verify. Maybe we can use previous request
           request1.IcbPrices = new List<IndividualPrice>();

           if (pofConfiguration1.PriceableItemsAndParameterTableForRc != null &&
               pofConfiguration1.PriceableItemsAndParameterTableForRc.Count > 0)
           {
               var chargeRate = new ChargesRate { Price = 66.66m };
               var qip = new IndividualPrice
               {
                   ProductOfferingId = idProductOfferingToQuoteFor2,
                   CurrentChargeType = ChargeType.RecurringCharge,
                   ChargesRates = new List<ChargesRate> { chargeRate }
               };

               request1.IcbPrices.Add(qip);
           }

           #endregion

           QuoteResponse response2 = null;

           clientInvoked = false;
           try
           {
               response2 = SharedTestCodeQuoting.InvokeCreateQuote(request1);
               clientInvoked = true;
           }
           catch (Exception ex)
           {
               Assert.Fail("QuotingService_CreateQuote_Client thrown an exception: " + ex.Message);
           }

           Assert.IsFalse(response2.Status == QuoteStatus.Failed, response2.FailedMessage);
           Assert.IsTrue(clientInvoked, "QuotingService_CreateQuote_Client didn't executed propely");
           Assert.AreEqual(expectedQuoteTotal2, response2.TotalAmount, "Wrong TotalAmount");

           Assert.AreEqual(response2.TotalAmount, response2.TotalAmount, "Total amount was different on the second run");

           #region Assync call through delegate
           
           qsc = new QuotingServiceClient();

           try
           {
               qsc.ClientCredentials.UserName.UserName = "su";
               qsc.ClientCredentials.UserName.Password = "su123";

               QuoteAsyncProcessingDelegate asynCall = QuoteAsyncProcessing;

               // Asynchronously invoke the Factorize method.
               IAsyncResult result = asynCall.BeginInvoke(qsc, request1, out response2, null, null);

               while (!result.IsCompleted)
               {
                   // Do any work you can do before waiting.
                   result.AsyncWaitHandle.WaitOne(1000, false);
               }
               result.AsyncWaitHandle.Close();

               Assert.IsFalse(response1.Status == QuoteStatus.Failed, response2.FailedMessage);
               Assert.AreEqual(expectedQuoteTotal2, response2.TotalAmount, "Wrong TotalAmount");

           }
           catch (Exception ex)
           {
               Assert.Fail("QuotingService_CreateQuote_Client thrown an exception: " + ex.Message);
           }
           finally
           {
               if (qsc.State != CommunicationState.Opened)
               {
                   qsc.Abort();
               }
           }

           #endregion

           #endregion



           #region Create Subscription for PO #2. Enter Custom Rates.

           MTSubscription subscription2 = null;
           MTPCAccount account2 = null;
           bool subscriptionForPO2Created = false;
           //bool ICBSForSubscription2Created = false;

           try
           {
               account2 = SharedTestCode.CurrentProductCatalog.GetAccount(idAccountToQuoteFor);

               var effDate = new MTPCTimeSpanClass
               {
                   StartDate = request1.EffectiveDate,
                   StartDateType = MTPCDateType.PCDATE_TYPE_ABSOLUTE
               };

               object modifiedDate = MetraTime.Now;
               subscription2 = account2.Subscribe(idProductOfferingToQuoteFor2, effDate, out modifiedDate);
               subscriptionForPO2Created = true;

               //SharedTestCode.ApplyIcbPricesToSubscription(idProductOfferingToQuoteFor2, subscription2.ID, request1.IcbPrices);
               //ICBSForSubscription2Created = true;

           }
           catch (Exception ex)
           {
               Assert.Fail("Creating subscription after quote failed with exception: " + ex);
           }
           finally
           {
               if (subscription2 != null)
               {
                   account2.RemoveSubscription(subscription2.ID);
               }
           }

           #endregion

           #region Create Subscription for PO #1. Enter Custom Rates.

           request1.IcbPrices = ICBsReuest1Backup;

           MTSubscription subscription1 = null;
           MTPCAccount account1 = null;
           bool subscriptionForPO1Created = false;
           //bool ICBSForSubscription1Created = false;

           try
           {
               account1 = SharedTestCode.CurrentProductCatalog.GetAccount(idAccountToQuoteFor);

               var effDate = new MTPCTimeSpanClass
               {
                   StartDate = request1.EffectiveDate,
                   StartDateType = MTPCDateType.PCDATE_TYPE_ABSOLUTE
               };

               object modifiedDate = MetraTime.Now;
               subscription1 = account1.Subscribe(idProductOfferingToQuoteFor1, effDate, out modifiedDate);
               subscriptionForPO1Created = true;

               //SharedTestCode.ApplyIcbPricesToSubscription(idProductOfferingToQuoteFor1, subscription1.ID, request1.IcbPrices);
               //ICBSForSubscription1Created = true;

           }
           catch (Exception ex)
           {
               Assert.Fail("Creating subscription after quote failed with exception: " + ex);
           }
           finally
           {
               if (subscription1 != null)
               {
                   account1.RemoveSubscription(subscription1.ID);
               }
           }

           Assert.IsTrue(subscriptionForPO1Created, "Subscription wasn't created for PO #1");
           Assert.IsTrue(subscriptionForPO2Created, "Subscription wasn't created for PO #2");
           //Assert.IsTrue(ICBSForSubscription1Created, "ICBS for subscription1 wasn't created");
           //Assert.IsTrue(ICBSForSubscription2Created, "ICBS for subscription1 wasn't created");

           #endregion

           #endregion
       }

        private delegate void QuoteAsyncProcessingDelegate(QuotingServiceClient quotingService, QuoteRequest req,
                                                           out QuoteResponse quoteResp);

        // Async processing which does not affect response
        private void QuoteAsyncProcessing(QuotingServiceClient quotingService, QuoteRequest req,
                                          out QuoteResponse quoteResp)
        {
            Trace.WriteLine("Begin Async Processing");
            quoteResp = null;
            try
            {

                quotingService.CreateQuote(req, out quoteResp);


            }
            finally
            {
                if (quotingService.State == CommunicationState.Opened)
                {
                    quotingService.Close();
                }
                else
                {
                    quotingService.Abort();
                }
            }

            Trace.WriteLine("Finished Async Processing");
        }

        #region Helpers


        /// <summary>
        /// Creates and verifies the created quote if failed message is not expected,
        /// otherwise checks that quote response status is failed and that the failed message
        /// contains the expected text
        /// </summary>
        /// <param name="idAccount">Account id to quote for</param>
        /// <param name="idPO">PO id to quote for</param>
        /// <param name="testName"></param>
        /// <param name="testShortName"></param>
        /// <param name="partialFailedMessage">Part of the failed message that is expected.
        /// Skip or set to null if the request is expected to pass and to be verified</param>
        /// <returns>Created and verified response</returns>
        private QuoteResponse CreateAndVerifyQuote(int idAccount, int idPO, string testName, string testShortName, string partialFailedMessage = null)
        {
            #region Prepare

            //Values to use for verification
            decimal expectedQuoteTotal = 19.95M * 2 + 9.95M;
            string expectedQuoteCurrency = "USD";

            #endregion

            #region Test and Verify

            var request = new QuoteRequest();
            request.Accounts.Add(idAccount);
            request.ProductOfferings.Add(idPO);
            request.QuoteIdentifier = "MyQuoteId-" + testShortName + "-1234";
            request.QuoteDescription = "Quote generated by Automated Test: " + testName;
            request.ReportParameters = new ReportParams() { PDFReport = QuotingTestScenarios.RunPDFGenerationForAllTestsByDefault };
            request.EffectiveDate = MetraTime.Now;
            request.EffectiveEndDate = MetraTime.Now.AddMonths(2);

            QuoteResponse response = null;

            bool clientInvoked = false;
            try
            {
                response = SharedTestCodeQuoting.InvokeCreateQuote(request);
                clientInvoked = true;
            }
            catch (Exception ex)
            {
                Assert.Fail("QuotingService_CreateQuote_Client thrown an exception: " + ex.Message);
            }

            if (partialFailedMessage == null)
            {
                Assert.IsFalse(response.Status == QuoteStatus.Failed, response.FailedMessage);
                Assert.IsTrue(clientInvoked, "QuotingService_CreateQuote_Client didn't executed propely");
                Assert.AreEqual(expectedQuoteTotal, response.TotalAmount, "Wrong TotalAmount");
                Assert.AreEqual(expectedQuoteCurrency, response.Currency, "Wrong Currency");
            }
            else
            {
                Assert.IsTrue(response.Status == QuoteStatus.Failed, "The quote response status was not failed");
                Assert.IsTrue(response.FailedMessage.Contains(partialFailedMessage), "The quote response message was incorrect");
            }

            #endregion

            return response;
        }
        #endregion
    }
}
