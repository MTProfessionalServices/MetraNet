#region Generated using ICE (Do not modify this region)
/// Generated using ICE
/// ICE CodeGen Version: 1.0.0
/// Transactional = false
#endregion
using System;
using System.Collections.Generic;
using MetraTech.Pipeline;
using MetraTech.DataAccess;
using System.Linq;
using System.Runtime.Caching;
#region AutoGenerated Enum Includes (Do not modify this region)
//ENUM_USING
#endregion

namespace MetraTech.Pipeline.Plugins
{
    /// <summary>
    /// Plugin to calculate business days and holidays between two dates
    /// </summary>
    public sealed partial class BusinessDayPlugin : PlugInBase
    {
        /// <summary>
        /// cache structure to hold the holidays
        /// </summary>
        private ObjectCache _holidays;

        /// <summary>
        /// cache of business day calcs to speed up processing
        /// </summary>
        private ObjectCache _spanCache;

        /// <summary>
        /// maps calendar names to ids
        /// </summary>
        private Dictionary<string, int> _nameToIdMap = new Dictionary<string, int>();

        /// <summary>
        /// maps calendar ids to names
        /// </summary>
        private Dictionary<int, string> _idToNameMap = new Dictionary<int, string>();

        /// <summary>
        /// when the last calendar init occurred
        /// </summary>
        private DateTime _lastInit = DateTime.MinValue;

        /// <summary>
        /// how many seconds to wait between init reloads
        /// </summary>
        private long _initWait = 300;

        #region ProcessAllSessions (Only modify this in the rare case you need to handle more than one session at once)
        /// <summary>
        /// This method is called each time the plug-in recieves a session set
        /// </summary>
        protected override void ProcessAllSessions(PropertiesCollection propsCol)
        {
            bool partiallyFailed = false;
            foreach (Properties props in propsCol)
            {
                //set the current session for logging purposes
                SetCurrentSession(props.Session);

                try
                {
                    //process each session
                    ProcessSession(props);
                }
                catch (Exception ex)
                {
                    partiallyFailed = true;
                    Log(LogLevel.Warning,
                        string.Format("Error when processing session: {0}", ex.Message));
                    //mark the session as failed
                    props.Session.MarkAsFailed(
                        string.Format("Error when processing session. Source: {0}, Message: {1}",
                        ex.Source, ex.Message), MARK_AS_FAILED_CODE_FAILED);
                }
                finally
                {
                    Log(LogLevel.Debug, "Session object disposed successfully");
                    props.Session.Dispose();
                }
            }

            //if any of the sessions failed, go ahead and throw an exception here
            if (partiallyFailed)
                throw new MetraTech.Pipeline.PlugIns.PartialFailureException();
        }
        #endregion

        #region Startup override
        protected override void StartUp(MetraTech.Interop.SysContext.IMTSystemContext systemContext, MetraTech.Interop.MTPipelineLib.IMTConfigPropSet propSet)
        {
            _holidays = new MemoryCache("HOLIDAY_CACHE");
            _spanCache = new MemoryCache("SPAN_CACHE");
            if (!GeneralConfig.CalculateHolidays.HasValue)
            {
                throw new ApplicationException("CalculateHolidays must be set in plugin configuration");
            }
            if (GeneralConfig.LoadCalendars.HasValue && GeneralConfig.LoadCalendars.Value)
            {
                InitWorkingDays();
            }
            if (GeneralConfig.ReloadWait.HasValue)
            {
                _initWait = GeneralConfig.ReloadWait.Value;
            }
            InitCalendars();
        }
        #endregion

        #region Shutdown override
        public override void Shutdown()
        {
        }
        #endregion

        /// <summary>
        /// This method is called for each session in the session set.
        /// </summary>
        protected override void ProcessSession(Properties props)
        {
            #region Instructions
            /* -Pipeline Inputs and Outputs
             *  Pipeline inputs and outputs are accessed via the props variable.
             *  Value types (int, long, bool, enums, etc..) are marked as nullable.
             *  When you look at the type you'll see, for example, int? instead of int.
             *  Nullable value types are used because the Pipeline value could possibly be null.
             *  You can check to see if the value is null by checking the .HasValue property. 
             *  There are two ways you can get the actual value of the variable. First by using 
             *  the .Value property.
             *  Example:
             *      int a = props.Pipeline.Foo.Value; //The type of Foo is int? (a.k.a. Nullable<int>) but the type of Foo.Value is int.
             *  And second by doing a cast:
             *  Example:
             *      int a = (int)props.Pipeline.Foo; //The type of Foo is int? (a.k.a. Nullable<int>)
             *  Reference types (string, classes you write) are already nullable so there's no 
             *  need to treat them special.
             *  Example:
             *      string foo = props.Pipeline.Foo; //The type of Foo is string.
             *
             * -General Configuration Variables
             *  Accessed via the GeneralConfig property of BusinessDayPlugin.
             *  Example: 
             *      string filePath = GeneralConfig.FilePath;
             * 
             * -Errors
             *  If there is a critical error and you would like to make the the current session as failed,
             *  throw an exception of type ApplicationException with a custom message. 
             *  The message will be logged. The ProcessAllSessions method will catch the 
             *  exception and mark the current session as failed and move on to the next session to process.
             *  Example: 
             *      throw new ApplicationException("The value Foo was outside the expected range");
             * 
             * -Logging
             *  You can log messages via the Log function.
             *  Example: Log(LogLevel.Debug, "Test message");
             */
            #endregion
            Log(LogLevel.Debug, "Start");

            /*
             * This looks pretty good
             * Thanks to whoever is building this in their spare time. MUCH APPRECIATED
             * Can you please add support for 
             *          -- a BOOLEAN flag called "IgnoreHolidays" to specify if you want to ignore holidays when computing
             *          -- numeric # of weekend days, to support a 1 day weekend instead of 2 day 
             *                  (1 day weekend is the case in a lot of South East ASIAN countries) 
             *                  instead of 2 days which is getting wider adoptance     
             *          -- configurable day(s) for the weekend. this would work in tandem with the number of weekend days attribute
             *                  Middle East may consider FRIDAY as weekend 
             *                  US may consider Saturday and Sunday
             *                  Sri Lanka may consider Sunday
             *                  Yes Brown people still have to catchup in terms of holidays;)
             */                 

            if (!props.Pipeline.StartDate.HasValue)
            {
                throw new ApplicationException("StartDate must be set");
            }
            if (!props.Pipeline.EndDate.HasValue)
            {
                throw new ApplicationException("EndDate must be set");
            }

            var calendarId = new CalendarIdentifier { CalendarId = props.Pipeline.CalendarId, CalendarName = props.Pipeline.CalendarName };

            var firstDay = props.Pipeline.StartDate.Value;
            var lastDay = props.Pipeline.EndDate.Value;
            firstDay = firstDay.Date;
            lastDay = lastDay.Date;

            if (firstDay > lastDay)
            {
                throw new ApplicationException("StartDate must be before EndDate");
            }

            // handle default calendars
            if (calendarId.CalendarId.HasValue || !string.IsNullOrEmpty(calendarId.CalendarName))
            {
                calendarId.CalendarId = GeneralConfig.DefaultCalendarId;
                calendarId.CalendarName = GeneralConfig.DefaultCalendarName;
            }

            // convert calendar identifiers/names
            if (!props.Pipeline.CalendarId.HasValue && string.IsNullOrEmpty(props.Pipeline.CalendarName))
            {
                props.Pipeline.CalendarId = calendarId.CalendarId;
                props.Pipeline.CalendarName = calendarId.CalendarName;
            }
            if (!props.Pipeline.CalendarId.HasValue && !string.IsNullOrEmpty(props.Pipeline.CalendarName))
            {
                if (!_nameToIdMap.ContainsKey(props.Pipeline.CalendarName))
                {
                    InitCalendars();
                    if (!_nameToIdMap.ContainsKey(props.Pipeline.CalendarName))
                    {
                        throw new ApplicationException(string.Format("Undefined calendar name: {0}", calendarId.CalendarName));
                    }
                }
                props.Pipeline.CalendarId = _nameToIdMap[props.Pipeline.CalendarName];
            }
            if (props.Pipeline.CalendarId.HasValue && !_idToNameMap.ContainsKey(props.Pipeline.CalendarId.Value))
            {
                InitCalendars();
                if (!_idToNameMap.ContainsKey(props.Pipeline.CalendarId.Value))
                {
                    throw new ApplicationException(string.Format("Undefined calendar with id: {0}", calendarId.CalendarId.Value));
                }
            }
            if (!props.Pipeline.CalendarId.HasValue)
            {
                props.Pipeline.CalendarId = -1;
            }

            // cache lookups
            var spanId = string.Format("{0}:{1},{2}", calendarId.CalendarId.Value, firstDay.ToString("yyyyMMdd"), lastDay.ToString("yyyyMMdd"));
            if (_spanCache.Contains(spanId))
            {
                SpanCount count = (SpanCount)_spanCache[spanId];
                props.Pipeline.NumBusinessDays = count.NumBusinessDays;
                props.Pipeline.NumHolidays = count.NumHolidays;
            }
            else
            {

                var span = lastDay - firstDay;
                var businessDays = span.Days + 1;
                var fullWeekCount = businessDays / 7;

                // find out if there are weekends during the time exceeding the full weeks
                if (businessDays > fullWeekCount * 7)
                {
                    businessDays -= DateTimeExtensions.GetExtraNonWorkingDayCount(calendarId, firstDay.DayOfWeek, lastDay.DayOfWeek);
                }

                // subtract the weekends during the full weeks in the interval
                businessDays -= fullWeekCount * DateTimeExtensions.GetNonWorkingDayCount(calendarId);

                props.Pipeline.NumBusinessDays = businessDays;

                var numHolidays = 0;
                if (GeneralConfig.CalculateHolidays.Value)
                {
                    if (calendarId.CalendarId.Value == -1)
                    {
                        throw new ApplicationException("Calendar must be set when CalculateHolidays is set");
                    }
                    numHolidays = GetHolidays(calendarId, firstDay, lastDay).Count(day => day.IsWorkingDay(calendarId) && day >= firstDay && day <= lastDay);
                    props.Pipeline.NumHolidays = numHolidays;
                }

                // and now store the cached item
                SpanCount count = new SpanCount { NumBusinessDays = businessDays, NumHolidays = numHolidays };
                _spanCache.Set(spanId, count, null);
            }
        }

        /*
        private void Span()
        {
            DateTime start = DateTime.Now;
            int numBusinessDays = 50;
            DateTime end = start.AddDays(numBusinessDays);
            CalendarIdentifier calendarId = new CalendarIdentifier();
            IEnumerable<DateTime> holidays = GetHolidays(calendarId, start, end);
            int diff = 10;
            while (diff < numBusinessDays)
            {
                end = end.AddDays(1);
                if (!holidays.Contains(end) && end.IsWorkingDay(calendarId))
                {
                    diff++;
                }
            }
        }
         * */

        /// <summary>
        /// Get the holidays that overlap with the supplied dates
        /// </summary>
        /// <param name="calendarId">The calendar identifier</param>
        /// <param name="start">The start date</param>
        /// <param name="end">The end date</param>
        /// <returns>The holidays</returns>
        private IEnumerable<DateTime> GetHolidays(CalendarIdentifier calendarId, DateTime start, DateTime end)
        {
            if (calendarId == null)
            {
                throw new ArgumentNullException("calendarId");
            }
            else if (!calendarId.CalendarId.HasValue)
            {
                throw new ApplicationException("CalendarId must be set");
            }
            else if (calendarId.CalendarId.Value == -1)
            {
                throw new ApplicationException("CalendarId is invalid");
            }
            Holidays holidays;
            if (_holidays.Contains(calendarId.CalendarId.Value.ToString()))
            {
                holidays = (Holidays)_holidays[calendarId.CalendarId.Value.ToString()];
            }
            else
            {
                // set the dummy with opposite min/max to trigger a reload
                holidays = new Holidays();
                holidays.MaxYear = int.MinValue;
                holidays.MinYear = int.MaxValue;
            }
            lock (holidays)
            {
                if (holidays.Dates == null || start.Year < holidays.MinYear || end.Year > holidays.MaxYear)
                {
                    // load holidays
                    int minYear;
                    int maxYear;
                    if (start.Year < holidays.MinYear)
                    {
                        minYear = start.Year;
                    }
                    else
                    {
                        minYear = holidays.MaxYear;
                    }
                    if (end.Year <= holidays.MaxYear)
                    {
                        maxYear = holidays.MinYear;
                    }
                    else
                    {
                        maxYear = end.Year;
                    }
                    List<DateTime> list = new List<DateTime>();
                    using (var conn = ConnectionManager.CreateConnection())
                    {
                        using (var stmt = conn.CreateAdapterStatement(@"SELECT
HOL.n_year AS n_year,
HOL.n_month AS n_month,
HOL.n_day AS n_day
FROM T_CALENDAR CAL
INNER JOIN T_CALENDAR_DAY DAY ON DAY.id_calendar = CAL.id_calendar AND DAY.n_code = 2
INNER JOIN T_CALENDAR_HOLIDAY HOL ON HOL.id_day = DAY.id_day
WHERE 1=1
AND CAL.id_calendar = %%ID_CALENDAR%%
AND HOL.n_year BETWEEN %%MIN_YEAR%% AND %%MAX_YEAR%%
;"))
                        {
                            stmt.AddParam("%%ID_CALENDAR%%", calendarId.CalendarId.Value);
                            stmt.AddParam("%%MIN_YEAR%%", minYear);
                            stmt.AddParam("%%MAX_YEAR%%", maxYear);
                            using (var crsr = stmt.ExecuteReader())
                            {
                                while (crsr.Read())
                                {
                                    if (crsr.IsDBNull("n_year"))
                                    {
                                        throw new ApplicationException("Configured holiday does not have year set in T_CALENDAR_HOLIDAY");
                                    }
                                    if (crsr.IsDBNull("n_month"))
                                    {
                                        throw new ApplicationException("Configured holiday does not have month set in T_CALENDAR_HOLIDAY");
                                    }
                                    if (crsr.IsDBNull("n_day"))
                                    {
                                        throw new ApplicationException("Configured holiday does not have day set in T_CALENDAR_HOLIDAY");
                                    }
                                    int year = crsr.GetInt32("n_year");
                                    int month = crsr.GetInt32("n_month");
                                    int day = crsr.GetInt32("n_day");
                                    DateTime holiday = new DateTime(year, month, day);
                                    list.Add(holiday);
                                }
                            }
                        }

                    }
                    if (holidays.Dates == null || (minYear == start.Year && maxYear == end.Year))
                    {
                        holidays.Dates = list;
                    }
                    else
                    {
                        holidays.Dates.AddRange(list);
                    }
                    _holidays.Set(calendarId.CalendarId.Value.ToString(), holidays, null);
                }
            }
            return holidays.Dates;
        }

        /// <summary>
        /// Initialize the per-country working days
        /// </summary>
        private void InitWorkingDays()
        {
            // load working days
            using (var conn = ConnectionManager.CreateConnection())
            {
                using (var stmt = conn.CreateAdapterStatement(@"SELECT
A.id_calendar AS id_calendar,
B.nm_name AS nm_calendar,
CASE WHEN SU.n_code != 3 THEN 1 ELSE CASE WHEN DE.n_code != 3 THEN 1 ELSE 0 END END AS c_sunday,
CASE WHEN MO.n_code = 3 THEN 0 ELSE CASE WHEN DW.n_code = 3 THEN 0 ELSE 1 END END AS c_monday,
CASE WHEN TU.n_code = 3 THEN 0 ELSE CASE WHEN DW.n_code = 3 THEN 0 ELSE 1 END END AS c_tuesday,
CASE WHEN WE.n_code = 3 THEN 0 ELSE CASE WHEN DW.n_code = 3 THEN 0 ELSE 1 END END AS c_wednesday,
CASE WHEN TH.n_code = 3 THEN 0 ELSE CASE WHEN DW.n_code = 3 THEN 0 ELSE 1 END END AS c_thursday,
CASE WHEN FR.n_code = 3 THEN 0 ELSE CASE WHEN DW.n_code = 3 THEN 0 ELSE 1 END END AS c_friday,
CASE WHEN SA.n_code != 3 THEN 1 ELSE CASE WHEN DE.n_code != 3 THEN 1 ELSE 0 END END AS c_saturday
FROM T_CALENDAR A
INNER JOIN T_BASE_PROPS B ON A.id_calendar = B.id_prop
LEFT OUTER JOIN T_CALENDAR_DAY SU ON SU.id_calendar = A.id_calendar AND SU.n_weekday = 0
LEFT OUTER JOIN T_CALENDAR_DAY MO ON MO.id_calendar = A.id_calendar AND MO.n_weekday = 1
LEFT OUTER JOIN T_CALENDAR_DAY TU ON TU.id_calendar = A.id_calendar AND TU.n_weekday = 2
LEFT OUTER JOIN T_CALENDAR_DAY WE ON WE.id_calendar = A.id_calendar AND WE.n_weekday = 3
LEFT OUTER JOIN T_CALENDAR_DAY TH ON TH.id_calendar = A.id_calendar AND TH.n_weekday = 4
LEFT OUTER JOIN T_CALENDAR_DAY FR ON FR.id_calendar = A.id_calendar AND FR.n_weekday = 5
LEFT OUTER JOIN T_CALENDAR_DAY SA ON SA.id_calendar = A.id_calendar AND SA.n_weekday = 6
LEFT OUTER JOIN T_CALENDAR_DAY DW ON DW.id_calendar = A.id_calendar AND DW.n_weekday = 7
LEFT OUTER JOIN T_CALENDAR_DAY DE ON DE.id_calendar = A.id_calendar AND DE.n_weekday = 8
WHERE 1=1"))
                {
                    using (var crsr = stmt.ExecuteReader())
                    {
                        while (crsr.Read())
                        {
                            int idCalendar = crsr.GetInt32("id_calendar");
                            string nmCalendar = crsr.GetString("nm_calendar");
                            bool[] days = { crsr.GetBoolean("c_sunday"),
                                        crsr.GetBoolean("c_monday"),
                                        crsr.GetBoolean("c_tuesday"),
                                        crsr.GetBoolean("c_wednesday"),
                                        crsr.GetBoolean("c_thursday"),
                                        crsr.GetBoolean("c_friday"),
                                        crsr.GetBoolean("c_saturday")
                                      };
                            var calendarId = new CalendarIdentifier { CalendarId = idCalendar, CalendarName = nmCalendar };
                            DateTimeExtensions.SetWorkingDays(calendarId, days);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// initialize the calendar id->name and name->id maps
        /// </summary>
        private void InitCalendars()
        {
            var now = MetraTime.Now;
            lock (this)
            {
                var span = now.Subtract(_lastInit);
                if (_initWait <= 0 || span.TotalSeconds >= _initWait)
                {
                    using (var conn = ConnectionManager.CreateConnection())
                    {
                        using (var stmt = conn.CreateAdapterStatement(@"SELECT
A.id_calendar AS id_calendar,
B.nm_name AS nm_calendar,
FROM T_CALENDAR A
INNER JOIN T_BASE_PROPS B ON A.id_calendar = B.id_prop
WHERE 1=1"))
                        {
                            var idToName = new Dictionary<int, string>();
                            var nameToId = new Dictionary<string, int>();
                            using (var crsr = stmt.ExecuteReader())
                            {
                                while (crsr.Read())
                                {
                                    int idCalendar = crsr.GetInt32("id_calendar");
                                    string nmCalendar = crsr.GetString("nm_calendar");
                                    idToName[idCalendar] = nmCalendar;
                                    if (nameToId.ContainsKey(nmCalendar))
                                    {
                                        throw new ApplicationException(string.Format("Invalid configuration: two calendars share the same name: {0}", nmCalendar));
                                    }
                                    nameToId[nmCalendar] = idCalendar;
                                }
                            }
                            _idToNameMap = idToName;
                            _nameToIdMap = nameToId;
                        }
                    }
                }
                _lastInit = now;
            }
        }
    }

    /// <summary>
    /// cache entry class to hold the holidays, and their current set of minimum maximum dates loaded...
    /// </summary>
    public class Holidays
    {
        /// <summary>
        /// the holidays
        /// </summary>
        public List<DateTime> Dates
        {
            get;
            set;
        }

        /// <summary>
        /// the minimum year loaded so far
        /// </summary>
        public int MinYear
        {
            get;
            set;
        }

        /// <summary>
        /// the maximum year loaded so far
        /// </summary>
        public int MaxYear
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Extension class for DateTime to provide a method for what days are workdays
    /// </summary>
    public static class DateTimeExtensions
    {
        /// <summary>
        /// List of working days by calendar.  If a calendar has no entry, then it is assumed to be M-F.
        /// </summary>
        private static Dictionary<Int32, bool[]> _workingDays = new Dictionary<Int32, bool[]>();

        /// <summary>
        /// stores a cache of extra working days for non-complete weeks per calendar
        /// </summary>
        private static Dictionary<Int32, int[,]> _extraNonWorkingDayCounts = new Dictionary<Int32, int[,]>();

        /// <summary>
        /// stores a cache of non-working days per week per calendar
        /// </summary>
        private static Dictionary<Int32, int> _nonWorkingDayCounts = new Dictionary<Int32, int>();

        /// <summary>
        /// default number of weekend overlap days for the standard saturday/sunday weekend
        /// </summary>
        private static int[,] _defaultCounts = new int[,] {{1,1,1,1,1,1,2},
                                                           {2,0,0,0,0,0,1},
                                                           {2,2,0,0,0,0,1},
                                                           {2,2,2,0,0,0,1},
                                                           {2,2,2,2,0,0,1},
                                                           {2,2,2,2,2,0,1},
                                                           {2,2,2,2,2,2,1}};
        /// <summary>
        /// default number of weekend days per week for the standard saturday/sunday weekend
        /// </summary>
        private static int _defaultCount = 2;

        /// <summary>
        /// Configure the working days for a specific calendar
        /// </summary>
        /// <param name="calendarId">The calendar to use</param>
        /// <param name="days">What days are considered working days (0th element is sunday)</param>
        public static void SetWorkingDays(CalendarIdentifier calendarId, bool[] days)
        {
            if (calendarId == null)
            {
                throw new ArgumentNullException("calendarId");
            }
            else if (!calendarId.CalendarId.HasValue)
            {
                throw new ApplicationException("CalendarId must be set");
            }
            else if (calendarId.CalendarId.Value == -1)
            {
                throw new ApplicationException("CalendarId is invalid");
            }
            _workingDays[calendarId.CalendarId.Value] = days;
            int count = 0;
            foreach (bool i in days)
            {
                if (i)
                {
                    count++;
                }
            }
            _nonWorkingDayCounts[calendarId.CalendarId.Value] = count;
            int[,] list = new int[7, 7];
            for (var i = 0; i < 7; i++)
            {
                for (var j = 0; j < 7; j++)
                {
                    for (var x = i; x != j; x++)
                    {
                        if (x == 7)
                        {
                            x = -1;
                        }
                        else
                        {
                            if (days[x])
                            {
                                list[i, j]++;
                            }
                        }
                    }
                    if (days[j])
                    {
                        list[i, j]++;
                    }
                }
            }
            _extraNonWorkingDayCounts[calendarId.CalendarId.Value] = list;
        }

        /// <summary>
        /// For a given start/end day, return the number of non-workdays between them (less than a week)
        /// </summary>
        /// <param name="calendarId">The calendar to use</param>
        /// <param name="start">the start day</param>
        /// <param name="end">the end day</param>
        /// <returns>the number of non working days for this calendar for a sub-weeklong span</returns>
        public static int GetExtraNonWorkingDayCount(CalendarIdentifier calendarId, DayOfWeek start, DayOfWeek end)
        {
            if (calendarId == null)
            {
                throw new ArgumentNullException("calendarId");
            }
            else if (!calendarId.CalendarId.HasValue)
            {
                throw new ApplicationException("CalendarId must be set");
            }
            int[,] counts;
            if (calendarId.CalendarId.Value != -1 && _extraNonWorkingDayCounts.ContainsKey(calendarId.CalendarId.Value))
            {
                counts = _extraNonWorkingDayCounts[calendarId.CalendarId.Value];
            }
            else
            {
                counts = _defaultCounts;
            }
            return counts[(int)start, (int)end];
        }

        /// <summary>
        /// Get # of non-working days per week for a given calendar
        /// </summary>
        /// <param name="calendarId">The calendar Id to use</param>
        /// <returns>the number of non working days per week</returns>
        public static int GetNonWorkingDayCount(CalendarIdentifier calendarId)
        {
            if (calendarId == null)
            {
                throw new ArgumentNullException("calendarId");
            }
            else if (!calendarId.CalendarId.HasValue)
            {
                throw new ApplicationException("CalendarId must be set");
            }
            int count;
            if (calendarId.CalendarId.Value != -1 && _nonWorkingDayCounts.ContainsKey(calendarId.CalendarId.Value))
            {
                count = _nonWorkingDayCounts[calendarId.CalendarId.Value];
            }
            else
            {
                count = _defaultCount;
            }
            return count;
        }

        /// <summary>
        /// Whether the date is a normal working day (not saturday or sunday normally)
        /// The passed in calendar can be used for non-traditional working days
        /// </summary>
        /// <param name="date">the date to check</param>
        /// <param name="calendarId">The calendar id to use</param>
        /// <returns>whether it is a normal working day or not</returns>
        public static bool IsWorkingDay(this DateTime date, CalendarIdentifier calendarId)
        {
            if (calendarId == null)
            {
                throw new ArgumentNullException("calendarId");
            }
            else if (!calendarId.CalendarId.HasValue)
            {
                throw new ApplicationException("CalendarId must be set");
            }
            if (calendarId.CalendarId.Value == -1 || !_workingDays.ContainsKey(calendarId.CalendarId.Value))
            {
                return date.DayOfWeek != DayOfWeek.Saturday
                    && date.DayOfWeek != DayOfWeek.Sunday;
            }
            return !_workingDays[calendarId.CalendarId.Value][(int)date.DayOfWeek];
        }
    }

    /// <summary>
    /// Identifies a calendar either by id or name
    /// </summary>
    public class CalendarIdentifier
    {
        /// <summary>
        /// The calendar ID
        /// </summary>
        public Int32? CalendarId
        {
            get;
            set;
        }

        /// <summary>
        /// The calendar name
        /// </summary>
        public string CalendarName
        {
            get;
            set;
        }
    }

    /// <summary>
    /// cache class to hold precalculated values
    /// </summary>
    public class SpanCount
    {
        /// <summary>
        /// number of holidays
        /// </summary>
        public int NumHolidays
        {
            get;
            set;
        }

        /// <summary>
        /// number of business days
        /// </summary>
        public int NumBusinessDays
        {
            get;
            set;
        }
    }
}
