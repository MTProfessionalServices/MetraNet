#region Generated using ICE (Do not modify this region)
/// Generated using ICE
/// ICE CodeGen Version: 1.0.0
#endregion
using System;
using System.Collections.Generic;
using MetraTech.Pipeline;
#region AutoGenerated Enum Includes (Do not modify this region)
//ENUM_USING
#endregion

namespace MetraTech.Custom.Plugins.Core
{
    public sealed partial class WriteProductQueuePlugin : PlugInBase
    {
		#region ProcessAllSessions (Only modify this in the rare case you need to handle more than one session at once)
        /// <summary>
        /// This method is called each time the plug-in recieves a session set
        /// </summary>
        protected override void ProcessAllSessions(PropertiesCollection propsCol)
        {
            bool partiallyFailed = false;
            foreach (Properties props in propsCol)
            {
                //set the current session for logging purposes
                SetCurrentSession(props.Session);

                try
                {
                    //process each session
                    ProcessSession(props);
                }
                catch (Exception ex)
                {
                    partiallyFailed = true;
                    Log(LogLevel.Warning,
                        string.Format("Error when processing session: {0}", ex.Message));
                    //mark the session as failed
                    props.Session.MarkAsFailed(
                        string.Format("Error when processing session. Source: {0}, Message: {1}",
                        ex.Source, ex.Message), MARK_AS_FAILED_CODE_FAILED);
                }
                finally
                {
                    Log(LogLevel.Debug, "Session object disposed successfully");
                    props.Session.Dispose();
                }
            }

            //if any of the sessions failed, go ahead and throw an exception here
            if (partiallyFailed)
                throw new MetraTech.Pipeline.PlugIns.PartialFailureException();
        }
		#endregion
    
        #region Startup override
        protected override void StartUp(MetraTech.Interop.SysContext.IMTSystemContext systemContext, MetraTech.Interop.MTPipelineLib.IMTConfigPropSet propSet)
        {
            //TODO: add any code you would like to run at Configure time (when the plug-in is first loaded)
        }
        #endregion

        #region Shutdown override
        public override void Shutdown()
        {
            //TODO: add any code you would like to run when the plug-in shuts down
        }
        #endregion

        /// <summary>
        /// This method is called for each session in the session set.
        /// </summary>
        protected override void ProcessSession(Properties props)
        {
            #region Instructions
            /* -Pipeline Inputs and Outputs
             *  Pipeline inputs and outputs are accessed via the props variable.
             *  Value types (int, long, bool, enums, etc..) are marked as nullable.
             *  When you look at the type you'll see, for example, int? instead of int.
             *  Nullable value types are used because the Pipeline value could possibly be null.
             *  You can check to see if the value is null by checking the .HasValue property. 
             *  There are two ways you can get the actual value of the variable. First by using 
             *  the .Value property.
             *  Example:
             *      int a = props.Pipeline.Foo.Value; //The type of Foo is int? (a.k.a. Nullable<int>) but the type of Foo.Value is int.
             *  And second by doing a cast:
             *  Example:
             *      int a = (int)props.Pipeline.Foo; //The type of Foo is int? (a.k.a. Nullable<int>)
             *  Reference types (string, classes you write) are already nullable so there's no 
             *  need to treat them special.
             *  Example:
             *      string foo = props.Pipeline.Foo; //The type of Foo is string.
             *
             * -General Configuration Variables
             *  Accessed via the GeneralConfig property of WriteProductQueuePlugin.
             *  Example: 
             *      string filePath = GeneralConfig.FilePath;
             * 
             * -Errors
             *  If there is a critical error and you would like to make the the current session as failed,
             *  throw an exception of type ApplicationException with a custom message. 
             *  The message will be logged. The ProcessAllSessions method will catch the 
             *  exception and mark the current session as failed and move on to the next session to process.
             *  Example: 
             *      throw new ApplicationException("The value Foo was outside the expected range");
             * 
             * -Logging
             *  You can log messages via the Log function.
             *  Example: Log(LogLevel.Debug, "Test message");
             */
            #endregion
            Log(LogLevel.Debug, "Start");           
            
            //TODO: Add your business logic here
        }		
		
	} 
} 
