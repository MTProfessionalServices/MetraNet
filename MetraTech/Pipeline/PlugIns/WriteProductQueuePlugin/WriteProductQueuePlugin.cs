#region Generated using ICE (Do not modify this region)
/// Generated using ICE
/// ICE CodeGen Version: 1.0.0
#endregion
using System;
using System.Collections.Generic;
using MetraTech.Pipeline.Plugins.WriteProductQueue;
using MetraTech.Pipeline;
#region AutoGenerated Enum Includes (Do not modify this region)
//ENUM_USING
#endregion

namespace MetraTech.Pipeline.Plugins
{
    /// <summary>
    /// WriteProductQueue plugin supports sending the contents of a PV to a RabbitMQ queue
    /// 
    /// This is primarilly intended to send usage to the Near Realtime Counters system, but can be used to write to any RabbitMQ
    /// </summary>
    public sealed partial class WriteProductQueuePlugin : MetraTech.Pipeline.Plugins.WriteProductQueue.PlugInBase
    {
        /// <summary>
        /// This is a convenience field to help us calculate a unix-style time_t timestamp
        /// </summary>
        private static DateTime dt1970 = new DateTime(1970, 1, 1);

        /// <summary>
        /// The connection factory for the Rabbit MQ connections
        /// </summary>
        private RabbitMQ.Client.ConnectionFactory factory;

        /// <summary>
        /// The serializer to use
        /// </summary>
        private ISessionSerializer serializer;

        /// <summary>
        /// whether this session set has partially failed or not
        /// </summary>
        private bool partiallyFailed;

        /// <summary>
        /// cache for mapping message sequence numbers to session ids
        /// </summary>
        private Dictionary<ulong, string> messageToSessionMap = new Dictionary<ulong, string>();

        /// <summary>
        /// cache for mapping sessions ids to sessions
        /// </summary>
        private Dictionary<string, ISession> sessionMap = new Dictionary<string, ISession>();

        /// <summary>
        /// list of unconfirmed messages
        /// </summary>
        private List<ulong> openConfirms = new List<ulong>();

        #region ProcessAllSessions (Only modify this in the rare case you need to handle more than one session at once)
        /// <summary>
        /// This method is called each time the plug-in recieves a session set
        /// </summary>
        protected override void ProcessAllSessions(MetraTech.Pipeline.Plugins.WriteProductQueue.PropertiesCollection propsCol)
        {
            // 1) cleanup session data
            partiallyFailed = false;
            sessionMap.Clear();
            messageToSessionMap.Clear();
            openConfirms.Clear();

            Log(LogLevel.Debug, "Creating new connection...");

            // 1) Grab a connection
            RabbitMQ.Client.IConnection connection;
            try
            {
                connection = factory.CreateConnection();
            }
            catch (Exception ex)
            {
                Log("Unable to create connection", ex);
                throw new ApplicationException("Unable to connect to queue", ex);
            }
            using (connection)
            {
                try
                {
                    Log(LogLevel.Debug, string.Format("Processing {0} sessions...", propsCol == null ? 0 : propsCol.Count));

                    // 2) grab a channel
                    Log(LogLevel.Debug, "Creating new channel...");
                    using (var model = connection.CreateModel())
                    {
                        // 3) setup event handlers based on configurations
                        if ((GeneralConfig.MandatoryRouting.HasValue && GeneralConfig.MandatoryRouting.Value)
                            || (GeneralConfig.ImmediateDelivery.HasValue && GeneralConfig.ImmediateDelivery.Value))
                        {
                            model.BasicReturn += new RabbitMQ.Client.Events.BasicReturnEventHandler((mdl, args) => { Return(args); });
                        }
                        if (GeneralConfig.ConfirmRouting.HasValue && GeneralConfig.ConfirmRouting.Value)
                        {
                            model.ConfirmSelect();
                            model.BasicNacks += new RabbitMQ.Client.Events.BasicNackEventHandler((mdl, args) => { Reject(args); });
                            model.BasicAcks += new RabbitMQ.Client.Events.BasicAckEventHandler((mdl, args) => { Confirm(args); });
                        }

                        // 4) loop through the sessions
                        foreach (MetraTech.Pipeline.Plugins.WriteProductQueue.Properties props in propsCol)
                        {
                            Log(LogLevel.Debug, "Processing session...");
                            // set the current session for logging purposes
                            SetCurrentSession(props.Session);

                            // 5) just process the session directly
                            try
                            {
                                Log(LogLevel.Debug, "Performing synchronous queuing...");
                                // process each session
                                ProcessSession(props, model);
                            }
                            catch (Exception ex)
                            {
                                partiallyFailed = true;
                                Log("Error when processing session", ex);
                                // mark the session as failed
                                props.Session.MarkAsFailed(
                                    string.Format("Error when processing session. Source: {0}, Message: {1}",
                                    ex.Source, ex.Message), MARK_AS_FAILED_CODE_FAILED);
                            }
                        }

                        // 6) handle confirms/returns
                        if (GeneralConfig.WaitTimeout.HasValue)
                        {
                            bool tout = false;
                            bool res = true;
                            var ts = new TimeSpan(0, 0, GeneralConfig.WaitTimeout.Value);
                            do
                            {
                                res = res && model.WaitForConfirms(ts, out tout);
                                Log(LogLevel.Debug, string.Format("Still waiting for all confirms ({0} pending)", openConfirms.Count));
                            }
                            while (tout);
                        }
                        else
                        {
                            var res = model.WaitForConfirms();
                            Log(LogLevel.Debug, string.Format("Everything confirmed: {0}", res ? "all acknowledged" : "some rejected"));
                        }

                        // 7) dispose of the sessions
                        foreach (var session in sessionMap.Values)
                        {
                            try
                            {
                                session.Dispose();
                            }
                            catch
                            {
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    Log("Error processing session", ex);
                    throw;
                }
            }

            Log(LogLevel.Debug, "Finished processing...");

            // if any of the sessions failed, go ahead and throw an exception here
            if (partiallyFailed)
            {
                throw new MetraTech.Pipeline.PlugIns.PartialFailureException();
            }
        }
        #endregion

        #region Startup override
        /// <summary>
        /// This method takes care of configuring the RabbitMQ connection factory
        /// </summary>
        /// <param name="systemContext">the system context</param>
        /// <param name="propSet">the configuration property set</param>
        protected override void StartUp(MetraTech.Interop.SysContext.IMTSystemContext systemContext, MetraTech.Interop.MTPipelineLib.IMTConfigPropSet propSet)
        {
            Log(LogLevel.Info, "Configuring plugin...");

            // 1) get the Name ID for the ProductViewID (pipeline identifier)
            var nameId = systemContext.GetNameID();
            int pvNameId;
            Log(LogLevel.Info, "Getting NameID for _ProductViewID...");
            try
            {
                pvNameId = nameId.GetNameID("_ProductViewID");
            }
            catch (Exception ex)
            {
                Log("Error retrieving NameID for _ProductViewID", ex);
                throw;
            }

            Log(LogLevel.Info, "Initializing Queue Connection Factory...");

            try
            {
                // 2) create the factory
                factory = new RabbitMQ.Client.ConnectionFactory();

                // 3) configure connection factory
                factory.HostName = GeneralConfig.FactoryHostname ?? factory.HostName;
                factory.Port = RabbitMQ.Client.AmqpTcpEndpoint.UseDefaultPort;
                if (GeneralConfig.FactoryPort.HasValue)
                {
                    factory.Port = GeneralConfig.FactoryPort.Value;
                }
                factory.Protocol = RabbitMQ.Client.Protocols.DefaultProtocol;
                if (!string.IsNullOrEmpty(GeneralConfig.FactoryProtocol))
                {
                    factory.Protocol = RabbitMQ.Client.Protocols.SafeLookup(GeneralConfig.FactoryProtocol);
                }
                if (GeneralConfig.RequestedHeartbeat.HasValue)
                {
                    factory.RequestedHeartbeat = (ushort)GeneralConfig.RequestedHeartbeat.Value;
                }
                factory.VirtualHost = GeneralConfig.FactoryVirtualHost ?? factory.VirtualHost;

                // 4) if we have a QueueName, then we will use that to set the username/password via servers.xml
                if (!string.IsNullOrEmpty(GeneralConfig.QueueName))
                {
                    Log(LogLevel.Debug, string.Format("Retrieving Queue configuration from servers.xml for queue {0}", GeneralConfig.QueueName));
                    try
                    {
                        MetraTech.Interop.MTServerAccess.IMTServerAccessDataSet sa = new MetraTech.Interop.MTServerAccess.MTServerAccessDataSet();
                        sa.Initialize();
                        MetraTech.Interop.MTServerAccess.IMTServerAccessData accessData;
                        accessData = sa.FindAndReturnObject(GeneralConfig.QueueName);
                        factory.UserName = accessData.UserName;
                        factory.Password = accessData.Password;
                    }
                    catch (Exception e)
                    {
                        Log(string.Format("Unable to lookup login information for queue {0} in servers.xml", GeneralConfig.QueueName), e);
                        throw;
                    }
                }

                Log(LogLevel.Debug, string.Format("   Hostname: {0}", factory.HostName));
                Log(LogLevel.Debug, string.Format("   Hostname: {0}", factory.UserName));
                Log(LogLevel.Debug, string.Format("       Port: {0}", factory.Port));
                Log(LogLevel.Debug, string.Format("   Protocol: {0}", factory.Protocol.ApiName));
                Log(LogLevel.Debug, string.Format("  Heartbeat: {0}", factory.RequestedHeartbeat));
                Log(LogLevel.Debug, string.Format("VirtualHost: {0}", factory.VirtualHost));

                Log(LogLevel.Debug, "Queue Connection Factory Initialized...");
            }
            catch (Exception ex)
            {
                Log("Error configuring Queue Connection Factory", ex);
                throw;
            }

            // 5) cache the ProductView mappings (for serialization, etc)
            Log(LogLevel.Info, "Loading Product View Definitions...");

            var ProductViews = new Dictionary<long, List<PropertyInfo>>();

            try
            {
                Log(LogLevel.Debug, "Retrieving ProductViewDefinitionCollection...");
                ProductViewDefinitionCollection pvdc = new ProductViewDefinitionCollection();
                foreach (var pv in pvdc.Names)
                {
                    Log(LogLevel.Debug, string.Format("Loading Product View Definition for {0}", pv));
                    string nmPv = (string)pv;
                    var pvd = pvdc.GetProductViewDefinition(nmPv);
                    if (pvd == null)
                    {
                        throw new ApplicationException(string.Format("Unable to retrieve Product View Definition for {0}", nmPv));
                    }
                    var props = new List<PropertyInfo>();
                    ProductViews[pvd.NameID] = props;

                    foreach (var p in pvd.Properties)
                    {
                        var prop = (MetraTech.Interop.MTProductCatalog.IMTPropertyMetaData)p;
                        props.Add(new PropertyInfo { DataType = prop.DataType, DBColumnName = prop.DBColumnName, NameID = nameId.GetNameID(prop.Name) });
                    }

                    // 6) add t_acc_usage columns
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_AccountID"), DBColumnName = "id_payee", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_INTEGER });
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_Currency"), DBColumnName = "am_currency", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_STRING });
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_Timestamp"), DBColumnName = "dt_session", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_DATETIME });
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_PayingAccount"), DBColumnName = "id_acc", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_INTEGER });
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_IntervalId"), DBColumnName = "id_usage_interval", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_INTEGER });
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_Amount"), DBColumnName = "amount", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_DECIMAL });
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_FedTax"), DBColumnName = "tax_federal", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_DECIMAL });
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_StateTax"), DBColumnName = "tax_state", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_DECIMAL });
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_CountyTax"), DBColumnName = "tax_county", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_DECIMAL });
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_LocalTax"), DBColumnName = "tax_local", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_DECIMAL });
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_OtherTax"), DBColumnName = "tax_other", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_DECIMAL });

                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_PriceableItemInstanceID"), DBColumnName = "id_pi_instance", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_INTEGER });
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_PriceableItemTemplateID"), DBColumnName = "id_pi_template", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_INTEGER });
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_ProductOfferingID"), DBColumnName = "id_prod", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_INTEGER });
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_CollectionID"), DBColumnName = "tx_batch", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_STRING });
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_SubscriptionEntity"), DBColumnName = "id_se", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_INTEGER });
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_DivisionCurrency"), DBColumnName = "div_currency", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_STRING });
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_DivisionAmount"), DBColumnName = "div_amount", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_DECIMAL });
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_TaxInclusive"), DBColumnName = "tax_inclusive", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_STRING });
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_TaxCalculated"), DBColumnName = "tax_calculated", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_STRING });
                    props.Add(new PropertyInfo { NameID = nameId.GetNameID("_TaxInformational"), DBColumnName = "tax_informational", DataType = Interop.MTProductCatalog.PropValType.PROP_TYPE_STRING });
                }
                Log(LogLevel.Debug, "Finished loading Product View Definitions");
            }
            catch (Exception ex)
            {
                Log("Error loading Product View Definitions", ex);
                throw;
            }

            Log(LogLevel.Debug, "Configuring the serializer...");
            // configurable serializer
            try
            {
                if (string.IsNullOrEmpty(GeneralConfig.SerializerClass))
                {
                    Log(LogLevel.Debug, "Using default MVM serializer");
                    serializer = new MvmSessionSerializer();
                }
                else
                {
                    Log(LogLevel.Debug, string.Format("Using serializer: {0}", GeneralConfig.SerializerClass));
                    var st = Type.GetType(GeneralConfig.SerializerClass, true, true);
                    if (st != null)
                    {
                        var sc = st.GetConstructor(new Type[0]);
                        if (sc != null)
                        {
                            var obj = sc.Invoke(new object[0]);
                            if (obj != null)
                            {
                                serializer = (ISessionSerializer)obj;
                                if (serializer == null)
                                {
                                    throw new ApplicationException("Specified serializer is not the correct interface");
                                }
                            }
                            else
                            {
                                throw new ApplicationException("Specified serializer could not be created");
                            }
                        }
                        else
                        {
                            throw new ApplicationException("Specified serializer does not have a default constructor");
                        }
                    }
                    else
                    {
                        throw new ApplicationException("Specified serializer could not be found");
                    }
                }
                serializer.Init(pvNameId, ProductViews);
            }
            catch (Exception ex)
            {
                Log("Error loading serializer", ex);
                throw;
            }

            Log(LogLevel.Info, "Finished configuring plugin");
        }
        #endregion

        #region Shutdown override
        /// <summary>
        /// Nothing to do on shutdown
        /// </summary>
        public override void Shutdown()
        {
        }
        #endregion

        /// <summary>
        /// This method is called for each session in the session set.
        /// </summary>
        protected override void ProcessSession(MetraTech.Pipeline.Plugins.WriteProductQueue.Properties props, RabbitMQ.Client.IModel model)
        {
            Log(LogLevel.Debug, "Start queuing session");

            try
            {
                // 2) grab the basic properties
                Log(LogLevel.Debug, "Setting message properties...");
                var basicProperties = model.CreateBasicProperties();

                // 3) configure the basic properties
                if (!string.IsNullOrEmpty(props.Pipeline.ApplicationId))
                {
                    basicProperties.AppId = props.Pipeline.ApplicationId;
                }
                else if (!string.IsNullOrEmpty(GeneralConfig.ApplicationId))
                {
                    basicProperties.AppId = GeneralConfig.ApplicationId;
                }

                if (!string.IsNullOrEmpty(GeneralConfig.ContentEncoding))
                {
                    basicProperties.ContentEncoding = GeneralConfig.ContentEncoding;
                }

                if (!string.IsNullOrEmpty(GeneralConfig.ContentType))
                {
                    basicProperties.ContentType = GeneralConfig.ContentType;
                }

                if (!string.IsNullOrEmpty(props.Pipeline.CorrelationId))
                {
                    basicProperties.CorrelationId = props.Pipeline.CorrelationId;
                }

                if (GeneralConfig.PersistentDelivery.HasValue)
                {
                    basicProperties.DeliveryMode = (byte)(GeneralConfig.PersistentDelivery.Value ? 2 : 1);
                }
                if (!string.IsNullOrEmpty(props.Pipeline.Expiration))
                {
                    basicProperties.Expiration = props.Pipeline.Expiration;
                }
                else if (!string.IsNullOrEmpty(GeneralConfig.Expiration))
                {
                    basicProperties.Expiration = GeneralConfig.Expiration;
                }

                if (!string.IsNullOrEmpty(props.Pipeline.MessageId))
                {
                    basicProperties.MessageId = props.Pipeline.MessageId;
                }
                else
                {
                    basicProperties.MessageId = props.Session.UIDEncoded;
                }

                int? priority = null;
                if (props.Pipeline.MessagePriority.HasValue)
                {
                    priority = props.Pipeline.MessagePriority.Value;
                }
                else if (GeneralConfig.MessagePriority.HasValue)
                {
                    priority = GeneralConfig.MessagePriority.Value;
                }
                if (priority.HasValue && (priority.Value < 0 || priority.Value > 9))
                {
                    throw new IndexOutOfRangeException("MessagePriority must be between 0 and 9");
                }
                else if (priority.HasValue)
                {
                    basicProperties.Priority = (byte)priority.Value;
                }

                if (!string.IsNullOrEmpty(props.Pipeline.ReplyTo))
                {
                    basicProperties.ReplyTo = props.Pipeline.ReplyTo;
                }

                if (props.Pipeline.Timestamp.HasValue)
                {
                    basicProperties.Timestamp = new RabbitMQ.Client.AmqpTimestamp((long)(props.Pipeline.Timestamp.Value - dt1970).TotalSeconds);
                }

                if (!string.IsNullOrEmpty(props.Pipeline.MessageType))
                {
                    basicProperties.Type = props.Pipeline.MessageType;
                }
                else if (!string.IsNullOrEmpty(GeneralConfig.MessageType))
                {
                    basicProperties.Type = GeneralConfig.MessageType;
                }
                else
                {
                    basicProperties.Type = "pv";
                }

                if (!string.IsNullOrEmpty(props.Pipeline.UserId))
                {
                    basicProperties.UserId = props.Pipeline.UserId;
                }
                else if (!string.IsNullOrEmpty(GeneralConfig.UserId))
                {
                    basicProperties.UserId = GeneralConfig.UserId;
                }
                else if (!string.IsNullOrEmpty(factory.UserName))
                {
                    basicProperties.UserId = factory.UserName;
                }
                else
                {
                    basicProperties.UserId = "guest";
                }

                // 4) populate/format message
                System.Text.StringBuilder builder = new System.Text.StringBuilder();
                Log(LogLevel.Debug, "Serializing message...");
                var msg = serializer.SerializeSession(props.Session);

                string exchange = string.Empty;
                if (!string.IsNullOrEmpty(props.Pipeline.ExchangeName))
                {
                    exchange = props.Pipeline.ExchangeName;
                }
                else if (!string.IsNullOrEmpty(GeneralConfig.ExchangeName))
                {
                    exchange = GeneralConfig.ExchangeName;
                }
                string routingKey = string.Empty;
                if (!string.IsNullOrEmpty(props.Pipeline.RoutingKey))
                {
                    routingKey = props.Pipeline.RoutingKey;
                }
                else if (!string.IsNullOrEmpty(GeneralConfig.RoutingKey))
                {
                    routingKey = GeneralConfig.RoutingKey;
                }

                // 5) setup message handling confirmations/returns etc.
                Log(LogLevel.Debug, string.Format("Publishing message: {0} to exchange {1} and routing key {2}", msg, exchange, routingKey));

                AddConfirmation(props.Session, model.NextPublishSeqNo);

                // 6) publish the message
                model.BasicPublish(exchange, routingKey, GeneralConfig.MandatoryRouting ?? true, GeneralConfig.ImmediateDelivery ?? false, basicProperties, msg);

                Log(LogLevel.Debug, "Message published...");
            }
            catch (Exception ex)
            {
                Log("Unable to queue ProductView", ex);
                throw;
            }
            Log(LogLevel.Info, "Done queuing session");
        }

        /// <summary>
        /// register an unconfirmed message
        /// </summary>
        /// <param name="session">the session</param>
        /// <param name="messageId">the message id</param>
        public void AddConfirmation(ISession session, ulong messageId)
        {
            Log(LogLevel.Debug, string.Format("Registering transaction: {0} ({1})", session.UIDEncoded, messageId));
            messageToSessionMap[messageId] = session.UIDEncoded;
            sessionMap[session.UIDEncoded] = session;
            lock (openConfirms)
            {
                openConfirms.Add(messageId);
            }
        }

        /// <summary>
        /// Return the specified message
        /// </summary>
        /// <param name="args">the event</param>
        public void Return(RabbitMQ.Client.Events.BasicReturnEventArgs args)
        {
            Log(LogLevel.Error, string.Format("Returning Message: {0} ({1})", args.ReplyText, args.BasicProperties.MessageId));
            sessionMap[args.BasicProperties.MessageId].MarkAsFailed(
                string.Format("Error queuing session. Source: {0}, Message: {1}",
                args.BasicProperties.MessageId, args.ReplyText), MARK_AS_FAILED_CODE_FAILED);
            partiallyFailed = true;
        }

        /// <summary>
        /// Reject the specified message
        /// </summary>
        /// <param name="args">the event</param>
        public void Reject(RabbitMQ.Client.Events.BasicNackEventArgs args)
        {
            Log(LogLevel.Error, string.Format("Rejecting {0}: {1}", args.Multiple ? "all messages up to" : "message", args.DeliveryTag));

            if (args.DeliveryTag == 0 && args.Multiple)
            {
                lock (openConfirms)
                {
                    foreach (var id in openConfirms)
                    {
                        partiallyFailed = true;
                        sessionMap[messageToSessionMap[id]].MarkAsFailed(
                            string.Format("Error queuing session. Source: {0}, Message: {1}",
                            messageToSessionMap[args.DeliveryTag], "Rejected"), MARK_AS_FAILED_CODE_FAILED);
                    }
                    openConfirms.Clear();
                }
            }
            else if (args.Multiple)
            {
                lock (openConfirms)
                {
                    foreach (var id in openConfirms)
                    {
                        partiallyFailed = true;
                        sessionMap[messageToSessionMap[id]].MarkAsFailed(
                            string.Format("Error queuing session. Source: {0}, Message: {1}",
                            messageToSessionMap[args.DeliveryTag], "Rejected"), MARK_AS_FAILED_CODE_FAILED);
                        openConfirms.Remove(id);
                        if (id == args.DeliveryTag)
                        {
                            break;
                        }
                    }
                }
            }
            else
            {
                lock (openConfirms)
                {
                    partiallyFailed = true;
                    sessionMap[messageToSessionMap[args.DeliveryTag]].MarkAsFailed(
                        string.Format("Error queuing session. Source: {0}, Message: {1}",
                        messageToSessionMap[args.DeliveryTag], "Rejected"), MARK_AS_FAILED_CODE_FAILED);
                    openConfirms.Remove(args.DeliveryTag);
                }
            }
        }

        /// <summary>
        /// Confirm the message
        /// </summary>
        /// <param name="args">the event</param>
        public void Confirm(RabbitMQ.Client.Events.BasicAckEventArgs args)
        {
            Log(LogLevel.Debug, string.Format("Confirming {0}: {1}", args.Multiple ? "all messages up to" : "message", args.DeliveryTag));
            if (args.DeliveryTag == 0 && args.Multiple)
            {
                lock (openConfirms)
                {
                    openConfirms.Clear();
                }
            }
            else if (args.Multiple)
            {
                lock (openConfirms)
                {
                    foreach (var id in openConfirms)
                    {
                        openConfirms.Remove(id);
                        if (id == args.DeliveryTag)
                        {
                            break;
                        }
                    }
                }
            }
            else
            {
                lock (openConfirms)
                {
                    openConfirms.Remove(args.DeliveryTag);
                }
            }
        }
    }

    /// <summary>
    /// Interface for the session serialization
    /// </summary>
    public interface ISessionSerializer
    {
        /// <summary>
        /// Serialize a single (possibly multipoint) session
        /// </summary>
        /// <param name="session">The session to serialize</param>
        /// <returns>The byte array output</returns>
        byte[] SerializeSession(ISession session);

        void Init(int pvNameId, Dictionary<long, List<PropertyInfo>> productViews);
    }

    /// <summary>
    /// OOTB base XML serializer
    /// </summary>
    public sealed class XmlSessionSerializer : ISessionSerializer
    {
        /// <summary>
        /// static logger
        /// </summary>
        private static Logger logger = new Logger("[WriteProductQueue]");

        /// <summary>
        /// This is the name ID for the ProductView field in the pipeline.  This is used to retrieve the selected PV for each session.
        /// </summary>
        private int ProductViewNameId;

        /// <summary>
        /// A cache of the product view configurations.  This is used to store the serialization formats for a given ProductView.
        /// </summary>
        private Dictionary<long, List<PropertyInfo>> ProductViews;

        public void Init(int pvNameId, Dictionary<long, List<PropertyInfo>> productViews)
        {
            ProductViewNameId = pvNameId;
            ProductViews = productViews;
        }

        /// <summary>
        /// Serialize the session to XML
        /// </summary>
        /// <param name="session">The session to serialize</param>
        /// <returns>The serialized session, serialized using UTF8</returns>
        public byte[] SerializeSession(ISession session)
        {
            var builder = new System.Text.StringBuilder();
            SerializeSession(builder, session);
            return System.Text.Encoding.UTF8.GetBytes(builder.ToString());
        }

        /// <summary>
        /// basic XML serializer
        /// </summary>
        /// <param name="builder">the string builder</param>
        /// <param name="session">the session to serialize</param>
        private void SerializeSession(System.Text.StringBuilder builder, ISession session)
        {
            var idPv = session.GetLongProperty(ProductViewNameId);

            if (!ProductViews.ContainsKey(idPv))
            {
                throw new ApplicationException(string.Format("No ProductView found for id: {0}", idPv));
            }

            var pvd = ProductViews[idPv];
            builder.Append("<pv>");
            if (session.InternalID > 0)
            {
                builder.Append("<id_sess>").Append(session.InternalID).Append("</id_sess>");
            }
            if (session.InternalParentID > 0)
            {
                builder.Append("<id_parent_sess>").Append(session.InternalParentID).Append("</id_parent_sess>");
            }
            builder.Append("<id_view>").Append(idPv).Append("</id_view>");
            builder.Append("<id_svc>").Append(session.ServiceDefinitionID).Append("</id_svc>");
            builder.Append("<tx_uid>").Append(session.UIDEncoded).Append("</tx_uid>");
            builder.Append("<dt_crt>").Append(MetraTime.Now.ToString("s", System.Globalization.CultureInfo.InvariantCulture)).Append("</dt_crt>");
            foreach (var prop in pvd)
            {
                var pName = prop.DBColumnName;
                switch (prop.DataType)
                {
                    case Interop.MTProductCatalog.PropValType.PROP_TYPE_BOOLEAN:
                        if (session.PropertyExists(prop.NameID, ISession.PropertyType.Bool))
                        {
                            builder.Append('<').Append(pName).Append('>').Append(session.GetBooleanProperty(prop.NameID) ? "true" : "false").Append("</").Append(pName).Append('>');
                        }
                        break;
                    case Interop.MTProductCatalog.PropValType.PROP_TYPE_DATETIME:
                    case Interop.MTProductCatalog.PropValType.PROP_TYPE_TIME:
                        if (session.PropertyExists(prop.NameID, ISession.PropertyType.DateTime))
                        {
                            builder.Append('<').Append(pName).Append('>').Append(session.GetDateTimeProperty(prop.NameID).ToString("s", System.Globalization.CultureInfo.InvariantCulture)).Append("</").Append(pName).Append('>');
                        }
                        break;
                    case Interop.MTProductCatalog.PropValType.PROP_TYPE_DECIMAL:
                        if (session.PropertyExists(prop.NameID, ISession.PropertyType.Decimal))
                        {
                            builder.Append('<').Append(pName).Append('>').Append(session.GetDecimalProperty(prop.NameID)).Append("</").Append(pName).Append('>');
                        }
                        break;
                    case Interop.MTProductCatalog.PropValType.PROP_TYPE_DOUBLE:
                        if (session.PropertyExists(prop.NameID, ISession.PropertyType.Double))
                        {
                            builder.Append('<').Append(pName).Append('>').Append(session.GetDoubleProperty(prop.NameID)).Append("</").Append(pName).Append('>');
                        }
                        break;
                    case Interop.MTProductCatalog.PropValType.PROP_TYPE_ENUM:
                        if (session.PropertyExists(prop.NameID, ISession.PropertyType.Enum))
                        {
                            builder.Append('<').Append(pName).Append('>').Append(session.GetEnumProperty(prop.NameID)).Append("</").Append(pName).Append('>');
                        }
                        break;
                    case Interop.MTProductCatalog.PropValType.PROP_TYPE_INTEGER:
                        if (session.PropertyExists(prop.NameID, ISession.PropertyType.Int))
                        {
                            builder.Append('<').Append(pName).Append('>').Append(session.GetIntegerProperty(prop.NameID)).Append("</").Append(pName).Append('>');
                        }
                        break;
                    case Interop.MTProductCatalog.PropValType.PROP_TYPE_BIGINTEGER:
                        if (session.PropertyExists(prop.NameID, ISession.PropertyType.Long))
                        {
                            builder.Append('<').Append(pName).Append('>').Append(session.GetLongProperty(prop.NameID)).Append("</").Append(pName).Append('>');
                        }
                        break;
                    case Interop.MTProductCatalog.PropValType.PROP_TYPE_STRING:
                    case Interop.MTProductCatalog.PropValType.PROP_TYPE_UNICODE_STRING:
                    case Interop.MTProductCatalog.PropValType.PROP_TYPE_ASCII_STRING:
                        if (session.PropertyExists(prop.NameID, ISession.PropertyType.String))
                        {
                            builder.Append('<').Append(pName).Append('>').Append(System.Security.SecurityElement.Escape(session.GetStringProperty(prop.NameID))).Append("</").Append(pName).Append('>');
                        }
                        break;
                    default:
                        logger.LogWarning(string.Format("Ignoring unhandled data type {0} for property: {1}", prop.DataType, pName));
                        break;
                }
            }
            // handle multipoint
            if (session.IsParent && session.SessionChildren != null)
            {
                builder.Append("<children>");
                foreach (ISession child in session.SessionChildren)
                {
                    SerializeSession(builder, child);
                }
                builder.Append("</children>");
            }
            builder.Append("</pv>");
        }

    }

    /// <summary>
    /// OOTB MVM Serializer using BinaryWriter
    /// </summary>
    public sealed class MvmSessionSerializer : ISessionSerializer
    {
        /// <summary>
        /// static logger
        /// </summary>
        private static Logger logger = new Logger("[WriteProductQueue]");

        /// <summary>
        /// This is the name ID for the ProductView field in the pipeline.  This is used to retrieve the selected PV for each session.
        /// </summary>
        private int ProductViewNameId;

        /// <summary>
        /// A cache of the product view configurations.  This is used to store the serialization formats for a given ProductView.
        /// </summary>
        private Dictionary<long, List<PropertyInfo>> ProductViews;

        /// <summary>
        /// cache the id to formats
        /// </summary>
        private Dictionary<long, int> MvmFormatIds = new Dictionary<long, int>();

        /// <summary>
        /// format to use for dates
        /// </summary>
        private string DbDateFormat;

        /// <summary>
        /// whether to debug the stream or not
        /// </summary>
        public bool DebugStream = false;

        public void Init(int pvNameId, Dictionary<long, List<PropertyInfo>> productViews)
        {
            ProductViewNameId = pvNameId;
            ProductViews = productViews;

            var baseFormat = "id_sess,id_parent_sess,id_view,id_svc,tx_uid,dt_crt";

            foreach (var pv in ProductViews.Keys)
            {
                var format = baseFormat;
                var props = ProductViews[pv];
                foreach (var key in props)
                {
                    logger.LogDebug("Adding format: " + key.DBColumnName.ToLower(System.Globalization.CultureInfo.InvariantCulture));
                    format += "," + key.DBColumnName.ToLower(System.Globalization.CultureInfo.InvariantCulture);
                }
                format += ",child_count";
                using (var conn = MetraTech.DataAccess.ConnectionManager.CreateConnection())
                {
                    if (conn.ConnectionInfo.IsOracle)
                    {
                        DbDateFormat = "yyyyMMddHHmmss";
                    }
                    else
                    {
                        DbDateFormat = "yyyy-MM-dd HH:mm:ss.fff";
                    }
                    using (var stmt = conn.CreateCallableStatement("mvm_get_format_id"))
                    {
                        // break the format string into 4000 byte chunks.
                        double chunksDbl = format.Length / 4000;
                        int chunks = (int)Math.Ceiling(chunksDbl);
                        int i = 0;
                        for (i = 0; i <= chunks; i++)
                        {
                            string paramName = "p_format_string" + (i + 1);
                            int startIdx = 4000 * i;
                            int len = 4000;
                            if ((startIdx + len) > format.Length) len = format.Length - startIdx;
                            string paramValue = format.Substring(startIdx, len);
                            stmt.AddParam(paramName, DataAccess.MTParameterType.String, paramValue);
                        }
                        for (; i < 5; i++)
                        {
                            string paramName = "p_format_string" + (i + 1);
                            stmt.AddParam(paramName, DataAccess.MTParameterType.String, string.Empty);
                        }
                        stmt.AddOutputParam("p_format_id", DataAccess.MTParameterType.Integer);
                        var rc = stmt.ExecuteNonQuery();
                        object output = stmt.GetOutputValue("p_format_id");
                        logger.LogDebug(string.Format("MVM Format Id for PV {0} is {1} (proc returned {2})", pv, output, rc));
                        MvmFormatIds[pv] = (int)output;
                    }
                }

            }
        }

        /// <summary>
        /// Serialize the session to MVM binary format
        /// </summary>
        /// <param name="session">The session to serialize</param>
        /// <returns>The serialized session, serialized using UTF8</returns>
        public byte[] SerializeSession(ISession session)
        {
            using (var stream = new System.IO.MemoryStream())
            {
                using (var writer = new System.IO.BinaryWriter(stream))
                {
                    SerializeSession(writer, session);
                    writer.Flush();
                }
                var ba = stream.ToArray();
                if (DebugStream)
                {
                    DebugSession(ba, string.Empty);
                }
                return ba;
            }
        }

        /// <summary>
        /// MVM binary serializer
        /// </summary>
        /// <param name="builder">the writer</param>
        /// <param name="session">the session to serialize</param>
        private void SerializeSession(System.IO.BinaryWriter writer, ISession session)
        {
            var idPv = session.GetLongProperty(ProductViewNameId);

            if (!ProductViews.ContainsKey(idPv))
            {
                throw new ApplicationException(string.Format("No ProductView found for id: {0}", idPv));
            }

            var pvd = ProductViews[idPv];
            var mvmFormatId = MvmFormatIds[idPv];
            writer.Write(mvmFormatId.ToString());
            if (session.InternalID > 0)
            {
                writer.Write(session.InternalID.ToString());
            }
            else
            {
                writer.Write(string.Empty);
            }
            if (session.InternalParentID > 0)
            {
                writer.Write(session.InternalParentID.ToString());
            }
            else
            {
                writer.Write(string.Empty);
            }
            writer.Write(idPv.ToString());
            writer.Write(session.ServiceDefinitionID.ToString());
            if (session.UID != null)
            {
                var hex = new System.Text.StringBuilder(session.UID.Length * 2);
                foreach (var b in session.UID)
                {
                    hex.AppendFormat("{0:X2}", b);
                }
                writer.Write(hex.ToString());
            }
            else
            {
                writer.Write(string.Empty);
            }
            writer.Write(MetraTime.Now.ToString(DbDateFormat, System.Globalization.CultureInfo.InvariantCulture));
            foreach (var prop in pvd)
            {
                var pName = prop.DBColumnName;
//                logger.LogDebug("Adding field: " + pName);
                if (pName.Equals("tx_batch"))
                {
                    if (session.PropertyExists(prop.NameID, ISession.PropertyType.String))
                    {
                        var txBatch = session.GetStringProperty(prop.NameID);
                        writer.Write(MetraTech.Utils.MSIXUtils.DecodeUIDAsString(txBatch));
                    }
                    else
                    {
                        writer.Write(string.Empty);
                    }
                }
                else
                {
                    switch (prop.DataType)
                    {
                        case Interop.MTProductCatalog.PropValType.PROP_TYPE_BOOLEAN:
                            if (session.PropertyExists(prop.NameID, ISession.PropertyType.Bool))
                            {
                                writer.Write(session.GetBooleanProperty(prop.NameID) ? "1" : "0");
                            }
                            else
                            {
                                writer.Write(string.Empty);
                            }
                            break;
                        case Interop.MTProductCatalog.PropValType.PROP_TYPE_DATETIME:
                        case Interop.MTProductCatalog.PropValType.PROP_TYPE_TIME:
                            if (session.PropertyExists(prop.NameID, ISession.PropertyType.DateTime))
                            {
                                writer.Write(session.GetDateTimeProperty(prop.NameID).ToString(DbDateFormat, System.Globalization.CultureInfo.InvariantCulture));
                            }
                            else
                            {
                                writer.Write(string.Empty);
                            }
                            break;
                        case Interop.MTProductCatalog.PropValType.PROP_TYPE_DECIMAL:
                            if (session.PropertyExists(prop.NameID, ISession.PropertyType.Decimal))
                            {
                                writer.Write(session.GetDecimalProperty(prop.NameID).ToString("0.##########"));
                            }
                            else
                            {
                                writer.Write(string.Empty);
                            }
                            break;
                        case Interop.MTProductCatalog.PropValType.PROP_TYPE_DOUBLE:
                            if (session.PropertyExists(prop.NameID, ISession.PropertyType.Double))
                            {
                                writer.Write(session.GetDoubleProperty(prop.NameID).ToString("0.##########"));
                            }
                            else
                            {
                                writer.Write(string.Empty);
                            }
                            break;
                        case Interop.MTProductCatalog.PropValType.PROP_TYPE_ENUM:
                            if (session.PropertyExists(prop.NameID, ISession.PropertyType.Enum))
                            {
                                writer.Write(session.GetEnumProperty(prop.NameID).ToString());
                            }
                            else
                            {
                                writer.Write(string.Empty);
                            }
                            break;
                        case Interop.MTProductCatalog.PropValType.PROP_TYPE_INTEGER:
                            if (session.PropertyExists(prop.NameID, ISession.PropertyType.Int))
                            {
                                writer.Write(session.GetIntegerProperty(prop.NameID).ToString());
                            }
                            else
                            {
                                writer.Write(string.Empty);
                            }
                            break;
                        case Interop.MTProductCatalog.PropValType.PROP_TYPE_BIGINTEGER:
                            if (session.PropertyExists(prop.NameID, ISession.PropertyType.Long))
                            {
                                writer.Write(session.GetLongProperty(prop.NameID).ToString());
                            }
                            else
                            {
                                writer.Write(string.Empty);
                            }
                            break;
                        case Interop.MTProductCatalog.PropValType.PROP_TYPE_STRING:
                        case Interop.MTProductCatalog.PropValType.PROP_TYPE_UNICODE_STRING:
                        case Interop.MTProductCatalog.PropValType.PROP_TYPE_ASCII_STRING:
                            if (session.PropertyExists(prop.NameID, ISession.PropertyType.String))
                            {
                                writer.Write(session.GetStringProperty(prop.NameID));
                            }
                            else
                            {
                                writer.Write(string.Empty);
                            }
                            break;
                        default:
                            logger.LogWarning(string.Format("Ignoring unhandled data type {0} for property: {1}", prop.DataType, pName));
                            writer.Write(string.Empty);
                            break;
                    }
                }
            }
            // handle multipoint
            if (session.IsParent && session.SessionChildren != null)
            {
                using (var stream = new System.IO.MemoryStream())
                {
                    var count = 0;
                    using (var cw = new System.IO.BinaryWriter(stream))
                    {
                        foreach (ISession child in session.SessionChildren)
                        {
                            count++;
                            SerializeSession(cw, child);
                        }
                        cw.Flush();
                    }
                    writer.Write(count.ToString());
                    writer.Write(stream.ToArray());
                }
            }
            else
            {
                writer.Write("0");
            }
        }

        /// <summary>
        /// Debug the serializer
        /// </summary>
        /// <param name="buffer">the buffer</param>
        private void DebugSession(byte[] buffer, string indent)
        {
            using (var stream = new System.IO.MemoryStream(buffer))
            {
                using (var reader = new System.IO.BinaryReader(stream))
                {
                    var mvmFormatId = int.Parse(reader.ReadString());
                    // TODO: proper debugging
                    while (reader.BaseStream.CanRead)
                    {
                        logger.LogDebug(indent + "SERIALIZED: " + reader.ReadString());
                    }
                }
            }
        }
    }

    public class PropertyInfo
    {
        public string DBColumnName
        {
            get;
            set;
        }

        public Interop.MTProductCatalog.PropValType DataType
        {
            get;
            set;
        }

        public int NameID
        {
            get;
            set;
        }
    }
}
