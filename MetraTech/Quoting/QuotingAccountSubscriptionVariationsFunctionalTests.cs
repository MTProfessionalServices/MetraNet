using System;
using MetraTech.Domain.Quoting;
using MetraTech.Quoting.Test.Domain;
using MetraTech.TestCommon;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using MetraTech.Interop.MTProductCatalog;
using MetraTech.Shared.Test;

namespace MetraTech.Quoting.Test
{
    [TestClass]
    public class QuotingRecurringChargeVariationsFunctionalTests
    {
        #region Setup/Teardown

        [ClassInitialize]
        public static void InitTests(TestContext testContext)
        {
            SharedTestCode.MakeSureServiceIsStarted("ActivityServices");
            SharedTestCode.MakeSureServiceIsStarted("Pipeline");
        }

        #endregion

        [TestMethod, MTFunctionalTest(TestAreas.Quoting)]
        public void QuotingWithExistingSubscriptionToDifferentPO()
        {
            #region Prepare
            string testName = "QuotingWithExistingSubscriptionToDifferentPO";
            string testShortName = "Q_OtherPO"; //Account name and perhaps others need a 'short' (less than 40 when combined with testRunUniqueIdentifier
            //string testDescription = @"Given an account with existing subscription to a Product Offering and a quote request to a second Product Offering, When quote is run Then it includes only the usage for the second PO";
            string testRunUniqueIdentifier = MetraTime.Now.ToString(); //Identifier to make this run unique

            QuoteImplementationData quoteImpl = new QuoteImplementationData();
            QuoteVerifyData expected = new QuoteVerifyData();

            // Create account
            var corpAccountHolder = new CorporateAccountFactory(testShortName, testRunUniqueIdentifier);
            corpAccountHolder.Instantiate();

            Assert.IsNotNull(corpAccountHolder.Item._AccountID, "Unable to create account for test run");
            int idAccountToQuoteFor = (int)corpAccountHolder.Item._AccountID;

            // Create/Verify Product Offering Exists
            var pofConfiguration = new ProductOfferingFactoryConfiguration(testName, testRunUniqueIdentifier);
            pofConfiguration.CountPairRCs = 1;
            pofConfiguration.CountNRCs = 1;
            pofConfiguration.Currency = "USD";

            IMTProductOffering productOffering = ProductOfferingFactory.Create(pofConfiguration);
            Assert.IsNotNull(productOffering.ID, "Unable to create PO for test run");
            int idExisitingProductOffering = productOffering.ID;

            // Subscribe account to PO
            var effDate = new MTPCTimeSpanClass
            {
                StartDate = MetraTime.Now,
                StartDateType = MTPCDateType.PCDATE_TYPE_ABSOLUTE
            };
            object modifiedDate = MetraTime.Now;

            IMTProductCatalog productCatalog = new MTProductCatalogClass();
            IMTSessionContext sessionContext = (IMTSessionContext)SharedTestCode.LoginAsSU();

            productCatalog.SetSessionContext(sessionContext);

            var acc = productCatalog.GetAccount(idAccountToQuoteFor);

            var subscription = acc.Subscribe(idExisitingProductOffering, effDate, out modifiedDate);

            //Values to use for verification
            expected.CountAccounts = 1;
            expected.CountNRCs = pofConfiguration.CountNRCs * expected.CountAccounts;
            expected.CountFlatRCs = pofConfiguration.CountPairRCs + (pofConfiguration.CountPairRCs * expected.CountAccounts);



            expected.Total = pofConfiguration.CountPairRCs * pofConfiguration.RCAmount * 2 +
                                         pofConfiguration.CountNRCs * pofConfiguration.NRCAmount;

            #endregion

            #region Test and Verify

            try
            {
                // Create another PO
                pofConfiguration.UniqueIdentifier = MetraTime.Now.ToString();
                productOffering = ProductOfferingFactory.Create(pofConfiguration);

                Assert.IsNotNull(productOffering.ID, "Unable to create PO the second time for test run");
                int idProductOfferingToQuoteFor = productOffering.ID;

                //Prepare quote request
                quoteImpl.Request.Accounts.Add(idAccountToQuoteFor);
                quoteImpl.Request.ProductOfferings.Add(idProductOfferingToQuoteFor);
                quoteImpl.Request.QuoteIdentifier = "MyQuoteId-" + testShortName + "-1234";
                quoteImpl.Request.QuoteDescription = "Quote generated by Automated Test: " + testName;
                quoteImpl.Request.ReportParameters = new ReportParams() { PDFReport = QuotingTestScenarios.RunPDFGenerationForAllTestsByDefault };
                quoteImpl.Request.EffectiveDate = MetraTime.Now;
                quoteImpl.Request.EffectiveEndDate = MetraTime.Now;
                quoteImpl.Request.Localization = "en-US";

                quoteImpl.Response = QuotingTestScenarios.CreateQuoteAndVerifyResults(quoteImpl, expected);
                // Make sure account is still subscribed to initial PO
                Assert.IsNotNull(acc.GetSubscriptionByProductOffering(idExisitingProductOffering));
            }
            finally
            {
                // Remove created subscription
                acc.RemoveSubscription(subscription.ID);
            }

            #endregion
        }

        [TestMethod, MTFunctionalTest(TestAreas.Quoting)]
        public void QuotingWithExistingSubscriptionToConflictedPO()
        {
            #region Prepare
            string testName = "QuotingWithExistingSubscriptionToConflictedPO";
            string testShortName = "Q_OtherPOCon"; //Account name and perhaps others need a 'short' (less than 40 when combined with testRunUniqueIdentifier
            //string testDescription = @"";
            string testRunUniqueIdentifier = MetraTime.Now.ToString(); //Identifier to make this run unique

            QuoteImplementationData quoteImpl = new QuoteImplementationData();
            QuoteVerifyData expected = new QuoteVerifyData();

            // Create account
            CorporateAccountFactory corpAccountHolder = new CorporateAccountFactory(testShortName, testRunUniqueIdentifier);
            corpAccountHolder.Instantiate();

            Assert.IsNotNull(corpAccountHolder.Item._AccountID, "Unable to create account for test run");
            int idAccountToQuoteFor = (int)corpAccountHolder.Item._AccountID;

            // Create/Verify Product Offering Exists
            var pofConfiguration = new ProductOfferingFactoryConfiguration(testName, testRunUniqueIdentifier);

            pofConfiguration.CountNRCs = 2;
            pofConfiguration.CountPairRCs = 2;

            IMTProductOffering productOffering = ProductOfferingFactory.Create(pofConfiguration);
            Assert.IsNotNull(productOffering.ID, "Unable to create PO for test run");

            //Values to use for verification
            pofConfiguration.TotalAmount = pofConfiguration.CountPairRCs * pofConfiguration.RCAmount * 2 +
                                           pofConfiguration.CountNRCs * pofConfiguration.NRCAmount;
            pofConfiguration.Currency = "USD";

            int idExisitingProductOffering = productOffering.ID;

            // Subscribe account to PO
            var effDate = new MTPCTimeSpanClass
            {
                StartDate = MetraTime.Now,
                StartDateType = MTPCDateType.PCDATE_TYPE_ABSOLUTE
            };


            object modifiedDate = MetraTime.Now;

            IMTProductCatalog productCatalog = new MTProductCatalogClass();
            IMTSessionContext sessionContext = (IMTSessionContext)SharedTestCode.LoginAsSU();

            productCatalog.SetSessionContext(sessionContext);

            var acc = productCatalog.GetAccount(idAccountToQuoteFor);

            var subscription = acc.Subscribe(idExisitingProductOffering, effDate, out modifiedDate);

            //Values to use for verification
            expected.Total = 0M;
            expected.Currency = "";

            expected.CountNRCs = 0;
            expected.CountFlatRCs = 0;

            const string expectedErrorMessagePartialText = "already subscribed";

            #endregion

            #region Test and Verify

            //Prepare quote request
            quoteImpl.Request.Accounts.Add(idAccountToQuoteFor);
            quoteImpl.Request.ProductOfferings.Add(idExisitingProductOffering);
            quoteImpl.Request.QuoteIdentifier = "MyQuoteId-" + testShortName + "-1234";
            quoteImpl.Request.QuoteDescription = "Quote generated by Automated Test: " + testName;
            quoteImpl.Request.ReportParameters = new ReportParams() { PDFReport = QuotingTestScenarios.RunPDFGenerationForAllTestsByDefault };
            quoteImpl.Request.EffectiveDate = MetraTime.Now;
            quoteImpl.Request.EffectiveEndDate = MetraTime.Now;
            quoteImpl.Request.Localization = "en-US";

            try
            {
                quoteImpl.Response = SharedTestCodeQuoting.InvokeCreateQuote(quoteImpl.Request);
            }
            finally
            {
                // Remove created subscription
                acc.RemoveSubscription(subscription.ID);
            }

            Assert.IsTrue(quoteImpl.Response.Status == QuoteStatus.Failed, "Expected response quote status must be failed");
            Assert.IsTrue(!string.IsNullOrEmpty(quoteImpl.Response.FailedMessage), "Failed quote does not have FailedMessage set");

            //Verify the message we expect is there
            Assert.IsTrue(quoteImpl.Response.FailedMessage.Contains(expectedErrorMessagePartialText)
                , "Expected failure message with text '{0}' but got failure message '{1}'", expectedErrorMessagePartialText, quoteImpl.Response.FailedMessage);




            #endregion
        }

    }
}
