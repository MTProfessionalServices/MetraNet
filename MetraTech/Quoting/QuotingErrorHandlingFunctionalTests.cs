using System;
using System.Collections.Generic;
using MetraTech.Domain.Quoting;
using MetraTech.DomainModel.Enums.Core.Metratech_com_billingcycle;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using MetraTech.Interop.MTProductCatalog;
using MetraTech.Shared.Test;

namespace MetraTech.Quoting.Test
{
  [TestClass]
  public class QuotingErrorHandlingFunctionalTests
  {
    #region Setup/Teardown

    [ClassInitialize]
    public static void InitTests(TestContext testContext)
    {
      SharedTestCode.MakeSureServiceIsStarted("ActivityServices");
      SharedTestCode.MakeSureServiceIsStarted("Pipeline");
    }

    #endregion

    [TestMethod]
    public void ProductOfferingWithMissingRCRatesReturnsClearErrorMessage()
    {
      //FEAT-2540
      #region Prepare

      string testName = "ProductOfferingWithMissingRCRatesReturnsClearErrorMessage";
      string testShortName = "Q_NoRCRates"; //Account name and perhaps others need a 'short' (less than 40 when combined with testRunUniqueIdentifier
      //string testDescription = @"Given an account and a Product Offering with missing Recurring Charge rates, When quote is run Then it fails and returns a clear error message";
      string testRunUniqueIdentifier = MetraTime.Now.ToString(); //Identifier to make this run unique


      // Create account
      CorporateAccountFactory corpAccountHolder = new CorporateAccountFactory(testShortName, testRunUniqueIdentifier);
      corpAccountHolder.Instantiate();

      Assert.IsNotNull(corpAccountHolder.Item._AccountID, "Unable to create account for test run");
      int idAccountToQuoteFor = (int)corpAccountHolder.Item._AccountID;

      // Create/Verify Product Offering Exists
      IMTProductOffering productOffering = ProductOfferingFactory.CreateWithRCMissingRates(testShortName, testRunUniqueIdentifier);
      Assert.IsNotNull(productOffering.ID, "Unable to create PO for test run");
      int idProductOfferingToQuoteFor = productOffering.ID;

      //Values to use for verification... needed only to pass in but not used since we never complete the quote
      decimal expectedQuoteTotal = 0.00M;
      string expectedQuoteCurrency = "USD";

      int expectedQuoteNRCsCount = 1;
      int expectedQuoteFlatRCsCount = 2;


      string expectedErrorMessagePartialText = "pipeline";
      #endregion


      #region Test and Verify
      //Prepare request
      QuoteRequest request = new QuoteRequest();
      request.Accounts.Add(idAccountToQuoteFor);
      request.ProductOfferings.Add(idProductOfferingToQuoteFor);
      request.QuoteIdentifier = "MyQuoteId-" + testShortName + "-1234";
      request.QuoteDescription = "Quote generated by Automated Test: " + testName;
      request.ReportParameters = new ReportParams(){PDFReport = QuotingTestScenarios.RunPDFGenerationForAllTestsByDefault};
      request.EffectiveDate = MetraTime.Now;
      request.EffectiveEndDate = MetraTime.Now;
      request.Localization = "en-US";

      //Give request to testing scenario along with expected results for verification; get back response for further verification

      //Create and pass the implementation so we can further check the error result
      QuotingImplementation quotingImplementation = QuotingTestScenarios.GetDefaultQuotingImplementationForTestRun(new QuotingRepository());

      //We are expecting error/exception
      try
      {
        QuoteResponse response = QuotingTestScenarios.CreateQuoteAndVerifyResults(request,
                                                                          expectedQuoteTotal,
                                                                          expectedQuoteCurrency,
                                                                          expectedQuoteFlatRCsCount,
                                                                          expectedQuoteNRCsCount,
                                                                          quotingImplementation: quotingImplementation);

        Assert.Fail("An exception should have been thrown due to missing rate errors in pipeline");
      }
      catch (Exception ex)
      {
        //Assert.AreEqual("Parameter cannot be null or empty.", ex.Message);
        Assert.IsTrue(ex.Message.Contains(expectedErrorMessagePartialText), "Expected message about pipeline missing rates");
      }

      QuoteResponse erroredResponse = quotingImplementation.CurrentResponse;

      //Verify it is an errored response
      Assert.IsTrue(erroredResponse.Status == QuoteStatus.Failed);
      Assert.IsTrue(!string.IsNullOrEmpty(erroredResponse.FailedMessage), "Failed quote does not have FailedMessage set");

      //Verify the message we expect is there
      Assert.IsTrue(erroredResponse.FailedMessage.Contains(expectedErrorMessagePartialText));

      //TODO: Verify the log has information about this error
      //quotingImplementation.CurrentMessageLog.Count

      //Verify that the repository has recorded this failure an error message
      SharedTestCodeQuoting.VerifyQuoteResponseIsErrorInRepository(erroredResponse.idQuote, expectedErrorMessagePartialText, quotingImplementation.QuotingRepository);

      #endregion
    }

    [TestMethod]
    public void ProductOfferingWithMissingNRCRatesReturnsClearErrorMessage()
    {
      //TODO: FEAT-2541

      #region Prepare
      string testName = "ProductOfferingWithMissingNRCRatesReturnsClearErrorMessage";
      string testShortName = "Q_NoRCRates"; //Account name and perhaps others need a 'short' (less than 40 when combined with testRunUniqueIdentifier
      //string testDescription = @"Given an account and a Product Offering with missing Non-Recurring Charge rates, When quote is run Then it fails and returns a clear error message";
      string testRunUniqueIdentifier = MetraTime.Now.ToString(); //Identifier to make this run unique

      // Create account
      CorporateAccountFactory corpAccountHolder = new CorporateAccountFactory(testShortName, testRunUniqueIdentifier);
      corpAccountHolder.Instantiate();

      Assert.IsNotNull(corpAccountHolder.Item._AccountID, "Unable to create account for test run");
      int idAccountToQuoteFor = (int)corpAccountHolder.Item._AccountID;

      // Create/Verify Product Offering Exists

      IMTProductOffering productOffering = ProductOfferingFactory.CreateWithNRCMissingRates(testShortName, testRunUniqueIdentifier);
      Assert.IsNotNull(productOffering.ID, "Unable to create PO for test run");
      int idProductOfferingToQuoteFor = productOffering.ID;

      ////Values to use for verification
      decimal expectedQuoteTotal = 39.95M;
      string expectedQuoteCurrency = "USD";

      int expectedQuoteNRCsCount = 1;
      int expectedQuoteFlatRCsCount = 2;


      string expectedErrorMessagePartialText = "pipeline";
      #endregion


      #region Test and Verify
      //Prepare request
      QuoteRequest request = new QuoteRequest();
      request.Accounts.Add(idAccountToQuoteFor);
      request.ProductOfferings.Add(idProductOfferingToQuoteFor);
      request.QuoteIdentifier = "MyQuoteId-" + testShortName + "-1234";
      request.QuoteDescription = "Quote generated by Automated Test: " + testName;
      request.ReportParameters = new ReportParams(){PDFReport = QuotingTestScenarios.RunPDFGenerationForAllTestsByDefault};
      request.EffectiveDate = MetraTime.Now;
      request.EffectiveEndDate = MetraTime.Now;
      request.Localization = "en-US";

      //Give request to testing scenario along with expected results for verification; get back response for further verification

      //Create and pass the implementation so we can further check the error result
      QuotingImplementation quotingImplementation = QuotingTestScenarios.GetDefaultQuotingImplementationForTestRun(new QuotingRepository());

      //We are expecting error/exception
      try
      {
      QuoteResponse response = QuotingTestScenarios.CreateQuoteAndVerifyResults(request,
                                                                                expectedQuoteTotal,
                                                                                expectedQuoteCurrency,
                                                                                expectedQuoteFlatRCsCount,
                                                                                expectedQuoteNRCsCount,
                                                                                quotingImplementation: quotingImplementation);
        Assert.Fail("An exception should have been thrown");
      }
      catch (Exception ex)
      {
        //Assert.AreEqual("Parameter cannot be null or empty.", ex.Message);
        Assert.IsTrue(ex.Message.Contains(expectedErrorMessagePartialText), "Expected message about pipeline missing rates");
      }

      QuoteResponse erroredResponse = quotingImplementation.CurrentResponse;

      //Verify it is an errored response
      Assert.IsTrue(erroredResponse.Status == QuoteStatus.Failed);
      Assert.IsTrue(!string.IsNullOrEmpty(erroredResponse.FailedMessage), "Failed quote does not have FailedMessage set");

      //Verify the message we expect is there
      Assert.IsTrue(erroredResponse.FailedMessage.Contains(expectedErrorMessagePartialText));

      //Verify that the repository has recorded this failure an error message
      SharedTestCodeQuoting.VerifyQuoteResponseIsErrorInRepository(erroredResponse.idQuote, expectedErrorMessagePartialText, quotingImplementation.QuotingRepository);

      #endregion
    }

    [TestMethod]
    public void QuotingWithBadInputParameters()
    {
      #region Bad Account Id

      string testRunUniqueIdentifier = MetraTime.Now.ToString(); //Identifier to make this run unique
      const string TEST_NAME = "QuotingWithBadInputParameters";
      const string TEST_SHORT_NAME = "Q_Err_Basic";

      var pofConfiguration = new ProductOfferingFactoryConfiguration(TEST_NAME, testRunUniqueIdentifier);

      pofConfiguration.CountNRCs = 1;
      pofConfiguration.CountPairRCs = 1;

      IMTProductOffering productOffering = ProductOfferingFactory.Create(pofConfiguration);
      Assert.IsNotNull(productOffering.ID, "Unable to create PO for test run");

      int idPoToQuoteFor = productOffering.ID;

      var accountIdsToQuoteFor = new List<int> { 666666 };
      var poIdsToQuoteFor = new List<int> { idPoToQuoteFor };

      string expectedErrorMessagePartial = "Invalid attempt to read when no data is present.";

      QuotingTestScenarios.RunTestCheckingBadInputs(accountIdsToQuoteFor, poIdsToQuoteFor, expectedErrorMessagePartial);

      #endregion

      #region Bad PO Id

      testRunUniqueIdentifier = MetraTime.Now.ToString(); //Identifier to make this run unique

      CorporateAccountFactory corpAccountHolder = new CorporateAccountFactory(TEST_SHORT_NAME, testRunUniqueIdentifier);
      corpAccountHolder.Instantiate();

      Assert.IsNotNull(corpAccountHolder.Item._AccountID, "Unable to create account for test run");
      int idAccountToQuoteFor = (int)corpAccountHolder.Item._AccountID;

      accountIdsToQuoteFor = new List<int> { idAccountToQuoteFor };
      poIdsToQuoteFor = new List<int> { 666666 };

      expectedErrorMessagePartial = "not effective in the specified time interval";

      QuotingTestScenarios.RunTestCheckingBadInputs(accountIdsToQuoteFor, poIdsToQuoteFor, expectedErrorMessagePartial);

      #endregion

      #region Accounts In Different Billing Cycle

      testRunUniqueIdentifier = MetraTime.Now.ToString(); //Identifier to make this run unique

      corpAccountHolder = new CorporateAccountFactory(TEST_SHORT_NAME, testRunUniqueIdentifier);
      corpAccountHolder.CycleType = UsageCycleType.Annually;
      corpAccountHolder.Instantiate();
      Assert.IsNotNull(corpAccountHolder.Item._AccountID, "Unable to create account for test run");
      int idAccountDifferentCycleToQuoteFor = (int)corpAccountHolder.Item._AccountID;

      expectedErrorMessagePartial = "All accounts must be in the same billing cycle";

      accountIdsToQuoteFor = new List<int> { idAccountToQuoteFor, idAccountDifferentCycleToQuoteFor };
      poIdsToQuoteFor = new List<int> { idPoToQuoteFor };

      QuotingTestScenarios.RunTestCheckingBadInputs(accountIdsToQuoteFor, poIdsToQuoteFor, expectedErrorMessagePartial);

      #endregion

      #region Empty List Of Accounts

      expectedErrorMessagePartial = "At least one account must be specified for the quote";

      accountIdsToQuoteFor = new List<int>();
      poIdsToQuoteFor = new List<int>();

      QuotingTestScenarios.RunTestCheckingBadInputs(accountIdsToQuoteFor, poIdsToQuoteFor, expectedErrorMessagePartial);

      #endregion

      #region Empty List Of Accounts

      expectedErrorMessagePartial = "At least one product offering must be specified for the quote";

      accountIdsToQuoteFor = new List<int>() { idAccountToQuoteFor };
      poIdsToQuoteFor = new List<int>();

      QuotingTestScenarios.RunTestCheckingBadInputs(accountIdsToQuoteFor, poIdsToQuoteFor, expectedErrorMessagePartial);

      #endregion
    }
  }
}
