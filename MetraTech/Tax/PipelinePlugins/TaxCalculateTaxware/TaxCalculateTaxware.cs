#region Generated using ICE (Do not modify this region)
/// Generated using ICE
/// ICE CodeGen Version: 1.0.0
/// Transactional = false
#endregion
using System;
using System.Collections.Generic;
using MetraTech.Pipeline;
using MetraTech.Tax.Framework.DataAccess;
using MetraTech.Tax.Framework.Taxware;
using MetraTech.DataAccess;
using MetraTech.DomainModel.Enums.Tax.Metratech_com_tax;
#region AutoGenerated Enum Includes (Do not modify this region)
//ENUM_USING
#endregion

namespace MetraTech.Tax.Plugins
{
    public sealed partial class TaxCalculateTaxware : PlugInBase
    {
		#region ProcessAllSessions (Only modify this in the rare case you need to handle more than one session at once)
        /// <summary>
        /// This method is called each time the plug-in recieves a session set
        /// </summary>
        protected override void ProcessAllSessions(PropertiesCollection propsCol)
        {
            bool partiallyFailed = false;
            foreach (Properties props in propsCol)
            {
                //set the current session for logging purposes
                SetCurrentSession(props.Session);

                try
                {
                    //process each session
                    ProcessSession(props);
                }
                catch (Exception ex)
                {
                    partiallyFailed = true;
                    Log(LogLevel.Warning,
                        string.Format("Error when processing session: {0}", ex.Message));
                    Log(LogLevel.Warning, "Exception: " + ex.Message + " StackTrace: " +
                        ex.StackTrace);
                    //mark the session as failed
                    props.Session.MarkAsFailed(
                        string.Format("Error when processing session. Source: {0}, Message: {1}",
                        ex.Source, ex.Message), MARK_AS_FAILED_CODE_FAILED);
                }
                finally
                {
                    Log(LogLevel.Debug, "Session object disposed successfully");
                    props.Session.Dispose();
                }
            }

            //if any of the sessions failed, go ahead and throw an exception here
            if (partiallyFailed)
                throw new MetraTech.Pipeline.PlugIns.PartialFailureException();
        }
		#endregion
    
        #region Startup override
        protected override void StartUp(MetraTech.Interop.SysContext.IMTSystemContext systemContext, MetraTech.Interop.MTPipelineLib.IMTConfigPropSet propSet)
        {
            Log(LogLevel.Debug, "Starting Startup TaxCalculateTaxware");
            //TODO: add any code you would like to run at Configure time (when the plug-in is first loaded)

            // Set up the Taxware manager that will be used to calculate tax.
            m_taxManager = new TaxwareSyncTaxManagerDBBatch();
        }
        #endregion

        #region Shutdown override
        public override void Shutdown()
        {
            //TODO: add any code you would like to run when the plug-in shuts down
        }
        #endregion

        /// <summary>
        /// This method is called for each session in the session set.
        /// </summary>
        protected override void ProcessSession(Properties props)
        {
            #region Instructions
            /* -Pipeline Inputs and Outputs
             *  Pipeline inputs and outputs are accessed via the props variable.
             *  Value types (int, long, bool, enums, etc..) are marked as nullable.
             *  When you look at the type you'll see, for example, int? instead of int.
             *  Nullable value types are used because the Pipeline value could possibly be null.
             *  You can check to see if the value is null by checking the .HasValue property. 
             *  There are two ways you can get the actual value of the variable. First by using 
             *  the .Value property.
             *  Example:
             *      int a = props.Pipeline.Foo.Value; //The type of Foo is int? (a.k.a. Nullable<int>) but the type of Foo.Value is int.
             *  And second by doing a cast:
             *  Example:
             *      int a = (int)props.Pipeline.Foo; //The type of Foo is int? (a.k.a. Nullable<int>)
             *  Reference types (string, classes you write) are already nullable so there's no 
             *  need to treat them special.
             *  Example:
             *      string foo = props.Pipeline.Foo; //The type of Foo is string.
             *
             * -General Configuration Variables
             *  Accessed via the GeneralConfig property of TaxCalculateTaxware.
             *  Example: 
             *      string filePath = GeneralConfig.FilePath;
             * 
             * -Errors
             *  If there is a critical error and you would like to make the the current session as failed,
             *  throw an exception of type ApplicationException with a custom message. 
             *  The message will be logged. The ProcessAllSessions method will catch the 
             *  exception and mark the current session as failed and move on to the next session to process.
             *  Example: 
             *      throw new ApplicationException("The value Foo was outside the expected range");
             * 
             * -Logging
             *  You can log messages via the Log function.
             *  Example: Log(LogLevel.Debug, "Test message");
             */
            #endregion
            Log(LogLevel.Debug, "Starting ProcessSession TaxCalculateTaxware");

            // Set the tax manager parameters for this tax calculation.
            // A tax run ID of 0 is associated with a pipeline run.
            m_taxManager.TaxRunId = 0;

            // Generate a unique tax charge ID for this transaction.
            // This ID is unique with respect to tax run ID -1 (pipeline runs).
            long id_tax_charge = m_taxManager.GenerateUniqueTaxChargeIdForPipeline();
            Log(LogLevel.Debug, "The id tax charge associated with this is " + id_tax_charge);

            // Do we need to store the tax details?
            m_taxManager.TaxDetailsNeeded = true;
            if (GeneralConfig.ShouldTaxDetailsBeStored.HasValue)
            {
                m_taxManager.TaxDetailsNeeded = GeneralConfig.ShouldTaxDetailsBeStored.Value;
                Log(LogLevel.Debug, "Config setting for details = " + m_taxManager.TaxDetailsNeeded);
            }
            else
            {
                Log(LogLevel.Debug, "TaxDetailsNeeded not set in config.");
            }

            // Construct an input tax row.
            TaxableTransaction taxableTransaction = new TaxableTransaction(TaxVendor.Taxware);
            TaxParameter taxParameter;
            
            // Parameters coming from required pipeline session variables.
            taxParameter = new TaxParameter("id_acc", "Account", Type.GetType("System.Int32"), props.Pipeline.AccountID);
            taxableTransaction.StoreTaxParameter(taxParameter);
            taxParameter = new TaxParameter("id_tax_charge", "ID Tax Charge", Type.GetType("System.Int64"), id_tax_charge);
            taxableTransaction.StoreTaxParameter(taxParameter);
            taxParameter = new TaxParameter("id_usage_interval", "Usage Interval", Type.GetType("System.Int64"), props.Pipeline.IntervalID);
            taxableTransaction.StoreTaxParameter(taxParameter);
            taxParameter = new TaxParameter("amount", "Account", Type.GetType("System.Decimal"), props.Pipeline.Amount);
            taxableTransaction.StoreTaxParameter(taxParameter);
            taxParameter = new TaxParameter("invoice_date", "Invoice Date", Type.GetType("System.DateTime"), props.Pipeline.InvoiceDate);
            taxableTransaction.StoreTaxParameter(taxParameter);

            // Parameters coming from optional pipeline session variables or plug-in configuration values.

            // Parameter: IsImpliedTax
            bool? isImpliedTax;
            if (props.Pipeline.IsImpliedTax.HasValue)
            {
                isImpliedTax = props.Pipeline.IsImpliedTax;
            }
            else
            {
                isImpliedTax = GeneralConfig.DefaultIsImpliedTax;
            }
            taxParameter = new TaxParameter("is_implied_tax", "IsImpliedTax", Type.GetType("System.String"), 
                                            (isImpliedTax.HasValue && isImpliedTax.Value)?"true":"false");
            taxableTransaction.StoreTaxParameter(taxParameter);

            // Parameter: ProductCode
            if (props.Pipeline.ProductCode != null)
            {
                Log(LogLevel.Debug, "Getting product code from session.");
                taxParameter = new TaxParameter("product_code", "Product Code", Type.GetType("System.String"), props.Pipeline.ProductCode);
            }
            else
            {
                Log(LogLevel.Debug, "Getting product code from config.");
                taxParameter = new TaxParameter("product_code", "Product Code", Type.GetType("System.String"), GeneralConfig.DefaultProductCode);
            }
            taxableTransaction.StoreTaxParameter(taxParameter);

            // Parameter: RoundingDigits
            if (props.Pipeline.RoundingDigits.HasValue)
                taxParameter = new TaxParameter("round_digits", "Rounding Digits", Type.GetType("System.Int32"), props.Pipeline.RoundingDigits);
            else
                taxParameter = new TaxParameter("round_digits", "Rounding Digits", Type.GetType("System.Int32"),GeneralConfig.DefaultRoundingDigits);
            taxableTransaction.StoreTaxParameter(taxParameter);

            // Parameter: RoundingAlgorithm
            if (props.Pipeline.RoundingAlgorithm != null)
                taxParameter = new TaxParameter("round_alg", "Rounding Algorithm", Type.GetType("System.String"), props.Pipeline.RoundingAlgorithm);
            else
                taxParameter = new TaxParameter("round_alg", "Rounding Algorithm", Type.GetType("System.String"), GeneralConfig.DefaultRoundingAlgorithm);
            taxableTransaction.StoreTaxParameter(taxParameter);

            // Parameter: CustomerName
            if (props.Pipeline.CustomerName != null)
                taxParameter = new TaxParameter("customer_name", "Customer Name", Type.GetType("System.String"), props.Pipeline.CustomerName);
            else
                taxParameter = new TaxParameter("customer_name", "Customer Name", Type.GetType("System.String"), GeneralConfig.DefaultCustomerName);
            taxableTransaction.StoreTaxParameter(taxParameter);

            // Parameter: BillToGeoCode
            if (props.Pipeline.BillToGeoCode.HasValue)
                taxParameter = new TaxParameter("bill_to_geo_code", "BillToGeoCode", Type.GetType("System.Int32"), props.Pipeline.BillToGeoCode);
            else
                taxParameter = new TaxParameter("bill_to_geo_code", "BillToGeoCode", Type.GetType("System.Int32"), GeneralConfig.DefaultBillToGeoCode);
            taxableTransaction.StoreTaxParameter(taxParameter);

            // Parameter: LoaGeoCode
            if (props.Pipeline.LoaGeoCode.HasValue)
                taxParameter = new TaxParameter("loa_geo_code", "LoaGeoCode", Type.GetType("System.Int32"), props.Pipeline.LoaGeoCode);
            else
                taxParameter = new TaxParameter("loa_geo_code", "LoaGeoCode", Type.GetType("System.Int32"), GeneralConfig.DefaultLoaGeoCode);
            taxableTransaction.StoreTaxParameter(taxParameter);

            // Parameter: LorGeoCode
            if (props.Pipeline.LorGeoCode.HasValue)
                taxParameter = new TaxParameter("lor_geo_code", "LorGeoCode", Type.GetType("System.Int32"), props.Pipeline.LorGeoCode);
            else
                taxParameter = new TaxParameter("lor_geo_code", "LorGeoCode", Type.GetType("System.Int32"), GeneralConfig.DefaultLorGeoCode);
            taxableTransaction.StoreTaxParameter(taxParameter);

            // Parameter: LspGeoCode
            if (props.Pipeline.LspGeoCode.HasValue)
                taxParameter = new TaxParameter("lsp_geo_code", "LspGeoCode", Type.GetType("System.Int32"), props.Pipeline.LspGeoCode);
            else
                taxParameter = new TaxParameter("lsp_geo_code", "LspGeoCode", Type.GetType("System.Int32"), GeneralConfig.DefaultLspGeoCode);
            taxableTransaction.StoreTaxParameter(taxParameter);

            // Parameter: ShipFromGeoCode
            if (props.Pipeline.ShipFromGeoCode.HasValue)
                taxParameter = new TaxParameter("ship_from_geo_code", "ShipFromGeoCode", Type.GetType("System.Int32"), props.Pipeline.ShipFromGeoCode);
            else
                taxParameter = new TaxParameter("ship_from_geo_code", "ShipFromGeoCode", Type.GetType("System.Int32"), GeneralConfig.DefaultShipFromGeoCode);
            taxableTransaction.StoreTaxParameter(taxParameter);

            // Parameter: ShipToGeoCode
            if (props.Pipeline.ShipToGeoCode.HasValue)
                taxParameter = new TaxParameter("ship_to_geo_code", "ShipToGeoCode", Type.GetType("System.Int32"), props.Pipeline.ShipToGeoCode);
            else
                taxParameter = new TaxParameter("ship_to_geo_code", "ShipToGeoCode", Type.GetType("System.Int32"), GeneralConfig.DefaultShipToGeoCode);
            taxableTransaction.StoreTaxParameter(taxParameter);

            // Parameter: Currency
            if (props.Pipeline.Currency != null)
                taxParameter = new TaxParameter("currency", "Currency", Type.GetType("System.String"), props.Pipeline.Currency);
            else
                taxParameter = new TaxParameter("currency", "Currency", Type.GetType("System.String"), GeneralConfig.DefaultCurrency);
            taxableTransaction.StoreTaxParameter(taxParameter);

            // Calculate the taxes
            List<TransactionIndividualTax> taxDetails;
            TransactionTaxSummary taxSummary;
            m_taxManager.CalculateTaxes(taxableTransaction, out taxSummary, out taxDetails);
            
            // Store the taxes
            props.Pipeline.FederalTaxAmount = taxSummary.TaxFedAmount;
            props.Pipeline.FederalTaxAmountRounded = taxSummary.TaxFedRounded;
            props.Pipeline.FederalTaxName = taxSummary.TaxFedName;
            props.Pipeline.StateTaxAmount = taxSummary.TaxStateAmount;
            props.Pipeline.StateTaxAmountRounded = taxSummary.TaxStateRounded;
            props.Pipeline.StateTaxName = taxSummary.TaxStateName;
            props.Pipeline.CountyTaxAmount = taxSummary.TaxCountyAmount;
            props.Pipeline.CountyTaxAmountRounded = taxSummary.TaxCountyRounded;
            props.Pipeline.CountyTaxName = taxSummary.TaxCountyName;
            props.Pipeline.LocalTaxAmount = taxSummary.TaxLocalAmount;
            props.Pipeline.LocalTaxAmountRounded = taxSummary.TaxLocalRounded;
            props.Pipeline.LocalTaxName = taxSummary.TaxLocalName;
            props.Pipeline.OtherTaxAmount = taxSummary.TaxOtherAmount;
            props.Pipeline.OtherTaxAmountRounded = taxSummary.TaxOtherRounded;
            props.Pipeline.OtherTaxName = taxSummary.TaxOtherName;
        }

         
        // Holds the Taxware manager that is used to calculate tax. This manager holds
        // cache of information for efficiency (example: a cache of Taxware rate schedules).
        private TaxwareSyncTaxManagerDBBatch m_taxManager;
	} 
} 
