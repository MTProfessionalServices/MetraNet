#region

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Configuration;
using System.Diagnostics;
using System.Xml;
using MetraTech.Interop.SysContext;
using MetraTech.Pipeline;

#endregion

namespace MetraTech.Tax.Plugins.AutoGenerated
{

  #region Properties class

  public class Properties
  {
    #region Variables

    private readonly PipelineProperties _pipeline;
    private readonly ISession _session;

    #endregion

    #region Construction

    private Properties(PipelineProperties pipeline, ISession session = null)
    {
      _pipeline = pipeline;
      _session = session;
    }

    internal static Properties CreatePrototype(PlugInBase.LogDelegate log, IMTSystemContext systemContext,
                                               XmlDocument xmlConfig)
    {
      var pipelinePrototype = PipelineProperties.CreatePrototype(log, systemContext, xmlConfig);

      return new Properties(pipelinePrototype);
    }

    internal static Properties Create(Properties prototype, ISession session)
    {
      var pipeline = PipelineProperties.Create(prototype._pipeline, session);

      return new Properties(pipeline, session);
    }

    #endregion

    #region Properties

    internal ISession Session
    {
      get { return _session; }
    }

    internal PipelineProperties Pipeline
    {
      get { return _pipeline; }
    }

    #endregion
  }

  #endregion

  #region GeneralConfig class

  public sealed class GeneralConfig
  {
    #region General config variables

    private readonly bool? _defaultIsImpliedTax;
    private readonly string _defaultProductCode;
    private readonly string _defaultRoundingAlgorithm;
    private readonly int? _defaultRoundingDigits;
    private readonly bool? _shouldTaxDetailsBeStored;
    //GENERAL_CONFIG_VAR

    #endregion

    #region Construction

    private const string GeneralConfigTag = "GeneralConfig";
    private readonly string _xPathToGeneralConfig = String.Format("{0}", GeneralConfigTag);

    internal GeneralConfig(XmlDocument xmlConfig)
    {
      if (xmlConfig.DocumentElement != null)
      {
        var generalConfigProps = xmlConfig.DocumentElement.SelectSingleNode(_xPathToGeneralConfig);

        if (generalConfigProps == null)
        {
          throw new ConfigurationErrorsException(
            String.Format(
              "The '{0}' was not found in t xpath = {1}. Can not configure Plug-in. Configuration content = '{2}'"
              , GeneralConfigTag, _xPathToGeneralConfig, xmlConfig.OuterXml));
        }

        _shouldTaxDetailsBeStored = bool.Parse(GetValueFromParameter(generalConfigProps, "ShouldTaxDetailsBeStored"));
        _defaultIsImpliedTax = bool.Parse(GetValueFromParameter(generalConfigProps, "DefaultIsImpliedTax"));
        _defaultProductCode = GetValueFromParameter(generalConfigProps, "DefaultProductCode");
        _defaultRoundingAlgorithm = GetValueFromParameter(generalConfigProps, "DefaultRoundingAlgorithm");
        _defaultRoundingDigits = int.Parse(GetValueFromParameter(generalConfigProps, "DefaultRoundingDigits"));
      }
      else
        throw new ConfigurationErrorsException("The DocumentElement was not found. Can not configure Plug-in.");
      //GENERAL_CONFIG_ASSIGN
    }

    private static string GetValueFromParameter(XmlNode node, string paramName)
    {
      var childNode = node.SelectSingleNode(paramName);
      if (childNode == null)
      {
        throw new ConfigurationErrorsException(
          String.Format("The '{0}' parametr name does not set into '{1}'. Section content = '{2}'"
                        , paramName, GeneralConfigTag, node.OuterXml));
      }
      return childNode.InnerText;
    }

    #endregion

    #region General Config Properties

    /// <summary>
    ///     For each transaction tax, MetraNet can stored detalied information (in the t_tax_details table).  This value determines if these details are saved or not.
    /// </summary>
    internal bool? ShouldTaxDetailsBeStored
    {
      get { return _shouldTaxDetailsBeStored; }
    }

    /// <summary>
    ///     If true, the amount already includes the tax.
    /// </summary>
    internal bool? DefaultIsImpliedTax
    {
      get { return _defaultIsImpliedTax; }
    }

    /// <summary>
    ///     A code identifying the product.  This same code should be used in the VertexQ parameter table define the tax rate for the product.
    /// </summary>
    internal string DefaultProductCode
    {
      get { return _defaultProductCode; }
    }

    /// <summary>
    ///     The rounding algorithm to use. Acceptable values are: NONE or BANK.  NONE means no rounding will be performed. BANK means banker's rounding will be performed.
    /// </summary>
    internal string DefaultRoundingAlgorithm
    {
      get { return _defaultRoundingAlgorithm; }
    }

    /// <summary>
    ///     The number of rounding digits. 0 - no rounding, 1 round to 1 digit after decimal point, 2 for 2 digits, etc.
    /// </summary>
    internal int? DefaultRoundingDigits
    {
      get { return _defaultRoundingDigits; }
    }

    //GENERAL_CONFIG_PROP

    #endregion
  }

  #endregion

  #region Properties Collection class

  public sealed class PropertiesCollection : IEnumerable<Properties>
  {
    private readonly Properties _prototype;
    private readonly ReadOnlyCollection<ISession> _sessions;

    public PropertiesCollection(Properties prototype, ReadOnlyCollection<ISession> sessions)
    {
      _sessions = sessions;
      _prototype = prototype;
    }

    public Properties this[int index]
    {
      get { return Properties.Create(_prototype, _sessions[index]); }
    }

    public int Count
    {
      get { return _sessions.Count; }
    }

    public bool IsReadOnly
    {
      get { return true; }
    }

    public IEnumerator<Properties> GetEnumerator()
    {
      return new PropertiesEnumerator(this);
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
      return new PropertiesEnumerator(this);
    }

    public int IndexOf(Properties item)
    {
      return _sessions.IndexOf(item.Session);
    }

    public bool Contains(Properties item)
    {
      return _sessions.Contains(item.Session);
    }

    public void CopyTo(Properties[] array, int arrayIndex)
    {
      for (int i = 0, j = arrayIndex;
           j < array.Length && i < _sessions.Count;
           ++i, ++j)
      {
        array[j] = Properties.Create(_prototype, _sessions[i]);
      }
    }

    public struct PropertiesEnumerator : IEnumerator<Properties>
    {
      private const int Start = -1;
      private int _index;
      private PropertiesCollection _propsCol;

      public PropertiesEnumerator(PropertiesCollection propsCol)
      {
        _propsCol = propsCol;
        _index = Start;
      }

      public Properties Current
      {
        get { return _propsCol[_index]; }
      }

      public void Dispose()
      {
        _propsCol = null;
        _index = Start;
      }

      object IEnumerator.Current
      {
        get { return Current; }
      }

      public bool MoveNext()
      {
        if ((_index + 1) <= (_propsCol.Count - 1))
        {
          ++_index;
          return true;
        }
        return false;
      }

      public void Reset()
      {
        _index = Start;
      }
    }
  }

  #endregion

  #region PipelineProperties Class

  public sealed class PipelineProperties
  {
    #region Non-Pipeline variables

    private readonly IEnumConfig _enumConfig;
    private readonly PlugInBase.LogDelegate _log;
    private readonly ISession _session;

    #endregion

    #region Pipeline variables

    private readonly Binding<int> _accountId;
    private readonly Binding<decimal> _amount;
    private readonly Binding<int> _billedLines;
    private readonly Binding<string> _bundleCategoryCode;
    private readonly Binding<string> _bundleFlag;
    private readonly Binding<string> _bundleServiceCode;
    private readonly Binding<decimal> _callMinutes;
    private readonly Binding<string> _categoryCode;
    private readonly Binding<string> _chargeToIncorporatedCode;
    private readonly Binding<string> _chargeToLocation;
    private readonly Binding<string> _chargeToLocationMode;
    private readonly Binding<string> _cityExemptFlag;
    private readonly Binding<string> _countyExemptFlag;
    private readonly Binding<decimal> _countyTaxAmount;
    private readonly Binding<decimal> _countyTaxAmountRounded;
    private readonly Binding<string> _countyTaxName;
    private readonly Binding<string> _creditCode;
    private readonly Binding<string> _customerCode;
    private readonly Binding<string> _customerReference;
    private readonly Binding<string> _federalExemptFlag;
    private readonly Binding<decimal> _federalTaxAmount;
    private readonly Binding<decimal> _federalTaxAmountRounded;
    private readonly Binding<string> _federalTaxName;
    private readonly Binding<int> _intervalId;
    private readonly Binding<DateTime> _invoiceDate;
    private readonly Binding<string> _invoiceNumber;
    private readonly Binding<bool> _isImpliedTax;
    private readonly Binding<decimal> _localTaxAmount;
    private readonly Binding<decimal> _localTaxAmountRounded;
    private readonly Binding<string> _localTaxName;
    private readonly Binding<string> _originIncorporatedCode;
    private readonly Binding<string> _originLocation;
    private readonly Binding<string> _originLocationMode;
    private readonly Binding<decimal> _otherTaxAmount;
    private readonly Binding<decimal> _otherTaxAmountRounded;
    private readonly Binding<string> _otherTaxName;
    private readonly Binding<string> _productCode;
    private readonly Binding<string> _roundingAlgorithm;
    private readonly Binding<int> _roundingDigits;
    private readonly Binding<string> _saleResaleCode;
    private readonly Binding<string> _serviceCode;
    private readonly Binding<string> _stateExemptFlag;
    private readonly Binding<decimal> _stateTaxAmount;
    private readonly Binding<decimal> _stateTaxAmountRounded;
    private readonly Binding<string> _stateTaxName;
    private readonly Binding<long> _taxChargeId;
    private readonly Binding<string> _taxedGeoCodeIncorporatedCode;
    private readonly Binding<string> _taxedGeoCodeOverrideCode;
    private readonly Binding<string> _terminationIncorporatedCode;
    private readonly Binding<string> _terminationLocation;
    private readonly Binding<string> _terminationLocationMode;
    private readonly Binding<string> _transactionCode;
    private readonly Binding<int> _trunkLines;
    private readonly Binding<string> _userArea;
    private readonly Binding<string> _utilityCode;
    private readonly Binding<string> _writeBundleDetailFlag;
    //BINDING_ID_VAR

    #endregion

    #region Construction

    private const string PipelineBinding = "PipelineBinding";
    private readonly string _xPathToPipelineBinding = String.Format("{0}", PipelineBinding);

    private PipelineProperties(PlugInBase.LogDelegate log, IMTSystemContext systemContext, XmlDocument xmlConfig)
    {
      var documentElement = xmlConfig.DocumentElement;
      if (documentElement == null)
        throw new ConfigurationErrorsException("The DocumentElement was not found. Can not configure Plug-in.");

      _log = log;

      //Init the enum config
      _enumConfig = systemContext.GetEnumConfig();

      //get the nameID
      var nameId = systemContext.GetNameID();

      var pipelineProps = documentElement.SelectSingleNode(_xPathToPipelineBinding);

      if (pipelineProps == null)
      {
        throw new ConfigurationErrorsException(
          String.Format(
            "The '{0}' was not found in t xpath = {1}. Can not configure Plug-in. Configuration content = '{2}'"
            , PipelineBinding, _xPathToPipelineBinding, xmlConfig.OuterXml));
      }

      // Required input parameters
      _accountId = new Binding<int>(nameId.GetNameID(GetValueFromParameter(pipelineProps, "AccountID")));
      _amount = new Binding<decimal>(nameId.GetNameID(GetValueFromParameter(pipelineProps, "Amount")));
      _invoiceDate = new Binding<DateTime>(nameId.GetNameID(GetValueFromParameter(pipelineProps, "InvoiceDate")));
      _intervalId = new Binding<int>(nameId.GetNameID(GetValueFromParameter(pipelineProps, "IntervalID")));
      _originLocation = new Binding<string>(nameId.GetNameID(GetValueFromParameter(pipelineProps, "OriginLocation")));
      _terminationLocation =
        new Binding<string>(nameId.GetNameID(GetValueFromParameter(pipelineProps, "TerminationLocation")));
      _serviceCode = new Binding<string>(nameId.GetNameID(GetValueFromParameter(pipelineProps, "ServiceCode")));
      _categoryCode = new Binding<string>(nameId.GetNameID(GetValueFromParameter(pipelineProps, "CategoryCode")));

      // Optional input parameters
      _originLocationMode = GetOptionalBinding<string>(nameId, pipelineProps, "OriginLocationMode");
      _terminationLocationMode = GetOptionalBinding<string>(nameId, pipelineProps, "TerminationLocationMode");
      _chargeToLocationMode = GetOptionalBinding<string>(nameId, pipelineProps, "ChargeToLocationMode");
      _chargeToLocation = GetOptionalBinding<string>(nameId, pipelineProps, "ChargeToLocation");
      _originIncorporatedCode = GetOptionalBinding<string>(nameId, pipelineProps, "OriginIncorporatedCode");
      _terminationIncorporatedCode = GetOptionalBinding<string>(nameId, pipelineProps, "TerminationIncorporatedCode");
      _chargeToIncorporatedCode = GetOptionalBinding<string>(nameId, pipelineProps, "ChargeToIncorporatedCode");
      _invoiceNumber = GetOptionalBinding<string>(nameId, pipelineProps, "InvoiceNumber");
      _customerCode = GetOptionalBinding<string>(nameId, pipelineProps, "CustomerCode");
      _customerReference = GetOptionalBinding<string>(nameId, pipelineProps, "CustomerReference");
      _billedLines = GetOptionalBinding<int>(nameId, pipelineProps, "BilledLines");
      _trunkLines = GetOptionalBinding<int>(nameId, pipelineProps, "TrunkLines");
      _utilityCode = GetOptionalBinding<string>(nameId, pipelineProps, "UtilityCode");
      _saleResaleCode = GetOptionalBinding<string>(nameId, pipelineProps, "SaleResaleCode");
      _writeBundleDetailFlag = GetOptionalBinding<string>(nameId, pipelineProps, "WriteBundleDetailFlag");
      _transactionCode = GetOptionalBinding<string>(nameId, pipelineProps, "TransactionCode");
      _taxedGeoCodeIncorporatedCode = GetOptionalBinding<string>(nameId, pipelineProps, "TaxedGeoCodeIncorporatedCode");
      _taxedGeoCodeOverrideCode = GetOptionalBinding<string>(nameId, pipelineProps, "TaxedGeoCodeOverrideCode");
      _callMinutes = GetOptionalBinding<decimal>(nameId, pipelineProps, "CallMinutes");
      _federalExemptFlag = GetOptionalBinding<string>(nameId, pipelineProps, "FederalExemptFlag");
      _stateExemptFlag = GetOptionalBinding<string>(nameId, pipelineProps, "StateExemptFlag");
      _countyExemptFlag = GetOptionalBinding<string>(nameId, pipelineProps, "CountyExemptFlag");
      _cityExemptFlag = GetOptionalBinding<string>(nameId, pipelineProps, "CityExemptFlag");
      _creditCode = GetOptionalBinding<string>(nameId, pipelineProps, "CreditCode");
      _userArea = GetOptionalBinding<string>(nameId, pipelineProps, "UserArea");
      _bundleFlag = GetOptionalBinding<string>(nameId, pipelineProps, "BundleFlag");
      _bundleServiceCode = GetOptionalBinding<string>(nameId, pipelineProps, "BundleServiceCode");
      _bundleCategoryCode = GetOptionalBinding<string>(nameId, pipelineProps, "BundleCategoryCode");
      _productCode = GetOptionalBinding<string>(nameId, pipelineProps, "ProductCode");
      _isImpliedTax = GetOptionalBinding<bool>(nameId, pipelineProps, "IsImpliedTax");
      _roundingAlgorithm = GetOptionalBinding<string>(nameId, pipelineProps, "RoundingAlgorithm");
      _roundingDigits = GetOptionalBinding<int>(nameId, pipelineProps, "RoundingDigits");

      // Optional output parameters
      _federalTaxAmount = GetOptionalBinding<decimal>(nameId, pipelineProps, "FederalTaxAmount");
      _federalTaxAmountRounded = GetOptionalBinding<decimal>(nameId, pipelineProps, "FederalTaxAmountRounded");
      _federalTaxName = GetOptionalBinding<string>(nameId, pipelineProps, "FederalTaxName");
      _stateTaxAmount = GetOptionalBinding<decimal>(nameId, pipelineProps, "StateTaxAmount");
      _stateTaxAmountRounded = GetOptionalBinding<decimal>(nameId, pipelineProps, "StateTaxAmountRounded");
      _stateTaxName = GetOptionalBinding<string>(nameId, pipelineProps, "StateTaxName");
      _countyTaxAmount = GetOptionalBinding<decimal>(nameId, pipelineProps, "CountyTaxAmount");
      _countyTaxAmountRounded = GetOptionalBinding<decimal>(nameId, pipelineProps, "CountyTaxAmountRounded");
      _countyTaxName = GetOptionalBinding<string>(nameId, pipelineProps, "CountyTaxName");
      _localTaxAmount = GetOptionalBinding<decimal>(nameId, pipelineProps, "LocalTaxAmount");
      _localTaxAmountRounded = GetOptionalBinding<decimal>(nameId, pipelineProps, "LocalTaxAmountRounded");
      _localTaxName = GetOptionalBinding<string>(nameId, pipelineProps, "LocalTaxName");
      _otherTaxAmount = GetOptionalBinding<decimal>(nameId, pipelineProps, "OtherTaxAmount");
      _otherTaxAmountRounded = GetOptionalBinding<decimal>(nameId, pipelineProps, "OtherTaxAmountRounded");
      _otherTaxName = GetOptionalBinding<string>(nameId, pipelineProps, "OtherTaxName");
      _taxChargeId = GetOptionalBinding<long>(nameId, pipelineProps, "TaxChargeID");
    }

    private PipelineProperties(PipelineProperties prototype, ISession session)
    {
      _session = session;
      _enumConfig = prototype._enumConfig;
      _log = prototype._log;

      // Required input parameters
      _accountId = new Binding<int>(prototype._accountId.Id);
      _amount = new Binding<decimal>(prototype._amount.Id);
      _invoiceDate = new Binding<DateTime>(prototype._invoiceDate.Id);
      _intervalId = new Binding<int>(prototype._intervalId.Id);
      _originLocation = new Binding<string>(prototype._originLocation.Id);
      _terminationLocation = new Binding<string>(prototype._terminationLocation.Id);
      _serviceCode = new Binding<string>(prototype._serviceCode.Id);
      _categoryCode = new Binding<string>(prototype._categoryCode.Id);

      // Optional input parameters
      _originLocationMode = new Binding<string>(prototype._originLocationMode.Id);
      _terminationLocationMode = new Binding<string>(prototype._terminationLocationMode.Id);
      _chargeToLocationMode = new Binding<string>(prototype._chargeToLocationMode.Id);
      _chargeToLocation = new Binding<string>(prototype._chargeToLocation.Id);
      _originIncorporatedCode = new Binding<string>(prototype._originIncorporatedCode.Id);
      _terminationIncorporatedCode = new Binding<string>(prototype._terminationIncorporatedCode.Id);
      _chargeToIncorporatedCode = new Binding<string>(prototype._chargeToIncorporatedCode.Id);
      _invoiceNumber = new Binding<string>(prototype._invoiceNumber.Id);
      _customerCode = new Binding<string>(prototype._customerCode.Id);
      _customerReference = new Binding<string>(prototype._customerReference.Id);
      _billedLines = new Binding<int>(prototype._billedLines.Id);
      _trunkLines = new Binding<int>(prototype._trunkLines.Id);
      _utilityCode = new Binding<string>(prototype._utilityCode.Id);
      _saleResaleCode = new Binding<string>(prototype._saleResaleCode.Id);
      _writeBundleDetailFlag = new Binding<string>(prototype._writeBundleDetailFlag.Id);
      _transactionCode = new Binding<string>(prototype._transactionCode.Id);
      _taxedGeoCodeIncorporatedCode = new Binding<string>(prototype._taxedGeoCodeIncorporatedCode.Id);
      _taxedGeoCodeOverrideCode = new Binding<string>(prototype._taxedGeoCodeOverrideCode.Id);
      _callMinutes = new Binding<decimal>(prototype._callMinutes.Id);
      _federalExemptFlag = new Binding<string>(prototype._federalExemptFlag.Id);
      _stateExemptFlag = new Binding<string>(prototype._stateExemptFlag.Id);
      _countyExemptFlag = new Binding<string>(prototype._countyExemptFlag.Id);
      _cityExemptFlag = new Binding<string>(prototype._cityExemptFlag.Id);
      _creditCode = new Binding<string>(prototype._creditCode.Id);
      _userArea = new Binding<string>(prototype._userArea.Id);
      _bundleFlag = new Binding<string>(prototype._bundleFlag.Id);
      _bundleServiceCode = new Binding<string>(prototype._bundleServiceCode.Id);
      _bundleCategoryCode = new Binding<string>(prototype._bundleCategoryCode.Id);
      _productCode = new Binding<string>(prototype._productCode.Id);
      _isImpliedTax = new Binding<bool>(prototype._isImpliedTax.Id);
      _roundingAlgorithm = new Binding<string>(prototype._roundingAlgorithm.Id);
      _roundingDigits = new Binding<int>(prototype._roundingDigits.Id);

      // Optional output parameters
      _federalTaxAmount = new Binding<decimal>(prototype._federalTaxAmount.Id);
      _federalTaxAmountRounded = new Binding<decimal>(prototype._federalTaxAmountRounded.Id);
      _federalTaxName = new Binding<string>(prototype._federalTaxName.Id);
      _stateTaxAmount = new Binding<decimal>(prototype._stateTaxAmount.Id);
      _stateTaxAmountRounded = new Binding<decimal>(prototype._stateTaxAmountRounded.Id);
      _stateTaxName = new Binding<string>(prototype._stateTaxName.Id);
      _countyTaxAmount = new Binding<decimal>(prototype._countyTaxAmount.Id);
      _countyTaxAmountRounded = new Binding<decimal>(prototype._countyTaxAmountRounded.Id);
      _countyTaxName = new Binding<string>(prototype._countyTaxName.Id);
      _localTaxAmount = new Binding<decimal>(prototype._localTaxAmount.Id);
      _localTaxAmountRounded = new Binding<decimal>(prototype._localTaxAmountRounded.Id);
      _localTaxName = new Binding<string>(prototype._localTaxName.Id);
      _otherTaxAmount = new Binding<decimal>(prototype._otherTaxAmount.Id);
      _otherTaxAmountRounded = new Binding<decimal>(prototype._otherTaxAmountRounded.Id);
      _otherTaxName = new Binding<string>(prototype._otherTaxName.Id);
      _taxChargeId = new Binding<long>(prototype._taxChargeId.Id);
    }

    internal static PipelineProperties CreatePrototype(PlugInBase.LogDelegate log, IMTSystemContext systemContext,
                                                       XmlDocument xmlConfig)
    {
      return new PipelineProperties(log, systemContext, xmlConfig);
    }

    internal static PipelineProperties Create(PipelineProperties prototype, ISession session)
    {
      return new PipelineProperties(prototype, session);
    }

    private static Binding<T> GetOptionalBinding<T>(IMTNameID nameId, XmlNode pipelineProps, string propertyName)
    {
      var parameterValue = GetValueFromParameter(pipelineProps, propertyName);
      return parameterValue.Length <= 0 ? new Binding<T>(-1) : new Binding<T>(nameId.GetNameID(parameterValue));
    }

    private static string GetValueFromParameter(XmlNode node, string paramName)
    {
      var childNode = node.SelectSingleNode(paramName);
      if (childNode == null)
      {
        throw new ConfigurationErrorsException(
          String.Format("The '{0}' parametr name does not set into '{1}'. Section content = '{2}'"
                        , paramName, PipelineBinding, node.OuterXml));
      }
      return childNode.InnerText;
    }

    #endregion

    #region Read Values from the Session

    private static readonly Dictionary<Type, Func<ISession, int, object>> TypeMappingGet = new Dictionary
      <Type, Func<ISession, int, object>>
      {
        {typeof (int), (x, y) => x.GetIntegerProperty(y)},
        {typeof (long), (x, y) => x.GetLongProperty(y)},
        {typeof (double), (x, y) => x.GetDoubleProperty(y)},
        {typeof (bool), (x, y) => x.GetBooleanProperty(y)},
        {typeof (string), (x, y) => x.GetStringProperty(y)},
        {typeof (DateTime), (x, y) => x.GetDateTimeProperty(y)},
        {typeof (decimal), (x, y) => x.GetDecimalProperty(y)}
      };

    private static object GetSessionValue<T>(ISession session, int propertyId)
    {
      return TypeMappingGet[typeof (T)].Invoke(session, propertyId);
    }

    private object GetPropertyValue<T>(Binding<T> property)
    {
      try
      {
        if (!property.HasValue && property.Id > -1)
        {
          property.Value = (T) GetSessionValue<T>(_session, property.Id);
          property.HasValue = true;
        }
      }
#pragma warning disable 0168
      catch (Exception ex)
#pragma warning restore 0168
      {
#if ERROR_ON_NULL_GET
        var message = _log(PlugInBase.LogLevel.Error, "An error occurred when trying to get the value");
        throw new InvalidValueException(message, ex);
#endif
      }
      return property.HasValue ? property.Value : (object) null;
    }

    #endregion

    #region Write values to the Session

    private static readonly Dictionary<Type, Action<ISession, int, object>> TypeMappingSet = new Dictionary
      <Type, Action<ISession, int, object>>
      {
        {typeof (int), (x, y, z) => x.SetIntegerProperty(y, (int) z)},
        {typeof (long), (x, y, z) => x.SetLongProperty(y, (long) z)},
        {typeof (double), (x, y, z) => x.SetDoubleProperty(y, (double) z)},
        {typeof (bool), (x, y, z) => x.SetBooleanProperty(y, (bool) z)},
        {typeof (string), (x, y, z) => x.SetStringProperty(y, (string) z)},
        {typeof (DateTime), (x, y, z) => x.SetDateTimeProperty(y, (DateTime) z)},
        {typeof (decimal), (x, y, z) => x.SetDecimalProperty(y, (decimal) z)}
      };

    private static void SetSessionValue<T>(ISession session, int propertyId, object value)
    {
      TypeMappingSet[typeof (T)].Invoke(session, propertyId, value);
    }

    private void SetPropertyValue<T>(Binding<T> property, object value)
    {
      if ((typeof (T) == typeof (string)) && value == null)
        value = string.Empty;
      
      if (value == null)
      {
        var message = _log(PlugInBase.LogLevel.Error, "Cannot set pipeline values to null");
        throw new InvalidValueException(message);
      }

      if (property.Id > -1)
        SetSessionValue<T>(_session, property.Id, value);
    }

    #endregion

    #region Pipeline Properties

    #region In Properties

    /// <summary>
    ///     (In) This account to be taxed.
    /// </summary>
    internal int? AccountId
    {
      get { return (int?) GetPropertyValue(_accountId); }
    }

    /// <summary>
    ///     (In) This is the dollar amount of the transaction being taxed. This amount is used as the base taxable amount for the calculation. If a particular tax requires that other amounts be added to the taxable amount, CTQ will do this automatically. The taxable amount will not be changed by CTQ.
    /// </summary>
    internal decimal? Amount
    {
      get { return (decimal?) GetPropertyValue(_amount); }
    }

    /// <summary>
    ///     (In) The invoice date. It is used to determine whether the transaction took place before or after the effective date of the current rate. If it took place before the effective date on file, the previous rate is used. If the transaction took place on or after the effective date, the current rate is used.
    /// </summary>
    internal DateTime? InvoiceDate
    {
      get { return (DateTime?) GetPropertyValue(_invoiceDate); }
    }

    /// <summary>
    ///     (In) The interval ID associated with the transaction.
    /// </summary>
    internal int? IntervalId
    {
      get { return (int?) GetPropertyValue(_intervalId); }
    }

    /// <summary>
    ///     (In) The service address location where the transaction (call) originated. The value in this field is treated as a GeoCode, NPA/NXX, or ZIP + 4 Code, depending on the value in OriginLocationMode: If OriginLocationMode = G, the value in this field is assumed to be a GeoCode. If OriginLocationMode = N, this field is required and is assumed to contain an NPA/NXX. If you do not populate this field and you pass an N in the OriginLocationMode field for the same record, the Calculation program aborts and returns an error code. If OriginLocationMode = P (for postal code), this field is required and is assumed to contain a ZIP + 4 Code. If you do not populate this field and you pass a P in the OriginLocationMode field for the same record, the Calculation program aborts and returns an error code.
    /// </summary>
    internal string OriginLocation
    {
      get { return (string) GetPropertyValue(_originLocation); }
    }

    /// <summary>
    ///     (In) The service address location where the transaction (call) terminated. The value in this field is treated as a GeoCode, NPA/NXX, or ZIP + 4 Code, depending on the value in TerminationLocationMode: If TerminationLocationMode = G, the value in this field is assumed to be a GeoCode. If TerminationLocationMode = N, this field is required and is assumed to contain an NPA/NXX. If you do not populate this field and you pass an N in the TerminationLocationMode field for the same record, the Calculation program aborts and returns an error code. The field is left justified and zero filled. If TerminationLocationMode = P, this field is required and is assumed to contain a ZIP + 4 Code. If you do not populate this field and you pass a P in the TerminationLocationMode field for the same record, the Calculation program aborts and returns an error code. The field is left justified and zero filled.
    /// </summary>
    internal string TerminationLocation
    {
      get { return (string) GetPropertyValue(_terminationLocation); }
    }

    /// <summary>
    ///     (In) The service code is used to describe the type of service being taxed. Not all taxes are calculated for all types of service. This field is used to determine which taxes should be calculated. Refer to your monthly update or to myVertex on the Vertex Web site for the most current list of service codes.
    /// </summary>
    internal string ServiceCode
    {
      get { return (string) GetPropertyValue(_serviceCode); }
    }

    /// <summary>
    ///     (In) The category code is used to describe the category of the service being taxed. Not all taxes are calculated for all categories of service. This field is used to determine which taxes should be calculated. Refer to your monthly update or to myVertex on the Vertex Web site for the most current list of category codes.
    /// </summary>
    internal string CategoryCode
    {
      get { return (string) GetPropertyValue(_categoryCode); }
    }

    /// <summary>
    ///     (In) (Default = G) The value in this field identifies the type of data in the OriginLocation field and tells CTQ how to access the data to find the origination jurisdiction. The values are: G = GeoCode, identifies the value in OriginLocation as a GeoCode. N = NPA/NXX, identifies the value in OriginLocation as an NPA/NXX. P = ZIP + 4 Code, identifies the value in OriginLocation as a ZIP + 4 Code.
    /// </summary>
    internal string OriginLocationMode
    {
      get { return (string) GetPropertyValue(_originLocationMode); }
    }

    /// <summary>
    ///     (In) (Default = G) The value in this field identifies the type of data in TerminationLocation and tells CTQ how to access the data to find the termination jurisdiction. G = GeoCode, identifies the value in TerminationLocation as a GeoCode. N = NPA/NXX, identifies the value in TerminationLocation as an NPA/NXX. P = ZIP + 4 Code, identifies the value in TerminationLocation as a ZIP + 4 Code.
    /// </summary>
    internal string TerminationLocationMode
    {
      get { return (string) GetPropertyValue(_terminationLocationMode); }
    }

    /// <summary>
    ///     (In) (Default = G) The value of this field identifies the type of data in the ChargeToLocation field and tells CTQ how to access the data to find the charge-to jurisdiction. G = GeoCode, identifies the value in ChargeToLocation as a GeoCode. N = NPA/NXX, identifies the value in ChargeToLocation as an NPA/NXX. Z = five-digit ZIP Code or Canadian Postal Code, identifies the value in ChargeToLocation as a five-digit ZIP Code or a Canadian Postal Code. P = ZIP + 4 Code, identifies the value in ChargeToLocation as a ZIP + 4 Code.
    /// </summary>
    internal string ChargeToLocationMode
    {
      get { return (string) GetPropertyValue(_chargeToLocationMode); }
    }

    /// <summary>
    ///     (In) The service address location where the transaction (call) is billed or charged. The value in this field is treated as a GeoCode, NPA/NXX, ZIP Code or Canadian postal code, or ZIP + 4 Code, depending on the value in ChargeToLocationMode: If ChargeToLocationMode = G, the value in this field is assumed to be a GeoCode. If you do not populate this field, it defaults to the value in the OriginLocation field. If this parameter is assigned the value 00-000-0000, the program processes the billing location as the Federal GeoCode. If ChargeToLocationMode = N, the value in this field is assumed to be an NPA/NXX. The field is left justified and zero filled. If you do not populate this field, it defaults to the value in the OriginLocation field, and the value in the ChargeToLocationMode field is overwritten with the value in the OriginLocationMode field. If ChargeToLocationMode = Z, the value in this field is assumed to contain the two-position state code and the five-digit ZIP Code or, if the state code = CN, a Canadian Postal Code; only the first three characters of non-numeric Canadian postal codes are used to retrieve the appropriate GeoCode. CTQ uses this information to cross reference to the GeoCode. If you do not populate this field, it defaults to the value in the OriginLocation field. The field is left justified and zero filled. If ChargeToLocationMode = P, this field is assumed to contain the ZIP + 4 Code. If you do not populate this field, it defaults to the value in the OriginLocation field. This field is left justified.
    /// </summary>
    internal string ChargeToLocation
    {
      get { return (string) GetPropertyValue(_chargeToLocation); }
    }

    /// <summary>
    ///     (In) This attribute contains a code indicating whether the origin location lies within an incorporated area. If the tax authority from the rate record is 4 and this attribute is not set to O (outside), county tax is not calculated. You must know whether the customer is or is not located within the unincorporated area. If this attribute is populated with an O (the customer is located in the unincorporated area, the calculation will pick up the authority level 4 tax, if it exists. If an authority level 4 tax is present, no city level taxes (authority level 3) are returned. If the taxpayer is located within the incorporated area, the calculation picks up the authority level 3 taxes.
    /// </summary>
    internal string OriginIncorporatedCode
    {
      get { return (string) GetPropertyValue(_originIncorporatedCode); }
    }

    /// <summary>
    ///     (In) This attribute contains a code indicating whether the termination location is inside an incorporated region. If the tax authority from the rate record is 4 and this attribute is not set to O (outside), the county tax is not calculated. You must know whether the customer is or is not located within the unincorporated area. If the taxpayer is located in the unincorporated area and this attribute is populated with an O, the calculation will pick up the authority level 4 tax, if it exists. If an authority level 4 tax is present, no city level taxes (authority level 3) are returned. If the taxpayer is located within the incorporated area, the calculation picks up the authority level 3 taxes.defaultvalue value: I (inside the incorporated area)
    /// </summary>
    internal string TerminationIncorporatedCode
    {
      get { return (string) GetPropertyValue(_terminationIncorporatedCode); }
    }

    /// <summary>
    ///     (In) This attribute contains a code indicating whether the charge-to location lies within an incorporated area. If the tax authority from the rate record is 4 and this attribute is not set to O (outside), county tax is not calculated. You must know whether the customer is or is not located within the unincorporated area. If this attribute is populated with an O (the customer is located in the unincorporated area, the calculation will pick up the authority level 4 tax, if it exists. If an authority level 4 tax is present, no city level taxes (authority level 3) are returned. If the taxpayer is located within the incorporated area, the calculation picks up the authority level 3 taxes.
    /// </summary>
    internal string ChargeToIncorporatedCode
    {
      get { return (string) GetPropertyValue(_chargeToIncorporatedCode); }
    }

    /// <summary>
    ///     (In) This field may be used to pass transaction specific information. Depending on your business needs, it may be required for transactions subject to Max/Tier taxes. However, CTQ does not return an error message if you fail to populate this field. The Invoice Reference report is based on this information.
    /// </summary>
    internal string InvoiceNumber
    {
      get { return (string) GetPropertyValue(_invoiceNumber); }
    }

    /// <summary>
    ///     (In) A code used to designate the customer of a communications tax transaction. Some taxes apply to business or residential customers only, and this flag is used to determine whether a particular tax should be calculated. Valid Customer Codes are A(Tax on all customers), B (Tax on business customer only. This is the defaultvalue), R (Tax on residential customers only), # (Deactivate Tax. Tax is not processed).
    /// </summary>
    internal string CustomerCode
    {
      get { return (string) GetPropertyValue(_customerCode); }
    }

    /// <summary>
    ///     (In) The invoice or customer reference number associated with the transaction. This may be used to pass transaction-specific information to be used for record identification or for display on reports.This field is for customer identification. Depending on your business needs, it may be required for transactions subject to Max/Tier taxes. However, CTQ does not return an error message if you fail to populate this field. The Customer Reference report is based on this information.
    /// </summary>
    internal string CustomerReference
    {
      get { return (string) GetPropertyValue(_customerReference); }
    }

    /// <summary>
    ///     (In) This field contains the number of access lines represented on the bill. It must be populated with a non-zero number to calculate per month/per line charges.
    /// </summary>
    internal int? BilledLines
    {
      get { return (int?) GetPropertyValue(_billedLines); }
    }

    /// <summary>
    ///     (In) Number of trunk lines billed.
    /// </summary>
    internal int? TrunkLines
    {
      get { return (int?) GetPropertyValue(_trunkLines); }
    }

    /// <summary>
    ///     (In) The utility code is a flag that identifies the utility doing the billing as regulated or unregulated. Some taxes apply to regulated or unregulated utilities only and this flag is used to determine whether a particular tax should be	calculated.	A (Tax is on all service providers), R (Tax is on regulated service providers. This is the defaultvalue value), U (Tax is on Unregulated service providers), # (Deactivate Tax. Tax is not processed).
    /// </summary>
    internal string UtilityCode
    {
      get { return (string) GetPropertyValue(_utilityCode); }
    }

    /// <summary>
    ///     (In) (Default = S) This attribute identifies the transaction being taxed as either a Sale (ResaleFlagSale) or a Resale (ResaleFlagResale). Valid codes are A (All sales), R (resale), S (sale), # (deactivate Tax. Tax is not processed).
    /// </summary>
    internal string SaleResaleCode
    {
      get { return (string) GetPropertyValue(_saleResaleCode); }
    }

    /// <summary>
    ///     (In) Indicates which to record in the Tax Journal: summary tax data for the entire bundle or detail tax data for each component.
    /// </summary>
    internal string WriteBundleDetailFlag
    {
      get { return (string) GetPropertyValue(_writeBundleDetailFlag); }
    }

    /// <summary>
    ///     (In) The Transaction Code is used to distinguish normal tax calculation requests from special transaction processing. Example : defaultvalue or adjustment.
    /// </summary>
    internal string TransactionCode
    {
      get { return (string) GetPropertyValue(_transactionCode); }
    }

    /// <summary>
    ///     (In) If the DescriptionFlag attribute is set to Y for a tax calculation, then this attribute is valued with the IncorporatedCode of the taxing jurisdiction.
    /// </summary>
    internal string TaxedGeoCodeIncorporatedCode
    {
      get { return (string) GetPropertyValue(_taxedGeoCodeIncorporatedCode); }
    }

    /// <summary>
    ///     (In) A code used to explicitly specify the taxing jurisdiction. When set, this attribute overrides the standard behavior of the Two-of-three rule when determining a taxing jurisdiction. Note: With the exception of Vertex data for category 10 (wireless) transactions, depending on the rules of the taxing jurisdiction and regardless of which GeoCode Override Code you use, it may still be necessary to set one or both of the call location attributes (Origination, Termination, or Charge-to) that you are not using as the taxing jurisdiction. This is because the tax rules of the taxing jurisdiction may use either the origination or termination jurisdiction to determine whether tax applies. For example, the tax rules may include a requirement that the service in question originate in the taxing jurisdiction in order for the tax to be calculated. In this case, you would have to set an Origin attribute even if you were using the Charge-to location as the taxing jurisdiction. Valid Codes are A (override with origin), B (override with termination), C (override with charge-to), F (use origin location as taxedgeocode if rule finds no match), G (use termination location as taxedgeocode if rule finds no match), H (use charge-to location as taxedgeocode if rule finds no match), J (Evaluates the TaxedGeoCode and makes adjustments if a city was not identified in Two-of-three rule processing. The charge-to location is used to override the Two-of-three location if it matches the Two-of-three state or state/county. The origination location is used to override the Two-of-three location if the charge-to does not match the Two-of-three state or state/county combinations or if no Two-of-three match was identified at all.), Blank (defaultvalue. Two-of-Three processing rule applies).
    /// </summary>
    internal string TaxedGeoCodeOverrideCode
    {
      get { return (string) GetPropertyValue(_taxedGeoCodeOverrideCode); }
    }

    /// <summary>
    ///     (In) This is the duration of the call being taxed, in minutes and tenths of a minute. If you do not populate this field and are processing in batch mode, the initialized value of 0.00 is passed to the Calculation program.
    /// </summary>
    internal decimal? CallMinutes
    {
      get { return (decimal?) GetPropertyValue(_callMinutes); }
    }

    /// <summary>
    ///     (In) (Default = NULL) Setting this attribute to X indicates that the current transaction is exempt from all federal taxes.
    /// </summary>
    internal string FederalExemptFlag
    {
      get { return (string) GetPropertyValue(_federalExemptFlag); }
    }

    /// <summary>
    ///     (In) Setting this attribute to X indicates that the current transaction is exempt from all state taxes. defaultvalue value: NULL
    /// </summary>
    internal string StateExemptFlag
    {
      get { return (string) GetPropertyValue(_stateExemptFlag); }
    }

    /// <summary>
    ///     (In) (Default = NULL) Setting this attribute to X indicates that the current transaction is exempt from all county taxes.
    /// </summary>
    internal string CountyExemptFlag
    {
      get { return (string) GetPropertyValue(_countyExemptFlag); }
    }

    /// <summary>
    ///     (In) (Default = NULL) Setting this attribute to X indicates that the current transaction is exempt from all city taxes.
    /// </summary>
    internal string CityExemptFlag
    {
      get { return (string) GetPropertyValue(_cityExemptFlag); }
    }

    /// <summary>
    ///     (In) A code used to indicate if the transaction is a credit. Possible values are Y (yes, this is a credit) and N (no, this is not a credit).
    /// </summary>
    internal string CreditCode
    {
      get { return (string) GetPropertyValue(_creditCode); }
    }

    /// <summary>
    ///     (In) (Default = 0) This attribute can be used to pass transaction-specific information for record identification or for inclusion in reports. The User Area report is based on this information.
    /// </summary>
    internal string UserArea
    {
      get { return (string) GetPropertyValue(_userArea); }
    }

    /// <summary>
    ///     (In) Indicates if the transaction was for a bundled service.
    /// </summary>
    internal string BundleFlag
    {
      get { return (string) GetPropertyValue(_bundleFlag); }
    }

    /// <summary>
    ///     (In) The service code associated with bundled service definition.
    /// </summary>
    internal string BundleServiceCode
    {
      get { return (string) GetPropertyValue(_bundleServiceCode); }
    }

    /// <summary>
    ///     (In) The category code associated with bundled service definition.
    /// </summary>
    internal string BundleCategoryCode
    {
      get { return (string) GetPropertyValue(_bundleCategoryCode); }
    }

    /// <summary>
    ///     (In) A code identifying the product. This same code should be used in the VertexQ parameter table define the tax rate for the product. This field may be left blank and the value from GeneralConfig will be used.
    /// </summary>
    internal string ProductCode
    {
      get { return (string) GetPropertyValue(_productCode); }
    }

    /// <summary>
    ///     (In) If true, the amount already includes the tax. This field may be left blank and the value from GeneralConfig will be used.
    /// </summary>
    internal bool? IsImpliedTax
    {
      get { return (bool?) GetPropertyValue(_isImpliedTax); }
    }

    /// <summary>
    ///     (In) The rounding algorithm to use.  Acceptable values are: NONE or BANK.  NONE means no rounding will be performed. BANK means banker's rounding will be performed. This field may be left blank and the value from GeneralConfig will be used.
    /// </summary>
    internal string RoundingAlgorithm
    {
      get { return (string) GetPropertyValue(_roundingAlgorithm); }
    }

    /// <summary>
    ///     (In) The number of rounding digits. 0 - no rounding, 1 round to 1 digit after decimal point, 2 for 2 digits, etc. This field may be left blank and the value from GeneralConfig will be used.
    /// </summary>
    internal int? RoundingDigits
    {
      get { return (int?) GetPropertyValue(_roundingDigits); }
    }

    #endregion

    #region Out Properties

    /// <summary>
    ///     (Out) The federal tax amount.
    /// </summary>
    internal decimal? FederalTaxAmount
    {
      set { SetPropertyValue(_federalTaxAmount, value); }
    }

    /// <summary>
    ///     (Out) The rounded federal tax amount.
    /// </summary>
    internal decimal? FederalTaxAmountRounded
    {
      set { SetPropertyValue(_federalTaxAmountRounded, value); }
    }

    /// <summary>
    ///     (Out) The federal tax name. This comes from the configured VertexQ parameter table defining the rate.
    /// </summary>
    internal string FederalTaxName
    {
      set { SetPropertyValue(_federalTaxName, value); }
    }

    /// <summary>
    ///     (Out) The state tax amount.
    /// </summary>
    internal decimal? StateTaxAmount
    {
      set { SetPropertyValue(_stateTaxAmount, value); }
    }

    /// <summary>
    ///     (Out) The rounded state tax amount.
    /// </summary>
    internal decimal? StateTaxAmountRounded
    {
      set { SetPropertyValue(_stateTaxAmountRounded, value); }
    }

    /// <summary>
    ///     (Out) The state tax name.
    /// </summary>
    internal string StateTaxName
    {
      set { SetPropertyValue(_stateTaxName, value); }
    }

    /// <summary>
    ///     (Out) The county tax amount.
    /// </summary>
    internal decimal? CountyTaxAmount
    {
      set { SetPropertyValue(_countyTaxAmount, value); }
    }

    /// <summary>
    ///     (Out) The rounded county tax amount.
    /// </summary>
    internal decimal? CountyTaxAmountRounded
    {
      set { SetPropertyValue(_countyTaxAmountRounded, value); }
    }

    /// <summary>
    ///     (Out) The county tax name.
    /// </summary>
    internal string CountyTaxName
    {
      set { SetPropertyValue(_countyTaxName, value); }
    }

    /// <summary>
    ///     (Out) The local tax amount.
    /// </summary>
    internal decimal? LocalTaxAmount
    {
      set { SetPropertyValue(_localTaxAmount, value); }
    }

    /// <summary>
    ///     (Out) The rounded local tax amount.
    /// </summary>
    internal decimal? LocalTaxAmountRounded
    {
      set { SetPropertyValue(_localTaxAmountRounded, value); }
    }

    /// <summary>
    ///     (Out) The local tax name.
    /// </summary>
    internal string LocalTaxName
    {
      set { SetPropertyValue(_localTaxName, value); }
    }

    /// <summary>
    ///     (Out) Other tax amount.
    /// </summary>
    internal decimal? OtherTaxAmount
    {
      set { SetPropertyValue(_otherTaxAmount, value); }
    }

    /// <summary>
    ///     (Out) The rounded other tax amount.
    /// </summary>
    internal decimal? OtherTaxAmountRounded
    {
      set { SetPropertyValue(_otherTaxAmountRounded, value); }
    }

    /// <summary>
    ///     (Out) Other tax name.
    /// </summary>
    internal string OtherTaxName
    {
      set { SetPropertyValue(_otherTaxName, value); }
    }

    /// <summary>
    ///     (Out) An index that can be used to get detailed information about the tax if tax details were stored (based on configuration).  This value is used for the column id_tax_charge in t_tax_details.
    /// </summary>
    internal long? TaxChargeId
    {
      set { SetPropertyValue(_taxChargeId, value); }
    }

    #endregion

    #endregion
  }

  #endregion

  #region Binding Class

  [DebuggerStepThrough]
  internal class Binding<T>
  {
    internal Binding(int id)
    {
      Id = id;
      Value = default(T);
    }

    protected internal bool HasValue { get; set; }

    protected internal T Value { get; set; }

    protected internal int Id { get; private set; }
  }

  #endregion

#if CONTAINS_ENUMS
  #region EnumBinding Class
    internal sealed class EnumBinding<T> : Binding<T>
        where T : struct
    {
  #region Private Variables
        private readonly Dictionary<int, int> m_csToDb;
        private readonly Dictionary<int, int> m_dbToCs;
        private readonly string m_enumSpace;
        private readonly string m_enumName;
    #endregion

  #region Construction
        internal EnumBinding(int id, IEnumConfig enumConfig)
            : base(id)
        {
            m_csToDb = new Dictionary<int, int>();
            m_dbToCs = new Dictionary<int, int>();

            //build the enum id mapping
            object[] attrs = typeof(T).GetCustomAttributes(typeof(MTEnumAttribute), false);

            MTEnumAttribute info = attrs[0] as MTEnumAttribute;

            m_enumSpace = info.EnumSpace;
            m_enumName = info.EnumName;

            //get the ordinal of the value in the C# enum and save it along with the db id for the enum value
            foreach (string oldEnumStr in info.OldEnumValues)
            {
                if (!oldEnumStr.Contains(":"))
                    throw new InvalidEnumAttributeException(m_enumSpace + " " + m_enumName + " has an invalid OldEnumValues value on it's MTEnumAttribute");

                string[] set = oldEnumStr.Split(':');
                int ordinal = int.Parse(set[0]);
                string strVal = set[1];

                //trim extra quotes
                strVal = strVal.Trim('"');

                //get the id from the database
                int dbId = enumConfig.GetID(m_enumSpace, m_enumName, strVal);

                //add to both forward and reverse lookup lists
                //this will use up twice as much memory (still very little compared to everything else...)
                //but it will be just as fast for forward and reverse lookups
                m_csToDb.Add(ordinal, dbId);
                m_dbToCs.Add(dbId, ordinal);
            }
        }
    #endregion

  #region Properties and Methods
        internal int GetDatabaseIDForValue(T value)
        {
            return m_csToDb[Convert.ToInt32(value)];
        }
        internal void SetUsingDatabaseID(int dbId)
        {
            m_value = (T)Enum.ToObject(typeof(T), m_dbToCs[dbId]);
        }
        internal string EnumSpace
        {
            get { return m_enumSpace; }
        }
        internal string EnumName
        {
            get { return m_enumName; }
        }
    #endregion
    }
  #endregion
#endif
}