#region

using System;
using System.Collections.Generic;
using System.Diagnostics;
using MetraTech.DomainModel.Enums.Tax.Metratech_com_tax;
using MetraTech.Interop.SysContext;
using MetraTech.Pipeline.PlugIns;
using MetraTech.Tax.Framework.DataAccess;
using MetraTech.Tax.Framework.VertexQ;
using MetraTech.Tax.Plugins.AutoGenerated;
using IMTConfigPropSet = MetraTech.Interop.MTPipelineLib.IMTConfigPropSet;

#endregion

namespace MetraTech.Tax.Plugins
{
    public sealed partial class TaxCalculateVertexQ
    {
        #region ProcessAllSessions (Only modify this in the rare case you need to handle more than one session at once)

        /// <summary>
        ///     This method is called each time the plug-in recieves a session set
        /// </summary>
        protected override void ProcessAllSessions(PropertiesCollection propsCol)
        {
            var partiallyFailed = false;
            var stopWatch = new Stopwatch();
            stopWatch.Start();

            // Make sure we don't write details more than once
            _sessionSetTransactionDetails.Clear();

            foreach (var props in propsCol)
            {
                //set the current session for logging purposes
                SetCurrentSession(props.Session);

                try
                {
                    //process each session
                    ProcessSession(props);
                }
                catch (Exception ex)
                {
                    partiallyFailed = true;
                    Log(LogLevel.Warning, string.Format("Error when processing session: {0}", ex.Message));
                    Log(LogLevel.Warning, "Exception: " + ex.Message + " StackTrace: " +ex.StackTrace);
                    props.Session.MarkAsFailed(string.Format("Error when processing session. Source: {0}, Message: {1}",ex.Source, ex.Message), MARK_AS_FAILED_CODE_FAILED);
                }
                finally
                {
                    Log(LogLevel.Debug, "Session object disposed successfully");
                    props.Session.Dispose();
                }
            }

            //if any of the sessions failed, go ahead and throw an exception here
            if (partiallyFailed)
                throw new PartialFailureException();

            // All of the sessions completed successfully. If appropriate, store
            // tax transaction details in the t_tax_details table via bulk insert.
            StoreTransactionDetailsInDb();
            stopWatch.Stop();
            Log(LogLevel.Debug, string.Format("TIMING: TaxCalculateVertexQ.ProcessAllSessions numSessions={0} ms={1}", propsCol.Count, stopWatch.ElapsedMilliseconds));
        }

        #endregion

        #region Startup override

        protected override void StartUp(IMTSystemContext systemContext, IMTConfigPropSet propSet)
        {
            Log(LogLevel.Debug, "Starting Startup TaxCalculateVertexQ");
            var stopWatch = new Stopwatch();
            stopWatch.Start();
            //TODO: add any code you would like to run at Configure time (when the plug-in is first loaded)

            // Set up the VertexQ manager that will be used to calculate tax.
            _taxManager = new VertexQSyncTaxManagerDBBatch();

            // Create a list to hold info that will later be written to t_tax_details
            _sessionSetTransactionDetails = new List<TaxManagerPersistenceObject>();
            stopWatch.Stop();
            Log(LogLevel.Debug,
                string.Format("TIMING: TaxCalculateVertexQ.Startup ms={0}", stopWatch.ElapsedMilliseconds));
        }

        #endregion

        #region Shutdown override

        public override void Shutdown()
        {
            //TODO: add any code you would like to run when the plug-in shuts down
        }

        #endregion

        private List<TaxManagerPersistenceObject> _sessionSetTransactionDetails;
        private VertexQSyncTaxManagerDBBatch _taxManager;

        /// <summary>
        ///     This method is called for each session in the session set.
        /// </summary>
        protected override void ProcessSession(Properties props)
        {
            #region Instructions

            /* -Pipeline Inputs and Outputs
             *  Pipeline inputs and outputs are accessed via the props variable.
             *  Value types (int, long, bool, enums, etc..) are marked as nullable.
             *  When you look at the type you'll see, for example, int? instead of int.
             *  Nullable value types are used because the Pipeline value could possibly be null.
             *  You can check to see if the value is null by checking the .HasValue property. 
             *  There are two ways you can get the actual value of the variable. First by using 
             *  the .Value property.
             *  Example:
             *      int a = props.Pipeline.Foo.Value; //The type of Foo is int? (a.k.a. Nullable<int>) but the type of Foo.Value is int.
             *  And second by doing a cast:
             *  Example:
             *      int a = (int)props.Pipeline.Foo; //The type of Foo is int? (a.k.a. Nullable<int>)
             *  Reference types (string, classes you write) are already nullable so there's no 
             *  need to treat them special.
             *  Example:
             *      string foo = props.Pipeline.Foo; //The type of Foo is string.
             *
             * -General Configuration Variables
             *  Accessed via the GeneralConfig property of TaxCalculateVertexQ.
             *  Example: 
             *      string filePath = GeneralConfig.FilePath;
             * 
             * -Errors
             *  If there is a critical error and you would like to make the the current session as failed,
             *  throw an exception of type ApplicationException with a custom message. 
             *  The message will be logged. The ProcessAllSessions method will catch the 
             *  exception and mark the current session as failed and move on to the next session to process.
             *  Example: 
             *      throw new ApplicationException("The value Foo was outside the expected range");
             * 
             * -Logging
             *  You can log messages via the Log function.
             *  Example: Log(LogLevel.Debug, "Test message");
             */

            #endregion

            var stopWatch = new Stopwatch();
            stopWatch.Start();
            Log(LogLevel.Debug, "Starting ProcessSession TaxCalculateVertexQ");

            // Set the tax manager parameters for this tax calculation.
            // A tax run ID of 0 is associated with a pipeline run.
            _taxManager.TaxRunId = 0;

            // Generate a unique tax charge ID for this transaction.
            // This ID is unique with respect to tax run ID -1 (pipeline runs).
            var idTaxCharge = _taxManager.GenerateUniqueTaxChargeIdForPipeline();
            Log(LogLevel.Debug, "The id tax charge associated with this is " + idTaxCharge);
            stopWatch.Stop();
            Log(LogLevel.Debug,
                string.Format("TIMING: TaxCalculateVertexQ.ProcessSession determined id_tax_charge ms={0}", stopWatch.ElapsedMilliseconds));
            stopWatch.Restart();

            // Always set TaxDetailsNeeded to false so that the TaxManager will NOT write
            // to t_tax_details table.  The plugin will write to t_tax_details via
            // bulk insert if appropriate after the sessionSet is complete.
            _taxManager.TaxDetailsNeeded = false;

            // Construct an input tax row.
            var taxableTransaction = new TaxableTransaction(TaxVendor.VertexQ);

            // Parameters coming from required pipeline session variables.
            var taxParameter = new TaxParameter("id_acc", "Account", typeof(int), props.Pipeline.AccountId);
            taxableTransaction.StoreTaxParameter(taxParameter);
            taxParameter = new TaxParameter("id_tax_charge", "ID Tax Charge", typeof(long), idTaxCharge);
            taxableTransaction.StoreTaxParameter(taxParameter);
            taxParameter = new TaxParameter("id_usage_interval", "Usage Interval", typeof(long), props.Pipeline.IntervalId);
            taxableTransaction.StoreTaxParameter(taxParameter);
            taxParameter = new TaxParameter("amount", "Account", typeof(decimal), props.Pipeline.Amount);
            taxableTransaction.StoreTaxParameter(taxParameter);
            taxParameter = new TaxParameter("invoice_date", "Invoice Date", typeof(DateTime), props.Pipeline.InvoiceDate);
            taxableTransaction.StoreTaxParameter(taxParameter);
            taxParameter = new TaxParameter("origin_location", "OriginLocation", typeof(string), props.Pipeline.OriginLocation);
            taxableTransaction.StoreTaxParameter(taxParameter);
            taxParameter = new TaxParameter("termination_location", "TerminationLocation", typeof(string), props.Pipeline.TerminationLocation);
            taxableTransaction.StoreTaxParameter(taxParameter);
            taxParameter = new TaxParameter("category_code", "CategoryCode", typeof(string), props.Pipeline.CategoryCode);
            taxableTransaction.StoreTaxParameter(taxParameter);
            taxParameter = new TaxParameter("service_code", "ServiceCode", typeof(string), props.Pipeline.ServiceCode);
            taxableTransaction.StoreTaxParameter(taxParameter);

            stopWatch.Stop();
            Log(LogLevel.Debug,
                string.Format("TIMING: TaxCalculateVertexQ.ProcessSession retrieved required params ms={0}", stopWatch.ElapsedMilliseconds));
            stopWatch.Restart();

            // Parameters coming from optional pipeline session variables or plug-in configuration values.

            var isImpliedTax = props.Pipeline.IsImpliedTax.HasValue ? props.Pipeline.IsImpliedTax : GeneralConfig.DefaultIsImpliedTax;
            taxParameter = new TaxParameter("is_implied_tax", "IsImpliedTax", typeof(string), (isImpliedTax.HasValue && isImpliedTax.Value) ? "true" : "false");
            taxableTransaction.StoreTaxParameter(taxParameter);

            taxParameter = props.Pipeline.ProductCode != null
                               ? new TaxParameter("product_code", "Product Code", typeof(string), props.Pipeline.ProductCode)
                               : new TaxParameter("product_code", "Product Code", typeof(string), GeneralConfig.DefaultProductCode);
            taxableTransaction.StoreTaxParameter(taxParameter);

            taxParameter = props.Pipeline.RoundingDigits.HasValue
                               ? new TaxParameter("round_digits", "Rounding Digits", typeof(int), props.Pipeline.RoundingDigits)
                               : new TaxParameter("round_digits", "Rounding Digits", typeof(int), GeneralConfig.DefaultRoundingDigits);
            taxableTransaction.StoreTaxParameter(taxParameter);

            taxParameter = props.Pipeline.RoundingAlgorithm != null
                               ? new TaxParameter("round_alg", "Rounding Algorithm", typeof(string), props.Pipeline.RoundingAlgorithm)
                               : new TaxParameter("round_alg", "Rounding Algorithm", typeof(string), GeneralConfig.DefaultRoundingAlgorithm);
            taxableTransaction.StoreTaxParameter(taxParameter);

            if (props.Pipeline.OriginLocationMode != null)
            {
                taxParameter = new TaxParameter("origin_location_mode", "OriginLocationMode", typeof(string), props.Pipeline.OriginLocationMode);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.TerminationLocationMode != null)
            {
                taxParameter = new TaxParameter("termination_location_mode", "TerminationLocationMode", typeof(string), props.Pipeline.TerminationLocationMode);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.ChargeToLocation != null)
            {
                taxParameter = new TaxParameter("charge_to_location", "ChargeToLocation", typeof(string), props.Pipeline.ChargeToLocation);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.ChargeToLocationMode != null)
            {
                taxParameter = new TaxParameter("charge_to_location_mode", "ChargeToLocationMode", typeof(string), props.Pipeline.ChargeToLocationMode);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.OriginIncorporatedCode != null)
            {
                taxParameter = new TaxParameter("origin_incorporated_code", "OriginIncorporatedCode", typeof(string), props.Pipeline.OriginIncorporatedCode);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.TerminationIncorporatedCode != null)
            {
                taxParameter = new TaxParameter("termination_incorporated_code", "TerminationIncorporatedCode", typeof(string), props.Pipeline.TerminationIncorporatedCode);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.ChargeToIncorporatedCode != null)
            {
                taxParameter = new TaxParameter("charge_to_incorporated_code", "ChargeToIncorporatedCode", typeof(string), props.Pipeline.ChargeToIncorporatedCode);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.InvoiceNumber != null)
            {
                taxParameter = new TaxParameter("invoice_number", "InvoiceNumber", typeof(string), props.Pipeline.InvoiceNumber);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.CustomerCode != null)
            {
                taxParameter = new TaxParameter("customer_code", "CustomerCode", typeof(string), props.Pipeline.CustomerCode);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.CustomerReference != null)
            {
                taxParameter = new TaxParameter("customer_reference", "CustomerReference", typeof(string), props.Pipeline.CustomerReference);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.BilledLines.HasValue)
            {
                taxParameter = new TaxParameter("billed_lines", "BilledLines", typeof(int), props.Pipeline.BilledLines);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.TrunkLines.HasValue)
            {
                taxParameter = new TaxParameter("trunk_lines", "TrunkLines", typeof(int), props.Pipeline.TrunkLines);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.UtilityCode != null)
            {
                taxParameter = new TaxParameter("utility_code", "UtilityCode", typeof(string), props.Pipeline.UtilityCode);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.SaleResaleCode != null)
            {
                taxParameter = new TaxParameter("sale_resale_code", "SaleResaleCode", typeof(string), props.Pipeline.SaleResaleCode);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.WriteBundleDetailFlag != null)
            {
                taxParameter = new TaxParameter("write_bundle_detail_flag", "WriteBundleDetailFlag", typeof(string), props.Pipeline.WriteBundleDetailFlag);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.TransactionCode != null)
            {
                taxParameter = new TaxParameter("transaction_code", "TransactionCode", typeof(string), props.Pipeline.TransactionCode);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.TaxedGeoCodeIncorporatedCode != null)
            {
                taxParameter = new TaxParameter("taxed_geo_code_incorporated_code", "TaxedGeoCodeIncorporatedCode", typeof(string), props.Pipeline.TaxedGeoCodeIncorporatedCode);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.TaxedGeoCodeOverrideCode != null)
            {
                taxParameter = new TaxParameter("taxed_geo_code_override_code", "TaxedGeoCodeOverrideCode", typeof(string), props.Pipeline.TaxedGeoCodeOverrideCode);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.CallMinutes.HasValue)
            {
                taxParameter = new TaxParameter("call_minutes", "CallMinutes", typeof(decimal), props.Pipeline.CallMinutes);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.FederalExemptFlag != null)
            {
                taxParameter = new TaxParameter("federal_exempt_flag", "FederalExemptFlag", typeof(string), props.Pipeline.FederalExemptFlag);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.StateExemptFlag != null)
            {
                taxParameter = new TaxParameter("state_exempt_flag", "StateExemptFlag", typeof(string), props.Pipeline.StateExemptFlag);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.CountyExemptFlag != null)
            {
                taxParameter = new TaxParameter("county_exempt_flag", "CountyExemptFlag", typeof(string), props.Pipeline.CountyExemptFlag);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.CityExemptFlag != null)
            {
                taxParameter = new TaxParameter("city_exempt_flag", "CityExemptFlag", typeof(string), props.Pipeline.CityExemptFlag);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.CreditCode != null)
            {
                taxParameter = new TaxParameter("credit_code", "ChargeToLocationMode", typeof(string), props.Pipeline.CreditCode);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.UserArea != null)
            {
                taxParameter = new TaxParameter("user_area", "UserArea", typeof(string), props.Pipeline.UserArea);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.BundleFlag != null)
            {
                taxParameter = new TaxParameter("bundle_flag", "BundleFlag", typeof(string), props.Pipeline.BundleFlag);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.BundleServiceCode != null)
            {
                taxParameter = new TaxParameter("bundle_service_code", "BundleServiceCode", typeof(string), props.Pipeline.BundleServiceCode);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }
            if (props.Pipeline.BundleCategoryCode != null)
            {
                taxParameter = new TaxParameter("bundle_category_code", "BundleCategoryCode", typeof(string), props.Pipeline.BundleCategoryCode);
                taxableTransaction.StoreTaxParameter(taxParameter);
            }

            stopWatch.Stop();
            Log(LogLevel.Debug,
                string.Format("TIMING: TaxCalculateVertexQ.ProcessSession retrieved optional params ms={0}", stopWatch.ElapsedMilliseconds));
            stopWatch.Restart();

            // Calculate the taxes
            List<TransactionIndividualTax> transactionDetails;
            TransactionTaxSummary transactionSummary;
            _taxManager.CalculateTaxes(taxableTransaction, out transactionSummary, out transactionDetails);

            stopWatch.Stop();
            Log(LogLevel.Debug,
                string.Format("TIMING: TaxCalculateVertexQ.ProcessSession calculated taxes ms={0}", stopWatch.ElapsedMilliseconds));
            stopWatch.Restart();

            // Store the taxes
            props.Pipeline.FederalTaxAmount = transactionSummary.TaxFedAmount;
            props.Pipeline.FederalTaxAmountRounded = transactionSummary.TaxFedRounded;
            props.Pipeline.FederalTaxName = transactionSummary.TaxFedName;
            props.Pipeline.StateTaxAmount = transactionSummary.TaxStateAmount;
            props.Pipeline.StateTaxAmountRounded = transactionSummary.TaxStateRounded;
            props.Pipeline.StateTaxName = transactionSummary.TaxStateName;
            props.Pipeline.CountyTaxAmount = transactionSummary.TaxCountyAmount;
            props.Pipeline.CountyTaxAmountRounded = transactionSummary.TaxCountyRounded;
            props.Pipeline.CountyTaxName = transactionSummary.TaxCountyName;
            props.Pipeline.LocalTaxAmount = transactionSummary.TaxLocalAmount;
            props.Pipeline.LocalTaxAmountRounded = transactionSummary.TaxLocalRounded;
            props.Pipeline.LocalTaxName = transactionSummary.TaxLocalName;
            props.Pipeline.OtherTaxAmount = transactionSummary.TaxOtherAmount;
            props.Pipeline.OtherTaxAmountRounded = transactionSummary.TaxOtherRounded;
            props.Pipeline.OtherTaxName = transactionSummary.TaxOtherName;

            if (GeneralConfig.ShouldTaxDetailsBeStored.HasValue && GeneralConfig.ShouldTaxDetailsBeStored.Value)
            {
                _sessionSetTransactionDetails.AddRange(transactionDetails);
            }
            stopWatch.Stop();
            Log(LogLevel.Debug,
                string.Format("TIMING: TaxCalculateVertexQ.ProcessSession finished ms={0}", stopWatch.ElapsedMilliseconds));
        }

        /// <summary>
        ///     Store the contents of _sessionSetTransactionDetails in t_tax_details table
        /// </summary>
        private void StoreTransactionDetailsInDb()
        {
            try
            {
                if (_sessionSetTransactionDetails.Count == 0)
                    return;

                var tableWriter = new TaxManagerBatchDbTableWriter(_taxManager.GetTaxDetailTableName(),_taxManager.GetBulkInsertSize());
                tableWriter.Add(_sessionSetTransactionDetails);
                tableWriter.Commit();
            }
            catch (Exception ex)
            {
                Log(LogLevel.Error, string.Format("StoreTransactionDetailsInDb: Unable to store the details of the tax transactions in the table t_tax_details: {0}", ex.Message));
                throw;
            }
        }
    }
}