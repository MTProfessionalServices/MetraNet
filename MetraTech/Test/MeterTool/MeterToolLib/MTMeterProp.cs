using System;
using System.Xml;
using System.Reflection;
using MetraTech;
using MetraTech.Test;

namespace MetraTech.Test.MeterTool.MeterToolLib
{
  /// <summary>
  /// MTMeter Property Type
  /// </summary>
  public enum PropertyType
  {
    /// <summary>
    /// MTMeterProp represents a session that will be created in a compound.
    /// </summary>
    SESSION = 0,
    /// <summary>
    /// MTMeterProp represents a property that will be created in the session.
    /// </summary>
    PROPERTY = 1
  }

  /// <summary>
  /// Type of random value that will be generated.
  /// </summary>
  public enum ValueType
  {
    /// <summary>
    /// Random value chosen from the CSV or newline-separated property string.
    /// </summary>
    PROPERTY_STRING = 0,
    /// <summary>
    /// Random value falling in the range specified by the Floor and the Ceiling
    /// </summary>
    VALUE_RANGE = 1,
    /// <summary>
    /// Property is not metered.
    /// </summary>
    NOT_METERED = 2,
    /// <summary>
    /// Value generated is equal to another value the session.
    /// </summary>
    PROP_EQUALS = 3,
    /// <summary>
    /// Random value falling in the range defined by two other properties.
    /// </summary>
    BETWEEN = 4,
    /// <summary>
    /// Random value returned by the specified plugin.
    /// </summary>
    PLUGIN = 5

  }
  /////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////
  /// <summary>
  /// MTMeter object can be inserted directly into a tree control since it derives from TreeNode
  /// </summary>
  public class MTMeterProp : System.Windows.Forms.TreeNode, IPluginHost
  {
    //Property Variables
    private string msName;
    private string msMSIXType;
    private string msMSIXLength;
    private string msMSIXRequired;
    private string msMSIXDescription;
    private string msMSIXDefaultValue;

    //Metered data
    private int mintMinSessions;
    private int mintMaxSessions;

    //Data used to generate random values
    private string msPropertyString;
	  private bool mbPropertyStringRandom;
		private int mintPropertyStringIndex;
    private object moMinValue;
    private object moMaxValue;
    private string msFloor;
    private string msCeiling;
    private string msPropEquals;
    private string msPluginName;

    //Additional Data
    private bool mbAdditionalData;
    private bool mbGreaterThan;
    private bool mbLessThan;
    private string msGreaterThan;
    private string msLessThan;

    //Random value to meter generated by Call to Generate Random Value
    private object moGeneratedValue;

    //Temp Max / Min values that are the intersection between the 
    // BETWEEN or VALUE_RANGE parameters and the GREATER_THAN and
    // LESS_THAN restrictions
    private object moTempMin;
    private object moTempMax;


    //Helpful  objects / enums
    private char[] seps = { ',', '\n'};
    private Random randomGenerator;
    private PropertyType meType;
    private ValueType meValueType;

    private PropertyBag mSmokeTestProperties = null;

    private IPlugin mPlugin = null;

    public bool Register(IPlugin ipi)
    {
      mPlugin = ipi;
      //System.Windows.Forms.MessageBox.Show("Registered: " + ipi.Name);
      return true;
    }

    /////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Default constructor.
    /// </summary>
    public MTMeterProp()
    {
      randomGenerator = new Random(DateTime.Now.Millisecond);
      SetDefaults();
    }
    /////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Construct MTMeterProp object with the given name
    /// </summary>
    /// <param name="sName">Name of the Session/Property</param>   
    public MTMeterProp(string sName)
    {
      msName = sName;
      base.Text = msName;
      randomGenerator = new Random(DateTime.Now.Millisecond);
      meType = PropertyType.PROPERTY;
      msMSIXType = "unistring";

      SetDefaults();
    }
    /////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Construct an MTMeterProp with the specified name and PropertyType
    /// </summary>
    /// <param name="sName"></param>
    /// <param name="eType"></param>
    public MTMeterProp(string sName, PropertyType eType)
    {
      msName = sName;
      base.Text = msName;
      randomGenerator = new Random(DateTime.Now.Millisecond);
      meType = eType;
      msMSIXType = "unistring";

      SetDefaults();
    }
    /////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Construct an MTMeterProp with the specified name, property type, and
    /// related MSIX type.
    /// </summary>
    /// <param name="sName"></param>
    /// <param name="eType"></param>
    /// <param name="sMSIXType"></param>
    public MTMeterProp(string sText, PropertyType eType, string sMSIXType)
    {
      msName = sText;
      base.Text = msName;
      randomGenerator = new Random(DateTime.Now.Millisecond);
      meType = eType;
      msMSIXType = sMSIXType;

      SetDefaults();
    }

    /// <summary>
    /// Set default values for most of the member variables
    /// </summary>
    private void SetDefaults()
    {
      msMSIXLength = "";
      msMSIXDescription ="";
      msPropertyString = "";
      msMSIXRequired = "";
      msMSIXDefaultValue = "";

      mintMinSessions = 1;
      mintMaxSessions = 1;

      moMinValue = (string)"";
      moMaxValue = (string)"";
      moGeneratedValue = (string)"";

      msFloor = "";
      msCeiling = "";
      msPropEquals = "";

      msPluginName = "";

      mbAdditionalData = false;
      mbGreaterThan = false;
      mbLessThan = false;
      msGreaterThan = "";
      msLessThan = "";

			mbPropertyStringRandom = true;
			mintPropertyStringIndex = 0;
    }
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Name of the MTMeterProp
    /// </summary>
    public new string Name
    {
      get
      {
        return msName;
      }
      
      set
      {
        msName = value;
        base.Text = msName;
      }
    }
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Length property for the MTMeterProp
    /// </summary>
    public string MSIXLength
    {
      get
      {
        return msMSIXLength;
      }
      
      set
      {
        msMSIXLength = value;
      }
    }
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Default value of the related MSIX property
    /// </summary>
    public string MSIXDefaultValue
    {
      get
      {
        return msMSIXDefaultValue;
      }
      
      set
      {
        msMSIXDefaultValue = value;
      }
    }
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// String representation of the MSIX required property
    /// </summary>
    public string MSIXRequired
    {
      get
      {
        return msMSIXRequired;
      }
      
      set
      {
        msMSIXRequired = value;
      }
    }
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// MSIX description
    /// </summary>
    public string MSIXDescription
    {
      get
      {
        return msMSIXDescription;
      }
      
      set
      {
        msMSIXDescription = value;
      }
    }
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Property string used to determine random values.
    /// </summary>
    public string PropertyString
    {
      get
      {
        return msPropertyString;
      }

      set
      {
        msPropertyString = value;
      }
    }
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Property type for the MTMeterProp. (Read Only)
    /// </summary>
    public PropertyType Type
    {
      get
      {
        return meType;
      }
    }

    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Type of the related MSIX property.  (Read Only)
    /// </summary>
    public string MSIXType
    {
      get
      {
        return msMSIXType;
      }
    }
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Minimum number of sessions to meter (Applies only if PropertyType == SESSION)
    /// </summary>
    public int MinSessions
    {
      get
      {
        return mintMinSessions;
      }
      set
      {
        if(value >= 0)
          mintMinSessions = value;
      }
    }
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Maximum number of sessions to meter (Applies only if PropertyType == SESSION
    /// </summary>
    public int MaxSessions
    {
      get
      {
        return mintMaxSessions;
      }
      set
      {
        if(value >= 0)
          mintMaxSessions = value;
      }
    }
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Type of value generated by the property.
    /// </summary>
    public ValueType ValueType
    {
      get
      {
        return meValueType;
      }
      set
      {
        meValueType = value;
      }
    }
    /////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    private object ConvertStringToTypedValue(string sInput, string sType)
    {
			if (sInput == null)
				return null;

      object objReturn = null;

      //Convert the input string to the proper typed value
       switch(sType.ToLower())
      {
        case "string":
        case "unistring":
        case "enum":
          objReturn = sInput;
          break;

        case "int32":
          objReturn = int.Parse(sInput);
          break;

        case "int64":
          objReturn = long.Parse(sInput);
          break;

        case "boolean":
           //Specially handle many possible boolean values
          if(String.Compare(sInput, "T", true) == 0 ||
            String.Compare(sInput, "1", true) == 0 ||
            String.Compare(sInput, "true", true) == 0 ||
            String.Compare(sInput, "Y", true) == 0 ||
            String.Compare(sInput, "Yes", true) == 0)
            objReturn = (bool)true;
          else
            objReturn = (bool)false;
          break;
    
        case "timestamp":
          objReturn = DateTime.Parse(sInput);
          break;

        case "double":
        case "decimal":
        case "float":
          objReturn = double.Parse(sInput);
          break;

        default:
        {
          System.Exception oErr = new System.Exception("Unknown MSIX Type!  Unable to convert to typed value");
          throw oErr;
        }

      }
      return(objReturn);
    }

    /////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Return a string representation of the mininum value, which
    /// may be a string, date, double, etc.
    /// </summary>
    public string MinValue
    {
      get
      {
        return moMinValue.ToString();
      }
      set
      {
        try
        {
          moMinValue = ConvertStringToTypedValue(value, msMSIXType);
        }
        catch
        {
          //Don't change the value
        }
      }
    }
    /////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// String representation of the maximum value.
    /// </summary>
    public string MaxValue
    {
      get
      {
        return moMaxValue.ToString();
      }
      set
      {
        try
        {
          moMaxValue = ConvertStringToTypedValue(value, msMSIXType);
        }
        catch
        {
          //Do nothing
        }
      }
    }

    /////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Floor value when determining value range
    /// </summary>
    public string Floor
    {
      get
      {
        return msFloor;
      }
      set
      {
        msFloor = value;
      }
    }

   /////////////////////////////////////////////////////////////////////////
   /////////////////////////////////////////////////////////////////////////
   /// <summary>
   /// Ceiling when determining value range
   /// </summary>
    public string Ceiling
    {
      get
      {
        return msCeiling;
      }
      set
      {
        msCeiling = value;
      }
    }
    /////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Related property to set this property's generated value equal to
    /// </summary>
    public string PropEquals
    {
      get
      {
        return msPropEquals;
      }
      set
      {
        msPropEquals = value;
      }
    }

    public bool AdditionalData
    {
      get
      {
        return mbAdditionalData;
      }
      set
      {
        mbAdditionalData = value;
      }
    }

    public bool GreaterThan
    {
      get
      {
        return mbGreaterThan;
      }
      set
      {
        mbGreaterThan = value;
      }
    }

    public bool LessThan
    {
      get
      {
        return mbLessThan;
      }
      set
      {
        mbLessThan = value;
      }
    }

		public bool PropertyStringRandom
		{
			get
			{
				return mbPropertyStringRandom;
			}
			set
			{
				mbPropertyStringRandom = value;
			}
		}

    public string GreaterThanProp
    {
      get
      {
        return msGreaterThan;
      }
      set
      {
        msGreaterThan = value;
      }
    }

    public string LessThanProp
    {
      get
      {
        return msLessThan;
      }
      set
      {
        msLessThan = value;
      }
    }

    public string PluginName
    {
      get
      {
        return msPluginName;
      }
      set
      {
        msPluginName = value;
      }
    }

    /////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Return the typed, generated random value for this property.
    /// </summary>
    /// <returns>Typed, Random value</returns>
    public object GetGeneratedValue()
    {
      return moGeneratedValue;
    }

    /////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Generate a new random value.
    /// </summary>
    public void GenerateValue()
    {
      //Do nothing if this property isn't going to be metered
      if(meValueType == ValueType.NOT_METERED)
        return;

      moGeneratedValue = ConvertStringToTypedValue(GetRandomValue(), msMSIXType);
    }

    /// <summary>
    /// Get the value of another session property that is related to this one.  Currently
    /// supports parent relationships.  [parent.AudioConferenceID]
    /// </summary>
    /// <param name="sProperty">Property whose value to get.</param>
    /// <returns>Value of the property</returns>
    public string GetRelatedValue(string sProperty)
    {
      //Remove any wacky brackets
      if(sProperty.StartsWith("["))
        sProperty = sProperty.Remove(0, 1);

      if(sProperty.EndsWith("]"))
        sProperty = sProperty.Remove(sProperty.Length - 1, 1);


       //1:  See if we need to go to the parent
      if(sProperty.StartsWith("parent."))
      {
        //Get the parent
        MTMeterProp oParent;
        oParent = (MTMeterProp)this.Parent;

        //Strip the property
        sProperty = sProperty.Remove(0, ((string)(".parent")).Length);
        return oParent.GetRelatedValue(sProperty);
      } 
      else 
      {
        //Check for sibling property
        foreach(MTMeterProp oMeterType in this.Parent.Nodes)
        {
          if(String.Compare(oMeterType.Name, sProperty, true) == 0)
            return(oMeterType.GetGeneratedValue().ToString());
        }
      }

      // Property Doesn't exist... return ""
      return("");
    }

		private string GetNextPropertyStringSequentialValue()
		{
			string[] values = msPropertyString.Split(seps);
			
      long index = mintPropertyStringIndex;

      mintPropertyStringIndex++;

      if (mintPropertyStringIndex >= values.Length)
        mintPropertyStringIndex = 0;

      return values[index].Trim();
		}

    /// <summary>
    /// Generate and return a random value that conforms to the parameters entered by the user.
    /// </summary>
    /// <returns>String representation of the random value</returns>
    private string GetRandomValue()
    {	
      // Step 1: Split current UI property values
      if(meValueType == ValueType.PROPERTY_STRING)
      {
        string sValue;

				if (mbPropertyStringRandom)
				{
					string[] values = msPropertyString.Split(seps);
					int randomIndex = randomGenerator.Next(0, values.Length);
					sValue = values[randomIndex].Trim();
				}
				else
				{
					sValue = GetNextPropertyStringSequentialValue();
				}

        //Check for keywords
	    int nPos;
		//PropertyBag SmokeTestProperties = null;

        if(sValue.IndexOf("[now]") >= 0)
          sValue = sValue.Replace("[now]", DateTime.Now.ToString());

        if(sValue.IndexOf("[metratime]") >= 0)
          sValue = sValue.Replace("[metratime]", MetraTech.MetraTime.Now.ToString());

        if(sValue.IndexOf("[ticks]") >= 0)
          sValue = sValue.Replace("[ticks]", DateTime.Now.Ticks.ToString());
		
		if((nPos=sValue.IndexOf("[propertybag.")) >= 0)
		{
			if (mSmokeTestProperties==null)
			{
				mSmokeTestProperties  = new PropertyBag();
				mSmokeTestProperties.Initialize("SmokeTest");
			}

			  int nPos2 = sValue.IndexOf("]",nPos+1);
			  string sPropBagKey = sValue.Substring(nPos+13,nPos2-(nPos+13));
			  
		      object oTemp = mSmokeTestProperties[sPropBagKey];
			  if (oTemp==null)
			  {
				throw new Exception("Unable to retrieve property bag value for " + sPropBagKey);
			  }

			  sValue = sValue.Substring(0,nPos) + oTemp.ToString() + sValue.Substring(nPos2+1);
			  
		}

        return sValue;
      }
      else if(meValueType == ValueType.PLUGIN)
      {
        // EXECUTE PLUGIN
        return ExecutePlugin();
      }
      else if(meValueType == ValueType.VALUE_RANGE)
      {
        SetIntersectionValues(moMinValue, moMaxValue);
        return(GetValueFromRange(moTempMin.ToString(), moTempMax.ToString()));
      }

      else if(meValueType == ValueType.PROP_EQUALS)
      {
        //Strip brackets
        return GetRelatedValue(msPropEquals);
      }
      else if(meValueType == ValueType.BETWEEN)
      {
        string sFloor = GetRelatedValue(msFloor);
        string sCeiling = GetRelatedValue(msCeiling);

        //Now check additional criteria
        object oFloor = ConvertStringToTypedValue(sFloor, msMSIXType);
        object oCeiling = ConvertStringToTypedValue(sCeiling, msMSIXType);

        SetIntersectionValues(oFloor, oCeiling);

        return GetValueFromRange(moTempMin.ToString(), moTempMax.ToString());
      }
      return("");
    }

    /// <summary>
    /// ExecutePlugin - executes user defined plugin.  If the plugin for this property is not yet
    /// loaded then it is created.  If this property is called again then the plugin is taken from 
    /// memory.
    /// </summary>
    /// <returns>value from plugin</returns>
    private string ExecutePlugin()
    {
      string sValue = msPluginName.Trim();

      //Remove any wacky brackets
      if(sValue.StartsWith("["))
        sValue = sValue.Remove(0, 1);
      if(sValue.EndsWith("]"))
        sValue = sValue.Remove(sValue.Length - 1, 1);

      // Load and run Plugin 
      if(mPlugin == null)
      {
        string sAss = sValue.Substring(0, sValue.LastIndexOf("."));
        string sPlugin = sValue.Remove(0, sAss.Length + 1);
        Type ObjType = null;
        IPlugin ipi;
        // load the plugin dll
        try
        {
          Assembly ass = null;
          ass = Assembly.Load(sAss);
          if (ass != null)
          {
            ObjType = ass.GetType(sAss + "." + sPlugin);
          }
        }
        catch (Exception exp)
        {
          System.Windows.Forms.MessageBox.Show(exp.Message.ToString());
          if(exp.InnerException != null)
            System.Windows.Forms.MessageBox.Show(exp.InnerException.Message.ToString());
        }

        try
        {
          // OK Lets create plugin
          if (ObjType != null)
          {
            ipi = (IPlugin)Activator.CreateInstance(ObjType);
            ipi.Host = this;
              
            // Run plugin
            sValue = ipi.Run(this);
          }
        }
        catch (Exception exp)
        {
          System.Windows.Forms.MessageBox.Show(exp.Message.ToString());
          if(exp.InnerException != null)
            System.Windows.Forms.MessageBox.Show(exp.InnerException.Message.ToString());
        }
      }
      else
      {
        try
        {
          sValue = mPlugin.Run(this);
        }
        catch (Exception exp)
        {
          System.Windows.Forms.MessageBox.Show(exp.Message.ToString());
          if(exp.InnerException != null)
            System.Windows.Forms.MessageBox.Show(exp.InnerException.Message.ToString());
        }
      }
      return sValue;
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="oRefValue"></param>
    private void SetIntersectionValues(object oRefMinValue, object oRefMaxValue)
    {
      string sGreater;
      object oGreater = "";

      string sLess;
      object oLess = "";

      //Get the greater-than value
      if(mbGreaterThan)
      {
        sGreater = GetRelatedValue(msGreaterThan);
        oGreater = ConvertStringToTypedValue(sGreater, msMSIXType);
        if(CompareTypedValues(oGreater, oRefMaxValue, msMSIXType) == 1)
        {
          Exception oErr = new Exception("Conflict:  Instructed to make value greater than max value!");
          throw oErr;
        }
      }

      //Get the less-than value
      if(mbLessThan)
      {
        sLess = GetRelatedValue(msLessThan);
        oLess = ConvertStringToTypedValue(sLess, msMSIXType);
        if(CompareTypedValues(oLess, oRefMinValue, msMSIXType) == - 1)
        {
          Exception oErr = new Exception("Conflict:  Instructed to make value less than min value!");
          throw oErr;
        }

      }

      //This is right...think about it
      if(mbGreaterThan && mbLessThan)
      {
        if(CompareTypedValues(oGreater, oLess, msMSIXType) == 1)
        {
          Exception oErr = new Exception("Conflict:  Instructed to make value greater than and less than a given value!");
          throw oErr;
        }
      }

      //Set the values to use for the range
      //If the less_than value is less than the maximum value, then it should
      //be the upperbound
      if(mbLessThan && CompareTypedValues(oLess, oRefMaxValue, msMSIXType) == -1)
        moTempMax = oLess;
      else
        moTempMax = oRefMaxValue;

      //If the greater_than value is greater than the minimum value, then it
      //should be the lower bound
      if(mbGreaterThan && CompareTypedValues(oGreater, oRefMinValue, msMSIXType) == 1)
        moTempMin = oGreater;
      else
        moTempMin = oRefMinValue;
    }

    /// <summary>
    /// Perform a comparision of the two objects, based on the MSIX type.
    /// </summary>
    /// <param name="oVal1">First Value</param>
    /// <param name="oVal2">Second Value</param>
    /// <param name="sType">Type of values</param>
    /// <returns><![CDATA[-1 if oVal1 > oVal2, 0  if oVal1 = oVal2, 1 if oVal1 < oVal2]]></returns>
    private int CompareTypedValues(object oVal1, object oVal2, string sType)
    {
      int nReturn;
      switch(sType.ToLower())
      {
        case "string":
        case "unistring":
        case "enum":
          int iResult = String.Compare(oVal1.ToString(), oVal2.ToString());

          if(iResult > 0)
            return(1);
          else if(iResult == 0)
            nReturn = 0;
          else
            nReturn = -1;

          break;

        case "int32":
          int iVal1 = int.Parse(oVal1.ToString());
          int iVal2 = int.Parse(oVal2.ToString());

          if(iVal1 > iVal2)
            nReturn = 1;
          else if(iVal1 == iVal2)
            nReturn = 0;
          else
            nReturn = -1;
          break;

        case "int64":
          long lVal1 = long.Parse(oVal1.ToString());
          long lVal2 = long.Parse(oVal2.ToString());

          if(lVal1 > lVal2)
            nReturn = 1;
          else if(lVal1 == lVal2)
            nReturn = 0;
          else
            nReturn = -1;
          break;

        case "timestamp":
          DateTime dVal1 = DateTime.Parse(oVal1.ToString());
          DateTime dVal2 = DateTime.Parse(oVal2.ToString());

          if(dVal1 > dVal2)
            nReturn = 1;
          else if(dVal1 == dVal2)
            nReturn = 0;
          else
            nReturn =-1;
          break;

        case "double":
        case "decimal":
        case "float":
          double dblVal1 = double.Parse(oVal1.ToString());
          double dblVal2 = double.Parse(oVal2.ToString());

          if(dblVal1 > dblVal2)
            nReturn = 1;
          else if(dblVal1 == dblVal2)
            nReturn = 0;
          else
            nReturn = -1;
          break;

        default:
        {
          if(sType.ToLower() == "boolean")
          {
            Exception bErr = new Exception("Unable to compare boolean types!");
            throw bErr;
          }

          Exception dErr = new Exception("Unknown MSIX Type!  Unable to convert to typed value");
          throw dErr;
        }
      }
      return(nReturn);
    }
    
    
    /// <summary>
    /// Generate a value falling in the specified range.
    /// </summary>
    /// <param name="sStart">String representation of the floor</param>
    /// <param name="sEnd">String representation of the ceiling</param>
    /// <returns>String representation of the random value</returns>
    private string GetValueFromRange(string sStart, string sEnd)
    {
      double dblRandom;
      string sReturn = "";

      switch(msMSIXType.ToLower())
      {
        case "int32":
          sReturn = randomGenerator.Next(int.Parse(sStart), int.Parse(sEnd)).ToString();
          break;

        case "int64":
          long r = ((uint)randomGenerator.Next()) | (((uint)randomGenerator.Next()) << 32);
          sReturn = (r % (long.Parse(sEnd) - long.Parse(sStart)) + long.Parse(sStart)).ToString(); 
          break;

        case "timestamp":
          DateTime oMin;
          DateTime oMax;
          DateTime oReturn;

          oMin = DateTime.Parse(sStart);
          oMax = DateTime.Parse(sEnd);

          dblRandom = randomGenerator.NextDouble();

          oReturn = new DateTime((long)(oMin.Ticks + (dblRandom * (oMax.Ticks - oMin.Ticks))));

          sReturn = oReturn.ToString();
          break;

        case "double":
        case "decimal":
        case "float":
          dblRandom = randomGenerator.NextDouble();
          double dblReturn = double.Parse(sStart) + (dblRandom * (double.Parse(sEnd) - double.Parse(sStart)));
          sReturn = dblReturn.ToString();
          break;
      }

      return(sReturn);
    }
    /////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Load the MTMeterProp from an XML file
    /// </summary>
    /// <param name="oNode"></param>
    public void DeSerialize(XmlNode oNode)
    {
      //Handle session and property a little differently
      if(String.Compare(oNode.Name, "session", true) == 0)
      {
        MTMeterProp oChildMeterProp;
        XmlNode oTempNode;

        meType = PropertyType.SESSION;

        //Name
        oTempNode = oNode.SelectSingleNode("name");
        msName = oTempNode.InnerText;
        base.Text = msName;

        //Description
        oTempNode = oNode.SelectSingleNode("description");
        if(oTempNode != null)
          msMSIXDescription = oTempNode.InnerText;

        //Min sessions
        oTempNode = oNode.SelectSingleNode("min_sessions");
        if(oTempNode != null)
          mintMinSessions = int.Parse(oTempNode.InnerText);

        //Max sessions
        oTempNode = oNode.SelectSingleNode("max_sessions");
        if(oTempNode != null)
          mintMaxSessions = int.Parse(oTempNode.InnerText);

        //Load Properties
        foreach(XmlNode oPropertyNode in oNode.SelectNodes("properties/property"))
        {
          oChildMeterProp = new MTMeterProp();
          oChildMeterProp.DeSerialize(oPropertyNode);
          Nodes.Add(oChildMeterProp);
        }         

        //Load Sessions
        foreach(XmlNode oSessionNode in oNode.SelectNodes("sessions/session"))
        {
          oChildMeterProp = new MTMeterProp();
          oChildMeterProp.DeSerialize(oSessionNode);
          Nodes.Add(oChildMeterProp);
        }
      }
      else
      {
        //Load property information
        XmlNode oTempNode;

        meType = PropertyType.PROPERTY;

        //Name
        oTempNode = oNode.SelectSingleNode("name");
        msName = oTempNode.InnerText;
        base.Text = msName;

        //MSIX Type
        oTempNode = oNode.SelectSingleNode("msix_type");
        msMSIXType = oTempNode.InnerText;

        //Description
        oTempNode = oNode.SelectSingleNode("description");
        if(oTempNode != null)
          msMSIXDescription = oTempNode.InnerText;

        //Value type
        oTempNode = oNode.SelectSingleNode("value_type");
        if(oTempNode != null)
        {
          if(string.Compare(oTempNode.InnerText, "property_string", true) == 0)
            meValueType = ValueType.PROPERTY_STRING;
          else if(string.Compare(oTempNode.InnerText, "between", true) == 0)
            meValueType = ValueType.BETWEEN;
          else if(string.Compare(oTempNode.InnerText, "not_metered", true) == 0)
            meValueType = ValueType.NOT_METERED;
          else if(string.Compare(oTempNode.InnerText, "prop_equals", true) == 0)
            meValueType = ValueType.PROP_EQUALS;
          else if(string.Compare(oTempNode.InnerText, "plugin", true) == 0)
            meValueType = ValueType.PLUGIN;
          else
            meValueType = ValueType.VALUE_RANGE;
        }
        else
          meValueType = ValueType.PROPERTY_STRING;
    
        //Default Value   
        oTempNode = oNode.SelectSingleNode("default_value");
        if(oTempNode != null)
          msMSIXDefaultValue = oTempNode.InnerText;

        //Property String
        oTempNode = oNode.SelectSingleNode("property_string");
        if(oTempNode != null)
          msPropertyString = oTempNode.InnerText;

				oTempNode = oNode.SelectSingleNode("property_string_random");
				if(oTempNode != null)
				{
					if(string.Compare(oTempNode.InnerText, "True") == 0)
						mbPropertyStringRandom = true;
					else
						mbPropertyStringRandom = false;
				}

        //Length
        oTempNode = oNode.SelectSingleNode("length");
        if(oTempNode != null)
          msMSIXLength = oTempNode.InnerText;

        //Required
        oTempNode = oNode.SelectSingleNode("required");
        if(oTempNode != null)
          msMSIXRequired = oTempNode.InnerText;

        //Description
        oTempNode = oNode.SelectSingleNode("description");
        if(oTempNode != null)
          msMSIXDescription = oTempNode.InnerText;

        //Min Value
        oTempNode = oNode.SelectSingleNode("min_value");
        if(oTempNode != null)
          MinValue = oTempNode.InnerText;

        //Max Value
        oTempNode = oNode.SelectSingleNode("max_value");
        if(oTempNode != null)
          MaxValue = oTempNode.InnerText;

        //Floor
        oTempNode = oNode.SelectSingleNode("floor");
        if(oTempNode != null)
          msFloor = oTempNode.InnerText;

        //Ceiling
        oTempNode = oNode.SelectSingleNode("ceiling");
        if(oTempNode != null)
          msCeiling = oTempNode.InnerText;

        //PropEquals
        oTempNode = oNode.SelectSingleNode("prop_equals");
        if(oTempNode != null)
          msPropEquals = oTempNode.InnerText;

        //Plugin
        oTempNode = oNode.SelectSingleNode("plugin");
        if(oTempNode != null)
          msPluginName = oTempNode.InnerText;

        //Additional Data
        //Additional Enabled
        oTempNode = oNode.SelectSingleNode("additional_data/additional_data_enabled");
        if(oTempNode != null)
        {
          if(string.Compare(oTempNode.InnerText, "True") == 0)
            mbAdditionalData = true;
          else
            mbAdditionalData = false;
        }

        //Greater than
        oTempNode = oNode.SelectSingleNode("additional_data/greater_than_enabled");
        if(oTempNode != null)
        {
          if(string.Compare(oTempNode.InnerText, "True") == 0)
            mbGreaterThan = true;
          else
            mbGreaterThan = false;
        }

        oTempNode = oNode.SelectSingleNode("additional_data/greater_than_prop");
        if(oTempNode != null)
          msGreaterThan = oTempNode.InnerText;
        
        //Less than
        oTempNode = oNode.SelectSingleNode("additional_data/less_than_enabled");
        if(oTempNode != null)
        {
          if(string.Compare(oTempNode.InnerText, "True") == 0)
            mbLessThan = true;
          else
            mbLessThan = false;
        }

        oTempNode = oNode.SelectSingleNode("additional_data/less_than_prop");
        if(oTempNode != null)
          msLessThan = oTempNode.InnerText;


        //If required set the color in the tree to red
        if(msMSIXRequired.ToUpper() == "Y")
          ForeColor = System.Drawing.Color.Red;

      }
    }
    /////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Serialize this data into XML format and attach it to the parent
    /// </summary>
    /// <param name="oParentNode"></param>
    public void Serialize(XmlNode oParentNode)
    {
      //Handle case of session or property
      if(meType == PropertyType.SESSION)
      {
        XmlNode oSessionNode;
        XmlNode oSessionsNode;
        XmlNode oPropertiesNode;
        XmlNode oTempNode;
        
        oSessionNode = oParentNode.OwnerDocument.CreateElement("session");

        //Name
        oTempNode = oParentNode.OwnerDocument.CreateElement("name");
        oTempNode.InnerText = msName;
        oSessionNode.AppendChild(oTempNode);

        //Add description
        oTempNode = oParentNode.OwnerDocument.CreateElement("description");
        oTempNode.InnerText = msMSIXDescription;
        oSessionNode.AppendChild(oTempNode);

        //Add min sessions
        oTempNode = oParentNode.OwnerDocument.CreateElement("min_sessions");
        oTempNode.InnerText = mintMinSessions.ToString();
        oSessionNode.AppendChild(oTempNode);

        //Add max sessions
        oTempNode = oParentNode.OwnerDocument.CreateElement("max_sessions");
        oTempNode.InnerText = mintMaxSessions.ToString();
        oSessionNode.AppendChild(oTempNode);

        //Add Properties & sessions
        oPropertiesNode = oParentNode.OwnerDocument.CreateElement("properties");
        oSessionsNode = oParentNode.OwnerDocument.CreateElement("sessions");

        foreach(MTMeterProp oChildProp in Nodes)
        {
          if(oChildProp.Type == PropertyType.SESSION)
            oChildProp.Serialize(oSessionsNode);
          else
            oChildProp.Serialize(oPropertiesNode);
        }

        //Add the sessions and properties to the session
        oSessionNode.AppendChild(oPropertiesNode);
        oSessionNode.AppendChild(oSessionsNode);

        //Add to the parent
        oParentNode.AppendChild(oSessionNode);
      }
      else
      {
        //Add property values
        XmlNode oPropertyNode;
        XmlNode oXMLNode;

        oPropertyNode = oParentNode.OwnerDocument.CreateElement("property");

        //Name
        oXMLNode = oParentNode.OwnerDocument.CreateElement("name");
        oXMLNode.InnerText = msName;
        oPropertyNode.AppendChild(oXMLNode);

        //Type String
        oXMLNode = oParentNode.OwnerDocument.CreateElement("msix_type");
        oXMLNode.InnerText = msMSIXType;
        oPropertyNode.AppendChild(oXMLNode);

        //Value Type
        oXMLNode = oParentNode.OwnerDocument.CreateElement("value_type");

        switch(meValueType)
        {
          case ValueType.PROPERTY_STRING:
            oXMLNode.InnerText = "property_string";
            break;
          case ValueType.BETWEEN:
            oXMLNode.InnerText = "between";
            break;
          case ValueType.NOT_METERED:
            oXMLNode.InnerText = "not_metered";
            break;
          case ValueType.PROP_EQUALS:
            oXMLNode.InnerText = "prop_equals";
            break;
          case ValueType.VALUE_RANGE:
            oXMLNode.InnerText = "value_range";
            break;
          case ValueType.PLUGIN:
            oXMLNode.InnerText = "plugin";
            break;
        }

        oPropertyNode.AppendChild(oXMLNode);

        //Property String
        if(msPropertyString.Length > 0)
        {
          oXMLNode = oParentNode.OwnerDocument.CreateElement("property_string");
          oXMLNode.InnerText = msPropertyString;
          oPropertyNode.AppendChild(oXMLNode);
        }

				//Property String Random
				oXMLNode = oParentNode.OwnerDocument.CreateElement("property_string_random");
				if(mbPropertyStringRandom)
					oXMLNode.InnerText = "True";
				else
					oXMLNode.InnerText = "False";
				oPropertyNode.AppendChild(oXMLNode);


        //Default Value
        if(msMSIXDefaultValue.Length > 0)
        {
          oXMLNode = oParentNode.OwnerDocument.CreateElement("default_value");
          oXMLNode.InnerText = msMSIXDefaultValue;
          oPropertyNode.AppendChild(oXMLNode);
        }

        //Length
        if(msMSIXLength.Length > 0)
        {
          oXMLNode = oParentNode.OwnerDocument.CreateElement("length");
          oXMLNode.InnerText = msMSIXLength;
          oPropertyNode.AppendChild(oXMLNode);
        }

        //Description
        if(msMSIXDescription.Length > 0)
        {
          oXMLNode = oParentNode.OwnerDocument.CreateElement("description");
          oXMLNode.InnerText = msMSIXDescription;
          oPropertyNode.AppendChild(oXMLNode);
        }

        //Required
        if(msMSIXRequired.Length> 0)
        {
          oXMLNode = oParentNode.OwnerDocument.CreateElement("required");
          oXMLNode.InnerText = msMSIXRequired;
          oPropertyNode.AppendChild(oXMLNode);
        }

        //Min Value
        if(moMinValue.ToString().Length > 0)
        {
          oXMLNode = oParentNode.OwnerDocument.CreateElement("min_value");
          oXMLNode.InnerText = moMinValue.ToString();
          oPropertyNode.AppendChild(oXMLNode);
        }

        //Max Value
        if(moMaxValue.ToString().Length > 0)
        {
          oXMLNode = oParentNode.OwnerDocument.CreateElement("max_value");
          oXMLNode.InnerText = moMaxValue.ToString();
          oPropertyNode.AppendChild(oXMLNode);
        }

        //Floor
        if(msFloor.Length > 0)
        {
          oXMLNode = oParentNode.OwnerDocument.CreateElement("floor");
          oXMLNode.InnerText = msFloor;
          oPropertyNode.AppendChild(oXMLNode);
        }

        //Ceiling
        if(msCeiling.Length > 0)
        {
          oXMLNode = oParentNode.OwnerDocument.CreateElement("ceiling");
          oXMLNode.InnerText = msCeiling;
          oPropertyNode.AppendChild(oXMLNode);
        }

        //PropEquals
        if(msPropEquals.Length > 0)
        {
          oXMLNode = oParentNode.OwnerDocument.CreateElement("prop_equals");
          oXMLNode.InnerText = msPropEquals.ToString();
          oPropertyNode.AppendChild(oXMLNode);
        }

        //Plugin
        if(msPluginName.Length > 0)
        {
          oXMLNode = oParentNode.OwnerDocument.CreateElement("plugin");
          oXMLNode.InnerText = msPluginName.ToString();
          oPropertyNode.AppendChild(oXMLNode);
        }

        //Additional Data
        XmlNode oAdditionalDataNode;
        oAdditionalDataNode = oParentNode.OwnerDocument.CreateElement("additional_data");
        
        oXMLNode = oParentNode.OwnerDocument.CreateElement("additional_data_enabled");
        if(mbAdditionalData)
          oXMLNode.InnerText = "True";
        else
          oXMLNode.InnerText = "False";
        oAdditionalDataNode.AppendChild(oXMLNode);
        

        //Greater than
        oXMLNode = oParentNode.OwnerDocument.CreateElement("greater_than_enabled");
        if(mbGreaterThan)
          oXMLNode.InnerText = "True";
        else
          oXMLNode.InnerText = "False";
        oAdditionalDataNode.AppendChild(oXMLNode);

        if(msGreaterThan.Length > 0)
        {
          oXMLNode = oParentNode.OwnerDocument.CreateElement("greater_than_prop");
          oXMLNode.InnerText = msGreaterThan.ToString();
          oAdditionalDataNode.AppendChild(oXMLNode);
        }

        //Less Than
        oXMLNode = oParentNode.OwnerDocument.CreateElement("less_than_enabled");
        if(mbLessThan)
          oXMLNode.InnerText = "True";
        else
          oXMLNode.InnerText = "False";
        oAdditionalDataNode.AppendChild(oXMLNode);

        if(msLessThan.Length > 0)
        {
          oXMLNode = oParentNode.OwnerDocument.CreateElement("greater_than_prop");
          oXMLNode.InnerText = msLessThan.ToString();
          oAdditionalDataNode.AppendChild(oXMLNode);
        }




        oPropertyNode.AppendChild(oAdditionalDataNode);

        oParentNode.AppendChild(oPropertyNode);
      }
    }
  }
}

