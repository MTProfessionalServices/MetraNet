<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>public class Subscription</title>
<link rel="stylesheet" rev="stylesheet" href="style.css" type="text/css">
</head>
<body>
<div class="upLinks">
<a href="index.html">Index</a> |
	  Namespace <a href="namespace-RabbitMQ.Client.MessagePatterns.html">RabbitMQ.Client.MessagePatterns</a>
</div>
<h1>public class Subscription</h1>
<ul>
<li>implements <code><code><span class="nonlocalTypeLink" title="System.IDisposable">IDisposable</span></code></code>
</li>
<li>implements <code><code><span class="nonlocalTypeLink" title="System.Collections.IEnumerable">IEnumerable</span></code></code>
</li>
<li>implements <code><code><span class="nonlocalTypeLink" title="System.Collections.IEnumerator">IEnumerator</span></code></code>
</li>
</ul>
<div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Manages a subscription to a queue or exchange.</div>
</div>
<div class="fullDoc">
<h4>Remarks</h4>
<div class="fullDocBody">
<p>
             This convenience class abstracts away from much of the detail
             involved in receiving messages from a queue or an exchange.
            </p>
<p>
             Once created, the Subscription consumes from a queue (using a
             QueueingBasicConsumer). Received deliveries can be retrieved
             by calling Next(), or by using the Subscription as an
             IEnumerator in, for example, a foreach loop.
            </p>
<p>
             Note that if the "noAck" option is enabled (which it is by
             default), then received deliveries are automatically acked
             within the server before they are even transmitted across the
             network to us. Calling Ack() on received events will always do
             the right thing: if "noAck" is enabled, nothing is done on an
             Ack() call, and if "noAck" is disabled, IModel.BasicAck() is
             called with the correct parameters.
            </p>
</div>
</div>
<h2>Property Summary</h2>
<table class="propertySummaryTable">
<tr>
<th class="propertyFlagsHeader">Flags</th>
<th class="propertyTypeHeader">Type</th>
<th class="propertyNameHeader">Name</th>
<th class="propertySummaryHeader">Summary</th>
</tr>
<tr>
<td class="propertyFlags">public </td>
<td class="propertyType"><code><a class="localTypeLink" title="RabbitMQ.Client.IBasicConsumer" href="type-RabbitMQ.Client.IBasicConsumer.html">IBasicConsumer</a></code></td>
<td class="propertyName">
<a href="#property-P:RabbitMQ.Client.MessagePatterns.Subscription.Consumer"><code>Consumer</code></a><span class="propertyAccessibility"> (r)</span>
</td>
<td class="propertySummary"><p class="docSummary documented">Retrieve the IBasicConsumer that is receiving the
            messages from the server for us. Normally, you will not
            need to access this property - use Next() and friends
            instead.</p></td>
</tr>
<tr>
<td class="propertyFlags">public </td>
<td class="propertyType"><code><code><span class="nonlocalTypeLink" title="System.String">string</span></code></code></td>
<td class="propertyName">
<a href="#property-P:RabbitMQ.Client.MessagePatterns.Subscription.ConsumerTag"><code>ConsumerTag</code></a><span class="propertyAccessibility"> (r)</span>
</td>
<td class="propertySummary"><p class="docSummary documented">Retrieve the consumer-tag that this subscription
            is using. Will usually be a server-generated
            name.</p></td>
</tr>
<tr>
<td class="propertyFlags">public </td>
<td class="propertyType"><code><a class="localTypeLink" title="RabbitMQ.Client.Events.BasicDeliverEventArgs" href="type-RabbitMQ.Client.Events.BasicDeliverEventArgs.html">BasicDeliverEventArgs</a></code></td>
<td class="propertyName">
<a href="#property-P:RabbitMQ.Client.MessagePatterns.Subscription.LatestEvent"><code>LatestEvent</code></a><span class="propertyAccessibility"> (r)</span>
</td>
<td class="propertySummary"><p class="docSummary documented">Returns the most recent value returned by Next(),
            or null when either no values have been retrieved yet, the
            end of the subscription has been reached, or the most
            recent value has already been Ack()ed. See also the
            documentation for Ack().</p></td>
</tr>
<tr>
<td class="propertyFlags">public </td>
<td class="propertyType"><code><a class="localTypeLink" title="RabbitMQ.Client.IModel" href="type-RabbitMQ.Client.IModel.html">IModel</a></code></td>
<td class="propertyName">
<a href="#property-P:RabbitMQ.Client.MessagePatterns.Subscription.Model"><code>Model</code></a><span class="propertyAccessibility"> (r)</span>
</td>
<td class="propertySummary"><p class="docSummary documented">Retrieve the IModel our subscription is carried by.</p></td>
</tr>
<tr>
<td class="propertyFlags">public </td>
<td class="propertyType"><code><code><span class="nonlocalTypeLink" title="System.Boolean">bool</span></code></code></td>
<td class="propertyName">
<a href="#property-P:RabbitMQ.Client.MessagePatterns.Subscription.NoAck"><code>NoAck</code></a><span class="propertyAccessibility"> (r)</span>
</td>
<td class="propertySummary"><p class="docSummary documented">Returns true if we are in "noAck" mode, where
            calls to Ack() will be no-ops, and where the server acks
            messages before they are delivered to us. Returns false if
            we are in a mode where calls to Ack() are required, and
            where such calls will actually send an acknowledgement
            message across the network to the server.</p></td>
</tr>
<tr>
<td class="propertyFlags">public </td>
<td class="propertyType"><code><code><span class="nonlocalTypeLink" title="System.String">string</span></code></code></td>
<td class="propertyName">
<a href="#property-P:RabbitMQ.Client.MessagePatterns.Subscription.QueueName"><code>QueueName</code></a><span class="propertyAccessibility"> (r)</span>
</td>
<td class="propertySummary"><p class="docSummary documented">Retrieve the queue name we have subscribed to.</p></td>
</tr>
</table>
<h2>Constructor Summary</h2>
<table class="methodSummaryTable">
<tr>
<th class="methodFlagsHeader">Flags</th>
<th class="methodNameHeader">Name</th>
<th class="methodSummaryHeader">Summary</th>
</tr>
<tr>
<td class="methodFlags">public </td>
<td class="methodName"><a href="#method-M:RabbitMQ.Client.MessagePatterns.Subscription.#ctor(RabbitMQ.Client.IModel,System.String,System.Boolean)"><code>Subscription(<span class="parameterType">IModel</span> model, <span class="parameterType">string</span> queueName, <span class="parameterType">bool</span> noAck)
  </code></a></td>
<td class="methodSummary"><p class="docSummary documented">Creates a new Subscription, with full control over
            both "noAck" mode and the name of the queue.</p></td>
</tr>
<tr>
<td class="methodFlags">public </td>
<td class="methodName"><a href="#method-M:RabbitMQ.Client.MessagePatterns.Subscription.#ctor(RabbitMQ.Client.IModel,System.String)"><code>Subscription(<span class="parameterType">IModel</span> model, <span class="parameterType">string</span> queueName)
  </code></a></td>
<td class="methodSummary"><p class="docSummary documented">Creates a new Subscription in "noAck" mode,
            consuming from a named queue.</p></td>
</tr>
</table>
<h2>Method Summary</h2>
<table class="methodSummaryTable">
<tr>
<th class="methodFlagsHeader">Flags</th>
<th class="methodNameHeader">Name</th>
<th class="methodSummaryHeader">Summary</th>
</tr>
<tr>
<td class="methodFlags">public </td>
<td class="methodName"><a href="#method-M:RabbitMQ.Client.MessagePatterns.Subscription.Ack"><code>void Ack()
  </code></a></td>
<td class="methodSummary"><p class="docSummary documented">If LatestEvent is non-null, passes it to
            Ack(BasicDeliverEventArgs). Causes LatestEvent to become
            null.</p></td>
</tr>
<tr>
<td class="methodFlags">public </td>
<td class="methodName"><a href="#method-M:RabbitMQ.Client.MessagePatterns.Subscription.Ack(RabbitMQ.Client.Events.BasicDeliverEventArgs)"><code>void Ack(<span class="parameterType">BasicDeliverEventArgs</span> evt)
  </code></a></td>
<td class="methodSummary"><p class="docSummary documented">If we are not in "noAck" mode, calls
            IModel.BasicAck with the delivery-tag from the passed in
            event; otherwise, sends nothing to the server. In both
            cases, if the passed-in event is the same as LatestEvent
            (by pointer comparison), sets LatestEvent to
            null.</p></td>
</tr>
<tr>
<td class="methodFlags">public </td>
<td class="methodName"><a href="#method-M:RabbitMQ.Client.MessagePatterns.Subscription.Close"><code>void Close()
  </code></a></td>
<td class="methodSummary"><p class="docSummary documented">Closes this Subscription, cancelling the consumer
            record in the server.</p></td>
</tr>
<tr>
<td class="methodFlags">public </td>
<td class="methodName"><a href="#method-M:RabbitMQ.Client.MessagePatterns.Subscription.Next(System.Int32,RabbitMQ.Client.Events.BasicDeliverEventArgs@)"><code>bool Next(<span class="parameterType">int</span> millisecondsTimeout, <span class="parameterType parameterDirectionOut">out BasicDeliverEventArgs</span> result)
  </code></a></td>
<td class="methodSummary"><p class="docSummary documented">Retrieves the next incoming delivery in our
            subscription queue, or times out after a specified number
            of milliseconds.</p></td>
</tr>
<tr>
<td class="methodFlags">public </td>
<td class="methodName"><a href="#method-M:RabbitMQ.Client.MessagePatterns.Subscription.Next"><code>BasicDeliverEventArgs Next()
  </code></a></td>
<td class="methodSummary"><p class="docSummary documented">Retrieves the next incoming delivery in our
            subscription queue.</p></td>
</tr>
</table>
<h2>Property Detail</h2>
<div class="propertyDetail">
<a name="property-P:RabbitMQ.Client.MessagePatterns.Subscription.Consumer"></a><h3>public IBasicConsumer Consumer<span class="propertyAccessibility"> (r)</span>
</h3>
<div class="propertyDoc"><div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Retrieve the IBasicConsumer that is receiving the
            messages from the server for us. Normally, you will not
            need to access this property - use Next() and friends
            instead.</div>
</div></div>
</div>
<div class="propertyDetail">
<a name="property-P:RabbitMQ.Client.MessagePatterns.Subscription.ConsumerTag"></a><h3>public string ConsumerTag<span class="propertyAccessibility"> (r)</span>
</h3>
<div class="propertyDoc"><div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Retrieve the consumer-tag that this subscription
            is using. Will usually be a server-generated
            name.</div>
</div></div>
</div>
<div class="propertyDetail">
<a name="property-P:RabbitMQ.Client.MessagePatterns.Subscription.LatestEvent"></a><h3>public BasicDeliverEventArgs LatestEvent<span class="propertyAccessibility"> (r)</span>
</h3>
<div class="propertyDoc"><div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Returns the most recent value returned by Next(),
            or null when either no values have been retrieved yet, the
            end of the subscription has been reached, or the most
            recent value has already been Ack()ed. See also the
            documentation for Ack().</div>
</div></div>
</div>
<div class="propertyDetail">
<a name="property-P:RabbitMQ.Client.MessagePatterns.Subscription.Model"></a><h3>public IModel Model<span class="propertyAccessibility"> (r)</span>
</h3>
<div class="propertyDoc"><div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Retrieve the IModel our subscription is carried by.</div>
</div></div>
</div>
<div class="propertyDetail">
<a name="property-P:RabbitMQ.Client.MessagePatterns.Subscription.NoAck"></a><h3>public bool NoAck<span class="propertyAccessibility"> (r)</span>
</h3>
<div class="propertyDoc"><div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Returns true if we are in "noAck" mode, where
            calls to Ack() will be no-ops, and where the server acks
            messages before they are delivered to us. Returns false if
            we are in a mode where calls to Ack() are required, and
            where such calls will actually send an acknowledgement
            message across the network to the server.</div>
</div></div>
</div>
<div class="propertyDetail">
<a name="property-P:RabbitMQ.Client.MessagePatterns.Subscription.QueueName"></a><h3>public string QueueName<span class="propertyAccessibility"> (r)</span>
</h3>
<div class="propertyDoc"><div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Retrieve the queue name we have subscribed to.</div>
</div></div>
</div>
<h2>Constructor Detail</h2>
<div class="methodDetail">
<a name="method-M:RabbitMQ.Client.MessagePatterns.Subscription.#ctor(RabbitMQ.Client.IModel,System.String,System.Boolean)"></a><h3>Subscription</h3>
<p><code>public </code><code>Subscription(<span class="parameterType">IModel</span> model, <span class="parameterType">string</span> queueName, <span class="parameterType">bool</span> noAck)
  </code></p>
<table class="methodDetailTable"><tr>
<th class="parametersHeader">Parameters</th>
<td class="parameters"><table class="parametersTable">
<tr>
<th class="parameterNameHeader">Name</th>
<th class="parameterTypeHeader">Type</th>
</tr>
<tr>
<td class="parameterName">model</td>
<td class="parameterType"><span class="parameterType"><code><a class="localTypeLink" title="RabbitMQ.Client.IModel" href="type-RabbitMQ.Client.IModel.html">IModel</a></code></span></td>
</tr>
<tr>
<td class="parameterName">queueName</td>
<td class="parameterType"><span class="parameterType"><code><code><span class="nonlocalTypeLink" title="System.String">string</span></code></code></span></td>
</tr>
<tr>
<td class="parameterName">noAck</td>
<td class="parameterType"><span class="parameterType"><code><code><span class="nonlocalTypeLink" title="System.Boolean">bool</span></code></code></span></td>
</tr>
</table></td>
</tr></table>
<div class="methodDetailDoc"><div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Creates a new Subscription, with full control over
            both "noAck" mode and the name of the queue.</div>
</div></div>
</div>
<div class="methodDetail">
<a name="method-M:RabbitMQ.Client.MessagePatterns.Subscription.#ctor(RabbitMQ.Client.IModel,System.String)"></a><h3>Subscription</h3>
<p><code>public </code><code>Subscription(<span class="parameterType">IModel</span> model, <span class="parameterType">string</span> queueName)
  </code></p>
<table class="methodDetailTable"><tr>
<th class="parametersHeader">Parameters</th>
<td class="parameters"><table class="parametersTable">
<tr>
<th class="parameterNameHeader">Name</th>
<th class="parameterTypeHeader">Type</th>
</tr>
<tr>
<td class="parameterName">model</td>
<td class="parameterType"><span class="parameterType"><code><a class="localTypeLink" title="RabbitMQ.Client.IModel" href="type-RabbitMQ.Client.IModel.html">IModel</a></code></span></td>
</tr>
<tr>
<td class="parameterName">queueName</td>
<td class="parameterType"><span class="parameterType"><code><code><span class="nonlocalTypeLink" title="System.String">string</span></code></code></span></td>
</tr>
</table></td>
</tr></table>
<div class="methodDetailDoc"><div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Creates a new Subscription in "noAck" mode,
            consuming from a named queue.</div>
</div></div>
</div>
<h2>Method Detail</h2>
<div class="methodDetail">
<a name="method-M:RabbitMQ.Client.MessagePatterns.Subscription.Ack"></a><h3>Ack</h3>
<p><code>public </code><code>void Ack()
  </code></p>
<table class="methodDetailTable">
<tr>
<th class="methodFlagsHeader">Flags</th>
<td class="methodFlags">public </td>
</tr>
<tr>
<th class="returnTypeHeader">Return type</th>
<td class="returnType"><code><code><span class="nonlocalTypeLink" title="System.Void">void</span></code></code></td>
</tr>
</table>
<div class="methodDetailDoc"><div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">If LatestEvent is non-null, passes it to
            Ack(BasicDeliverEventArgs). Causes LatestEvent to become
            null.</div>
</div></div>
</div>
<div class="methodDetail">
<a name="method-M:RabbitMQ.Client.MessagePatterns.Subscription.Ack(RabbitMQ.Client.Events.BasicDeliverEventArgs)"></a><h3>Ack</h3>
<p><code>public </code><code>void Ack(<span class="parameterType">BasicDeliverEventArgs</span> evt)
  </code></p>
<table class="methodDetailTable">
<tr>
<th class="methodFlagsHeader">Flags</th>
<td class="methodFlags">public </td>
</tr>
<tr>
<th class="returnTypeHeader">Return type</th>
<td class="returnType"><code><code><span class="nonlocalTypeLink" title="System.Void">void</span></code></code></td>
</tr>
<tr>
<th class="parametersHeader">Parameters</th>
<td class="parameters"><table class="parametersTable">
<tr>
<th class="parameterNameHeader">Name</th>
<th class="parameterTypeHeader">Type</th>
</tr>
<tr>
<td class="parameterName">evt</td>
<td class="parameterType"><span class="parameterType"><code><a class="localTypeLink" title="RabbitMQ.Client.Events.BasicDeliverEventArgs" href="type-RabbitMQ.Client.Events.BasicDeliverEventArgs.html">BasicDeliverEventArgs</a></code></span></td>
</tr>
</table></td>
</tr>
</table>
<div class="methodDetailDoc">
<div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">If we are not in "noAck" mode, calls
            IModel.BasicAck with the delivery-tag from the passed in
            event; otherwise, sends nothing to the server. In both
            cases, if the passed-in event is the same as LatestEvent
            (by pointer comparison), sets LatestEvent to
            null.</div>
</div>
<div class="fullDoc">
<h4>Remarks</h4>
<div class="fullDocBody">
             Make sure that this method is only called with events that
             originated from this Subscription - other usage will have
             unpredictable results.
            </div>
</div>
</div>
</div>
<div class="methodDetail">
<a name="method-M:RabbitMQ.Client.MessagePatterns.Subscription.Close"></a><h3>Close</h3>
<p><code>public </code><code>void Close()
  </code></p>
<table class="methodDetailTable">
<tr>
<th class="methodFlagsHeader">Flags</th>
<td class="methodFlags">public </td>
</tr>
<tr>
<th class="returnTypeHeader">Return type</th>
<td class="returnType"><code><code><span class="nonlocalTypeLink" title="System.Void">void</span></code></code></td>
</tr>
</table>
<div class="methodDetailDoc"><div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Closes this Subscription, cancelling the consumer
            record in the server.</div>
</div></div>
</div>
<div class="methodDetail">
<a name="method-M:RabbitMQ.Client.MessagePatterns.Subscription.Next(System.Int32,RabbitMQ.Client.Events.BasicDeliverEventArgs@)"></a><h3>Next</h3>
<p><code>public </code><code>bool Next(<span class="parameterType">int</span> millisecondsTimeout, <span class="parameterType parameterDirectionOut">out BasicDeliverEventArgs</span> result)
  </code></p>
<table class="methodDetailTable">
<tr>
<th class="methodFlagsHeader">Flags</th>
<td class="methodFlags">public </td>
</tr>
<tr>
<th class="returnTypeHeader">Return type</th>
<td class="returnType"><code><code><span class="nonlocalTypeLink" title="System.Boolean">bool</span></code></code></td>
</tr>
<tr>
<th class="parametersHeader">Parameters</th>
<td class="parameters"><table class="parametersTable">
<tr>
<th class="parameterNameHeader">Name</th>
<th class="parameterTypeHeader">Type</th>
</tr>
<tr>
<td class="parameterName">millisecondsTimeout</td>
<td class="parameterType"><span class="parameterType"><code><code><span class="nonlocalTypeLink" title="System.Int32">int</span></code></code></span></td>
</tr>
<tr>
<td class="parameterName">result</td>
<td class="parameterType"><span class="parameterType parameterDirectionOut"><code>out </code><code><a class="localTypeLink" title="RabbitMQ.Client.Events.BasicDeliverEventArgs" href="type-RabbitMQ.Client.Events.BasicDeliverEventArgs.html">BasicDeliverEventArgs</a></code></span></td>
</tr>
</table></td>
</tr>
</table>
<div class="methodDetailDoc">
<div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Retrieves the next incoming delivery in our
            subscription queue, or times out after a specified number
            of milliseconds.</div>
</div>
<div class="fullDoc">
<h4>Remarks</h4>
<div class="fullDocBody">
<p>
             Returns false only if the timeout expires before either a
             delivery appears or the end-of-stream is reached. If false
             is returned, the out parameter "result" is set to null,
             but LatestEvent is not updated.
            </p>
<p>
             Returns true to indicate a delivery or the end-of-stream.
            </p>
<p>
             If a delivery is already waiting in the queue, or one
             arrives before the timeout expires, it is removed from the
             queue and placed in the "result" out parameter. If the
             end-of-stream is detected before the timeout expires,
             "result" is set to null.
            </p>
<p>
             Whenever this method returns true, it updates LatestEvent
             to the value placed in "result" before returning.
            </p>
<p>
             End-of-stream can arise through the action of the
             Subscription.Close() method, or through the closure of the
             IModel or its underlying IConnection.
            </p>
<p>
             This method does not acknowledge any deliveries at all
             (but in "noAck" mode, the server will have
             auto-acknowledged each event before it is even sent across
             the wire to us).
            </p>
<p>
             A timeout of -1 (i.e. System.Threading.Timeout.Infinite)
             will be interpreted as a command to wait for an
             indefinitely long period of time for an item or the end of
             the stream to become available. Usage of such a timeout is
             equivalent to calling Next() with no arguments (modulo
             predictable method signature differences).
            </p>
</div>
</div>
</div>
</div>
<div class="methodDetail">
<a name="method-M:RabbitMQ.Client.MessagePatterns.Subscription.Next"></a><h3>Next</h3>
<p><code>public </code><code>BasicDeliverEventArgs Next()
  </code></p>
<table class="methodDetailTable">
<tr>
<th class="methodFlagsHeader">Flags</th>
<td class="methodFlags">public </td>
</tr>
<tr>
<th class="returnTypeHeader">Return type</th>
<td class="returnType"><code><a class="localTypeLink" title="RabbitMQ.Client.Events.BasicDeliverEventArgs" href="type-RabbitMQ.Client.Events.BasicDeliverEventArgs.html">BasicDeliverEventArgs</a></code></td>
</tr>
</table>
<div class="methodDetailDoc">
<div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Retrieves the next incoming delivery in our
            subscription queue.</div>
</div>
<div class="fullDoc">
<h4>Remarks</h4>
<div class="fullDocBody">
<p>
             Returns null when the end of the stream is reached and on
             every subsequent call. End-of-stream can arise through the
             action of the Subscription.Close() method, or through the
             closure of the IModel or its underlying IConnection.
            </p>
<p>
             Updates LatestEvent to the value returned.
            </p>
<p>
             Does not acknowledge any deliveries at all (but in "noAck"
             mode, the server will have auto-acknowledged each event
             before it is even sent across the wire to us).
            </p>
</div>
</div>
</div>
</div>
</body>
</html>
