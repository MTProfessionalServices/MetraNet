<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>public class SimpleRpcServer</title>
<link rel="stylesheet" rev="stylesheet" href="style.css" type="text/css">
</head>
<body>
<div class="upLinks">
<a href="index.html">Index</a> |
	  Namespace <a href="namespace-RabbitMQ.Client.MessagePatterns.html">RabbitMQ.Client.MessagePatterns</a>
</div>
<h1>public class SimpleRpcServer</h1>
<ul><li>implements <code><code><span class="nonlocalTypeLink" title="System.IDisposable">IDisposable</span></code></code>
</li></ul>
<div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Implements a simple RPC service, responding to
            requests received via a Subscription.</div>
</div>
<div class="fullDoc">
<h4>Remarks</h4>
<div class="fullDocBody">
<p>
             This class interprets requests such as those sent by instances
             of SimpleRpcClient.
            </p>
<p>
             The basic pattern for implementing a service is to subclass
             SimpleRpcServer, overriding HandleCall and HandleCast as
             appropriate, and then to create a Subscription object for
             receiving requests from clients, and start an instance of the
             SimpleRpcServer subclass with the Subscription.
            </p>
<div class="example"><pre class="code">
            	string queueName = "ServiceRequestQueue"; // See also Subscription ctors
            	using (IConnection conn = new ConnectionFactory()
            	                                .CreateConnection(serverAddress)) {
            	    using (IModel ch = conn.CreateModel()) {
            	        Subscription sub = new Subscription(ch, queueName);
            	        new MySimpleRpcServerSubclass(sub).MainLoop();
            	    }
            	}
            </pre></div>
<p>
             Note that this class itself does not declare any resources
             (exchanges, queues or bindings). The Subscription we use for
             receiving RPC requests should have already declared all the
             resources we need. See the Subscription constructors and the
             Subscription.Bind method.
            </p>
<p>
             If you are implementing a service that responds to
             "jms/stream-message"-formatted requests (as implemented by
             RabbitMQ.Client.Content.IStreamMessageReader), override
             HandleStreamMessageCall. Otherwise, override HandleSimpleCall
             or HandleCall as appropriate. Asynchronous, one-way requests
             are dealt with by HandleCast etc.
            </p>
<p>
             Every time a request is successfully received and processed
             within the server's MainLoop, the request message is Ack()ed
             using Subscription.Ack before the next request is
             retrieved. This causes the Subscription object to take care of
             acknowledging receipt and processing of the request message.
            </p>
<p>
             If transactional service is enabled, via SetTransactional(),
             then after every successful ProcessRequest, IModel.TxCommit is
             called. Making use of transactional service has effects on all
             parts of the application that share an IModel instance,
             completely changing the style of interaction with the AMQP
             server. For this reason, it is initially disabled, and must be
             explicitly enabled with a call to SetTransactional(). Please
             see the documentation for SetTransactional() for details.
            </p>
<p>
             To stop a running RPC server, call Close(). This will in turn
             Close() the Subscription, which will cause MainLoop() to
             return to its caller.
            </p>
<p>
             Unless overridden, ProcessRequest examines properties in the
             request content header, and uses them to dispatch to one of
             the Handle[...]() methods. See the documentation for
             ProcessRequest and each Handle[...] method for details.
            </p>
</div>
</div>
<div class="fullDoc seeAlso">
<h4>See</h4>
<div class="fullDocBody"><ul><li><code><a class="localTypeLink" title="RabbitMQ.Client.MessagePatterns.SimpleRpcClient" href="type-RabbitMQ.Client.MessagePatterns.SimpleRpcClient.html">RabbitMQ.Client.MessagePatterns.SimpleRpcClient</a></code></li></ul></div>
</div>
<h2>Property Summary</h2>
<table class="propertySummaryTable">
<tr>
<th class="propertyFlagsHeader">Flags</th>
<th class="propertyTypeHeader">Type</th>
<th class="propertyNameHeader">Name</th>
<th class="propertySummaryHeader">Summary</th>
</tr>
<tr>
<td class="propertyFlags">public </td>
<td class="propertyType"><code><code><span class="nonlocalTypeLink" title="System.Boolean">bool</span></code></code></td>
<td class="propertyName">
<a href="#property-P:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.Transactional"><code>Transactional</code></a><span class="propertyAccessibility"> (r)</span>
</td>
<td class="propertySummary"><p class="docSummary documented">Returns true if we are in "transactional" mode, or
            false if we are not.</p></td>
</tr>
</table>
<h2>Constructor Summary</h2>
<table class="methodSummaryTable">
<tr>
<th class="methodFlagsHeader">Flags</th>
<th class="methodNameHeader">Name</th>
<th class="methodSummaryHeader">Summary</th>
</tr>
<tr>
<td class="methodFlags">public </td>
<td class="methodName"><a href="#method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.#ctor(RabbitMQ.Client.MessagePatterns.Subscription)"><code>SimpleRpcServer(<span class="parameterType">Subscription</span> subscription)
  </code></a></td>
<td class="methodSummary"><p class="docSummary documented">Create, but do not start, an instance that will
            receive requests via the given Subscription.</p></td>
</tr>
</table>
<h2>Method Summary</h2>
<table class="methodSummaryTable">
<tr>
<th class="methodFlagsHeader">Flags</th>
<th class="methodNameHeader">Name</th>
<th class="methodSummaryHeader">Summary</th>
</tr>
<tr>
<td class="methodFlags">public </td>
<td class="methodName"><a href="#method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.Close"><code>void Close()
  </code></a></td>
<td class="methodSummary"><p class="docSummary documented">Shut down the server, causing MainLoop() to return
            to its caller.</p></td>
</tr>
<tr>
<td class="methodFlags">public virtual </td>
<td class="methodName"><a href="#method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.HandleCall(System.Boolean,RabbitMQ.Client.IBasicProperties,System.Byte%5B%5D,RabbitMQ.Client.IBasicProperties@)"><code>byte[] HandleCall(<span class="parameterType">bool</span> isRedelivered, <span class="parameterType">IBasicProperties</span> requestProperties, <span class="parameterType">byte[]</span> body, <span class="parameterType parameterDirectionOut">out IBasicProperties</span> replyProperties)
  </code></a></td>
<td class="methodSummary"><p class="docSummary documented">Called by ProcessRequest(), this is the most
            general method that handles RPC-style requests.</p></td>
</tr>
<tr>
<td class="methodFlags">public virtual </td>
<td class="methodName"><a href="#method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.HandleCast(System.Boolean,RabbitMQ.Client.IBasicProperties,System.Byte%5B%5D)"><code>void HandleCast(<span class="parameterType">bool</span> isRedelivered, <span class="parameterType">IBasicProperties</span> requestProperties, <span class="parameterType">byte[]</span> body)
  </code></a></td>
<td class="methodSummary"><p class="docSummary documented">Called by ProcessRequest(), this is the most
            general method that handles asynchronous, one-way
            requests.</p></td>
</tr>
<tr>
<td class="methodFlags">public virtual </td>
<td class="methodName"><a href="#method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.HandleSimpleCall(System.Boolean,RabbitMQ.Client.IBasicProperties,System.Byte%5B%5D,RabbitMQ.Client.IBasicProperties@)"><code>byte[] HandleSimpleCall(<span class="parameterType">bool</span> isRedelivered, <span class="parameterType">IBasicProperties</span> requestProperties, <span class="parameterType">byte[]</span> body, <span class="parameterType parameterDirectionOut">out IBasicProperties</span> replyProperties)
  </code></a></td>
<td class="methodSummary"><p class="docSummary documented">Called by the default HandleCall() implementation
            as a fallback.</p></td>
</tr>
<tr>
<td class="methodFlags">public virtual </td>
<td class="methodName"><a href="#method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.HandleSimpleCast(System.Boolean,RabbitMQ.Client.IBasicProperties,System.Byte%5B%5D)"><code>void HandleSimpleCast(<span class="parameterType">bool</span> isRedelivered, <span class="parameterType">IBasicProperties</span> requestProperties, <span class="parameterType">byte[]</span> body)
  </code></a></td>
<td class="methodSummary"><p class="docSummary documented">Called by the default HandleCast() implementation
            as a fallback.</p></td>
</tr>
<tr>
<td class="methodFlags">public virtual </td>
<td class="methodName"><a href="#method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.HandleStreamMessageCall(RabbitMQ.Client.Content.IStreamMessageBuilder,System.Boolean,RabbitMQ.Client.IBasicProperties,System.Object%5B%5D)"><code>void HandleStreamMessageCall(<span class="parameterType">IStreamMessageBuilder</span> replyWriter, <span class="parameterType">bool</span> isRedelivered, <span class="parameterType">IBasicProperties</span> requestProperties, <span class="parameterType">object[]</span> args)
  </code></a></td>
<td class="methodSummary"><p class="docSummary documented">Called by HandleCall and HandleCast when a
            "jms/stream-message" request is received.</p></td>
</tr>
<tr>
<td class="methodFlags">public </td>
<td class="methodName"><a href="#method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.MainLoop"><code>void MainLoop()
  </code></a></td>
<td class="methodSummary"><p class="docSummary documented">Enters the main loop of the RPC service.</p></td>
</tr>
<tr>
<td class="methodFlags">public virtual </td>
<td class="methodName"><a href="#method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.ProcessRequest(RabbitMQ.Client.Events.BasicDeliverEventArgs)"><code>void ProcessRequest(<span class="parameterType">BasicDeliverEventArgs</span> evt)
  </code></a></td>
<td class="methodSummary"><p class="docSummary documented">Process a single request received from our
            subscription.</p></td>
</tr>
<tr>
<td class="methodFlags">public </td>
<td class="methodName"><a href="#method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.SetTransactional"><code>void SetTransactional()
  </code></a></td>
<td class="methodSummary"><p class="docSummary documented">Enables transactional mode.</p></td>
</tr>
</table>
<h2>Property Detail</h2>
<div class="propertyDetail">
<a name="property-P:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.Transactional"></a><h3>public bool Transactional<span class="propertyAccessibility"> (r)</span>
</h3>
<div class="propertyDoc"><div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Returns true if we are in "transactional" mode, or
            false if we are not.</div>
</div></div>
</div>
<h2>Constructor Detail</h2>
<div class="methodDetail">
<a name="method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.#ctor(RabbitMQ.Client.MessagePatterns.Subscription)"></a><h3>SimpleRpcServer</h3>
<p><code>public </code><code>SimpleRpcServer(<span class="parameterType">Subscription</span> subscription)
  </code></p>
<table class="methodDetailTable"><tr>
<th class="parametersHeader">Parameters</th>
<td class="parameters"><table class="parametersTable">
<tr>
<th class="parameterNameHeader">Name</th>
<th class="parameterTypeHeader">Type</th>
</tr>
<tr>
<td class="parameterName">subscription</td>
<td class="parameterType"><span class="parameterType"><code><a class="localTypeLink" title="RabbitMQ.Client.MessagePatterns.Subscription" href="type-RabbitMQ.Client.MessagePatterns.Subscription.html">Subscription</a></code></span></td>
</tr>
</table></td>
</tr></table>
<div class="methodDetailDoc">
<div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Create, but do not start, an instance that will
            receive requests via the given Subscription.</div>
</div>
<div class="fullDoc">
<h4>Remarks</h4>
<div class="fullDocBody">
<p>
             The instance is initially in non-transactional mode. See
             SetTransactional().
            </p>
<p>
             Call MainLoop() to start the request-processing loop.
            </p>
</div>
</div>
</div>
</div>
<h2>Method Detail</h2>
<div class="methodDetail">
<a name="method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.Close"></a><h3>Close</h3>
<p><code>public </code><code>void Close()
  </code></p>
<table class="methodDetailTable">
<tr>
<th class="methodFlagsHeader">Flags</th>
<td class="methodFlags">public </td>
</tr>
<tr>
<th class="returnTypeHeader">Return type</th>
<td class="returnType"><code><code><span class="nonlocalTypeLink" title="System.Void">void</span></code></code></td>
</tr>
</table>
<div class="methodDetailDoc">
<div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Shut down the server, causing MainLoop() to return
            to its caller.</div>
</div>
<div class="fullDoc">
<h4>Remarks</h4>
<div class="fullDocBody">
             Acts by calling Close() on the server's Subscription object.
            </div>
</div>
</div>
</div>
<div class="methodDetail">
<a name="method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.HandleCall(System.Boolean,RabbitMQ.Client.IBasicProperties,System.Byte%5B%5D,RabbitMQ.Client.IBasicProperties@)"></a><h3>HandleCall</h3>
<p><code>public virtual </code><code>byte[] HandleCall(<span class="parameterType">bool</span> isRedelivered, <span class="parameterType">IBasicProperties</span> requestProperties, <span class="parameterType">byte[]</span> body, <span class="parameterType parameterDirectionOut">out IBasicProperties</span> replyProperties)
  </code></p>
<table class="methodDetailTable">
<tr>
<th class="methodFlagsHeader">Flags</th>
<td class="methodFlags">public virtual </td>
</tr>
<tr>
<th class="returnTypeHeader">Return type</th>
<td class="returnType"><code><code><span class="nonlocalTypeLink" title="System.Byte">byte[]</span></code></code></td>
</tr>
<tr>
<th class="parametersHeader">Parameters</th>
<td class="parameters"><table class="parametersTable">
<tr>
<th class="parameterNameHeader">Name</th>
<th class="parameterTypeHeader">Type</th>
</tr>
<tr>
<td class="parameterName">isRedelivered</td>
<td class="parameterType"><span class="parameterType"><code><code><span class="nonlocalTypeLink" title="System.Boolean">bool</span></code></code></span></td>
</tr>
<tr>
<td class="parameterName">requestProperties</td>
<td class="parameterType"><span class="parameterType"><code><a class="localTypeLink" title="RabbitMQ.Client.IBasicProperties" href="type-RabbitMQ.Client.IBasicProperties.html">IBasicProperties</a></code></span></td>
</tr>
<tr>
<td class="parameterName">body</td>
<td class="parameterType"><span class="parameterType"><code><code><span class="nonlocalTypeLink" title="System.Byte">byte[]</span></code></code></span></td>
</tr>
<tr>
<td class="parameterName">replyProperties</td>
<td class="parameterType"><span class="parameterType parameterDirectionOut"><code>out </code><code><a class="localTypeLink" title="RabbitMQ.Client.IBasicProperties" href="type-RabbitMQ.Client.IBasicProperties.html">IBasicProperties</a></code></span></td>
</tr>
</table></td>
</tr>
</table>
<div class="methodDetailDoc">
<div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Called by ProcessRequest(), this is the most
            general method that handles RPC-style requests.</div>
</div>
<div class="fullDoc">
<h4>Remarks</h4>
<div class="fullDocBody">
<p>
             This method should map requestProperties and body to
             replyProperties and the returned byte array.
            </p>
<p>
             The default implementation checks
             requestProperties.ContentType, and if it is
             "jms/stream-message" (i.e. the current value of
             StreamMessageBuilder.MimeType), parses it using
             StreamMessageReader and delegates to
             HandleStreamMessageCall before encoding and returning the
             reply. If the ContentType is any other value, the request
             is passed to HandleSimpleCall instead.
            </p>
<p>
             The isRedelivered flag is true when the server knows for
             sure that it has tried to send this request previously
             (although not necessarily to this application). It is not
             a reliable indicator of previous receipt, however - the
             only claim it makes is that a delivery attempt was made,
             not that the attempt succeeded. Be careful if you choose
             to use the isRedelivered flag.
            </p>
</div>
</div>
</div>
</div>
<div class="methodDetail">
<a name="method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.HandleCast(System.Boolean,RabbitMQ.Client.IBasicProperties,System.Byte%5B%5D)"></a><h3>HandleCast</h3>
<p><code>public virtual </code><code>void HandleCast(<span class="parameterType">bool</span> isRedelivered, <span class="parameterType">IBasicProperties</span> requestProperties, <span class="parameterType">byte[]</span> body)
  </code></p>
<table class="methodDetailTable">
<tr>
<th class="methodFlagsHeader">Flags</th>
<td class="methodFlags">public virtual </td>
</tr>
<tr>
<th class="returnTypeHeader">Return type</th>
<td class="returnType"><code><code><span class="nonlocalTypeLink" title="System.Void">void</span></code></code></td>
</tr>
<tr>
<th class="parametersHeader">Parameters</th>
<td class="parameters"><table class="parametersTable">
<tr>
<th class="parameterNameHeader">Name</th>
<th class="parameterTypeHeader">Type</th>
</tr>
<tr>
<td class="parameterName">isRedelivered</td>
<td class="parameterType"><span class="parameterType"><code><code><span class="nonlocalTypeLink" title="System.Boolean">bool</span></code></code></span></td>
</tr>
<tr>
<td class="parameterName">requestProperties</td>
<td class="parameterType"><span class="parameterType"><code><a class="localTypeLink" title="RabbitMQ.Client.IBasicProperties" href="type-RabbitMQ.Client.IBasicProperties.html">IBasicProperties</a></code></span></td>
</tr>
<tr>
<td class="parameterName">body</td>
<td class="parameterType"><span class="parameterType"><code><code><span class="nonlocalTypeLink" title="System.Byte">byte[]</span></code></code></span></td>
</tr>
</table></td>
</tr>
</table>
<div class="methodDetailDoc">
<div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Called by ProcessRequest(), this is the most
            general method that handles asynchronous, one-way
            requests.</div>
</div>
<div class="fullDoc">
<h4>Remarks</h4>
<div class="fullDocBody">
<p>
             The default implementation checks
             requestProperties.ContentType, and if it is
             "jms/stream-message" (i.e. the current value of
             StreamMessageBuilder.MimeType), parses it using
             StreamMessageReader and delegates to
             HandleStreamMessageCall, passing in null as the
             replyWriter parameter to indicate that no reply is desired
             or possible. If the ContentType is any other value, the
             request is passed to HandleSimpleCast instead.
            </p>
<p>
             The isRedelivered flag is true when the server knows for
             sure that it has tried to send this request previously
             (although not necessarily to this application). It is not
             a reliable indicator of previous receipt, however - the
             only claim it makes is that a delivery attempt was made,
             not that the attempt succeeded. Be careful if you choose
             to use the isRedelivered flag.
            </p>
</div>
</div>
</div>
</div>
<div class="methodDetail">
<a name="method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.HandleSimpleCall(System.Boolean,RabbitMQ.Client.IBasicProperties,System.Byte%5B%5D,RabbitMQ.Client.IBasicProperties@)"></a><h3>HandleSimpleCall</h3>
<p><code>public virtual </code><code>byte[] HandleSimpleCall(<span class="parameterType">bool</span> isRedelivered, <span class="parameterType">IBasicProperties</span> requestProperties, <span class="parameterType">byte[]</span> body, <span class="parameterType parameterDirectionOut">out IBasicProperties</span> replyProperties)
  </code></p>
<table class="methodDetailTable">
<tr>
<th class="methodFlagsHeader">Flags</th>
<td class="methodFlags">public virtual </td>
</tr>
<tr>
<th class="returnTypeHeader">Return type</th>
<td class="returnType"><code><code><span class="nonlocalTypeLink" title="System.Byte">byte[]</span></code></code></td>
</tr>
<tr>
<th class="parametersHeader">Parameters</th>
<td class="parameters"><table class="parametersTable">
<tr>
<th class="parameterNameHeader">Name</th>
<th class="parameterTypeHeader">Type</th>
</tr>
<tr>
<td class="parameterName">isRedelivered</td>
<td class="parameterType"><span class="parameterType"><code><code><span class="nonlocalTypeLink" title="System.Boolean">bool</span></code></code></span></td>
</tr>
<tr>
<td class="parameterName">requestProperties</td>
<td class="parameterType"><span class="parameterType"><code><a class="localTypeLink" title="RabbitMQ.Client.IBasicProperties" href="type-RabbitMQ.Client.IBasicProperties.html">IBasicProperties</a></code></span></td>
</tr>
<tr>
<td class="parameterName">body</td>
<td class="parameterType"><span class="parameterType"><code><code><span class="nonlocalTypeLink" title="System.Byte">byte[]</span></code></code></span></td>
</tr>
<tr>
<td class="parameterName">replyProperties</td>
<td class="parameterType"><span class="parameterType parameterDirectionOut"><code>out </code><code><a class="localTypeLink" title="RabbitMQ.Client.IBasicProperties" href="type-RabbitMQ.Client.IBasicProperties.html">IBasicProperties</a></code></span></td>
</tr>
</table></td>
</tr>
</table>
<div class="methodDetailDoc">
<div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Called by the default HandleCall() implementation
            as a fallback.</div>
</div>
<div class="fullDoc">
<h4>Remarks</h4>
<div class="fullDocBody">
             If the MIME ContentType of the request did not match any
             of the types specially recognised
             (e.g. "jms/stream-message"), this method is called instead
             with the raw bytes of the request. It should fill in
             replyProperties (or set it to null) and return a byte
             array to send back to the remote caller as a reply
             message.
            </div>
</div>
</div>
</div>
<div class="methodDetail">
<a name="method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.HandleSimpleCast(System.Boolean,RabbitMQ.Client.IBasicProperties,System.Byte%5B%5D)"></a><h3>HandleSimpleCast</h3>
<p><code>public virtual </code><code>void HandleSimpleCast(<span class="parameterType">bool</span> isRedelivered, <span class="parameterType">IBasicProperties</span> requestProperties, <span class="parameterType">byte[]</span> body)
  </code></p>
<table class="methodDetailTable">
<tr>
<th class="methodFlagsHeader">Flags</th>
<td class="methodFlags">public virtual </td>
</tr>
<tr>
<th class="returnTypeHeader">Return type</th>
<td class="returnType"><code><code><span class="nonlocalTypeLink" title="System.Void">void</span></code></code></td>
</tr>
<tr>
<th class="parametersHeader">Parameters</th>
<td class="parameters"><table class="parametersTable">
<tr>
<th class="parameterNameHeader">Name</th>
<th class="parameterTypeHeader">Type</th>
</tr>
<tr>
<td class="parameterName">isRedelivered</td>
<td class="parameterType"><span class="parameterType"><code><code><span class="nonlocalTypeLink" title="System.Boolean">bool</span></code></code></span></td>
</tr>
<tr>
<td class="parameterName">requestProperties</td>
<td class="parameterType"><span class="parameterType"><code><a class="localTypeLink" title="RabbitMQ.Client.IBasicProperties" href="type-RabbitMQ.Client.IBasicProperties.html">IBasicProperties</a></code></span></td>
</tr>
<tr>
<td class="parameterName">body</td>
<td class="parameterType"><span class="parameterType"><code><code><span class="nonlocalTypeLink" title="System.Byte">byte[]</span></code></code></span></td>
</tr>
</table></td>
</tr>
</table>
<div class="methodDetailDoc">
<div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Called by the default HandleCast() implementation
            as a fallback.</div>
</div>
<div class="fullDoc">
<h4>Remarks</h4>
<div class="fullDocBody">
             If the MIME ContentType of the request did not match any
             of the types specially recognised
             (e.g. "jms/stream-message"), this method is called instead
             with the raw bytes of the request.
            </div>
</div>
</div>
</div>
<div class="methodDetail">
<a name="method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.HandleStreamMessageCall(RabbitMQ.Client.Content.IStreamMessageBuilder,System.Boolean,RabbitMQ.Client.IBasicProperties,System.Object%5B%5D)"></a><h3>HandleStreamMessageCall</h3>
<p><code>public virtual </code><code>void HandleStreamMessageCall(<span class="parameterType">IStreamMessageBuilder</span> replyWriter, <span class="parameterType">bool</span> isRedelivered, <span class="parameterType">IBasicProperties</span> requestProperties, <span class="parameterType">object[]</span> args)
  </code></p>
<table class="methodDetailTable">
<tr>
<th class="methodFlagsHeader">Flags</th>
<td class="methodFlags">public virtual </td>
</tr>
<tr>
<th class="returnTypeHeader">Return type</th>
<td class="returnType"><code><code><span class="nonlocalTypeLink" title="System.Void">void</span></code></code></td>
</tr>
<tr>
<th class="parametersHeader">Parameters</th>
<td class="parameters"><table class="parametersTable">
<tr>
<th class="parameterNameHeader">Name</th>
<th class="parameterTypeHeader">Type</th>
</tr>
<tr>
<td class="parameterName">replyWriter</td>
<td class="parameterType"><span class="parameterType"><code><a class="localTypeLink" title="RabbitMQ.Client.Content.IStreamMessageBuilder" href="type-RabbitMQ.Client.Content.IStreamMessageBuilder.html">IStreamMessageBuilder</a></code></span></td>
</tr>
<tr>
<td class="parameterName">isRedelivered</td>
<td class="parameterType"><span class="parameterType"><code><code><span class="nonlocalTypeLink" title="System.Boolean">bool</span></code></code></span></td>
</tr>
<tr>
<td class="parameterName">requestProperties</td>
<td class="parameterType"><span class="parameterType"><code><a class="localTypeLink" title="RabbitMQ.Client.IBasicProperties" href="type-RabbitMQ.Client.IBasicProperties.html">IBasicProperties</a></code></span></td>
</tr>
<tr>
<td class="parameterName">args</td>
<td class="parameterType"><span class="parameterType"><code><code><span class="nonlocalTypeLink" title="System.Object">object[]</span></code></code></span></td>
</tr>
</table></td>
</tr>
</table>
<div class="methodDetailDoc">
<div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Called by HandleCall and HandleCast when a
            "jms/stream-message" request is received.</div>
</div>
<div class="fullDoc">
<h4>Remarks</h4>
<div class="fullDocBody">
<p>
             The args array contains the values decoded by HandleCall
             or HandleCast.
            </p>
<p>
             The replyWriter parameter will be null if we were called
             from HandleCast, in which case a reply is not expected or
             possible, or non-null if we were called from
             HandleCall. Use the methods of replyWriter in this case to
             assemble your reply, which will be sent back to the remote
             caller.
            </p>
<p>
             This default implementation does nothing, which
             effectively sends back an empty reply to any and all
             remote callers.
            </p>
</div>
</div>
</div>
</div>
<div class="methodDetail">
<a name="method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.MainLoop"></a><h3>MainLoop</h3>
<p><code>public </code><code>void MainLoop()
  </code></p>
<table class="methodDetailTable">
<tr>
<th class="methodFlagsHeader">Flags</th>
<td class="methodFlags">public </td>
</tr>
<tr>
<th class="returnTypeHeader">Return type</th>
<td class="returnType"><code><code><span class="nonlocalTypeLink" title="System.Void">void</span></code></code></td>
</tr>
</table>
<div class="methodDetailDoc">
<div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Enters the main loop of the RPC service.</div>
</div>
<div class="fullDoc">
<h4>Remarks</h4>
<div class="fullDocBody">
<p>
             Retrieves requests repeatedly from the service's
             subscription. Each request is passed to
             ProcessRequest. Once ProcessRequest returns, the request
             is acknowledged via Subscription.Ack(). If transactional
             mode is enabled, TxCommit is then called. Finally, the
             loop begins again.
            </p>
<p>
             Runs until the subscription ends, which happens either as
             a result of disconnection, or of a call to Close().
            </p>
</div>
</div>
</div>
</div>
<div class="methodDetail">
<a name="method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.ProcessRequest(RabbitMQ.Client.Events.BasicDeliverEventArgs)"></a><h3>ProcessRequest</h3>
<p><code>public virtual </code><code>void ProcessRequest(<span class="parameterType">BasicDeliverEventArgs</span> evt)
  </code></p>
<table class="methodDetailTable">
<tr>
<th class="methodFlagsHeader">Flags</th>
<td class="methodFlags">public virtual </td>
</tr>
<tr>
<th class="returnTypeHeader">Return type</th>
<td class="returnType"><code><code><span class="nonlocalTypeLink" title="System.Void">void</span></code></code></td>
</tr>
<tr>
<th class="parametersHeader">Parameters</th>
<td class="parameters"><table class="parametersTable">
<tr>
<th class="parameterNameHeader">Name</th>
<th class="parameterTypeHeader">Type</th>
</tr>
<tr>
<td class="parameterName">evt</td>
<td class="parameterType"><span class="parameterType"><code><a class="localTypeLink" title="RabbitMQ.Client.Events.BasicDeliverEventArgs" href="type-RabbitMQ.Client.Events.BasicDeliverEventArgs.html">BasicDeliverEventArgs</a></code></span></td>
</tr>
</table></td>
</tr>
</table>
<div class="methodDetailDoc">
<div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Process a single request received from our
            subscription.</div>
</div>
<div class="fullDoc">
<h4>Remarks</h4>
<div class="fullDocBody">
<p>
             If the request's properties contain a non-null, non-empty
             CorrelationId string (see IBasicProperties), it is assumed
             to be a two-way call, requiring a response. The ReplyTo
             header property is used as the reply address (via
             PublicationAddress.Parse, unless that fails, in which case it
             is treated as a simple queue name), and the request is
             passed to HandleCall().
            </p>
<p>
             If the CorrelationId is absent or empty, the request is
             treated as one-way asynchronous event, and is passed to
             HandleCast().
            </p>
<p>
             Usually, overriding HandleCall(), HandleCast(), or one of
             their delegates is sufficient to implement a service, but
             in some cases overriding ProcessRequest() is
             required. Overriding ProcessRequest() gives the
             opportunity to implement schemes for detecting interaction
             patterns other than simple request/response or one-way
             communication.
            </p>
</div>
</div>
</div>
</div>
<div class="methodDetail">
<a name="method-M:RabbitMQ.Client.MessagePatterns.SimpleRpcServer.SetTransactional"></a><h3>SetTransactional</h3>
<p><code>public </code><code>void SetTransactional()
  </code></p>
<table class="methodDetailTable">
<tr>
<th class="methodFlagsHeader">Flags</th>
<td class="methodFlags">public </td>
</tr>
<tr>
<th class="returnTypeHeader">Return type</th>
<td class="returnType"><code><code><span class="nonlocalTypeLink" title="System.Void">void</span></code></code></td>
</tr>
</table>
<div class="methodDetailDoc">
<div class="fullDoc">
<h4>Summary</h4>
<div class="fullDocBody">Enables transactional mode.</div>
</div>
<div class="fullDoc">
<h4>Remarks</h4>
<div class="fullDocBody">
<p>
             Once enabled, transactional mode is not only enabled for
             all users of the underlying IModel instance, but cannot be
             disabled without shutting down the entire IModel (which
             involves shutting down all the services depending on it,
             and should not be undertaken lightly).
            </p>
<p>
             This method calls IModel.TxSelect, every time it is
             called. (TxSelect is idempotent, so this is harmless.)
            </p>
</div>
</div>
</div>
</div>
</body>
</html>
