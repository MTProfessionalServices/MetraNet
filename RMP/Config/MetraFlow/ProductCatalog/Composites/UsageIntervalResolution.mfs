--
-- Usage Interval Resolution
--
-- Given incoming records that contain these fields:
--    Usage.AccountID
--    Usage.Timestamp
--    _IsSoftOverride (optional)
--
-- determines the usage interval that the timestamp
-- applies to.  The determined interval and associated times
-- are sent in the outgoing record as field:
--    Usage.IntervalID
--    Usage.IntervalStartTime
--    Usage.IntervalEndTime
--    Usage.IntervalEffectiveStartTime
--
-- If no acceptable interval is found, Usage.IntervalID is null.
-- The selected interval must meet these conditions:
--    1. The interval is open or (soft-closed and _IsSoftOverride is true)
--    2. The timestamp is less than the interval end time
--
-- From all the acceptable intervals, we select the interval with the
-- minimum effective date or (if the effective date is null, the typical
-- case, we use the start time).
--
-- This script uses partitioning so that this solution can be scaled.

operator usageIntervalResolution[
              in  "input"  is partitionInput("input"),
              out "output" is error_switch(0),
              out "error" is error_switch(1)]
(
  -- Since we are using partitioning in the script, we need to 
  -- re-partition the incoming data.  We do because we do not know
  -- partitioning of the incoming data and we must ensure that partitioning
  -- is done consistently.  In this script we are partitioning on 
  -- a hash of the account ID.
  -- This redistributon of the incoming data is done using a partition
  -- and collator operator.

  partitionInput: hashpart[key="Usage.AccountID"];
  collateInput: coll[];
  
  partitionInput -> collateInput;

  -- Add a field for _IsSoftOverride.  If this field already exists,
  -- then the field will not be created.

  addSoftOverride:
               expr[program="CREATE PROCEDURE usageIntervalAddSoftOverride 
                  @_IsSoftOverride BOOLEAN OUTPUT
                AS
                  SET @_IsSoftOverride = FALSE"];

  collateInput -> addSoftOverride;

  -- Add a unique identifier for each received row

  addTmpID: generate[program = "CREATE PROCEDURE usageIntervalGenerate
                        @tmpID BIGINT OUTPUT
                        AS
                        SET @tmpID = @@RECORDCOUNT"];

  addSoftOverride -> addTmpID;

  -- Because the t_acc_usage_interval is so large, we need to
  -- partition the data in the select statement when we read 
  -- this table. Later we will re-partition this data, so
  -- that it is consistently partitioned with our input.

  selectFromAui: select [baseQuery="select 
                   id_acc            AS aui_id_acc, 
                   id_usage_interval AS aui_id_interval,
                   dt_effective      AS aui_dt_effective,
                   tx_status         AS aui_tx_status
                   from t_acc_usage_interval
                   WHERE 
                   ({fn mod(id_acc, %%NUMPARTITIONS%%)} = %%PARTITION%%)
                   "];

  selectFromUi: select [baseQuery="select 
                  id_interval AS ui_id_interval,
                  dt_start    AS ui_dt_start,
                  dt_end      AS ui_dt_end
                  from t_usage_interval"];

  -- Inner join tables:  t_acc_usage_interval and t_usage_interval

  joinAuiUi: inner_hash_join [tableKey="aui_id_interval", 
                              probeKey="ui_id_interval"];

  selectFromAui -> joinAuiUi("table");
  selectFromUi  -> joinAuiUi("probe(0)")

  -- Create an effective date guaranteed to be non-null
  -- If the effective date is null, we set the effective 
  -- date to the start date.  This adds a new field to our
  -- record stream.

  addEffectiveNonNull:
               expr[program="CREATE PROCEDURE usageIntervalAddEffective
                  @aui_dt_effective DATETIME
                  @ui_dt_start DATETIME
                  @start_effective_time DATETIME OUTPUT
                AS
                SET @start_effective_time = 
                    CASE WHEN @aui_dt_effective IS NULL
                         THEN @ui_dt_start
                         ELSE @aui_dt_effective
                END"];

  joinAuiUi("output(0)") -> addEffectiveNonNull;

  -- Redistribute interval data by account ID
  -- This will give us consistency in partitioning.

  partitionIntervals: hashpart[key="aui_id_acc"];
  collateIntervals: coll[];

  addEffectiveNonNull -> partitionIntervals -> collateIntervals;

  -- Join with incoming session data
  -- Find all intervals whose ending date is greater than the incoming timestamp
  -- We use a right outer join so that all sessions appear even if
  -- there is no match

  joinIntervalsAndInput: right_outer_hash_join [
                       tableKey="aui_id_acc", 
                       probeKey="Usage.AccountID", 
                       residual="
                          CREATE FUNCTION usageIntervalJoinResidual(@Usage.Timestamp DATETIME
                                            @_IsSoftOverride BOOLEAN
                                            @start_effective_time DATETIME
                                            @ui_dt_end DATETIME
                                            @aui_tx_status VARCHAR) 
                          RETURNS BOOLEAN
                          AS
                            RETURN (@Usage.Timestamp <= @ui_dt_end) AND
                                     (@aui_tx_status = 'O' OR
                                     (@aui_tx_status = 'C' AND 
                                      @_IsSoftOverride))"];

  collateIntervals -> joinIntervalsAndInput("table");
  addTmpID -> joinIntervalsAndInput("probe(0)");

  -- Branch the stream.
  -- On one branch we are going to determine the interval with
  -- the minimum start time.  We use the tmpID we created earlier to
  -- know which records are grouped (represent all the interval matches).

  copy[];
  joinIntervalsAndInput("output(0)") -> copy;
  
  -- Reduce are matching intervals to the one with the
  -- minimum effective/start time

  findMinStart: sort_group_by[key="tmpID",
    initialize="
      CREATE PROCEDURE usageIntervalFindMinStartInit @minStart DATETIME
      AS
      SET @minStart = NULL",
    update="
      CREATE PROCEDURE usageIntervalFindMinStartUpd @minStart DATETIME
                         @start_effective_time DATETIME
      AS
      SET @minStart = 
        CASE WHEN ((@minStart IS NULL) OR
                   (@start_effective_time < @minStart))
             THEN @start_effective_time
             ELSE @minStart
             END"];

  copy(0) -> findMinStart;

  -- Now we have the minimum start so we will merge all the
  -- intervals down to this single one.

  finalJoin: right_merge_semi_join[leftKey="tmpID",
                                   rightKey="tmpID",
                                   residual= "
                          CREATE FUNCTION usageIntervalfinalJoin(@start_effective_time DATETIME
                                            @minStart DATETIME)
                          RETURNS BOOLEAN
                          AS
                            RETURN (@minStart = @start_effective_time)"];
  copy(1) -> finalJoin("right");

  findMinStart -> finalJoin("left");

  error_detect:expr[program="CREATE PROCEDURE usageIntervalErrorDetect
      @aui_id_interval                   INTEGER 
      @Usage.Timestamp                   DATETIME
      @Usage.AccountID                   INTEGER
      @Usage.IntervalID                  INTEGER
      @Usage.IntervalStartTime           DATETIME
      @Usage.IntervalEndTime             DATETIME
      @Usage.IntervalEffectiveStartTime  DATETIME
      @ui_dt_start                       DATETIME
      @ui_dt_end                         DATETIME
      @start_effective_time              DATETIME
      @_ErrorCode                        INTEGER  OUTPUT
      @_ErrorString                      NVARCHAR OUTPUT
      @_Plugin                           NVARCHAR OUTPUT
      @_Module                           NVARCHAR OUTPUT
    AS
      IF @aui_id_interval IS NULL
        BEGIN
          SET @_ErrorCode = 0xE1200025
          SET @_ErrorString = N'Could not find the next open usage interval for account ' + CAST(@Usage.AccountID AS NVARCHAR) + N' based on a transaction time of ' + CAST(@Usage.Timestamp AS NVARCHAR)
          SET @_Plugin = N'usageIntervalResolution'
          SET @_Module = N'usageIntervalResolution'
        END
      ELSE
        BEGIN
          SET @Usage.IntervalID                 = @aui_id_interval
          SET @Usage.IntervalStartTime          = @ui_dt_start
          SET @Usage.IntervalEndTime            = @ui_dt_end
          SET @Usage.IntervalEffectiveStartTime = @start_effective_time
        END"];

  finalJoin -> error_detect;

  -- Discard temporary fields
  discardTemps: project[inverse=true,
                        column="aui_id_acc",
                        column="aui_id_interval",
                        column="aui_dt_effective",
                        column="aui_tx_status",
                        column="ui_id_interval",
                        column="ui_dt_start",
                        column="ui_dt_end",
                        column="start_effective_time",
                        column="tmpID"
                       ];
  error_detect -> discardTemps;

  error_switch:switch[program="CREATE FUNCTION usageIntervalSwitch (@_ErrorCode INTEGER) 
                               RETURNS INTEGER
                               AS
                               RETURN CASE WHEN @_ErrorCode IS NULL OR 
                                      @_ErrorCode = 0 THEN 0 ELSE 1 END"];
  discardTemps -> error_switch;
)
