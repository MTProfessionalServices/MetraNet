
include "UsageIntervalResolution.mfs"

operator importme[string $USAGERECORDFILE, out "output" is svc_id_convert("output")]
(
svc_import:import[format="myRec
INTEGER=text_delimited_base10_int32(delimiter='|', null_value='')
BIGINT=text_delimited_base10_int64(delimiter='|', null_value='')
DECIMAL=text_delimited_base10_decimal(delimiter='|', null_value='')
BOOLEAN=text_delimited_boolean(delimiter='|', true_value='Y', false_value='N', null_value='')
NVARCHAR=text_delimited_nvarchar(delimiter='|', null_value='')
ENUM=text_delimited_enum(enum_space='Global',enum_type='CountryName', delimiter='|', null_value='')
DATETIME=iso8601_datetime(delimiter='|', null_value='')
(
Description NVARCHAR,
Time DATETIME,
Duration INTEGER,
Units DECIMAL,
AccountName NVARCHAR,
DecProp1 DECIMAL,
DecProp2 DECIMAL,
DecProp3 DECIMAL,
internalmtaccountid text_delimited_base10_int32(delimiter=crlf, null_value='')
)",
filename=$USAGERECORDFILE,
mode="sequential"];

svc_part:hashpart[key="AccountName", mode="sequential"];
svc_import -> svc_part;

create_root_usage_columns:expr[program="CREATE PROCEDURE p 
@PayingAccount_tmp INTEGER OUTPUT
@Timestamp_tmp DATETIME OUTPUT
@PriceableItemInstanceID_tmp INTEGER OUTPUT
@PriceableItemTemplateID_tmp INTEGER OUTPUT
@ProductOfferingID_tmp INTEGER OUTPUT
@AccountID_tmp INTEGER OUTPUT
@SessionID_tmp BINARY OUTPUT
@Amount_tmp DECIMAL OUTPUT
@FedTax_tmp DECIMAL OUTPUT
@StateTax_tmp DECIMAL OUTPUT
@CountyTax_tmp DECIMAL OUTPUT
@LocalTax_tmp DECIMAL OUTPUT
@OtherTax_tmp DECIMAL OUTPUT
@IntervalID_tmp INTEGER OUTPUT
@Currency_tmp NVARCHAR OUTPUT
@SubscriptionEntity_tmp INTEGER OUTPUT
@CollectionID_tmp BINARY OUTPUT
AS
DECLARE @dummy INTEGER"];
svc_part -> create_root_usage_columns;

create_root_usage_record:rename[
from="PayingAccount_tmp", to="Usage.PayingAccount"
,from="Timestamp_tmp", to="Usage.Timestamp"
,from="PriceableItemInstanceID_tmp", to="Usage.PriceableItemInstanceID"
,from="PriceableItemTemplateID_tmp", to="Usage.PriceableItemTemplateID"
,from="ProductOfferingID_tmp", to="Usage.ProductOfferingID"
,from="accountID_tmp", to="Usage.AccountID"
,from="SessionID_tmp", to="Usage.SessionID"
,from="Amount_tmp", to="Usage.Amount"
,from="FedTax_tmp", to="Usage.FedTax"
,from="StateTax_tmp", to="Usage.StateTax"
,from="CountyTax_tmp", to="Usage.CountyTax"
,from="LocalTax_tmp", to="Usage.LocalTax"
,from="OtherTax_tmp", to="Usage.OtherTax"
,from="IntervalID_tmp", to="Usage.IntervalID"
,from="Currency_tmp", to="Usage.Currency"
,from="SubscriptionEntity_tmp", to="Usage.SubscriptionEntity"
,from="CollectionID_tmp", to="Usage.CollectionID"];
create_root_usage_columns -> create_root_usage_record;

svc_id:id_generator[id="id_source_sess_int64", sequence="id_dbqueue", blockSize=1000];

create_root_usage_record -> svc_id;

svc_id_convert:expr[program="CREATE PROCEDURE IdConvert @id_source_sess_int64 BIGINT 
@Usage.SessionID BINARY 
@Time DATETIME @Usage.Timestamp DATETIME
@namespace NVARCHAR OUTPUT
@Usage.CollectionID BINARY 
AS
SET @Usage.SessionID = CAST(@id_source_sess_int64 AS BINARY)
SET @Usage.Timestamp = @Time
SET @namespace = N'mt'
SET @Usage.CollectionID = CAST(237423423453453LL AS BINARY)"];

svc_id -> svc_id_convert;
)

step ImportAndRate[]
(
svc_id_convert:importme[];

payj:account_lookup[identifier="accountname", 
namespace="mt", namespaceValueType="constant", 
timestamp="Time",
property="AccountID", as="_AccountID",
property="PayingAccountID", as="_PayingAccount",
property="UsageCycleID", as="_UsageCycleID",
property="PayerCurrency", as="_Currency",
property="TimezoneID", as="TimezoneID"
];
svc_id_convert -> payj;

payj_copy_properties:expr[program="CREATE PROCEDURE p 
@_AccountID INTEGER @Usage.AccountID INTEGER
@_PayingAccount INTEGER @Usage.PayingAccount INTEGER
@_Currency NVARCHAR @Usage.Currency NVARCHAR
AS
SET @Usage.AccountID = @_AccountID
SET @Usage.PayingAccount = @_PayingAccount
SET @Usage.Currency = @_Currency"];

payj(0) -> payj_copy_properties;

plmj:subscription_lookup[priceableItemName="Test Usage Charge", priceableItemNameValueType="constant", timestamp="Usage.Timestamp"];
payj_copy_properties -> plmj;

rsr:rate_schedule_lookup[parameterTable="metratech.com/decimalcalc", parameterTable="metratech.com/Calendar", parameterTable="metratech.com/rateconn"];

plmj -> rsr;

decimalcalc:rate_calculation[parameterTable="metratech.com/decimalcalc"];

rsr -> decimalcalc;

-----------------------------------
-----------------------------------
-- TODO: Calendar lookup. 
-----------------------------------
-----------------------------------
lookup_calendar:expr[program="
CREATE PROCEDURE e @CalendarCode ENUM OUTPUT
AS
SET @CalendarCode = #metratech.com/calendar/CalendarCode/Off-Peak#
"];
decimalcalc->lookup_calendar;

rateconn:rate_calculation[parameterTable="metratech.com/rateconn"];
lookup_calendar -> rateconn;

-----------------------------------
-----------------------------------
-- Pricing calculation
-----------------------------------
-----------------------------------
ratecalc:expr[program="
CREATE PROCEDURE audioconf @Units DECIMAL @Duration INTEGER @Rate DECIMAL @MTI INTEGER @MinCharge DECIMAL @SetupCharge DECIMAL @Usage.Amount DECIMAL @time DATETIME @Usage.Timestamp DATETIME  @DecProp4Applic BOOLEAN @DecProp4 DECIMAL OUTPUT
AS
DECLARE @RoundedDuration DECIMAL;
-- Calculate the duration rounded by the MTI
DECLARE @timeMod INTEGER;
DECLARE @timeDiv INTEGER;
SET @timeMod = @Duration % @MTI;
SET @timeDiv = @Duration / @MTI;
SET @timeDiv = CASE WHEN @timeMod > 0 OR @timeDiv = 0 THEN @timeDiv + 1 ELSE @timeDiv END;
SET @RoundedDuration = (CAST(@timeDiv AS DECIMAL) * CAST(@MTI AS DECIMAL))/ 60.0;
--PRINT '@RoundedDuration =' + CAST(@RoundedDuration AS VARCHAR);

-- Calculate the usage
DECLARE @UsageCharge DECIMAL;
SET @UsageCharge = @Rate*@RoundedDuration;
--PRINT '@UsageCharge =' + CAST(@UsageCharge AS VARCHAR);
-- Set charges to be the setup + usage
SET @Usage.Amount = @SetupCharge + @UsageCharge;
--PRINT '@Usage.Amount =' + CAST(@Usage.Amount AS VARCHAR);
-- Enforce the minimum charge
SET @Usage.Amount = CASE WHEN @Usage.Amount <= @MinCharge THEN @MinCharge ELSE @Usage.Amount END;
-- Set the timestamp from the metered in time value (this becomes dt_session)
SET @Usage.Timestamp = @time;

-- Set the value of DecProp4 based on @DecProp4Applic (the latter comes from a parameter table)
IF @DecProp4Applic
  SET @DecProp4 = 999.99"];

rateconn -> ratecalc;

auij:usageIntervalResolution[];
ratecalc -> auij;

move_properties:expr[program="CREATE PROCEDURE p 
@_PriceableItemTemplateID INTEGER @Usage.PriceableItemTemplateID INTEGER
@Subscription.PriceableItemInstanceID INTEGER @Usage.PriceableItemInstanceID INTEGER
@Subscription.ProductOfferingID INTEGER @Usage.ProductOfferingID INTEGER
AS
SET @Usage.PriceableItemTemplateID = @_PriceableItemTemplateID 
SET @Usage.PriceableItemInstanceID = @Subscription.PriceableItemInstanceID
SET @Usage.ProductOfferingID = @Subscription.ProductOfferingID"];

auij -> move_properties;

-- Write Product View : assign internal ids, sort and partition data, apply default values, perform constraint checks.
ren:write_product_view[productView="metratech.com/testpi"];
move_properties -> ren;

-----------------------------------
-----------------------------------
-- TODO: Batch update and materialized views
-----------------------------------
-----------------------------------

-----------------------------------
-----------------------------------
-- Land good records for subsequent loading
-----------------------------------
-----------------------------------
p:print[];
d:sequential_file_write[filename="C:\scratch\testpi_service_load_%1%.mfd"];
ren(0) -> p->d;
-----------------------------------
-----------------------------------
-- Feed all of the errors into the error output.
-----------------------------------
-----------------------------------
write_error[service="metratech.com/testpi"];
payj(1) -> write_error(0);
plmj(1) -> write_error(1);
rsr(1) -> write_error(2);
decimalcalc(1) -> write_error(3);
rateconn(1) -> write_error(4);
auij(1) -> write_error(5);
ren(1) -> write_error(6);
)

step LoadUsage[]
(
r:sequential_file_scan[filename="C:\scratch\testpi_service_load_%1%.mfd"];

l:load_usage[productView="metratech.com/testpi"];

r -> l;
)

step LoadErrors[]
(
failed_txn_message:sequential_file_scan[filename="C:\scratch\testpi_message_load_%1%.mfd"];
failed_txn_session_set:sequential_file_scan[filename="C:\scratch\testpi_session_set_load_%1%.mfd"];
dn:sequential_file_scan[filename="C:\scratch\testpi_service_error_load1_%1%.mfd"];
dn1:sequential_file_scan[filename="C:\scratch\testpi_service_error_load2_%1%.mfd"];

load_error[service="metratech.com/testpi"];

failed_txn_message -> load_error("message");
failed_txn_session_set -> load_error("session_set");
dn -> load_error("failed_transaction");
dn1 -> load_error("service");
)

steps
  ImportAndRate;
  LoadUsage;
  LoadErrors;
endsteps
