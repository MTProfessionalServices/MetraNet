<?xml version="1.0" encoding="utf-8"?>
<MetraFlowScript>
    <Name>CreateUsageIntervals</Name>
    <Description>Create new usage intervals and usage interval mappings.</Description>
    <Parameters>
        <Parameter>
            <Name>DT_NOW</Name>
            <SyntaxCheckValue>1970-01-01 00:00:00</SyntaxCheckValue>
            <Description>Current time to use a basis for calculating required usage intervals.</Description>
        </Parameter>
        <Parameter>
            <Name>DT_END</Name>
            <SyntaxCheckValue>2038-01-01 00:00:00</SyntaxCheckValue>
            <Description></Description>
        </Parameter>
        <Parameter>
            <Name>TEMP_DIR</Name>
            <SyntaxCheckValue>C:\Temp</SyntaxCheckValue>
            <Description></Description>
        </Parameter>
    </Parameters>
    <Script>
      <![CDATA[
aui_select:select[baseQuery="SELECT id_acc, id_usage_interval, dt_effective
FROM
t_acc_usage_interval
WHERE
{fn mod(id_acc, %%NUMPARTITIONS%%)} = %%PARTITION%%"];

aui_rename:rename[
from="id_acc", to="aui_id_acc",
from="id_usage_interval", to="aui_id_usage_interval"];

aui_select -> aui_rename;

aui_part:hashpart[key="aui_id_acc"];

aui_rename -> aui_part;

aui_coll:coll[];

aui_part -> aui_coll;

aui_copy:copy[];

aui_coll -> aui_copy;

aui_calculate_min_effective_filter:filter[program="CREATE FUNCTION f(@dt_effective DATETIME) RETURNS BOOLEAN
AS
RETURN NOT @dt_effective IS NULL"];

aui_copy(0) -> aui_calculate_min_effective_filter;

aui_calculate_min_effective:hash_group_by[key="aui_id_acc",
initialize="CREATE PROCEDURE p @min_dt_effective DATETIME
AS
SET @min_dt_effective = NULL",
update="CREATE PROCEDURE p @min_dt_effective DATETIME @dt_effective DATETIME
AS
IF NOT @dt_effective IS NULL AND (@min_dt_effective IS NULL OR @dt_effective < @min_dt_effective)
  SET @min_dt_effective = @dt_effective"];

aui_calculate_min_effective_filter -> aui_calculate_min_effective;

accstate_select:select[baseQuery="SELECT id_acc, vt_start, vt_end, 1 as tmp82342897317
FROM t_account_state
WHERE
status <> 'AR'
and
vt_end >= '%%DT_NOW%%'
and
vt_start < '%%DT_END%%'
and
{fn mod(id_acc, %%NUMPARTITIONS%%)} = %%PARTITION%%"];

constants:generate[program="CREATE PROCEDURE p @arg_dt_now DATETIME @arg_dt_end DATETIME @tmp882346126712 INTEGER
AS
SET @arg_dt_now = CAST('%%DT_NOW%%' AS DATETIME)
SET @arg_dt_end = CAST('%%DT_END%%' AS DATETIME)
SET @tmp882346126712 = 1",
numRecords=1];

constant_join:inner_hash_join[tableKey="tmp882346126712", probeKey="tmp82342897317"];

constants -> constant_join("table");
accstate_select -> constant_join("probe(0)");

accstate_rename:rename[
from="id_acc", to="accstate_id_acc",
from="vt_start", to="accstate_vt_start",
from="vt_end", to="accstate_vt_end"];

constant_join -> accstate_rename;

accstate_part:hashpart[key="accstate_id_acc"];

accstate_rename -> accstate_part;

accstate_coll:coll[];

accstate_part -> accstate_coll;

accstate_aui_join:right_outer_hash_join[tableKey="aui_id_acc", probeKey="accstate_id_acc"];

aui_calculate_min_effective -> accstate_aui_join("table");
accstate_coll -> accstate_aui_join("probe(0)");

accstate_aui_group_by:hash_group_by[key="accstate_id_acc",
initialize="CREATE PROCEDURE p @minstart_dt_start DATETIME @minstart_dt_end DATETIME
AS 
SET @minstart_dt_start = NULL
SET @minstart_dt_end = NULL",
update="CREATE PROCEDURE p @accstate_vt_start DATETIME @accstate_vt_end DATETIME @min_dt_effective DATETIME @minstart_dt_start DATETIME @minstart_dt_end DATETIME @arg_dt_end DATETIME
AS
DECLARE @tmp1 DATETIME
DECLARE @tmp2 DATETIME
SET @tmp1 = CASE WHEN @min_dt_effective IS NULL THEN @accstate_vt_start ELSE @min_dt_effective END
SET @tmp2 = CASE WHEN @accstate_vt_end > @arg_dt_end THEN @arg_dt_end ELSE @accstate_vt_end END
IF @minstart_dt_start IS NULL OR @minstart_dt_start > @tmp1
  SET @minstart_dt_start = @tmp1
IF @minstart_dt_end IS NULL OR @minstart_dt_end < @tmp2
  SET @minstart_dt_end = @tmp2"];

accstate_aui_join -> accstate_aui_group_by;

auc_select:select[baseQuery="SELECT id_acc, id_usage_cycle
FROM
t_acc_usage_cycle
WHERE
{fn mod(id_acc, %%NUMPARTITIONS%%)} = %%PARTITION%%"];

auc_rename:rename[
from="id_acc", to="auc_id_acc",
from="id_usage_cycle", to="auc_id_usage_cycle"];

auc_select -> auc_rename;

auc_part:hashpart[key="auc_id_acc"];

auc_rename -> auc_part;

auc_coll:coll[];

auc_part -> auc_coll;

auc_join:inner_hash_join[tableKey="auc_id_acc", probeKey="accstate_id_acc"];

auc_coll -> auc_join("table");

accstate_aui_group_by -> auc_join("probe(0)");

pc_select:select[baseQuery="SELECT id_interval, id_cycle, dt_start, dt_end
FROM
t_pc_interval
WHERE
{fn mod(id_interval, %%NUMPARTITIONS%%)} = %%PARTITION%%"];

pc_rename:rename[
from="id_interval", to="pc_id_interval",
from="id_cycle", to="pc_id_cycle",
from="dt_start", to="pc_dt_start",
from="dt_end", to="pc_dt_end"];

pc_select -> pc_rename;

pc_part:broadcast[];

pc_rename -> pc_part;

pc_coll:coll[];

pc_part -> pc_coll;

pc_join:inner_hash_join[tableKey="pc_id_cycle", probeKey="auc_id_usage_cycle",
residual="CREATE FUNCTION f (@pc_dt_start DATETIME @pc_dt_end DATETIME @minstart_dt_start DATETIME @minstart_dt_end DATETIME) RETURNS BOOLEAN
AS
RETURN @pc_dt_start <= @minstart_dt_end AND @minstart_dt_start < @pc_dt_end"];

pc_coll -> pc_join("table");
auc_join -> pc_join("probe(0)");

ui_select:select[baseQuery="SELECT id_interval, tx_interval_status
FROM
t_usage_interval
WHERE
{fn mod(id_interval, %%NUMPARTITIONS%%)} = %%PARTITION%%"];

ui_rename:rename[
from="id_interval", to="ui_id_interval",
from="tx_interval_status", to="ui_tx_interval_status"];

ui_select -> ui_rename;

ui_part:broadcast[];

ui_rename -> ui_part;

ui_coll:coll[];

ui_part -> ui_coll;

ui_join:right_outer_hash_join[tableKey="ui_id_interval", probeKey="pc_id_interval"];

ui_coll -> ui_join("table");
pc_join -> ui_join("probe(0)");

ui_filter:filter[program="CREATE FUNCTION f (@ui_tx_interval_status VARCHAR) RETURNS BOOLEAN
AS
RETURN @ui_tx_interval_status IS NULL OR @ui_tx_interval_status <> 'B'"];

ui_join -> ui_filter;

existing_mappings_filter:multi_hash_join[tableKey="aui_id_acc", tableKey="aui_id_usage_interval",
probe="right anti semi", probeKey="accstate_id_acc", probeKey="pc_id_interval"];

aui_copy(1) -> existing_mappings_filter("table");
ui_filter -> existing_mappings_filter("probe(0)");

new_mappings_copy:copy[];

existing_mappings_filter -> new_mappings_copy;

new_mappings_projection:project[
column="auc_id_acc",
column="pc_id_interval",
column="ui_tx_interval_status"];

new_mappings_copy(0) -> new_mappings_projection;

new_mappings_rename:rename[
from="auc_id_acc", to="id_acc",
from="pc_id_interval", to="id_usage_interval",
from="ui_tx_interval_status", to="tx_status"];

new_mappings_projection -> new_mappings_rename;

new_mappings_correct_status:expr[program="CREATE PROCEDURE p @tx_status VARCHAR
AS
IF @tx_status IS NULL
  SET @tx_status = 'O'"];

new_mappings_rename -> new_mappings_correct_status;

new_mappings_write:sequential_file_write[filename="%%TEMP_DIR%%\new_mappings_%1%.mfd"];

new_mappings_correct_status -> new_mappings_write;

new_intervals_filter:filter[program="CREATE FUNCTION f (@ui_id_interval INTEGER) RETURNS BOOLEAN
AS
RETURN @ui_id_interval IS NULL"];

new_mappings_copy(1) -> new_intervals_filter;

new_intervals_distinct:hash_group_by[key="pc_id_interval", 
initialize="CREATE PROCEDURE p @tmp_id_cycle INTEGER @tmp_dt_start DATETIME @tmp_dt_end DATETIME
AS
SET @tmp_id_cycle = NULL",
update="CREATE PROCEDURE p @tmp_id_cycle INTEGER @tmp_dt_start DATETIME @tmp_dt_end DATETIME
@pc_id_cycle INTEGER @pc_dt_start DATETIME @pc_dt_end DATETIME
AS
IF @tmp_id_cycle IS NULL
BEGIN
  SET @tmp_id_cycle = @pc_id_cycle
  SET @tmp_dt_start = @pc_dt_start
  SET @tmp_dt_end = @pc_dt_end
END"];

new_intervals_filter -> new_intervals_distinct;

new_intervals_coll:coll[mode="sequential"];

new_intervals_distinct -> new_intervals_coll;

new_intervals_distinct_final:hash_group_by[key="pc_id_interval", 
initialize="CREATE PROCEDURE p @id_usage_cycle INTEGER @dt_start DATETIME @dt_end DATETIME
AS
SET @id_usage_cycle = NULL",
update="CREATE PROCEDURE p @id_usage_cycle INTEGER @dt_start DATETIME @dt_end DATETIME
@tmp_id_cycle INTEGER @tmp_dt_start DATETIME @tmp_dt_end DATETIME
AS
IF @id_usage_cycle IS NULL
BEGIN
  SET @id_usage_cycle = @tmp_id_cycle
  SET @dt_start = @tmp_dt_start
  SET @dt_end = @tmp_dt_end
END",
mode="sequential"];

new_intervals_coll -> new_intervals_distinct_final;

new_intervals_rename:rename[
from="pc_id_interval", to="id_interval",
mode="sequential"];

new_intervals_distinct_final -> new_intervals_rename;

new_intervals_calc_status:expr[program="CREATE PROCEDURE p @tx_interval_status VARCHAR OUTPUT
AS
SET @tx_interval_status = 'O'",
mode="sequential"];

new_intervals_rename -> new_intervals_calc_status;

new_intervals_write:sequential_file_write[filename="%%TEMP_DIR%%\new_intervals_%1%.mfd", mode="sequential"];

new_intervals_calc_status -> new_intervals_write;
]]></Script>
</MetraFlowScript>