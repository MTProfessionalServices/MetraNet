<?xml version="1.0" encoding="utf-8"?>
<MetraFlowScript>
    <Name>InvoiceCreateInvoiceRecords2</Name>
    <Description>Generate invoice records for calculate invoice summaries.</Description>
    <Parameters>
        <Parameter>
            <Name>TEMP_DIR</Name>
            <SyntaxCheckValue>C:\Temp</SyntaxCheckValue>
            <Description>Directory in which to store temporary files.</Description>
        </Parameter>
        <Parameter>
            <Name>ID_INTERVAL</Name>
            <SyntaxCheckValue>1000</SyntaxCheckValue>
            <Description>Usage intervals for which invoices are being processed.</Description>
        </Parameter>
        <Parameter>
            <Name>ID_BILLGROUP</Name>
            <SyntaxCheckValue>1000</SyntaxCheckValue>
            <Description>Billing group for which invoices are being processed.</Description>
        </Parameter>
    </Parameters>
    <Script>
      <![CDATA[
invoice_summaries:sequential_file_scan[filename="%%TEMP_DIR%%\invoice_contributions_%1%.mfd"];

-- Having computed the invoice summary we now have to process a bunch of wacky logic to 
-- deal with the fact that an id_acc (formerly a payer) has been marked as non-billable.
-- In these cases we associated the payer at the end of the billed interval with the
-- invoice entries
avi_join:inner_hash_join[tableKey="avi_id_acc", probeKey="id_acc"];
avi:sequential_file_scan[filename="%%TEMP_DIR%%\invoice_t_av_internal_%1%.mfd"];

avi -> avi_join("table");
invoice_summaries -> avi_join("probe(0)");

aui_join:inner_hash_join[tableKey="aui_id_acc", probeKey="id_acc"];

aui:sequential_file_scan[filename="%%TEMP_DIR%%\invoice_t_acc_usage_interval_%1%.mfd"];

aui -> aui_join("table");
avi_join -> aui_join("probe(0)");

pay_join:inner_hash_join[tableKey="pay_id_payee", probeKey="id_acc", residual="
CREATE FUNCTION f (@ui_dt_end DATETIME @pay_dt_start DATETIME @pay_dt_end DATETIME) RETURNS BOOLEAN
AS
RETURN @ui_dt_end >= @pay_dt_start AND @ui_dt_end <= @pay_dt_end"];

pay:sequential_file_scan[filename="%%TEMP_DIR%%\invoice_t_payment_redirection_%1%.mfd"];

pay -> pay_join("table");
aui_join -> pay_join("probe(0)");

ns_join:inner_hash_join[tableKey="ns_id_acc", probeKey="id_acc"];

ns:sequential_file_scan[filename="%%TEMP_DIR%%\invoice_t_account_mapper_%1%.mfd"];

ns -> ns_join("table");
pay_join -> ns_join("probe(0)");

pay_join_part:hashpart[key="pay_id_payer"];

pay_join_coll:coll[];

auipay:select[baseQuery="SELECT 
aui.id_acc as auipay_id_acc, 
aui.id_usage_interval as auipay_id_usage_interval, 
aui.dt_effective as auipay_dt_effective,
ui.dt_start as auipay_dt_start, 
ui.dt_end as auipay_dt_end
FROM
tmp_invoice_new_payers np
INNER JOIN t_acc_usage_interval aui on aui.id_acc=np.pay_id_payer
INNER JOIN t_usage_interval ui ON aui.id_usage_interval=ui.id_interval
INNER JOIN t_usage_interval thisui ON ui.dt_start <= thisui.dt_end AND thisui.dt_end <= ui.dt_end
WHERE
thisui.id_interval=%%ID_INTERVAL%%
AND
{fn mod(aui.id_acc, %%NUMPARTITIONS%%)} = %%PARTITION%%",
partitionConstraint="Database"];

auipay_part:hashpart[key="auipay_id_acc",
partitionConstraint="Database"];

auipay_coll:coll[];

auipay_correction:expr[program="CREATE PROCEDURE p @auipay_dt_effective DATETIME @auipay_dt_start DATETIME @auipay_dt_start_corrected DATETIME OUTPUT
AS
SET @auipay_dt_start_corrected = CASE WHEN @auipay_dt_effective IS NULL THEN @auipay_dt_start ELSE dateadd('s',1,@auipay_dt_effective) END"];

auipay_join:inner_hash_join[tableKey="auipay_id_acc", probeKey="pay_id_payer", residual="
CREATE FUNCTION f (@ui_dt_end DATETIME @auipay_dt_start_corrected DATETIME @auipay_dt_end DATETIME) RETURNS BOOLEAN
AS
RETURN @ui_dt_end >= @auipay_dt_start_corrected AND @ui_dt_end <= @auipay_dt_end"];

auipay -> auipay_part -> auipay_coll -> auipay_correction -> auipay_join("table");
ns_join -> pay_join_part -> pay_join_coll -> auipay_join("probe(0)");

correct_for_nonbillable:expr[program="CREATE PROCEDURE p 
@avi_c_billable VARCHAR 
@pay_id_payer INTEGER 
@id_acc INTEGER 
@id_payer INTEGER OUTPUT
@auipay_id_usage_interval INTEGER 
@id_interval INTEGER 
@id_payer_interval INTEGER OUTPUT
AS
SET @id_payer = CASE WHEN @avi_c_billable = '0' THEN @pay_id_payer ELSE @id_acc END
SET @id_payer_interval = CASE WHEN @avi_c_billable = '0' THEN @auipay_id_usage_interval ELSE @id_interval END"];

misc_rename:rename[
from="avi_c_currency", to="invoice_currency"];

project_result:projection[
column="namespace",
column="id_interval",
column="id_acc",
column="invoice_amount",
column="invoice_currency",
column="payment_ttl_amt",
column="postbill_adj_ttl_amt",
column="ar_adj_ttl_amt",
column="tax_ttl_amt",
column="current_balance",
column="id_payer",
column="id_payer_interval"];

auipay_join -> correct_for_nonbillable -> misc_rename -> project_result;

-- Attach invoice sequence and number
-- TODO: More careful logic to prevent gaps in invoice numbers.
invoice_namespace_select:select[baseQuery="select namespace as invns_namespace,
invoice_prefix as invns_invoice_prefix, 
invoice_suffix as invns_invoice_suffix,
invoice_num_digits as invns_invoice_num_digits,
invoice_due_date_offset as invns_invoice_due_date_offset,
id_invoice_num_last as invns_invoice_id_invoice_num_last,
ui.dt_end as invoice_end_date
from 
t_invoice_namespace
cross join t_usage_interval ui
where
ui.id_interval=%%ID_INTERVAL%%",
mode="sequential"];

invoice_namespace_part:broadcast[mode="sequential"];

invoice_namespace_join:inner_hash_join[tableKey="invns_namespace", probeKey="namespace"];

invoice_namespace_select -> invoice_namespace_part -> invoice_namespace_join("table");
project_result -> invoice_namespace_join("probe(0)");

invoice_numbers:generate[program="CREATE PROCEDURE p
@invns_invoice_prefix NVARCHAR 
@invns_invoice_suffix NVARCHAR
@invns_invoice_num_digits INTEGER
@invns_invoice_due_date_offset INTEGER
@invns_invoice_id_invoice_num_last INTEGER
@invoice_end_date DATETIME 
@invoice_string NVARCHAR OUTPUT 
@invoice_date DATETIME OUTPUT
@invoice_due_date DATETIME OUTPUT
@id_invoice_num INTEGER OUTPUT
@sample_flag VARCHAR OUTPUT
@balance_forward_date DATETIME OUTPUT
AS
SET @id_invoice_num = @invns_invoice_id_invoice_num_last + CAST(@@RECORDCOUNT AS INTEGER)*@@PARTITIONCOUNT + @@PARTITION + 1
SET @invoice_string = @invns_invoice_prefix + CAST(@id_invoice_num AS NVARCHAR) + @invns_invoice_suffix
SET @invoice_date = @invoice_end_date
SET @invoice_due_date = dateadd('d', @invns_invoice_due_date_offset, @invoice_end_date)
SET @sample_flag = '0'
SET @balance_forward_date = @invoice_end_date"];

invoice_namespace_join -> invoice_numbers;

invoice_numbers_copy:copy;

invoice_numbers -> invoice_numbers_copy;

-- First feed is just insert into t_invoice

g61:generate[program="
CREATE PROCEDURE p @id_commit_unit INTEGER OUTPUT
AS
SET @id_commit_unit = CAST(@@RECORDCOUNT / 50000LL AS INTEGER)"];
c61:copy[];
invoice_numbers_copy(0) -> g61 -> c61;

au61:insert[table="t_invoice", schema="NetMeter", batchSize=50000, transactionKey="id_commit_unit"];
c61(0) -> au61;
sgb61:sort_group_by[key="id_commit_unit",
initialize="
CREATE PROCEDURE i @size_0 INTEGER 
AS
SET @size_0 = 0",
update="
CREATE PROCEDURE u @size_0 INTEGER 
AS
SET @size_0 = @size_0 + 1"];
c61(1) -> sgb61;
install61:sql_exec_direct[
statementList=[query="INSERT INTO t_invoice SELECT 
       [namespace]
      ,[invoice_string]
      ,[id_interval]
      ,[id_acc]
      ,[invoice_amount]
      ,[invoice_date]
      ,[invoice_due_date]
      ,[id_invoice_num]
      ,[invoice_currency]
      ,[payment_ttl_amt]
      ,[postbill_adj_ttl_amt]
      ,[ar_adj_ttl_amt]
      ,[tax_ttl_amt]
      ,[current_balance]
      ,[id_payer]
      ,[id_payer_interval]
      ,[sample_flag]
      ,[balance_forward_date]
 FROM %%%NETMETERSTAGE_PREFIX%%%%1% option(maxdop 1)",
        postprocess="DROP TABLE %%%NETMETERSTAGE_PREFIX%%%%1%"]
];

au61 ->[buffered=false] install61("input(0)");
sgb61 ->[buffered=false] install61("control");

-- Next feed is a summary and updates to t_invoice_range and t_invoice_namespace
invoice_range_parallel:hash_group_by[key="id_interval", key="namespace",
initialize="CREATE PROCEDURE i @tmp_id_invoice_num_first INTEGER @tmp_id_invoice_num_last INTEGER
AS
SET @tmp_id_invoice_num_first = 2147483647
SET @tmp_id_invoice_num_last = -2147483646",
update="CREATE PROCEDURE u @id_invoice_num INTEGER @tmp_id_invoice_num_first INTEGER @tmp_id_invoice_num_last INTEGER
AS
IF @id_invoice_num < @tmp_id_invoice_num_first
  SET @tmp_id_invoice_num_first = @id_invoice_num
IF @id_invoice_num > @tmp_id_invoice_num_last
  SET @tmp_id_invoice_num_last = @id_invoice_num"];

invoice_range_part:hashpart[key="id_interval", key="namespace"];
invoice_range_coll:coll[];

invoice_range_sequential:hash_group_by[key="id_interval", key="namespace",
initialize="CREATE PROCEDURE i @id_invoice_num_first INTEGER @id_invoice_num_last INTEGER
AS
SET @id_invoice_num_first = 2147483647
SET @id_invoice_num_last = -2147483646",
update="CREATE PROCEDURE u @tmp_id_invoice_num_first INTEGER @tmp_id_invoice_num_last INTEGER @id_invoice_num_first INTEGER @id_invoice_num_last INTEGER
AS
IF @id_invoice_num_first > @tmp_id_invoice_num_first
  SET @id_invoice_num_first = @tmp_id_invoice_num_first
IF @id_invoice_num_last < @tmp_id_invoice_num_last
  SET @id_invoice_num_last = @tmp_id_invoice_num_last"];

invoice_numbers_copy(1) -> invoice_range_parallel -> invoice_range_part -> invoice_range_coll -> invoice_range_sequential;

g62:generate[program="
CREATE PROCEDURE p @id_commit_unit INTEGER OUTPUT
AS
SET @id_commit_unit = CAST(@@RECORDCOUNT / 50000LL AS INTEGER)"];
c62:copy[];
invoice_range_sequential -> g62 -> c62;

au62:insert[table="invoice_summary_temp", schema="NetMeter", createTable=true, batchSize=50000, transactionKey="id_commit_unit"];
c62(0) -> au62;
sgb62:sort_group_by[key="id_commit_unit",
initialize="
CREATE PROCEDURE i @size_0 INTEGER 
AS
SET @size_0 = 0",
update="
CREATE PROCEDURE u @size_0 INTEGER 
AS
SET @size_0 = @size_0 + 1"];
c62(1) -> sgb62;
install62:sql_exec_direct[
statementList=[query="INSERT INTO t_invoice_range (id_interval, id_billgroup, namespace, id_invoice_num_first, id_invoice_num_last)
                      SELECT id_interval, %%ID_BILLGROUP%%, namespace, id_invoice_num_first, id_invoice_num_last
                      FROM %%%NETMETERSTAGE_PREFIX%%%%1% option(maxdop 1)",
               query="UPDATE t_invoice_namespace
                      SET t_invoice_namespace.id_invoice_num_last = inv.id_invoice_num_last
                      FROM %%%NETMETERSTAGE_PREFIX%%%%1% inv
                      WHERE t_invoice_namespace.namespace = inv.namespace",
               postprocess="DROP TABLE %%%NETMETERSTAGE_PREFIX%%%%1%"]
];

au62 ->[buffered=false] install62("input(0)");
sgb62 ->[buffered=false] install62("control");
]]></Script>
</MetraFlowScript>