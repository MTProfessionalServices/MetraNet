<?xml version="1.0" encoding="utf-8"?>
<MetraFlowScript>
    <Name>InvoiceSummarizeContributions</Name>
    <Description>Generate usage summaries, adjustment summaries and balance forward amounts for invoice calculation.</Description>
    <Parameters>
        <Parameter>
            <Name>TEMP_DIR</Name>
            <SyntaxCheckValue>C:\Temp</SyntaxCheckValue>
            <Description>Directory in which to store temporary files.</Description>
        </Parameter>
        <Parameter>
            <Name>ID_INTERVAL</Name>
            <SyntaxCheckValue>1000</SyntaxCheckValue>
            <Description>Usage intervals for which invoices are being processed.</Description>
        </Parameter>
        <Parameter>
            <Name>ID_BILLGROUP</Name>
            <SyntaxCheckValue>1000</SyntaxCheckValue>
            <Description>Billing group for which invoices are being processed.</Description>
        </Parameter>
    </Parameters>
    <Script>
      <![CDATA[
-- If an account has either a previous balance, an adjustment in the interval being processed 
-- or usage in the interval being processed, it needs an invoice record.

au:sequential_file_scan[filename="%%TEMP_DIR%%\t_acc_usage_%1%.mfd"];

au_part:hashpart[key="id_acc"];

au -> au_part;

au_coll:coll[];

au_part -> au_coll;

pi_template:select[baseQuery="SELECT piTemplated2.id_template, piTemplated2.id_template_parent, pi_type_props.n_kind
FROM t_pi_template piTemplated2
INNER JOIN t_base_props pi_type_props ON pi_type_props.id_prop=piTemplated2.id_pi
WHERE
{fn mod(piTemplated2.id_template, %%NUMPARTITIONS%%)} = %%PARTITION%%"];

pi_template_part:broadcast[];

pi_template_coll:coll[];

pi_template_join:right_outer_hash_join[tableKey="id_template", probeKey="id_pi_template"];

pi_template -> pi_template_part -> pi_template_coll -> pi_template_join("table");
au_coll -> pi_template_join("probe(0)");

first_pass_pvs:select[baseQuery="SELECT id_enum_data
FROM t_enum_data 
WHERE nm_enum_data LIKE N'%_TEMP'", mode="sequential"];

first_pass_part:broadcast[mode="sequential"];

first_pass_join:right_outer_hash_join[tableKey="id_enum_data", probeKey="id_view"];

first_pass_pvs -> first_pass_part -> first_pass_join("table");
pi_template_join -> first_pass_join("probe(0)");

usage_filter:filter[program="
CREATE FUNCTION f (@n_kind INTEGER @id_enum_data INTEGER @id_pi_template INTEGER @id_template_parent INTEGER) RETURNS BOOLEAN
AS
RETURN (@n_kind <> 15 or @id_enum_data IS NULL)
AND (@id_pi_template is null or @id_template_parent is null)"];

first_pass_join -> usage_filter;

view_hierarchy:select[baseQuery="SELECT vh.id_view as vh_id_view FROM t_view_hierarchy vh WHERE vh.id_view=vh.id_view_parent", 
mode="sequential"];

view_hierarchy_part:broadcast[mode="sequential"];

view_hierarchy_join:right_outer_hash_join[tableKey="vh_id_view", probeKey="id_view"];

view_hierarchy -> view_hierarchy_part -> view_hierarchy_join("table");
usage_filter -> view_hierarchy_join("probe(0)");

-- TODO: Filter earlier...
bg:select[baseQuery="SELECT id_acc as bgm_id_acc
FROM t_billgroup_member 
WHERE
id_billgroup=%%ID_BILLGROUP%%
AND
{fn mod(id_acc, %%NUMPARTITIONS%%)} = %%PARTITION%%",
partitionConstraint="Database"];

bg_part:hashpart[key="bgm_id_acc",
partitionConstraint="Database"];

bg_coll:coll[];

bg_filter:inner_hash_join[tableKey="bgm_id_acc", probeKey="id_acc"];

bg -> bg_part -> bg_coll -> bg_filter("table");
view_hierarchy_join -> bg_filter("probe(0)");


invoice_summary:hash_group_by[key="id_acc", key="id_usage_interval", 
initialize="CREATE PROCEDURE i @payment_ttl_amt DECIMAL @ar_adj_ttl_amt DECIMAL @tax_ttl_amt DECIMAL @current_charges DECIMAL
AS
SET @payment_ttl_amt = 0.0
SET @ar_adj_ttl_amt = 0.0
SET @tax_ttl_amt = 0.0
SET @current_charges = 0.0",
update="CREATE PROCEDURE u 
@id_view INTEGER 
@vh_id_view INTEGER 
@amount DECIMAL 
@Tax_Federal DECIMAL
@Tax_State DECIMAL
@Tax_County DECIMAL
@Tax_Local DECIMAL
@Tax_Other DECIMAL
@payment_ttl_amt DECIMAL 
@ar_adj_ttl_amt DECIMAL 
@tax_ttl_amt DECIMAL 
@current_charges DECIMAL
AS
IF @id_view = CAST(#metratech.com/payment# AS INTEGER)
  SET @payment_ttl_amt = @payment_ttl_amt + CASE WHEN @amount IS NULL THEN 0.0 ELSE @amount END
ELSE IF @id_view = CAST(#metratech.com/aradjustment# AS INTEGER)
  SET @ar_adj_ttl_amt = @ar_adj_ttl_amt + CASE WHEN @amount IS NULL THEN 0.0 ELSE @amount END
ELSE
BEGIN 
  SET @tax_ttl_amt = @tax_ttl_amt + 
                     CASE WHEN @Tax_Federal IS NULL THEN 0.0 ELSE @Tax_Federal END +
                     CASE WHEN @Tax_State IS NULL THEN 0.0 ELSE @Tax_State END +
                     CASE WHEN @Tax_County IS NULL THEN 0.0 ELSE @Tax_County END +
                     CASE WHEN @Tax_Local IS NULL THEN 0.0 ELSE @Tax_Local END +
                     CASE WHEN @Tax_Other IS NULL THEN 0.0 ELSE @Tax_Other END 
  IF NOT @vh_id_view IS NULL
    SET @current_charges = @current_charges + CASE WHEN @amount IS NULL THEN 0.0 ELSE @amount END
END"];

usage_invoice_contributions:expr[program="CREATE PROCEDURE p 
@current_charges DECIMAL
@tax_ttl_amt DECIMAL 
@ar_adj_ttl_amt DECIMAL
@payment_ttl_amt DECIMAL
@invoice_amount DECIMAL OUTPUT
@postbill_adj_ttl_amt DECIMAL OUTPUT
@current_balance DECIMAL OUTPUT
AS
SET @invoice_amount =   @current_charges + @tax_ttl_amt
SET @postbill_adj_ttl_amt = 0.0
SET @current_balance = @current_charges + @tax_ttl_amt + @ar_adj_ttl_amt + @payment_ttl_amt"];

bg_filter -> invoice_summary;

usage_contributions_rename:rename[
from="id_usage_interval", to="id_interval"];

usage_contributions_project:projection[
column="id_interval",
column="id_acc",
column="invoice_amount",
column="payment_ttl_amt",
column="postbill_adj_ttl_amt",
column="ar_adj_ttl_amt",
column="tax_ttl_amt",
column="current_balance"];

invoice_summary -> usage_invoice_contributions -> usage_contributions_rename -> usage_contributions_project;


-- Get last previous balance for accounts in our billgroup.  For robustness we examine
-- all existing invoices and pull the one with the latest interval end date.
adjustment_select:select[baseQuery="SELECT 
adj.id_acc_payer as aj_id_acc, 
adj.id_usage_interval as aj_id_usage_interval,
adj.n_adjustmenttype as aj_n_adjustmenttype, 
adj.AdjustmentAmount as aj_adjustmentamount,
adj.aj_tax_federal,
adj.aj_tax_state,
adj.aj_tax_county,
adj.aj_tax_local,
adj.aj_tax_other
FROM
t_adjustment_transaction adj
WHERE
adj.c_status = 'A'
and
adj.id_usage_interval=%%ID_INTERVAL%%
and 
(adj.id_sess is not null or adj.archive_sess is not null)
and
{fn mod(adj.id_adj_trx, %%NUMPARTITIONS%%)} = %%PARTITION%%",
partitionConstraint="Database"];

adjustment_part:hashpart[key="aj_id_acc",
partitionConstraint="Database"];

adjustment_coll:coll[];

aj_bgm:select[baseQuery="SELECT id_acc as bgm_id_acc
FROM
t_billgroup_member bgm
WHERE
bgm.id_billgroup=%%ID_BILLGROUP%%
AND
{fn mod(bgm.id_acc, %%NUMPARTITIONS%%)} = %%PARTITION%%",
partitionConstraint="Database"];

aj_bgm_part:hashpart[key="bgm_id_acc", 
partitionConstraint="Database"];

aj_bgm_coll:coll[];

aj_bgm_filter:inner_hash_join[tableKey="bgm_id_acc", probeKey="aj_id_acc"];

adjustment_select -> adjustment_part -> adjustment_coll -> aj_bgm_filter("probe(0)");
aj_bgm -> aj_bgm_part -> aj_bgm_coll -> aj_bgm_filter("table");

aj_group_by:hash_group_by[key="aj_id_acc", key="aj_id_usage_interval",
initialize="CREATE PROCEDURE i @PrebillAdjAmt DECIMAL @PrebillTaxAdjAmt DECIMAL @PostbillAdjAmt DECIMAL @PostbillTaxAdjAmt DECIMAL
AS
SET @PrebillAdjAmt = 0.0
SET @PrebillTaxAdjAmt = 0.0
SET @PostbillAdjAmt = 0.0
SET @PostbillTaxAdjAmt = 0.0",
update="CREATE PROCEDURE u @PrebillAdjAmt DECIMAL @PrebillTaxAdjAmt DECIMAL @PostbillAdjAmt DECIMAL @PostbillTaxAdjAmt DECIMAL
@aj_n_adjustmenttype INTEGER
@aj_adjustmentamount DECIMAL
@aj_tax_federal DECIMAL
@aj_tax_state DECIMAL
@aj_tax_county DECIMAL
@aj_tax_local DECIMAL
@aj_tax_other DECIMAL
AS
DECLARE @total_tax DECIMAL
SET @total_tax =    
      CASE WHEN @aj_tax_federal IS NULL THEN 0.0 ELSE @aj_tax_federal END +
      CASE WHEN @aj_tax_state IS NULL THEN 0.0 ELSE @aj_tax_state END +
      CASE WHEN @aj_tax_county IS NULL THEN 0.0 ELSE @aj_tax_county END +
      CASE WHEN @aj_tax_local IS NULL THEN 0.0 ELSE @aj_tax_local END +
      CASE WHEN @aj_tax_other IS NULL THEN 0.0 ELSE @aj_tax_other END 

IF @aj_n_adjustmenttype = 0
BEGIN
  SET @PrebillAdjAmt = @PrebillAdjAmt + CASE WHEN @aj_adjustmentamount IS NULL THEN 0.0 ELSE @aj_adjustmentamount END
  SET @PrebillTaxAdjAmt = @PrebillTaxAdjAmt + @total_tax
END
ELSE
BEGIN 
  SET @PostbillAdjAmt = @PostbillAdjAmt + CASE WHEN @aj_adjustmentamount IS NULL THEN 0.0 ELSE @aj_adjustmentamount END
  SET @PostbillTaxAdjAmt = @PostbillTaxAdjAmt + @total_tax
END"];

aj_invoice_contributions:expr[program="CREATE PROCEDURE p 
@PrebillAdjAmt DECIMAL 
@PrebillTaxAdjAmt DECIMAL 
@PostbillAdjAmt DECIMAL 
@PostbillTaxAdjAmt DECIMAL
@invoice_amount DECIMAL OUTPUT
@payment_ttl_amt DECIMAL OUTPUT
@postbill_adj_ttl_amt DECIMAL OUTPUT
@ar_adj_ttl_amt DECIMAL OUTPUT
@tax_ttl_amt DECIMAL OUTPUT
@current_balance DECIMAL OUTPUT
AS
SET @invoice_amount = @PrebillAdjAmt + @PrebillTaxAdjAmt
SET @payment_ttl_amt = 0.0
SET @postbill_adj_ttl_amt = @PostbillAdjAmt + @PostbillTaxAdjAmt
SET @ar_adj_ttl_amt = 0.0
SET @tax_ttl_amt = @PrebillTaxAdjAmt
SET @current_balance = @PrebillAdjAmt + @PrebillTaxAdjAmt + @PostbillAdjAmt + @PostbillTaxAdjAmt"];


aj_contributions_rename:rename[
from="aj_id_acc", to="id_acc",
from="aj_id_usage_interval", to="id_interval"];

aj_contributions_project:projection[
column="id_interval",
column="id_acc",
column="invoice_amount",
column="payment_ttl_amt",
column="postbill_adj_ttl_amt",
column="ar_adj_ttl_amt",
column="tax_ttl_amt",
column="current_balance"];

aj_bgm_filter -> aj_group_by -> aj_invoice_contributions -> aj_contributions_rename -> aj_contributions_project;


-- Get last previous balance for accounts in our billgroup.  For robustness we examine
-- all existing invoices and pull the one with the latest interval end date.
previous_invoice:select[baseQuery="SELECT inv.id_acc as inv_id_acc, inv.id_interval as inv_id_usage_interval, inv.current_balance as inv_current_balance
FROM
t_invoice inv
WHERE
{fn mod(inv.id_acc, %%NUMPARTITIONS%%)} = %%PARTITION%%",
partitionConstraint="Database"];

previous_invoice_part:hashpart[key="inv_id_acc",
partitionConstraint="Database"];

previous_invoice_coll:coll[];

inv_bgm:select[baseQuery="SELECT id_acc as bgm_id_acc
FROM
t_billgroup_member bgm
WHERE
bgm.id_billgroup=%%ID_BILLGROUP%%
AND
{fn mod(bgm.id_acc, %%NUMPARTITIONS%%)} = %%PARTITION%%",
partitionConstraint="Database"];

inv_bgm_part:hashpart[key="bgm_id_acc",
partitionConstraint="Database"];

inv_bgm_coll:coll[];

inv_bgm_filter:multi_hash_join[tableKey="bgm_id_acc" 
,probe="right semi", probeKey="inv_id_acc"
];

previous_invoice -> previous_invoice_part -> previous_invoice_coll -> inv_bgm_filter("probe(0)");
inv_bgm -> inv_bgm_part -> inv_bgm_coll -> inv_bgm_filter("table");

invoice_end_date:select[baseQuery="SELECT id_interval as ui_id_usage_interval, dt_end as ui_dt_end
FROM
t_usage_interval ui
WHERE
{fn mod(id_interval, %%NUMPARTITIONS%%)} = %%PARTITION%%"];

invoice_end_date_part:broadcast[];

invoice_end_date_coll:coll[]

invoice_end_date_join:inner_hash_join[tableKey="ui_id_usage_interval", probeKey="inv_id_usage_interval"];

invoice_end_date -> invoice_end_date_part -> invoice_end_date_coll -> invoice_end_date_join("table");
inv_bgm_filter -> invoice_end_date_join("probe(0)");

-- Pick last invoice
last_invoice:hash_group_by[key="inv_id_acc", key="inv_id_usage_interval",
initialize="CREATE PROCEDURE i @previous_balance DECIMAL @previous_balance_date DATETIME
AS
SET @previous_balance = 0.0
SET @previous_balance_date = CAST('1970-01-01' AS DATETIME)",
update="CREATE PROCEDURE u @previous_balance DECIMAL @previous_balance_date DATETIME
@inv_current_balance DECIMAL @ui_dt_end DATETIME
AS
IF @ui_dt_end > @previous_balance_date
BEGIN
  SET @previous_balance_date = @ui_dt_end
  SET @previous_balance = @inv_current_balance
END"];

invoice_end_date_join -> last_invoice;

previous_balance_contributions:expr[program="CREATE PROCEDURE p 
@previous_balance DECIMAL 
@invoice_amount DECIMAL OUTPUT
@payment_ttl_amt DECIMAL OUTPUT
@postbill_adj_ttl_amt DECIMAL OUTPUT
@ar_adj_ttl_amt DECIMAL OUTPUT
@tax_ttl_amt DECIMAL OUTPUT
@current_balance DECIMAL OUTPUT
AS
SET @invoice_amount = 0.0
SET @payment_ttl_amt = 0.0
SET @postbill_adj_ttl_amt = 0.0
SET @ar_adj_ttl_amt = 0.0
SET @tax_ttl_amt = 0.0
SET @current_balance = @previous_balance"];

previous_balance_rename:rename[
from="inv_id_acc", to="id_acc",
from="inv_id_usage_interval", to="id_interval"];

previous_balance_contributions_project:projection[
column="id_interval",
column="id_acc",
column="invoice_amount",
column="payment_ttl_amt",
column="postbill_adj_ttl_amt",
column="ar_adj_ttl_amt",
column="tax_ttl_amt",
column="current_balance"];

last_invoice -> previous_balance_contributions -> previous_balance_rename ->  previous_balance_contributions_project;

all_invoice_contributions:union_all[];

usage_contributions_project -> all_invoice_contributions(0);
aj_contributions_project -> all_invoice_contributions(1);
previous_balance_contributions_project -> all_invoice_contributions(2);

invoice_contributions_summary:hash_group_by[key="id_acc", key="id_interval",
initialize="CREATE PROCEDURE i 
@Table_invoice_amount DECIMAL 
@Table_payment_ttl_amt DECIMAL 
@Table_postbill_adj_ttl_amt DECIMAL 
@Table_ar_adj_ttl_amt DECIMAL 
@Table_tax_ttl_amt DECIMAL 
@Table_current_balance DECIMAL 
AS
SET @Table_invoice_amount = 0.0
SET @Table_payment_ttl_amt = 0.0
SET @Table_postbill_adj_ttl_amt = 0.0
SET @Table_ar_adj_ttl_amt = 0.0
SET @Table_tax_ttl_amt = 0.0
SET @Table_current_balance = 0.0",
update="CREATE PROCEDURE u 
@Probe_invoice_amount DECIMAL 
@Probe_payment_ttl_amt DECIMAL 
@Probe_postbill_adj_ttl_amt DECIMAL 
@Probe_ar_adj_ttl_amt DECIMAL 
@Probe_tax_ttl_amt DECIMAL 
@Probe_current_balance DECIMAL 
@Table_invoice_amount DECIMAL 
@Table_payment_ttl_amt DECIMAL 
@Table_postbill_adj_ttl_amt DECIMAL 
@Table_ar_adj_ttl_amt DECIMAL 
@Table_tax_ttl_amt DECIMAL 
@Table_current_balance DECIMAL 
AS
SET @Table_invoice_amount = @Table_invoice_amount + @Probe_invoice_amount
SET @Table_payment_ttl_amt = @Table_payment_ttl_amt + @Probe_payment_ttl_amt
SET @Table_postbill_adj_ttl_amt = @Table_postbill_adj_ttl_amt + @Probe_postbill_adj_ttl_amt
SET @Table_ar_adj_ttl_amt = @Table_ar_adj_ttl_amt + @Probe_ar_adj_ttl_amt
SET @Table_tax_ttl_amt = @Table_tax_ttl_amt + @Probe_tax_ttl_amt
SET @Table_current_balance = @Table_current_balance + @Probe_current_balance"];

all_invoice_contributions -> invoice_contributions_summary;

invoice_summaries:sequential_file_write[filename="%%TEMP_DIR%%\invoice_contributions_%1%.mfd"];

invoice_contributions_summary -> invoice_summaries;
]]></Script>
</MetraFlowScript>