<?xml version="1.0" encoding="utf-8"?>
<MetraFlowScript>
    <Name>NonRecurringChargeGenerateEvents</Name>
    <Description>Generate subscription start and end events that trigger non-recurring charge generation.</Description>
    <Parameters>
        <Parameter>
            <Name>TEMP_DIR</Name>
            <SyntaxCheckValue>C:\Temp</SyntaxCheckValue>
            <Description>Directory in which to store sort run files for sort run files.</Description>
        </Parameter>
        <Parameter>
            <Name>ID_RUN</Name>
            <SyntaxCheckValue>1000</SyntaxCheckValue>
            <Description>Usage server internal process identifier of the adapter invocation being processed.</Description>
        </Parameter>
        <Parameter>
            <Name>DT_START</Name>
            <SyntaxCheckValue>1970-01-01</SyntaxCheckValue>
            <Description>Start date of the time interval in which events occurred.</Description>
        </Parameter>
        <Parameter>
            <Name>DT_END</Name>
            <SyntaxCheckValue>2038-01-01</SyntaxCheckValue>
            <Description>End date of the time interval in which events occurred.</Description>
        </Parameter>
    </Parameters>
    <Script>
      <![CDATA[
t_sub_history:select[baseQuery="SELECT id_sub as s_id_sub, id_acc as s_id_acc, id_po as s_id_po, id_group as s_id_group, vt_start as s_vt_start, vt_end as s_vt_end, tt_start as s_tt_start, tt_end as s_tt_end
FROM
t_sub_history
WHERE
{fn mod(id_sub, %%NUMPARTITIONS%%)} = %%PARTITION%%"];

t_sub_history_branch:switch[program="CREATE FUNCTION f (@s_id_group INTEGER) RETURNS INTEGER
AS
RETURN CASE WHEN @s_id_group IS NULL THEN 0 ELSE 1 END"];
t_sub_history -> t_sub_history_branch;

t_sub_history_sub_filter:filter[program="CREATE FUNCTION f (@s_tt_end DATETIME) RETURNS BOOLEAN
AS
RETURN @s_tt_end = CAST('2038-01-01' AS DATETIME)"];
t_sub_history_branch(0) -> t_sub_history_sub_filter;

t_sub_history_calc_position:expr[program="CREATE PROCEDURE p @s_id_sub INTEGER @position INTEGER OUTPUT
AS
SET @position = @s_id_sub"];

t_sub_history_sub_filter -> t_sub_history_calc_position;

t_sub_history_project:projection[
column="s_id_po", 
column="s_id_acc",
column="s_id_sub",
column="s_vt_start",
column="s_vt_end",
column="s_tt_start",
column="s_tt_end",
column="position"];

t_sub_history_calc_position -> t_sub_history_project;

t_sub_history_gsub_part:hashpart[key="s_id_group"];

t_sub_history_branch(1) -> t_sub_history_gsub_part;

t_sub_history_gsub_coll:coll[];

t_sub_history_gsub_part -> t_sub_history_gsub_coll;

t_sub_history_gsub_sort:sort[key="s_id_group", temp_dir="%%TEMP_DIR%%", allowedMemory=100000000];

t_sub_history_gsub_coll -> t_sub_history_gsub_sort;

t_gsubmember_history:select[baseQuery="SELECT id_group as gsm_id_group, id_acc as gsm_id_acc, vt_start as gsm_vt_start, vt_end as gsm_vt_end, tt_start as gsm_tt_start, tt_end as gsm_tt_end
FROM
t_gsubmember_historical
WHERE
{fn mod(id_group, %%NUMPARTITIONS%%)} = %%PARTITION%%"];
t_gsubmember_history_part:hashpart[key="gsm_id_group"];

t_gsubmember_history -> t_gsubmember_history_part;

t_gsubmember_history_coll:coll[];
t_gsubmember_history_part -> t_gsubmember_history_coll;

t_gsubmember_history_sort:sort[key="gsm_id_group", key="gsm_id_acc", temp_dir="%%TEMP_DIR%%", allowedMemory=100000000];
t_gsubmember_history_coll -> t_gsubmember_history_sort;

t_gsubmember_history_copy:copy[];
t_gsubmember_history_sort -> t_gsubmember_history_copy;

t_gsubmember_history_rename:rename[
from="gsm_id_group", to="gsm2_id_group",
from="gsm_id_acc", to="gsm2_id_acc",
from="gsm_vt_start", to="gsm2_vt_start",
from="gsm_vt_end", to="gsm2_vt_end",
from="gsm_tt_start", to="gsm2_tt_start",
from="gsm_tt_end", to="gsm2_tt_end"];

t_gsubmember_history_copy(0) -> t_gsubmember_history_rename;

t_gsubmember_history_self_join:inner_merge_join[leftKey="gsm2_id_group", leftKey="gsm2_id_acc", rightKey="gsm_id_group", rightKey="gsm_id_acc", residual="
CREATE FUNCTION f (@gsm_vt_start DATETIME @gsm2_vt_start DATETIME @gsm_tt_start DATETIME @gsm2_tt_start DATETIME @gsm_tt_end DATETIME @gsm2_tt_end DATETIME) RETURNS BOOLEAN
AS 
RETURN @gsm_tt_start <= @gsm2_tt_end and @gsm2_tt_start <= @gsm_tt_end and @gsm_vt_start >= @gsm2_vt_start"];

t_gsubmember_history_rename -> t_gsubmember_history_self_join("left");
t_gsubmember_history_copy(1) -> t_gsubmember_history_self_join("right");

t_gsubmember_position_calc:sort_group_by[key="gsm_id_group", key="gsm_id_acc", key="gsm_vt_start", key="gsm_vt_end", key="gsm_tt_start", key="gsm_tt_end",
initialize="CREATE PROCEDURE p @position INTEGER
AS
SET @position = 0",
update="CREATE PROCEDURE u @position INTEGER
AS
SET @position = @position + 1"];
t_gsubmember_history_self_join -> t_gsubmember_position_calc;

gsub_sub_join:inner_merge_join[leftKey="gsm_id_group", rightKey="s_id_group"];
t_gsubmember_position_calc -> gsub_sub_join("left");
t_sub_history_gsub_sort -> gsub_sub_join("right");

gsub_projection:project[
column="s_id_po", 
column="gsm_id_acc",
column="s_id_sub",
column="gsm_vt_start",
column="gsm_vt_end",
column="gsm_tt_start",
column="gsm_tt_end",
column="position"];

gsub_sub_join -> gsub_projection;

gsub_rename:rename[
from="gsm_id_acc", to="s_id_acc",
from="gsm_vt_start", to="s_vt_start",
from="gsm_vt_end", to="s_vt_end",
from="gsm_tt_start", to="s_tt_start",
from="gsm_tt_end", to="s_tt_end"];

gsub_projection -> gsub_rename;

all_subs:union_all[];

gsub_rename -> all_subs(0);
t_sub_history_project -> all_subs(1);

all_subs_calc_some_stuff:expr[program="CREATE PROCEDURE p @s_vt_start DATETIME @s_vt_end DATETIME @s_tt_start DATETIME
@max_vt_tt_start DATETIME OUTPUT @max_vt_tt_end DATETIME OUTPUT
AS
SET @max_vt_tt_start = CASE WHEN @s_vt_start > @s_tt_start THEN @s_vt_start ELSE @s_tt_start END
SET @max_vt_tt_end = CASE WHEN @s_vt_end > @s_tt_start THEN @s_vt_end ELSE @s_tt_start END"];

all_subs -> all_subs_calc_some_stuff;

t_nonrecur_select:select[baseQuery="SELECT id_prop as nrc_id_prop, n_event_type as nrc_n_event_type
FROM 
t_nonrecur",
mode="sequential"];

t_pl_map_select:select[baseQuery="SELECT id_po as plm_id_po, id_pi_template as plm_id_pi_template, id_pi_instance as plm_id_pi_instance, id_pi_type as plm_id_pi_type
FROM 
t_pl_map
WHERE
id_paramtable IS NULL",
mode="sequential"];

t_nonrecur_pl_map_join:inner_hash_join[tableKey="nrc_id_prop", probeKey="plm_id_pi_instance", mode="sequential"];

t_pl_map_select -> t_nonrecur_pl_map_join("probe(0)");
t_nonrecur_select -> t_nonrecur_pl_map_join("table");

t_nonrecur_pl_map:broadcast[mode="sequential"];
t_nonrecur_pl_map_join -> t_nonrecur_pl_map;

t_nonrecur_sub_join:inner_hash_join[tableKey="plm_id_po", probeKey="s_id_po"];
t_nonrecur_pl_map -> t_nonrecur_sub_join("table");
all_subs_calc_some_stuff -> t_nonrecur_sub_join("probe(0)");

t_nonrecur_sub_hack:expr[program="CREATE PROCEDURE p @oo234 INTEGER OUTPUT
AS
SET @oo234 = 1"];

t_nonrecur_sub_join -> t_nonrecur_sub_hack;

nrc_recevent_inst_select:select[baseQuery="SELECT re.dt_activated, re.dt_deactivated, rei.dt_arg_start, rei.dt_arg_end
FROM
t_recevent re
INNER JOIN t_recevent_inst rei ON rei.id_event=re.id_event
WHERE
EXISTS
(
	SELECT 1
	FROM 
	t_recevent re2
	INNER JOIN t_recevent_inst rei2 ON re2.id_event=rei2.id_event
	INNER JOIN t_recevent_run rer2 ON rer2.id_instance=rei2.id_instance
	WHERE
	re.tx_name=re2.tx_name
	AND
	rer2.id_run=%%ID_RUN%%
)",
mode="sequential"];

nrc_recevent_hack:expr[program="CREATE PROCEDURE p @uj234 INTEGER OUTPUT @dt_start DATETIME OUTPUT @dt_end DATETIME OUTPUT
AS
SET @uj234 = 1
SET @dt_start = CAST('%%DT_START%%' AS DATETIME)
SET @dt_end = CAST('%%DT_END%%' AS DATETIME)", mode="sequential"];

nrc_recevent_inst_select -> nrc_recevent_hack; 

nrc_recevent_inst:broadcast[mode="sequential"];

nrc_recevent_hack -> nrc_recevent_inst;

nrc_recevent_join:inner_hash_join[tableKey="uj234", probeKey="oo234", residual="
CREATE FUNCTION f (@dt_activated DATETIME @dt_deactivated DATETIME @dt_arg_start DATETIME @dt_arg_end DATETIME @max_vt_tt_start DATETIME) RETURNS BOOLEAN
AS
RETURN @max_vt_tt_start >= @dt_activated AND @max_vt_tt_start <= CASE WHEN @dt_deactivated IS NULL THEN CAST('2038-01-01' AS DATETIME) ELSE @dt_deactivated END AND @max_vt_tt_start >= @dt_arg_start AND @max_vt_tt_start <= @dt_arg_end"];

nrc_recevent_inst -> nrc_recevent_join("table");
t_nonrecur_sub_hack -> nrc_recevent_join("probe(0)");

t_sub_history_acc_part:hashpart[key="s_id_acc", key="s_id_sub"];
nrc_recevent_join -> t_sub_history_acc_part;

t_sub_history_acc_coll:coll[];
t_sub_history_acc_part -> t_sub_history_acc_coll;

t_sub_history_acc_sub_sort:sort[key="s_id_acc", key="s_id_sub", key="plm_id_pi_instance", key="position", temp_dir="%%TEMP_DIR%%", allowedMemory=250000000];

t_sub_history_acc_coll -> t_sub_history_acc_sub_sort;

t_sub_history_acc_sub_copy:copy[];

t_sub_history_acc_sub_sort -> t_sub_history_acc_sub_copy;

t_sub_history_acc_sub_rename:rename[
from="s_id_acc", to="s2_id_acc",
from="s_id_sub", to="s2_id_sub",
from="s_vt_start", to="s2_vt_start",
from="s_vt_end", to="s2_vt_end",
from="s_tt_start", to="s2_tt_start",
from="s_tt_end", to="s2_tt_end",
from="plm_id_pi_instance", to="plm2_id_pi_instance",
from="max_vt_tt_start", to="max_vt_tt_start2",
from="max_vt_tt_end", to="max_vt_tt_end2",
from="dt_arg_end", to="dt_arg_end2",
from="dt_start", to="dt_start2",
from="dt_end", to="dt_end2",
from="nrc_n_event_type", to="nrc2_n_event_type",
from="position", to="position2"];

t_sub_history_acc_sub_copy(0) -> t_sub_history_acc_sub_rename;

t_sub_history_identify_nrcs:right_merge_anti_semi_join[leftKey="s2_id_acc", leftKey="s2_id_sub", leftKey="plm2_id_pi_instance", leftKey="position2",
rightKey="s_id_acc", rightKey="s_id_sub", rightKey="plm_id_pi_instance", rightKey="position",
residual="CREATE FUNCTION f (@nrc_n_event_type INTEGER @max_vt_tt_start DATETIME @max_vt_tt_end DATETIME @s_tt_start DATETIME @s_tt_end DATETIME @max_vt_tt_start2 DATETIME @max_vt_tt_end2 DATETIME @s2_tt_start DATETIME @s2_tt_end DATETIME @dt_arg_end2 DATETIME @dt_start DATETIME @dt_end DATETIME) RETURNS BOOLEAN
AS
RETURN (@nrc_n_event_type=1 
and 
@max_vt_tt_start >= @dt_start 
and
@max_vt_tt_start <= @dt_end
and
@dt_end >= @s_tt_start 
and
@dt_end <= @s_tt_end
and
@max_vt_tt_start2 < @dt_start 		
and
@dt_start > @s2_tt_start
and
	/* If a charge was previously billed, then it must have been true when billed */
	/* that tt_end > @dt_end > dbo.MTMaxOfTwoDates(tt_start, vt_start). */
	/* Granted, tt_end can be decrease as a fact is invalidated.  However, if we */
	/* assume that the adapter is NOT run in the future, then we conclude that */
	/* any subsequent tt_end will also be > @dt_end for the scheduled interval in */
	/* which the charge was billed.  Conversely if tt_end < @dt_end when the charge */
	/* was considered (and rejected), since tt_end is non-increasing it must still be */
	/* true.  Bottom line, we can figure out if the charge billed.  Whew! */
@dt_arg_end2 <= @s2_tt_end)
OR
(
@nrc_n_event_type=2
and
@max_vt_tt_end >= @dt_start 
and
@max_vt_tt_end <= @dt_end
and
@dt_end >= @s_tt_start 
and
@dt_end <= @s_tt_end
and
@max_vt_tt_end2 < @dt_start 		
and
@dt_start > @s2_tt_start
	and
	/* If a charge was previously billed, then it must have been true when billed */
	/* that tt_end > @dt_end > dbo.MTMaxOfTwoDates(tt_start, vt_start). */
	/* Granted, tt_end can be decrease as a fact is invalidated.  However, if we */
	/* assume that the adapter is NOT run in the future, then we conclude that */
	/* any subsequent tt_end will also be > @dt_end for the scheduled interval in */
	/* which the charge was billed; thus even now we know tt_end > dbo.MTMaxOfTwoDates(tt_start, vt_start). */
@dt_arg_end2 < @s2_tt_end
)
"];

t_sub_history_acc_sub_rename -> t_sub_history_identify_nrcs("left");
t_sub_history_acc_sub_copy(1) -> t_sub_history_identify_nrcs("right");

nrcs_to_meter:sequential_file_write[filename="%%TEMP_DIR%%\nrc_ready_to_rate_%1%.mfd"];

t_sub_history_identify_nrcs -> nrcs_to_meter;
]]></Script>
</MetraFlowScript>