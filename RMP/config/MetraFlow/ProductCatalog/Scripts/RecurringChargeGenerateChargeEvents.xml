<?xml version="1.0" encoding="utf-8"?>
<MetraFlowScript>
    <Name>RecurringChargeGenerateEvents</Name>
    <Description>Generates recurring charge, credit and correction events.</Description>
    <Parameters>
        <Parameter>
            <Name>TEMP_DIR</Name>
            <SyntaxCheckValue>C:\Temp</SyntaxCheckValue>
            <Description>Directory in which to store sort run files for sort run files.</Description>
        </Parameter>
        <Parameter>
            <Name>ID_INTERVAL</Name>
            <SyntaxCheckValue>1000</SyntaxCheckValue>
            <Description>Bill interval for which to process recurring charge events.</Description>
        </Parameter>
    </Parameters>
    <Script>
      <![CDATA[
all_charges:sequential_file_scan[filename="%%TEMP_DIR%%\rc_all_charges_%1%.mfd"];
credit_branch:copy[];
all_charges -> credit_branch;

udrc_values_0:sequential_file_scan[filename="%%TEMP_DIR%%\rc_temp_%1%.mfd"];
udrc_values_1:sequential_file_scan[filename="%%TEMP_DIR%%\rc_temp_%1%.mfd"];
udrc_values_2:sequential_file_scan[filename="%%TEMP_DIR%%\rc_temp_%1%.mfd"];

billing_intervals_1:sequential_file_scan[filename="%%TEMP_DIR%%\rc_billing_intervals_%1%.mfd"];

udrc_join:inner_merge_join[leftKey="v_id_sub", leftKey="v_id_pi_instance", rightKey="s_id_sub", rightKey="id_pi_instance", 
residual="CREATE FUNCTION f (@pc_dt_start DATETIME @pc_dt_end DATETIME @v_vt_start DATETIME @v_vt_end DATETIME @s_dt_start DATETIME @s_dt_end DATETIME @b_prorate_on_activate BOOLEAN @b_prorate_on_deactivate BOOLEAN @run_vt_start DATETIME @v_tt_start DATETIME @v_tt_end DATETIME @b_advance BOOLEAN) RETURNS BOOLEAN
AS
RETURN 
@pc_dt_end >= @v_vt_start AND @pc_dt_start <= @v_vt_end 
AND 
(@b_prorate_on_activate = FALSE OR @s_dt_start <= @v_vt_end) 
AND
(@b_advance = TRUE OR @b_prorate_on_deactivate = FALSE OR @s_dt_end >= @v_vt_start)
AND 
@run_vt_start >= @v_tt_start AND @run_vt_start <= @v_tt_end
"];

credit_branch_part:hashpart[key="s_id_sub"];
credit_branch_coll:coll[];
credit_branch_sort:sort[key="s_id_sub", key="id_pi_instance", temp_dir="%%TEMP_DIR%%", allowedMemory=10000000];

udrc_values_0 -> udrc_join("left");
credit_branch(0) -> credit_branch_part -> credit_branch_coll -> credit_branch_sort -> udrc_join("right");

billed_rate_date:expr[program="CREATE PROCEDURE p @BilledRateDate DATETIME OUTPUT AS SET @BilledRateDate = CAST('1970-01-01' AS DATETIME)"];

rename_charges:rename[
from="id_pi_instance", to="_PriceableItemInstanceID",
from="id_pi_template", to="_PriceableItemTemplateID",
from="id_pi_type", to="_PriceableItemTypeID",
from="id_po", to="_ProductOfferingID",
from="b_advance", to="Advance",
from="b_prorate_on_activate", to="ProrateOnSubscription",
from="b_prorate_instantly", to="ProrateInstantly",
from="b_prorate_on_deactivate", to="ProrateOnUnsubscription",
from="n_proration_cycle_length", to="ProrationCycleLength",
from="s_id_sub", to="_SubscriptionID",
from="s_dt_start", to="SubscriptionStart",
from="s_dt_end", to="SubscriptionEnd",
from="pc_dt_start", to="RCIntervalStart",
from="pc_dt_end", to="RCIntervalEnd",
from="charge_type", to="RCActionType",
from="p_id_payer", to="_PayingAccount",
from="p_id_payee", to="_AccountID",
from="v_value", to="UnitValue",
from="v_vt_start", to="UnitValueStart",
from="v_vt_end", to="UnitValueEnd",
from="b_id_usage_interval", to="_IntervalID",
from="b_id_billgroup", to="_BillGroupID",
from="b_dt_start", to="BillingIntervalStart",
from="b_dt_end", to="BillingIntervalEnd",
from="n_rating_type", to="RatingType",
from="run_vt_start", to="BillingIntervalRunDate"];

identify_charges:projection[
column="_PriceableItemInstanceID",
column="_PriceableItemTemplateID",
column="_PriceableItemTypeID",
column="_ProductOfferingID",
column="Advance",
column="ProrateOnSubscription",
column="ProrateInstantly",
column="ProrateOnUnsubscription",
column="ProrationCycleLength",
column="RatingType",
column="_SubscriptionID",
column="SubscriptionStart",
column="SubscriptionEnd",
column="RCIntervalStart",
column="RCIntervalEnd",
column="RCActionType",
column="_PayingAccount",
column="_AccountID",
column="UnitValue",
column="UnitValueStart",
column="UnitValueEnd",
column="_IntervalID",
column="_BillGroupID",
column="BillingIntervalStart",
column="BillingIntervalEnd",
column="BilledRateDate",
column="BillingIntervalRunDate"];

udrc_join -> billed_rate_date -> rename_charges -> identify_charges;

-- Now, having figured out who got initial and advance charges, we look for any credits that
-- need to be generated.

credit_filter:filter[program="
CREATE FUNCTION f (@charge_type NVARCHAR @pc_dt_start DATETIME @pc_dt_end DATETIME @s_dt_start DATETIME @s_dt_end DATETIME @s_dt_end1 DATETIME @nb_dt_start DATETIME @b_prorate_on_deactivate BOOLEAN) RETURNS BOOLEAN
AS
RETURN 
  @pc_dt_end > @s_dt_end1
  AND
  (@b_prorate_on_deactivate=TRUE or @pc_dt_start > @s_dt_end1)
  AND
  (
    (
      @charge_type = N'Initial'
      AND
      @pc_dt_end >= @s_dt_start AND @pc_dt_start <= @s_dt_end1
    )
    OR
    (
      @charge_type = N'Advance'
     AND
     @nb_dt_start > @s_dt_start
     AND
     @nb_dt_start < @s_dt_end1
    )
  )
"];

credit_intervals:rename[
from="b_id_payer", to="credit_id_payer",
from="b_id_usage_interval", to="credit_id_usage_interval",
from="b_id_billgroup", to="credit_id_billgroup",
from="b_id_cycle", to="credit_id_cycle",
from="b_dt_start", to="credit_dt_start",
from="b_dt_end", to="credit_dt_end",
from="run_vt_start", to="credit_run_vt_start"
];

-- A subscription has ended!  Attach to the billing interval in which it terminated and let's figure out whether any intervals need to be credited.
credit_join:inner_merge_join[leftKey="credit_id_payer", rightKey="b_id_payer",
residual="CREATE FUNCTION f (@credit_id_cycle INTEGER @b_id_cycle INTEGER @s_dt_start DATETIME @s_dt_end1 DATETIME @credit_dt_start DATETIME @pc_dt_start DATETIME @credit_dt_end DATETIME) RETURNS BOOLEAN
AS 
RETURN @credit_id_cycle = @b_id_cycle AND @s_dt_end1 >= @credit_dt_start AND @s_dt_end1 <= @credit_dt_end AND @s_dt_start < @credit_dt_start
-- Is this only for initial credits? 
AND @pc_dt_start < @credit_dt_end"];

credit_branch_credit_part:hashpart[key="s_id_sub"];
credit_branch_credit_coll:coll[];
credit_branch_credit_sort:sort[key="s_id_sub", key="id_pi_instance", temp_dir="%%TEMP_DIR%%", allowedMemory=10000000];

credit_udrc_join:inner_merge_join[leftKey="v_id_sub", leftKey="v_id_pi_instance", rightKey="s_id_sub", rightKey="id_pi_instance",
residual="CREATE FUNCTION f (@pc_dt_start DATETIME @pc_dt_end DATETIME @v_vt_start DATETIME @v_vt_end DATETIME @s_dt_start DATETIME @s_dt_end1 DATETIME @b_prorate_on_activate BOOLEAN @credit_run_vt_start DATETIME @v_tt_start DATETIME @v_tt_end DATETIME) RETURNS BOOLEAN
AS
RETURN @pc_dt_end >= @v_vt_start AND @pc_dt_start <= @v_vt_end AND (@b_prorate_on_activate = FALSE OR @s_dt_start <= @v_vt_end) AND @credit_run_vt_start >= @v_tt_start AND @credit_run_vt_start <= @v_tt_end AND @v_vt_end > @s_dt_end1"];

identify_credit:projection[
column="id_pi_instance",
column="id_pi_template",
column="id_pi_type",
column="id_po",
column="b_advance",
column="b_prorate_on_activate",
column="b_prorate_instantly",
column="b_prorate_on_deactivate",
column="n_proration_cycle_length",
column="n_rating_type",
column="s_id_sub",
column="s_dt_start",
column="s_dt_end",
column="pc_dt_start",
column="pc_dt_end",
column="charge_type",
column="p_id_payer",
column="p_id_payee",
-- These will be UnitValue and effective date
column="v_value",
column="v_vt_start",
column="v_vt_end",
-- These will be one before the BillingIntervalStart/End
column="credit_id_usage_interval",
column="credit_id_billgroup",
column="credit_dt_start",
column="credit_dt_end",
-- This is BilledRateDate
column="b_dt_end",
column="credit_run_vt_start"
];

tag_credit:expr[program="CREATE PROCEDURE p @charge_type NVARCHAR
AS
SET @charge_type = N'Credit'"];

rename_credit:rename[
from="id_pi_instance", to="_PriceableItemInstanceID",
from="id_pi_template", to="_PriceableItemTemplateID",
from="id_pi_type", to="_PriceableItemTypeID",
from="id_po", to="_ProductOfferingID",
from="b_advance", to="Advance",
from="b_prorate_on_activate", to="ProrateOnSubscription",
from="b_prorate_instantly", to="ProrateInstantly",
from="b_prorate_on_deactivate", to="ProrateOnUnsubscription",
from="n_proration_cycle_length", to="ProrationCycleLength",
from="s_id_sub", to="_SubscriptionID",
from="s_dt_start", to="SubscriptionStart",
from="s_dt_end", to="SubscriptionEnd",
from="pc_dt_start", to="RCIntervalStart",
from="pc_dt_end", to="RCIntervalEnd",
from="charge_type", to="RCActionType",
from="p_id_payer", to="_PayingAccount",
from="p_id_payee", to="_AccountID",
from="v_value", to="UnitValue",
from="v_vt_start", to="UnitValueStart",
from="v_vt_end", to="UnitValueEnd",
from="credit_id_usage_interval", to="_IntervalID",
from="credit_id_billgroup", to="_BillGroupID",
from="credit_dt_start", to="BillingIntervalStart",
from="credit_dt_end", to="BillingIntervalEnd",
from="b_dt_end", to="BilledRateDate",
from="n_rating_type", to="RatingType",
from="credit_run_vt_start", to="BillingIntervalRunDate"];

credit_branch(1) -> credit_filter -> credit_join("right");
billing_intervals_1 -> credit_intervals -> credit_join("left");
credit_join -> credit_branch_credit_part -> credit_branch_credit_coll -> credit_branch_credit_sort -> credit_udrc_join("right");
udrc_values_1 -> credit_udrc_join("left");
credit_udrc_join -> identify_credit -> tag_credit -> rename_credit;

-- Use the UDRC history in effect at the time of the credit generation to decide how much to credit.
-- Note that this may be very different from the UDRC history when the charge was first generated,
-- but the UDRC corrections processes make sure that all changes are accounted for.

-- These are read so we can look for changes to unit values in already billed charges.
-- Luckily we make the assumption that the payer for the original charge gets all corrections.

billing_intervals_2:sequential_file_scan[filename="%%TEMP_DIR%%\rc_billing_intervals_%1%.mfd"];

future_billing_intervals:rename[
from="b_id_payer", to="b_future_id_payer",
from="b_id_usage_interval", to="b_future_id_usage_interval",
from="b_id_billgroup", to="b_future_id_billgroup",
from="b_id_cycle", to="b_future_id_cycle",
from="b_dt_start", to="b_future_dt_start",
from="b_dt_end", to="b_future_dt_end",
from="run_vt_start", to="future_run_vt_start"
];

billing_intervals_2 -> future_billing_intervals;

-- TODO: We are already partitioned on b_future_id_payer and sorted on b_future_id_payer and b_future_id_usage_interval.  Is this good enough?
-- For the join 'create_future_billing_pairs' below the answer is yes since the equijoin key is only the payer.
--sort_future_billing_intervals:sort[key="b_future_id_payer", key="b_future_dt_start", temp_dir="%%TEMP_DIR%%", allowedMemory=10000000];
sort_future_billing_intervals:copy[];

future_billing_intervals -> sort_future_billing_intervals;

future_billing_intervals_copy:copy[];

sort_future_billing_intervals -> future_billing_intervals_copy;

future_billing_intervals_rename:rename[
from="b_future_id_payer", to="b_future_next_bill_id_payer",
from="b_future_id_usage_interval", to="b_future_next_bill_id_usage_interval",
from="b_future_id_billgroup", to="b_future_next_bill_id_billgroup",
from="b_future_id_cycle", to="b_future_next_bill_id_cycle",
from="b_future_dt_start", to="b_future_next_bill_dt_start",
from="b_future_dt_end", to="b_future_next_bill_dt_end", 
from="future_run_vt_start", to="future_next_bill_run_vt_start"];

future_billing_intervals_copy(0) -> future_billing_intervals_rename;

create_future_billing_pairs:right_outer_merge_join[leftKey="b_future_next_bill_id_payer", rightKey="b_future_id_payer", 
residual="
CREATE FUNCTION f (@b_future_dt_end DATETIME @b_future_next_bill_dt_start DATETIME) RETURNS BOOLEAN
AS
RETURN dateadd('s', 1.0, @b_future_dt_end) = @b_future_next_bill_dt_start"];
  
future_billing_intervals_copy(1) -> create_future_billing_pairs("right");
future_billing_intervals_rename -> create_future_billing_pairs("left");

-- Sequentially number each charge with a synthetic key to make
-- subsequent processing faster/easier. Make the key globally unique for the program
-- so we can repartition safely.
generate_charge_identifier:generate[program="
CREATE PROCEDURE p @id_future_charge BIGINT OUTPUT
AS
SET @id_future_charge = CAST(@@PARTITIONCOUNT AS BIGINT)*@@RECORDCOUNT + CAST(@@PARTITION AS BIGINT)"];
credit_branch(2) -> generate_charge_identifier;

sort_charges_payer_part:hashpart[key="b_id_payer"];
sort_charges_payer_coll:coll[];
sort_charges_payer:sort[key="b_id_payer", temp_dir="%%TEMP_DIR%%", allowedMemory=10000000];

generate_charge_identifier -> sort_charges_payer_part -> sort_charges_payer_coll -> sort_charges_payer;

-- Attach each billed charge to all known "future" (with respect to the charge) intervals
future_interval:inner_merge_join[leftKey="b_id_payer", rightKey="b_future_id_payer", residual="
CREATE FUNCTION f (@b_future_dt_start DATETIME @b_dt_start DATETIME) RETURNS BOOLEAN
AS
RETURN @b_future_dt_start >= @b_dt_start"];


create_future_billing_pairs -> future_interval("right");
sort_charges_payer -> future_interval("left");

-- TODO: All consumers of the credit branch want this sort order.
-- Oddly enough we have this sort here but then don't use it in the next join?
-- We do however use the sort order in the join after the next.
sort_charges_part:hashpart[key="s_id_sub"];
sort_charges_coll:coll[];
sort_charges:sort[key="s_id_sub", key="id_pi_instance", temp_dir="%%TEMP_DIR%%", allowedMemory=10000000];

future_interval -> sort_charges_part -> sort_charges_coll -> sort_charges;

future_udrc_values:rename[
from="v_id_pi_instance", to="v_future_id_pi_instance",
from="v_id_sub", to="v_future_id_sub",
from="v_value", to="v_future_value",
from="v_vt_start", to="v_future_vt_start",
from="v_vt_end", to="v_future_vt_end",
from="v_tt_start", to="v_future_tt_start",
from="v_tt_end", to="v_future_tt_end"];

udrc_values_2 -> future_udrc_values;

-- Attach each bill charge/future interval pair with the UDRC history in effect at the time
-- the interval was billed.
future_udrc_join:inner_merge_join[leftKey="s_id_sub", leftKey="id_pi_instance", rightKey="v_future_id_sub",
rightKey="v_future_id_pi_instance",
residual="CREATE FUNCTION f (@pc_dt_start DATETIME @pc_dt_end DATETIME 
@v_future_vt_start DATETIME @v_future_vt_end DATETIME 
@s_dt_start DATETIME @b_prorate_on_activate BOOLEAN 
@future_run_vt_start DATETIME 
@v_future_tt_start DATETIME @v_future_tt_end DATETIME) RETURNS BOOLEAN
AS
RETURN @pc_dt_end >= @v_future_vt_start AND 
@pc_dt_start <= @v_future_vt_end AND 
(@b_prorate_on_activate = FALSE OR @s_dt_start <= @v_future_vt_end) AND 
@future_run_vt_start >= @v_future_tt_start AND @future_run_vt_start <= @v_future_tt_end"];

sort_charges -> future_udrc_join("left");
future_udrc_values -> future_udrc_join("right");

-- Assert that we are sorted on id_future_charge at this point.
-- This may only be true depending which side of the merge join
-- we stick future interval on...
-- TODO: Figure out if this can be removed.
-- I have changed where the assignment of the id_future_charge occurs and at this point,
-- we KNOW that we have to resort.
sort_charge_id:sort[key="id_future_charge", temp_dir="%%TEMP_DIR%%", allowedMemory=50000000];

future_udrc_join -> sort_charge_id;

copy_sorted_udrc_values:copy[];

sort_charge_id -> copy_sorted_udrc_values;

future_next_udrc_values:rename[
from="id_future_charge", to="id_future_next_charge",
from="b_future_dt_start", to="b_future_next_dt_start",
from="b_future_dt_end", to="b_future_next_dt_end",
from="v_future_id_pi_instance", to="v_future_next_id_pi_instance",
from="v_future_id_sub", to="v_future_next_id_sub",
from="v_future_value", to="v_future_next_value",
from="v_future_vt_start", to="v_future_next_vt_start",
from="v_future_vt_end", to="v_future_next_vt_end",
from="v_future_tt_start", to="v_future_next_tt_start",
from="v_future_tt_end", to="v_future_next_tt_end"];

copy_sorted_udrc_values(0) -> future_next_udrc_values;

future_next_udrc_values_projection:projection[
column="id_future_next_charge",
column="b_future_next_dt_start",
column="b_future_next_dt_end",
column="v_future_next_id_pi_instance",
column="v_future_next_id_sub",
column="v_future_next_value",
column="v_future_next_vt_start",
column="v_future_next_vt_end",
column="v_future_next_tt_start",
column="v_future_next_tt_end"];

future_next_udrc_values -> future_next_udrc_values_projection;

-- Capture udrc intervals that have had some portion modified.
-- These are udrc unit values in adjacent bill intervals which a modification
-- to unit value between the two intervals.
-- TODO: Any extra joins to RC Interval to make sure that the change actually effects this RC?  I don't think
-- this is necessary.
-- First we get the 
udrc_credit_correction_join:right_merge_semi_join[
leftKey="id_future_next_charge", 
rightKey="id_future_charge", 
residual="
CREATE FUNCTION f (
@v_future_vt_start DATETIME @v_future_vt_end DATETIME 
@v_future_next_vt_start DATETIME @v_future_next_vt_end DATETIME
@v_future_value DECIMAL @v_future_next_value DECIMAL
@b_future_dt_end DATETIME @b_future_next_dt_start DATETIME) RETURNS BOOLEAN
AS
RETURN 
@v_future_value <> @v_future_next_value AND
(dateadd('s', 1.0, @b_future_dt_end) = @b_future_next_dt_start) AND 
@v_future_vt_start <= @v_future_next_vt_end AND @v_future_next_vt_start <= @v_future_vt_end"];


copy_sorted_udrc_values(1) -> udrc_credit_correction_join("right");
future_next_udrc_values_projection -> udrc_credit_correction_join("left");

copy_udrc_credit_correction:copy[];

udrc_credit_correction_join -> copy_udrc_credit_correction;


future_prev_udrc_values:rename[
from="id_future_charge", to="id_future_prev_charge",
from="b_future_dt_start", to="b_future_prev_dt_start",
from="b_future_dt_end", to="b_future_prev_dt_end",
from="v_future_id_pi_instance", to="v_future_prev_id_pi_instance",
from="v_future_id_sub", to="v_future_prev_id_sub",
from="v_future_value", to="v_future_prev_value",
from="v_future_vt_start", to="v_future_prev_vt_start",
from="v_future_vt_end", to="v_future_prev_vt_end",
from="v_future_tt_start", to="v_future_prev_tt_start",
from="v_future_tt_end", to="v_future_prev_tt_end"];

future_prev_udrc_values_projection:projection[
column="id_future_prev_charge",
column="b_future_prev_dt_start",
column="b_future_prev_dt_end",
column="v_future_prev_id_pi_instance",
column="v_future_prev_id_sub",
column="v_future_prev_value",
column="v_future_prev_vt_start",
column="v_future_prev_vt_end",
column="v_future_prev_tt_start",
column="v_future_prev_tt_end"];

-- Having identified credit corrections, any intersecting change needs to 
-- be debited (whether or not its value is different).
udrc_debit_correction_join:right_merge_semi_join[
leftKey="id_future_prev_charge", 
rightKey="id_future_charge", 
residual="
CREATE FUNCTION f (
@v_future_vt_start DATETIME @v_future_vt_end DATETIME 
@v_future_prev_vt_start DATETIME @v_future_prev_vt_end DATETIME
@v_future_value DECIMAL @v_future_prev_value DECIMAL
@b_future_dt_start DATETIME @b_future_prev_dt_end DATETIME) RETURNS BOOLEAN
AS
RETURN 
(dateadd('s', 1.0, @b_future_prev_dt_end) = @b_future_dt_start) AND 
@v_future_vt_start <= @v_future_prev_vt_end AND @v_future_prev_vt_start <= @v_future_vt_end"];

copy_sorted_udrc_values(2) -> udrc_debit_correction_join("right");
copy_udrc_credit_correction(0) -> future_prev_udrc_values -> future_prev_udrc_values_projection -> udrc_debit_correction_join
("left");


identify_credit_corrections:projection[
column="id_pi_instance",
column="id_pi_template",
column="id_pi_type",
column="id_po",
column="b_advance",
column="b_prorate_on_activate",
column="b_prorate_instantly",
column="b_prorate_on_deactivate",
column="n_proration_cycle_length",
column="n_rating_type",
column="s_id_sub",
column="s_dt_start",
column="s_dt_end",
column="pc_dt_start",
column="pc_dt_end",
column="charge_type",
column="p_id_payer",
column="p_id_payee",
-- These will be UnitValue and effective date
column="v_future_value",
column="v_future_vt_start",
column="v_future_vt_end",
-- These will be the BillingIntervalStart/End
column="b_future_next_bill_id_usage_interval",
column="b_future_next_bill_id_billgroup",
column="b_future_next_bill_dt_start",
column="b_future_next_bill_dt_end",
-- This is BilledRateDate
column="b_dt_end",
column="future_next_bill_run_vt_start"
--,column="projected_s_dt_end"
];

tag_credit_corrections:expr[program="CREATE PROCEDURE p @charge_type NVARCHAR
AS
SET @charge_type = CASE WHEN @charge_type = N'Initial' THEN N'InitialCorrection' ELSE N'AdvanceCorrection' END"];

rename_credit_corrections:rename[
from="id_pi_instance", to="_PriceableItemInstanceID",
from="id_pi_template", to="_PriceableItemTemplateID",
from="id_pi_type", to="_PriceableItemTypeID",
from="id_po", to="_ProductOfferingID",
from="b_advance", to="Advance",
from="b_prorate_on_activate", to="ProrateOnSubscription",
from="b_prorate_instantly", to="ProrateInstantly",
from="b_prorate_on_deactivate", to="ProrateOnUnsubscription",
from="n_proration_cycle_length", to="ProrationCycleLength",
from="s_id_sub", to="_SubscriptionID",
from="s_dt_start", to="SubscriptionStart",
from="s_dt_end", to="SubscriptionEnd",
from="pc_dt_start", to="RCIntervalStart",
from="pc_dt_end", to="RCIntervalEnd",
from="charge_type", to="RCActionType",
from="p_id_payer", to="_PayingAccount",
from="p_id_payee", to="_AccountID",
from="v_future_value", to="UnitValue",
from="v_future_vt_start", to="UnitValueStart",
from="v_future_vt_end", to="UnitValueEnd",
from="b_future_next_bill_id_usage_interval", to="_IntervalID",
from="b_future_next_bill_id_billgroup", to="_BillGroupID",
from="b_future_next_bill_dt_start", to="BillingIntervalStart",
from="b_future_next_bill_dt_end", to="BillingIntervalEnd",
from="b_dt_end", to="BilledRateDate",
from="n_rating_type", to="RatingType",
from="future_next_bill_run_vt_start", to="BillingIntervalRunDate"];

copy_udrc_credit_correction(1) -> identify_credit_corrections -> tag_credit_corrections -> rename_credit_corrections;

identify_debit_corrections:projection[
column="id_pi_instance",
column="id_pi_template",
column="id_pi_type",
column="id_po",
column="b_advance",
column="b_prorate_on_activate",
column="b_prorate_instantly",
column="b_prorate_on_deactivate",
column="n_proration_cycle_length",
column="n_rating_type",
column="s_id_sub",
column="s_dt_start",
column="s_dt_end",
column="pc_dt_start",
column="pc_dt_end",
column="charge_type",
column="p_id_payer",
column="p_id_payee",
-- These will be UnitValue and effective date
column="v_future_value",
column="v_future_vt_start",
column="v_future_vt_end",
-- These will be one before the BillingIntervalStart/End
column="b_future_id_usage_interval",
column="b_future_id_billgroup",
column="b_future_dt_start",
column="b_future_dt_end",
-- This is BilledRateDate
column="b_dt_end",
column="future_next_bill_run_vt_start"
--,column="projected_s_dt_end"
];

tag_debit_corrections:expr[program="CREATE PROCEDURE p @charge_type NVARCHAR
AS
SET @charge_type = CASE WHEN @charge_type = N'Initial' THEN N'InitialDebitCorrection' ELSE N'AdvanceDebitCorrection' END"];

rename_debit_corrections:rename[
from="id_pi_instance", to="_PriceableItemInstanceID",
from="id_pi_template", to="_PriceableItemTemplateID",
from="id_pi_type", to="_PriceableItemTypeID",
from="id_po", to="_ProductOfferingID",
from="b_advance", to="Advance",
from="b_prorate_on_activate", to="ProrateOnSubscription",
from="b_prorate_instantly", to="ProrateInstantly",
from="b_prorate_on_deactivate", to="ProrateOnUnsubscription",
from="n_proration_cycle_length", to="ProrationCycleLength",
from="s_id_sub", to="_SubscriptionID",
from="s_dt_start", to="SubscriptionStart",
from="s_dt_end", to="SubscriptionEnd",
from="pc_dt_start", to="RCIntervalStart",
from="pc_dt_end", to="RCIntervalEnd",
from="charge_type", to="RCActionType",
from="p_id_payer", to="_PayingAccount",
from="p_id_payee", to="_AccountID",
from="v_future_value", to="UnitValue",
from="v_future_vt_start", to="UnitValueStart",
from="v_future_vt_end", to="UnitValueEnd",
from="b_future_id_usage_interval", to="_IntervalID",
from="b_future_id_billgroup", to="_BillGroupID",
from="b_future_dt_start", to="BillingIntervalStart",
from="b_future_dt_end", to="BillingIntervalEnd",
from="b_dt_end", to="BilledRateDate",
from="n_rating_type", to="RatingType",
from="future_next_bill_run_vt_start", to="BillingIntervalRunDate"];

udrc_debit_correction_join -> identify_debit_corrections -> tag_debit_corrections -> rename_debit_corrections;


final_union:union_all[];

identify_charges -> final_union(0);
rename_credit -> final_union(1);
rename_credit_corrections -> final_union(2);
rename_debit_corrections -> final_union(3);

calculate_service_props:expr[program="CREATE PROCEDURE p 
@RCActionType NVARCHAR @BillingIntervalEnd DATETIME
@SubscriptionStart DATETIME @RCIntervalStart DATETIME @RCIntervalSubscriptionStart DATETIME OUTPUT
@SubscriptionEnd DATETIME @RCIntervalEnd DATETIME @RCIntervalSubscriptionEnd DATETIME OUTPUT
AS
DECLARE @tmp DATETIME
IF @RCActionType = N'Credit' OR @RCActionType = N'InitialCorrection' OR @RCActionType=N'AdvanceCorrection' OR @RCActionType = N'InitialDebitCorrection' OR @RCActionType=N'AdvanceDebitCorrection'
BEGIN
  -- In the case of credits we send part of the interval that we want to credit.  We don't do proration
  -- for partial days, so we round up the subscription end date to the end of day.
  -- TODO: This logic is assuming end dates are day granularity.
  SET @RCIntervalSubscriptionStart = CASE WHEN @SubscriptionEnd < @RCIntervalStart THEN @RCIntervalStart ELSE dateadd('s', 1, @SubscriptionEnd) END
  SET @RCIntervalSubscriptionEnd = @RCIntervalEnd
END
ELSE IF @RCActionType = N'Advance'
BEGIN
  SET @RCIntervalSubscriptionStart = @RCIntervalStart
  SET @RCIntervalSubscriptionEnd = @RCIntervalEnd
END
ELSE IF @RCActionType=N'Initial'
BEGIN
  SET @tmp = CASE WHEN @BillingIntervalEnd >= @SubscriptionEnd THEN @SubscriptionEnd ELSE NULL END
  SET @RCIntervalSubscriptionStart = CASE WHEN @SubscriptionStart < @RCIntervalStart THEN @RCIntervalStart ELSE @SubscriptionStart END
  SET @RCIntervalSubscriptionEnd = CASE WHEN @tmp IS NULL OR @RCIntervalEnd < @tmp THEN @RCIntervalEnd ELSE @tmp END
END
ELSE
BEGIN
  SET @RCIntervalSubscriptionStart = CASE WHEN @SubscriptionStart < @RCIntervalStart THEN @RCIntervalStart ELSE @SubscriptionStart END
  SET @RCIntervalSubscriptionEnd = CASE WHEN @SubscriptionEnd > @RCIntervalEnd THEN @RCIntervalEnd ELSE @SubscriptionEnd END
END"];

final_union -> calculate_service_props;

-- Filter to get just the charges to be billed in this interval
final_filter:filter[program="CREATE FUNCTION f (@_IntervalID INTEGER) RETURNS BOOLEAN
AS
RETURN @_IntervalID = %%ID_INTERVAL%%"];

calculate_service_props -> final_filter;

]]></Script>
</MetraFlowScript>
