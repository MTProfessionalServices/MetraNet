<?xml version="1.0" encoding="utf-8"?>
<MetraFlowScript>
    <Name>RecurringChargePayerExtract</Name>
    <Description>Generates recurring charge, credit and correction events.</Description>
    <Parameters>
        <Parameter>
            <Name>TEMP_DIR</Name>
            <SyntaxCheckValue>C:\Temp</SyntaxCheckValue>
            <Description>Directory in which to store sort run files for sort run files.</Description>
        </Parameter>
        <Parameter>
            <Name>SORT_DIR</Name>
            <SyntaxCheckValue>C:\Temp</SyntaxCheckValue>
            <Description>Directory in which to store sort run files for sort run files.</Description>
        </Parameter>
        <Parameter>
            <Name>ID_BILLGROUP</Name>
            <SyntaxCheckValue>1000</SyntaxCheckValue>
            <Description>Billgroup for which to extract the payer information.</Description>
        </Parameter>
    </Parameters>
    <Script>
      <![CDATA[
-- Given a list of payers (from a billgroup) we calculate two other sets:
-- 1) the list of payees that were paid for by that payer at some point in history
-- 2) this list of all payers for those payees.
-- This is necessary since when generating recurring charges sometimes we generate charges
-- for a subscription even if the payer is not the current payer (e.g. refund scenarios).
-- Also to make complete decisions about what to do for a given payee we need to know all
-- billing history related to it independently of that billing history is attached to a payer
-- being billed at this moment.
paying_accounts_select:select[baseQuery="select id_payer as p_id_payer, id_payee as p_id_payee, vt_start as p_vt_start, vt_end as p_vt_end, tt_start as p_tt_start, tt_end as p_tt_end 
from t_payment_redir_history
WHERE
{fn mod(id_payee, %%NUMPARTITIONS%%)} = %%PARTITION%%",
partitionConstraint="Database"];

paying_accounts_copy:copy[partitionConstraint="Database"];

paying_accounts_select -> paying_accounts_copy;

paying_accounts_payee_part:hashpart[key="p_id_payee",
partitionConstraint="Database"];

paying_accounts_copy(0) -> paying_accounts_payee_part;

paying_accounts_payee_coll:coll[];

paying_accounts_payee_part -> paying_accounts_payee_coll;

paying_accounts_rename:rename[
from="p_id_payer", to="np_id_payer",
from="p_id_payee", to="np_id_payee",
from="p_vt_start", to="np_vt_start",
from="p_vt_end", to="np_vt_end",
from="p_tt_start", to="np_tt_start",
from="p_tt_end", to="np_tt_end"];

paying_accounts_payee_coll -> paying_accounts_rename;

paying_accounts_sort:sort[key="np_id_payee", allowedMemory=500000000, temp_dir="%%SORT_DIR%%"];

paying_accounts_rename -> paying_accounts_sort;

paying_accounts_payer_part:hashpart[key="p_id_payer",
partitionConstraint="Database"];

paying_accounts_copy(1) -> paying_accounts_payer_part;

paying_accounts_payer_coll:coll[];

paying_accounts_payer_part -> paying_accounts_payer_coll;

billgroup_select:select[baseQuery="SELECT id_acc as bgm_id_acc
FROM
t_billgroup_member 
WHERE
id_billgroup=%%ID_BILLGROUP%%
AND
{fn mod(id_acc, %%NUMPARTITIONS%%)} = %%PARTITION%%",
partitionConstraint="Database"];

billgroup_part:hashpart[key="bgm_id_acc",
partitionConstraint="Database"];

billgroup_select -> billgroup_part;

billgroup_coll:coll[];

billgroup_part -> billgroup_coll;

filter_payers:multi_hash_join[tableKey="bgm_id_acc",
probe="right semi", probeKey="p_id_payer"];

billgroup_coll -> filter_payers("table");
paying_accounts_payer_coll -> filter_payers("probe(0)");

filtered_payers_payee_part:hashpart[key="p_id_payee"];

filter_payers -> filtered_payers_payee_part;

filtered_payers_payee_coll:coll[];

filtered_payers_payee_part -> filtered_payers_payee_coll;

filtered_payers_payee_sort:sort[key="p_id_payee", temp_dir="%%SORT_DIR%%", allowedMemory=200000000];

filtered_payers_payee_coll -> filtered_payers_payee_sort;

paying_accounts_self_join:right_merge_semi_join[leftKey="p_id_payee", rightKey="np_id_payee"];

filtered_payers_payee_sort -> paying_accounts_self_join("left");
paying_accounts_sort -> paying_accounts_self_join("right");

filter_payers_copy:copy[columnlist=[column="np_id_payee"],
columnlist=[column="np_id_payer", column="np_id_payee", column="np_vt_start", column="np_vt_end", column="np_tt_start", column="np_tt_end"]];

paying_accounts_self_join -> filter_payers_copy;

dedup_payee:hash_group_by[key="np_id_payee",
initialize="CREATE PROCEDURE p @cnt INTEGER
AS
SET @cnt = 0",
update="CREATE PROCEDURE p @cnt INTEGER
AS
SET @cnt = @cnt + 1"];

filter_payers_copy(0) -> dedup_payee;

payee_insert:insert[schema="NetMeter", table="tmp_rc_payees", createTable=true];

dedup_payee -> payee_insert;

payer_part:hashpart[key="np_id_payer"];

filter_payers_copy(1) -> payer_part;

payer_coll:coll[];

payer_part -> payer_coll;

payers_copy:copy[columnlist=[column="np_id_payer"]];

payer_coll -> payers_copy;

dedup_payer:hash_group_by[key="np_id_payer",
initialize="CREATE PROCEDURE p @cnt INTEGER
AS
SET @cnt = 0",
update="CREATE PROCEDURE p @cnt INTEGER
AS
SET @cnt = @cnt + 1"];

payers_copy(0) -> dedup_payer;

payer_insert:insert[schema="NetMeter", table="tmp_rc_payers", createTable=true];

dedup_payer -> payer_insert;

payment_redirection_write:sequential_file_write[filename="%%TEMP_DIR%%\rc_payment_redirection_%1%.mfd"];

payers_copy(1) -> payment_redirection_write;
]]></Script>
</MetraFlowScript>
