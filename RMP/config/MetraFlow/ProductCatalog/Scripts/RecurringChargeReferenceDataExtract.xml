<?xml version="1.0" encoding="utf-8"?>
<MetraFlowScript>
    <Name>RecurringChargeReferenceDataExtract</Name>
    <Description>Reads reference data used in the calculation of recurring charges.</Description>
    <Parameters>
        <Parameter>
            <Name>TEMP_DIR</Name>
            <SyntaxCheckValue>C:\Temp</SyntaxCheckValue>
            <Description>Directory in which to store sort run files for sort run files.</Description>
        </Parameter>
    </Parameters>
    <Script>
      <![CDATA[
udrc_values_select:select[baseQuery="select id_prop as v_id_pi_instance, id_sub as v_id_sub, n_value as v_value, vt_start as v_vt_start, vt_end as v_vt_end, tt_start as v_tt_start, tt_end as v_tt_end 
from t_recur_value 
WHERE
{fn mod(id_sub, %%NUMPARTITIONS%%)} = %%PARTITION%%",
partitionConstraint="Database"];

-- Pretend that flat recurring charges have a single 0.0 value for all time
udrc_values_faux:select[baseQuery="select plm.id_pi_instance as v_id_pi_instance, s.id_sub as v_id_sub, 0.0 as v_value, cast('1970-01-01' as datetime) as v_vt_start, cast('2038-01-01' as datetime) as v_vt_end, cast('1970-01-01' as datetime) as v_tt_start, cast('2038-01-01' as datetime) as v_tt_end 
from t_sub s 
INNER JOIN t_pl_map plm on s.id_po=plm.id_po
INNER JOIN t_base_props bp on bp.id_prop=plm.id_pi_type
WHERE
bp.n_kind=20
AND
plm.id_paramtable IS NULL
AND
{fn mod(s.id_sub, %%NUMPARTITIONS%%)} = %%PARTITION%%",
partitionConstraint="Database"];

udrc_values_union:union_all[partitionConstraint="Database"];

udrc_values_part:hashpart[key="v_id_sub",
partitionConstraint="Database"];
udrc_values_coll:coll[];
udrc_values_sort:sort[key="v_id_sub", key="v_id_pi_instance", temp_dir="%%TEMP_DIR%%", allowedMemory=10000000];

udrc_values_write:sequential_file_write[filename="%%TEMP_DIR%%\rc_temp_%1%.mfd"];

udrc_values_select -> udrc_values_union(0);
udrc_values_faux -> udrc_values_union(1);
udrc_values_union -> udrc_values_part -> udrc_values_coll -> udrc_values_sort -> udrc_values_write;

bill_groups_with_run_date:select[baseQuery="
select bgm.id_acc as bg_id_acc, bg.id_usage_interval as bg_id_usage_interval, bg.id_billgroup as bg_id_billgroup, rer.dt_start bg_vt_start
from
tmp_rc_payers t
INNER JOIN t_billgroup_member bgm ON t.np_id_payer=bgm.id_acc
INNER JOIN t_billgroup bg ON bg.id_billgroup=bgm.id_billgroup 
INNER JOIN t_recevent_inst rei ON rei.id_arg_interval=bg.id_usage_interval AND rei.id_arg_billgroup=bgm.id_billgroup
INNER JOIN t_recevent re ON rei.id_event=re.id_event
INNER JOIN t_recevent_run rer ON rer.id_instance=rei.id_instance
WHERE 
re.tx_name='RecurringCharges'
AND
{fn mod(t.np_id_payer, %%NUMPARTITIONS%%)} = %%PARTITION%%",
partitionConstraint="Database"];
bill_groups_with_run_date_part:hashpart[key="bg_id_acc",
partitionConstraint="Database"];
bill_groups_with_run_date_coll:coll[];
bill_groups_with_run_date_sort:sort[key="bg_id_acc", key="bg_id_usage_interval", temp_dir="%%TEMP_DIR%%", allowedMemory=10000000];

calculate_account_bill_interval_last_run_and_billgroup:sort_group_by[key="bg_id_acc", key="bg_id_usage_interval",
initialize="CREATE PROCEDURE p @run_vt_start DATETIME @b_id_billgroup INTEGER
AS
SET @run_vt_start = CAST('1970-01-01' AS DATETIME)
SET @b_id_billgroup = 0",
update="CREATE PROCEDURE u @bg_vt_start DATETIME @bg_id_billgroup INTEGER @run_vt_start DATETIME @b_id_billgroup INTEGER
AS
IF @bg_vt_start > @run_vt_start
BEGIN
  SET @run_vt_start = @bg_vt_start
  SET @b_id_billgroup = @bg_id_billgroup
END"];

select_account_bill_intervals:select[baseQuery="select 
aui.id_acc as b_id_payer,
aui.id_usage_interval as b_id_usage_interval,
ui.id_usage_cycle as b_id_cycle,
ui.dt_start as b_dt_start_uncorrected,
coalesce(dateadd(s, 1, aui.dt_effective), ui.dt_start) as b_dt_start,
ui.dt_end as b_dt_end
from 
tmp_rc_payers t 
INNER JOIN t_acc_usage_interval aui ON t.np_id_payer=aui.id_acc
inner join t_usage_interval ui on ui.id_interval=aui.id_usage_interval
INNER JOIN t_usage_cycle uc on ui.id_usage_cycle=uc.id_usage_cycle
WHERE
{fn mod(t.np_id_payer, %%NUMPARTITIONS%%)} = %%PARTITION%%",
partitionConstraint="Database"];

-- TODO: Push into database since this is the PK of t_acc_usage_interval
select_account_bill_intervals_part:hashpart[key="b_id_payer",
partitionConstraint="Database"];
select_account_bill_intervals_coll:coll[];
select_account_bill_intervals_sort:sort[key="b_id_payer", key="b_id_usage_interval", temp_dir="%%TEMP_DIR%%", allowedMemory=10000000];

account_bill_interval_last_run_join:right_outer_merge_join[
leftKey="bg_id_acc", leftKey="bg_id_usage_interval",
rightKey="b_id_payer", rightKey="b_id_usage_interval"];

set_default_run_date:expr[program="
CREATE PROCEDURE p @run_vt_start DATETIME
AS
IF @run_vt_start IS NULL 
  SET @run_vt_start = CAST('2038-01-01' AS DATETIME)"];

account_bill_interval_projection:projection[
column="b_id_payer",
column="b_id_usage_interval",
column="b_id_billgroup",
column="b_id_cycle",
column="b_dt_start",
column="b_dt_end",
column="run_vt_start"];

billing_intervals:sequential_file_write[filename="%%TEMP_DIR%%\rc_billing_intervals_%1%.mfd"];

bill_groups_with_run_date -> bill_groups_with_run_date_part -> bill_groups_with_run_date_coll -> bill_groups_with_run_date_sort -> calculate_account_bill_interval_last_run_and_billgroup -> account_bill_interval_last_run_join("left");
select_account_bill_intervals -> select_account_bill_intervals_part -> select_account_bill_intervals_coll -> select_account_bill_intervals_sort -> account_bill_interval_last_run_join("right");
account_bill_interval_last_run_join -> set_default_run_date -> account_bill_interval_projection -> billing_intervals;
]]></Script>
</MetraFlowScript>
