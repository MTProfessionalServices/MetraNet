group accountResolution;

BOOLEANmsixRenameFrom(n) ::= <<
<n.ColumnName>_TEMP
>>

ENUMmsixRenameFrom(n) ::= <<
<n.ColumnName>_TEMP
>>

INTEGERmsixRenameFrom(n) ::= <<
<n.ColumnName>
>>

BIGINTmsixRenameFrom(n) ::= <<
<n.ColumnName>
>>

VARCHARmsixRenameFrom(n) ::= <<
<n.ColumnName>
>>

NVARCHARmsixRenameFrom(n) ::= <<
<n.ColumnName>
>>

DECIMALmsixRenameFrom(n) ::= <<
<n.ColumnName>
>>

DATETIMEmsixRenameFrom(n) ::= <<
<n.ColumnName>
>>

msixRenameFrom(n) ::= <<
<n.Type>msixRenameFrom
>>

BOOLEANInputDecl(n) ::= <<
@<n.ColumnName> VARCHAR
>>

ENUMInputDecl(n) ::= <<
@<n.ColumnName> INTEGER
>>

BIGINTInputDecl(n) ::= <<
>>

VARCHARInputDecl(n) ::= <<
>>

NVARCHARInputDecl(n) ::= <<
>>

DECIMALInputDecl(n) ::= <<
>>

DATETIMEInputDecl(n) ::= <<
>>

BOOLEANOutputDecl(n) ::= <<
@<n.ColumnName>_TEMP BOOLEAN OUTPUT
>>

ENUMOutputDecl(n) ::= <<
@<n.ColumnName>_TEMP ENUM OUTPUT
>>

BIGINTOutputDecl(n) ::= <<
>>

VARCHAROutputDecl(n) ::= <<
>>

NVARCHAROutputDecl(n) ::= <<
>>

DECIMALOutputDecl(n) ::= <<
>>

DATETIMEOutputDecl(n) ::= <<
>>

BOOLEANConvertStmt(n) ::= <<
SET @<n.ColumnName>_TEMP = CASE WHEN @<n.ColumnName> = '1' THEN TRUE ELSE FALSE END
>>

ENUMConvertStmt(n) ::= <<
SET @<n.ColumnName>_TEMP = CAST(@<n.ColumnName> AS ENUM)
>>

BIGINTConvertStmt(n) ::= <<
>>

VARCHARConvertStmt(n) ::= <<
>>

NVARCHARConvertStmt(n) ::= <<
>>

DECIMALConvertStmt(n) ::= <<
>>

DATETIMEConvertStmt(n) ::= <<
>>

msixInputDecl(n) ::= <<
<n.Type>InputDecl
>>

msixOutputDecl(n) ::= <<
<n.Type>OutputDecl
>>

msixConvertStmt(n) ::= <<
<n.Type>ConvertStmt
>>

msixPropertyRename(n) ::= <<
from="<(msixRenameFrom(n))(n)>", to="<n.Name>",
>>

accountViewRead(table) ::= <<
av_<table.Name>_select:select[baseQuery="select id_acc <table.Properties:{p | , <p.ColumnName>}>
FROM
<table.TableName>
WHERE
{fn mod(id_acc, %%NUMPARTITIONS%%)} = %%PARTITION%%"];

av_<table.Name>_part:hashpart[key="id_acc"];
av_<table.Name>_select -> av_<table.Name>_part;

av_<table.Name>_coll:coll[];
av_<table.Name>_part -> av_<table.Name>_coll;

av_<table.Name>_convert:expr[program="CREATE PROCEDURE p 
@id_acc INTEGER
<table.Properties:{n | <(msixInputDecl(n))(n)>}; separator = "\n">
<table.Properties:{n | <(msixOutputDecl(n))(n)>}; separator = "\n">
AS
DECLARE @asdjf83423445555555555555 INTEGER
SET @asdjf83423445555555555555 = @id_acc
<table.Properties:{n | <(msixConvertStmt(n))(n)>}; separator = "\n">
"];
av_<table.Name>_coll -> av_<table.Name>_convert;

av_<table.Name>_rename:rename[
<table.Properties:{n | from="<(msixRenameFrom(n))(n)>", to="<n.Alias>",}; separator = "\n">
from="id_acc", to="av_<table.Name>_id_acc"
];
av_<table.Name>_convert -> av_<table.Name>_rename;

av_<table.Name>_copy:copy[];
av_<table.Name>_rename -> av_<table.Name>_copy;

<if(table.HasOriginatorProperties)>
av_join_<i>:right_outer_hash_join[tableKey="av_<table.Name>_id_acc", probeKey="<accountIdField>"];

  <if(table.HasPayerProperties)>
-- Some properties from this table go the originator and some to the payer,
-- project out the properties for each.
av_<table.Name>_originator_projection:project[
<table.Properties:{n | <if(!n.PayerProperty)>column="<n.Alias>",<endif>}; separator = "\n">
column="av_<table.Name>_id_acc"
];
av_<table.Name>_copy(0) -> av_<table.Name>_originator_projection -> av_join_<i>("table");
  <else>
av_<table.Name>_copy(0) -> av_join_<i>("table");
  <endif>
av_join_<table.prevIdx> -> av_join_<i>("probe(0)");
<else>
-- Make gluing operators together easier by always creating an operator for
-- each account view.
av_join_<i>:copy[];
av_join_<table.prevIdx> -> av_join_<i>;
<endif>

<if(table.HasPayerProperties)>
av_<table.Name>_rename_id_for_payer:rename[
from="av_<table.Name>_id_acc", to="av_<table.Name>_id_acc_for_payer"];
av_<table.Name>_copy(<if(table.HasOriginatorProperties)>1<else>0<endif>) -> av_<table.Name>_rename_id_for_payer;

av_payer_join_<i>:right_outer_hash_join[tableKey="av_<table.Name>_id_acc_for_payer", probeKey="<payingAccountIdField>"];

  <if(table.HasOriginatorProperties)>
-- Some properties from this table go the originator and some to the payer,
-- project out the properties for each.
av_<table.Name>_payer_projection:project[
<table.Properties:{n | <if(n.PayerProperty)>column="<n.Alias>",<endif>}; separator = "\n">
column="av_<table.Name>_id_acc_for_payer"
];
av_<table.Name>_rename_id_for_payer -> av_<table.Name>_payer_projection -> av_payer_join_<i>("table");
  <else>
av_<table.Name>_rename_id_for_payer -> av_payer_join_<i>("table");
  <endif>
av_payer_join_<table.prevIdx> -> av_payer_join_<i>("probe(0)");
<else>
-- Make gluing operators together easier by always creating an operator for
-- each account view.
av_payer_join_<i>:copy[];
av_payer_join_<table.prevIdx> -> av_payer_join_<i>;
<endif>
>>

accountResolutionComposite(operatorName, compositeInstanceName, payeeField, namespaceField, namespaceLiteral, timestampField, accountIdField, payingAccountIdField, usageCycleIdField, Tables) ::= <<
operator <operatorName> [
in  "input"  is <if(namespaceField)>name_part("input")<else><if(namespaceLiteral)>name_part("input")<else>amj(0)<endif><endif>,
out "output" is payj_error_branch(0),
out "error"  is payj_error_branch(1)]
(

-- Passed In Arguments:
--
--   payeeField:           <payeeField>
--   namespaceField:       <namespaceField>
--   namespaceLiteral:     <namespaceLiteral>
--   timestampField:       <timestampField>
--   accountIdField:       <accountIdField>
--   payingAccountIdField: <payingAccountIdField>

<if(namespaceField)>
  -- We were given the namespaceField: <namespaceField>

  name_part: hashpart[key="<payeeField>"];

  name_coll: coll[];

  nm_login_part: hashpart[key="nm_login"];

  nm_login_coll: coll[];

  -- First resolve by name

  am:  select[baseQuery="select nm_login, nm_space, id_acc as <accountIdField> from t_account_mapper 
              where {fn mod(id_acc, %%NUMPARTITIONS%%)} = %%PARTITION%%"];

  amj: right_outer_hash_join[tableKey="nm_login", tableKey="nm_space", probeKey="<payeeField>", probeKey="<namespaceField>"];

  name_part -> name_coll -> amj("probe(0)");

  am -> nm_login_part -> nm_login_coll -> amj("table");

<else>
  <if(namespaceLiteral)>
    -- We weren't given the namespaceField, but we have namespaceLiteral: <namespaceLiteral>

    name_part:hashpart[key="<payeeField>"];

    name_coll:coll[];

    nm_login_part:hashpart[key="nm_login"];

    nm_login_coll:coll[];

    -- First resolve by name

    am:select[baseQuery="select nm_login, id_acc as <accountIdField> from t_account_mapper 
              where nm_space='<namespaceLiteral>' and {fn mod(id_acc, %%NUMPARTITIONS%%)} = %%PARTITION%%"];

    amj:right_outer_hash_join[tableKey="nm_login", probeKey="<payeeField>"];

    name_part -> name_coll -> amj("probe(0)");

    am -> nm_login_part -> nm_login_coll -> amj("table");

  <else>
  -- Neither namespaceField nor namespaceLiteral where given.

  amj: expr[program="CREATE PROCEDURE p 
                  <if(namespaceField)>
                      @<payeeField> NVARCHAR 
                      @<accountIdField> NVARCHAR OUTPUT
                  <else>
                    <if(namespaceLiteral)>
                      @<payeeField> NVARCHAR 
                      @<accountIdField> NVARCHAR OUTPUT
                    <else>
                      @<payeeField> INTEGER 
                      @<accountIdField> INTEGER OUTPUT
                    <endif>
                  <endif>
                      AS SET @<accountIdField> = @<payeeField>"];
  <endif>
<endif>

  id_acc_part:hashpart[key="<accountIdField>"];

  av_join_0:coll[];

  amj(0)-> id_acc_part -> av_join_0;

  -- Lookup payer and payer's cycle
  -- Inner join: t_payment_redirection and t_acc_usage_cycle

  pay_select: select[baseQuery="select id_payee as pay_id_payee, 
                                       id_payer as <payingAccountIdField>, 
                                       vt_start as pay_vt_start, 
                                       vt_end as pay_vt_end, 
                                       id_usage_cycle <usageCycleIdField> 
                                from t_payment_redirection inner join t_acc_usage_cycle on id_acc=id_payer 
                                where {fn mod(id_payee, %%NUMPARTITIONS%%)} = %%PARTITION%%"];

  pay_payer_part:hashpart[key="<payingAccountIdField>"];

  pay_select -> pay_payer_part;

  av_payer_join_0:coll[];

  pay_payer_part -> av_payer_join_0;

  -- Lookup properties in account views.  Join as necessary
  -- for both originating account and paying account properties.
<Tables:{table | <accountViewRead(table)> }>

  pay_part:hashpart[key="pay_id_payee"];

  pay_coll:coll[];

  payj: right_outer_hash_join[probeKey="<accountIdField>", 
                              tableKey="pay_id_payee", 
                              residual="CREATE FUNCTION r (@<timestampField> DATETIME 
                                                           @pay_vt_start DATETIME 
                                                           @pay_vt_end DATETIME) 
                                        RETURNS BOOLEAN AS 
                                          RETURN @<timestampField> >= @pay_vt_start AND 
                                                 @<timestampField> \<= @pay_vt_end"];

  av_payer_join_<length(Tables)> -> pay_part -> pay_coll -> payj("table");

  av_join_<length(Tables)>->payj("probe(0)");

  /* @_Currency NVARCHAR  */

  discardTemps: project[inverse=true,
                       column="pay_id_payee",
                       column="pay_vt_start",
                       column="pay_vt_end",
                       column="av_Internal_id_acc",
                       column="av_Contact_id_acc",
                       column="nm_login"];
  payj -> discardTemps;
 
  payj_err: expr[program="CREATE PROCEDURE p 
                  <if(namespaceField)>
                                             @<payeeField> NVARCHAR 
                                             @<namespaceField> NVARCHAR
                  <else>
                    <if(namespaceLiteral)>
                                             @<payeeField> NVARCHAR 
                    <else>
                                             @<payeeField> INTEGER 
                    <endif>
                  <endif>
                                             @<accountIdField> INTEGER 
<if(usageCycleIdField)>
                                             @<usageCycleIdField> INTEGER
<endif>
                                             @<payingAccountIdField> INTEGER 
                                             @_ErrorCode INTEGER OUTPUT 
                                             @_ErrorString NVARCHAR OUTPUT
                                             @_Plugin NVARCHAR OUTPUT
                                             @_Module NVARCHAR OUTPUT
                          AS 
    IF @<accountIdField> IS NULL
      BEGIN
        SET @_ErrorCode = -517996508
        SET @_ErrorString = N'Unable to resolve accountname: ' + CAST(@<payeeField> AS NVARCHAR) 
<if(namespaceField)>
                                                               + N', namespace: ' + @<namespaceField>
<endif>
        SET @_Plugin = N'<compositeInstanceName>'
        SET @_Module = N'account_lookup'
      END
      ELSE IF @<payingAccountIdField> IS NULL OR @<payingAccountIdField> = -1
        BEGIN
          SET @_ErrorCode = -517996508
          SET @_ErrorString = N'Unable to resolve paying account for accountID ' + CAST(@<accountIdField> AS NVARCHAR)
          SET @_Plugin = N'<compositeInstanceName>'
          SET @_Module = N'account_lookup'
        END
<if(usageCycleIdField)>
      ELSE IF @<usageCycleIdField> IS NULL
        BEGIN
          SET @_ErrorCode = -517996508
          SET @_ErrorString = N'Unable to find payer usagecycle for accountID ' + 
                              CAST(@<accountIdField> AS NVARCHAR) + 
                              N', perhaps account does not have a valid payer'
          SET @_Plugin = N'<compositeInstanceName>'
          SET @_Module = N'account_lookup'
      END
<endif>

/******************
      ELSE IF @_Currency IS NULL
      BEGIN
        SET @_ErrorCode = -517996508
        SET @_ErrorString = N'Unable to find payer currency for accountID ' + CAST(@<accountIdField> AS NVARCHAR)
        SET @_Plugin = N'<compositeInstanceName>'
        SET @_Module = N'account_lookup'
      END
*******************/

"];

discardTemps -> payj_err;

payj_error_branch: switch[program="CREATE FUNCTION f (@_ErrorCode INTEGER) RETURNS INTEGER
                                   AS
                                   RETURN CASE WHEN @_ErrorCode IS NULL OR @_ErrorCode = 0 THEN 0 
                                               ELSE 1 END"];
payj_err -> payj_error_branch;
)

>>
