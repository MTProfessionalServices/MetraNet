group pcrate;

icbBranch() ::= <<
icb
>>

poBranch() ::= <<
po
>>

pcRateLookupResidualPredicate(conditions, branch) ::= <<
residual="CREATE FUNCTION ptLookupResidualPredicate (<conditions:{c |  @<c.Name> <c.Type> @<paramtabledef.Name>_<branch>_<c.Name> <c.Type> <if(c.OperatorPerRule)>@<paramtabledef.Name>_<branch>_<c.Name>_op INTEGER<endif>}; separator =" "> ) RETURNS BOOLEAN
AS
RETURN <conditions:{c | (@<paramtabledef.Name>_<branch>_<c.Name> IS NULL OR <if(c.OperatorPerRule)>compare(@<paramtabledef.Name>_<branch>_<c.Name>_op, @<c.Name>, @<paramtabledef.Name>_<branch>_<c.Name>)<else>@<c.Name> <c.Operator> @<paramtabledef.Name>_<branch>_<c.Name><endif>) }; separator =" AND ">"
>>

BOOLEANpcRateRenameFrom(n) ::= <<
<n.ColumnName>_TEMP
>>

ENUMpcRateRenameFrom(n) ::= <<
<n.ColumnName>_TEMP
>>

INTEGERpcRateRenameFrom(n) ::= <<
<n.ColumnName>
>>

BIGINTpcRateRenameFrom(n) ::= <<
<n.ColumnName>
>>

VARCHARpcRateRenameFrom(n) ::= <<
<n.ColumnName>
>>

NVARCHARpcRateRenameFrom(n) ::= <<
<n.ColumnName>
>>

DECIMALpcRateRenameFrom(n) ::= <<
<n.ColumnName>
>>

DATETIMEpcRateRenameFrom(n) ::= <<
<n.ColumnName>
>>

pcRateRenameFrom(n) ::= <<
<n.Type>pcRateRenameFrom
>>

OPInputDecl(n) ::= <<
@<n.ColumnName>_op NVARCHAR
>>

OPOutputDecl(n) ::= <<
@<n.ColumnName>_op_TEMP INTEGER OUTPUT
>>

OPConvertStmt(n) ::= <<
SET @<n.ColumnName>_op_TEMP = CASE WHEN @<n.ColumnName>_op = N'=' THEN 0 WHEN @<n.ColumnName>_op = N'!=' THEN 1 WHEN @<n.ColumnName>_op = N'\<' THEN 2 WHEN @<n.ColumnName>_op = N'\<=' THEN 3 WHEN @<n.ColumnName>_op = N'>' THEN 4 WHEN @<n.ColumnName>_op = N'>=' THEN 5 WHEN @<n.ColumnName>_op IS NULL THEN NULL END
>>

BOOLEANInputDecl(n) ::= <<
@<n.ColumnName> VARCHAR
>>

BOOLEANOutputDecl(n) ::= <<
@<n.ColumnName>_TEMP BOOLEAN OUTPUT
>>

BOOLEANConvertStmt(n) ::= <<
SET @<n.ColumnName>_TEMP = CASE WHEN @<n.ColumnName> = '1' THEN TRUE ELSE FALSE END
>>

ENUMInputDecl(n) ::= <<
@<n.ColumnName> INTEGER
>>

ENUMOutputDecl(n) ::= <<
@<n.ColumnName>_TEMP ENUM OUTPUT
>>

ENUMConvertStmt(n) ::= <<
SET @<n.ColumnName>_TEMP = CAST(@<n.ColumnName> AS ENUM)
>>

InputDecl(n) ::= <<
<n.Type>InputDecl
>>

OutputDecl(n) ::= <<
<n.Type>OutputDecl
>>

ConvertStmt(n) ::= <<
<n.Type>ConvertStmt
>>

POConditionRename(n) ::= <<
<if(n.OperatorPerRule)>
from="<(pcRateRenameFrom(n))(n)>", to="<paramtabledef.Name>_po_<n.Name>",
from="<n.ColumnName>_op_TEMP", to="<paramtabledef.Name>_po_<n.Name>_op",
<else>
from="<(pcRateRenameFrom(n))(n)>", to="<paramtabledef.Name>_po_<n.Name>",
<endif>
>>

ICBConditionRename(n) ::= <<
<if(n.OperatorPerRule)>
from="<(pcRateRenameFrom(n))(n)>", to="<paramtabledef.Name>_icb_<n.Name>",
from="<n.ColumnName>_op_TEMP", to="<paramtabledef.Name>_icb_<n.Name>_op",
<else>
from="<(pcRateRenameFrom(n))(n)>", to="<paramtabledef.Name>_icb_<n.Name>",
<endif>
>>

ConditionProjection(n) ::= <<
<if(n.OperatorPerRule)>
column="<(pcRateRenameFrom(n))(n)>",
column="<n.ColumnName>_op_TEMP",
<else>
column="<(pcRateRenameFrom(n))(n)>",
<endif>
>>

ConditionColumns(n) ::= <<
<if(n.OperatorPerRule)>
pt.<n.ColumnName>, pt.<n.ColumnName>_op
<else>
pt.<n.ColumnName>
<endif>
>>

pcRateComposite(operatorName, 
                compositeInstanceName, 
                paramtabledef, 
                AllActions, 
                BooleanActions, 
                AllConditions, 
                EquiJoinConditions, 
                NonEquiJoinConditions,
                parentPrefix) ::= <<

operator <operatorName>[
  in  "input"  is <paramtabledef.Name>_po("probe(0)"),
  out "output" is error_switch(0),
  out "error"  is error_switch(1)]
(
  -- Load rate table: <paramtabledef.Name>
  -- Get information about the given parameter table.

  <paramtabledef.Name>_pt: select[baseQuery=
    "select pt.id_sched, 
            pt.n_order, 
            <AllConditions:{n | <ConditionColumns(n)>}; separator = ", ">
                <if(AllConditions)>,<endif> 
            <AllActions:{n | pt.<n.ColumnName>}; separator = ", ">, 
            plm.id_sub
     from 
            <paramtabledef.TableName> pt
     inner join t_rsched r on r.id_sched=pt.id_sched
     left outer join t_pl_map plm on r.id_pricelist=plm.id_pricelist and 
                                     r.id_pi_template=plm.id_pi_template and 
                                     r.id_pt=plm.id_paramtable
     where {fn mod(pt.id_sched, %%NUMPARTITIONS%%)} = %%PARTITION%%
            and pt.tt_end = {ts '2038-01-01 00:00:00'}
     order by pt.id_sched asc, pt.n_order asc"];

  -- If there are boolean actions then convert the value
  -- from 0 and 1 to TRUE and FALSE
  <if(BooleanActions)>
    <paramtabledef.Name>_pt_conversions: expr[program="
        CREATE PROCEDURE ptLookupConversions
        <BooleanActions:{n | <(InputDecl(n))(n)>}; separator = "\n">
        <BooleanActions:{n | <(OutputDecl(n))(n)>}; separator = "\n">
        AS
        <BooleanActions:{n | <(ConvertStmt(n))(n)>}; separator = "\n">
        "];
  <endif>

  -- Project what we have so far.
  <paramtabledef.Name>_pt_projection:project[
                    column="id_sched", 
                    column="n_order", 
    <AllConditions:{n | <ConditionProjection(n)> }; separator = "\n"> 
    <AllActions:{n | column="<(pcRateRenameFrom(n))(n)>",}; separator = "\n"> 
                    column="id_sub"];

  <if(BooleanActions)>
    <paramtabledef.Name>_pt -> <paramtabledef.Name>_pt_conversions 
    <paramtabledef.Name>_pt_conversions -> <paramtabledef.Name>_pt_projection 
  <else>
    <paramtabledef.Name>_pt -> <paramtabledef.Name>_pt_projection
  <endif> 


  -- Broadcast non-ICB pricelists, partition ICB pricelists on subscription.
  -- Branch based on whether this parameter table is ICB or
  -- non-ICB.

  <paramtabledef.Name>_pt_split_icb: switch[program="
    CREATE FUNCTION ptLookupSplitIcb (@id_sub INTEGER) RETURNS INTEGER
    AS
    RETURN CASE WHEN @id_sub IS NULL THEN 0 ELSE 1 END"];

  <paramtabledef.Name>_pt_projection -> <paramtabledef.Name>_pt_split_icb;

  -- Going down the non_icb branch,
  -- we rename some fields: non_icb

  <paramtabledef.Name>_non_icb_rename:rename[
      from="id_sched", to="<paramtabledef.Name>_po_id_sched", 
      from="n_order", to="<paramtabledef.Name>_po_n_order",
      <AllConditions:{n | <POConditionRename(n)>}; separator = "\n"> 
      <AllActions:{n | from="<(pcRateRenameFrom(n))(n)>", 
                       to="<paramtabledef.Name>_po_<n.Name>",}; 
                   separator = "\n"> 
      from="id_sub", to="<paramtabledef.Name>_po_id_sub"];

  <paramtabledef.Name>_pt_split_icb(0) -> <paramtabledef.Name>_non_icb_rename 

  -- Broadcast to everyone
  <paramtabledef.Name>_pt_non_icb_part:broadcast[];

  <paramtabledef.Name>_non_icb_rename -> <paramtabledef.Name>_pt_non_icb_part 

  <paramtabledef.Name>_pt_non_icb_coll:coll[];

  <paramtabledef.Name>_pt_non_icb_part -> <paramtabledef.Name>_pt_non_icb_coll;

  -- Going down the icb branch
  -- Rename some fields: icb

  <paramtabledef.Name>_icb_rename:rename[
      from="id_sched", to="<paramtabledef.Name>_icb_id_sched", 
      from="n_order", to="<paramtabledef.Name>_icb_n_order", 
      <AllConditions:{n | <ICBConditionRename(n)>}; separator = "\n"> 
      <AllActions:{n | from="<(pcRateRenameFrom(n))(n)>", 
                       to="<paramtabledef.Name>_icb_<n.Name>",}; 
                   separator = "\n"> 
      from="id_sub", to="<paramtabledef.Name>_icb_id_sub"];

  <paramtabledef.Name>_pt_split_icb(1) -> <paramtabledef.Name>_icb_rename 

  -- Repartition by id_sub

  <paramtabledef.Name>_pt_icb_part: hashpart[
                                      key="<paramtabledef.Name>_icb_id_sub"];
  <paramtabledef.Name>_icb_rename -> <paramtabledef.Name>_pt_icb_part 

  <paramtabledef.Name>_pt_icb_coll:coll[];

  <paramtabledef.Name>_pt_icb_part -> <paramtabledef.Name>_pt_icb_coll;

  -- Rate table calculation: <paramtabledef.Name> 
  -- TODO: Handle boolean property conversion

  <if(EquiJoinConditions)>

    <if(NonEquiJoinConditions)>

      <paramtabledef.Name>_po: right_outer_hash_join[
        tableKey="<paramtabledef.Name>_po_id_sched", 
        <EquiJoinConditions:{n | tableKey="<paramtabledef.Name>_po_<n.Name>"}; 
                                          separator=",">, 
        probeKey="<parentPrefix><paramtabledef.Name>.PORateScheduleID", 
        <EquiJoinConditions:{c |probeKey="<c.Name>"}; 
                                          separator=",">, 
        <pcRateLookupResidualPredicate(conditions=NonEquiJoinConditions, 
                                       branch=poBranch())> ];

      -- TODO: Add an extra equijoin key on subscription; 
      -- this is consistent with the required partitioning 
      -- otherwise requires knowledge of a functional dependency to 
      -- infer correctness

      <paramtabledef.Name>_icb: right_outer_hash_join[
        tableKey="<paramtabledef.Name>_icb_id_sched", 
        <EquiJoinConditions:{n | tableKey="<paramtabledef.Name>_icb_<n.Name>"};
                                          separator=",">, 
        probeKey="<parentPrefix><paramtabledef.Name>.ICBRateScheduleID", 
        <EquiJoinConditions:{c |probeKey="<c.Name>"}; separator=",">, 
        <pcRateLookupResidualPredicate(conditions=NonEquiJoinConditions, 
                                       branch=icbBranch())> ];
    <else>
  
      <paramtabledef.Name>_po: right_outer_hash_join[
        tableKey="<paramtabledef.Name>_po_id_sched", 
        <EquiJoinConditions:{n | tableKey="<paramtabledef.Name>_po_<n.Name>"}; 
                                          separator=",">, 
        probeKey="<parentPrefix><paramtabledef.Name>.PORateScheduleID", 
        <EquiJoinConditions:{c |probeKey="<c.Name>"}; separator=","> ];
  
      -- TODO: Add an extra equijoin key on subscription; 
      -- this is consistent with the required partitioning 
      -- otherwise requires knowledge of a functional dependency to 
      -- infer correctness

      <paramtabledef.Name>_icb: right_outer_hash_join[
        tableKey="<paramtabledef.Name>_icb_id_sched", 
        <EquiJoinConditions:{n | tableKey="<paramtabledef.Name>_icb_<n.Name>"};
                                          separator=",">, 
        probeKey="<parentPrefix><paramtabledef.Name>.ICBRateScheduleID", 
        <EquiJoinConditions:{c |probeKey="<c.Name>"}; separator=","> ];
    <endif>
  
  <else> 
  <if(NonEquiJoinConditions)>
  
      <paramtabledef.Name>_po: right_outer_hash_join[
        tableKey="<paramtabledef.Name>_po_id_sched", 
        probeKey="<parentPrefix><paramtabledef.Name>.PORateScheduleID", 
        <pcRateLookupResidualPredicate(conditions=NonEquiJoinConditions, 
                                       branch=poBranch())>];
  
      -- TODO: Add an extra equijoin key on subscription; 
      -- this is consistent with the required partitioning 
      -- otherwise requires knowledge of a functional dependency to 
      -- infer correctness

      <paramtabledef.Name>_icb: right_outer_hash_join[
        tableKey="<paramtabledef.Name>_icb_id_sched", 
        probeKey="<parentPrefix><paramtabledef.Name>.ICBRateScheduleID", 
        <pcRateLookupResidualPredicate(conditions=NonEquiJoinConditions, 
                                       branch=icbBranch())>];
   <else>
      <paramtabledef.Name>_po: right_outer_hash_join[
        tableKey="<paramtabledef.Name>_po_id_sched", 
        probeKey="<parentPrefix><paramtabledef.Name>.PORateScheduleID"];
  
      -- TODO: Add an extra equijoin key on subscription; 
      -- this is consistent with the required partitioning 
      -- otherwise requires knowledge of a functional dependency to 
      -- infer correctness
      <paramtabledef.Name>_icb: right_outer_hash_join[
        tableKey="<paramtabledef.Name>_icb_id_sched", 
        probeKey="<parentPrefix><paramtabledef.Name>.ICBRateScheduleID"];
  
   <endif>
  
  <endif>

  <paramtabledef.Name>_pt_non_icb_coll -> <paramtabledef.Name>_po("table");
  
  -- Since we have non-equijoin conditions, 
  -- we may have multiple matches and 
  -- we only want to take the first with respect to n_order.
  -- We implement that logic by branching off and 
  -- calculating a group by over the input record 
  -- to get the min record (identified by its n_order) and then
  -- inner join (semi join) back to select.

  <if(NonEquiJoinConditions)>
  
    -- We are id_rs_request may exist under the parent (parent.id_rs_request).
    -- For some reason parent.id_rs_request is not accept in the copy[]
    -- operator below.  Because of this I'm copying parent.id_rs_request
    -- (or id_rs_request) to id_rs_request2

    <paramtabledef.Name>_po_candidate_copy_prep: expr[program="CREATE PROCEDURE p
                             @<parentPrefix>id_rs_request BIGINT
                             @id_rs_request2 BIGINT OUTPUT
			   AS SET @id_rs_request2 = @<parentPrefix>id_rs_request"
                          ];

    <paramtabledef.Name>_po_candidate_copy: copy[
      columnlist=[column="id_rs_request2", 
                  column="<paramtabledef.Name>_po_n_order"]];
  
    <paramtabledef.Name>_po_candidate_group_by: sort_group_by[
        key="id_rs_request2",
        initialize= "CREATE PROCEDURE ptLookupGroupByInit 
                      @<paramtabledef.Name>_po_n_order_min_order INTEGER 
            AS
            SET @<paramtabledef.Name>_po_n_order_min_order = NULL",
  
        update="CREATE PROCEDURE ptLookupGroupByUpdate 
                  @<paramtabledef.Name>_po_n_order INTEGER 
                  @<paramtabledef.Name>_po_n_order_min_order INTEGER  
            AS
              IF @<paramtabledef.Name>_po_n_order_min_order IS NULL OR 
                 @<paramtabledef.Name>_po_n_order \<= 
                          @<paramtabledef.Name>_po_n_order_min_order
              BEGIN
                SET @<paramtabledef.Name>_po_n_order_min_order = 
                      @<paramtabledef.Name>_po_n_order
              END"];
  
    <paramtabledef.Name>_po_candidate_rename: rename[
              from="id_rs_request2", 
              to="<paramtabledef.Name>_id_rs_request_po_min_order"];
   
    <paramtabledef.Name>_po_candidate_join: right_merge_semi_join[
        rightKey="id_rs_request2", 
        leftKey="<paramtabledef.Name>_id_rs_request_po_min_order", 
        residual="CREATE FUNCTION ptLookupCandidateJoin 
                    (@<paramtabledef.Name>_po_n_order INTEGER, 
                    @<paramtabledef.Name>_po_n_order_min_order INTEGER) 
                  RETURNS BOOLEAN
                  AS
                  RETURN (@<paramtabledef.Name>_po_n_order IS NULL AND 
                          @<paramtabledef.Name>_po_n_order_min_order IS NULL) 
                          OR  
                          (@<paramtabledef.Name>_po_n_order=
                           @<paramtabledef.Name>_po_n_order_min_order)"];
  
    <paramtabledef.Name>_po -> 
    <paramtabledef.Name>_po_candidate_copy_prep ->
    <paramtabledef.Name>_po_candidate_copy;

    <paramtabledef.Name>_po_candidate_copy(0) -> 
      <paramtabledef.Name>_po_candidate_group_by 

    <paramtabledef.Name>_po_candidate_group_by -> 
      <paramtabledef.Name>_po_candidate_rename 

    <paramtabledef.Name>_po_candidate_rename -> 
      <paramtabledef.Name>_po_candidate_join("left");
   
    <paramtabledef.Name>_po_candidate_copy(1) -> 
      <paramtabledef.Name>_po_candidate_join("right");
  
  <endif>


  <paramtabledef.Name>_pt_icb_coll -> <paramtabledef.Name>_icb("table");
  <if(NonEquiJoinConditions)>
    <paramtabledef.Name>_po_candidate_join -> <paramtabledef.Name>_icb("probe(0)");
  <else>
    <paramtabledef.Name>_po -> <paramtabledef.Name>_icb("probe(0)");
  <endif> 
  
  <if(NonEquiJoinConditions)>

    <paramtabledef.Name>_icb_candidate_copy_prep: expr[program="CREATE PROCEDURE p
                             @<parentPrefix>id_rs_request BIGINT
                             @id_rs_request2 BIGINT OUTPUT
			   AS SET @id_rs_request2 = @<parentPrefix>id_rs_request"
                          ];

    <paramtabledef.Name>_icb_candidate_copy: copy[
        columnlist=[column="id_rs_request2", 
                    column="<paramtabledef.Name>_icb_n_order"]];
  
    <paramtabledef.Name>_icb_candidate_group_by: sort_group_by[
          key="id_rs_request2",
          initialize="CREATE PROCEDURE ptLookupCandidateGroupByInit 
              @<paramtabledef.Name>_icb_n_order_min_order INTEGER 
              AS
              SET @<paramtabledef.Name>_icb_n_order_min_order = NULL",

          update="CREATE PROCEDURE ptLookupCandidateGroupByUpgrade
              @<paramtabledef.Name>_icb_n_order INTEGER 
              @<paramtabledef.Name>_icb_n_order_min_order INTEGER  
            AS
            IF @<paramtabledef.Name>_icb_n_order_min_order IS NULL OR 
               @<paramtabledef.Name>_icb_n_order \<= 
               @<paramtabledef.Name>_icb_n_order_min_order
            BEGIN
              SET @<paramtabledef.Name>_icb_n_order_min_order = 
                  @<paramtabledef.Name>_icb_n_order
            END"];
   
    <paramtabledef.Name>_icb_candidate_rename: rename[
        from="id_rs_request2", 
        to="<paramtabledef.Name>_id_rs_request_icb_min_order"];
   
    <paramtabledef.Name>_icb_candidate_join: right_merge_semi_join[
        rightKey="id_rs_request2", 
        leftKey="<paramtabledef.Name>_id_rs_request_icb_min_order", 
        residual="CREATE FUNCTION ptLookupIcbCandidateJoin 
            (@<paramtabledef.Name>_icb_n_order INTEGER, 
            @<paramtabledef.Name>_icb_n_order_min_order INTEGER) 
          RETURNS BOOLEAN
          AS
          RETURN (@<paramtabledef.Name>_icb_n_order IS NULL AND 
                  @<paramtabledef.Name>_icb_n_order_min_order IS NULL) OR  
                 (@<paramtabledef.Name>_icb_n_order=
                  @<paramtabledef.Name>_icb_n_order_min_order)"];
   
    <paramtabledef.Name>_icb -> 
    <paramtabledef.Name>_icb_candidate_copy_prep ->
    <paramtabledef.Name>_icb_candidate_copy;

    <paramtabledef.Name>_icb_candidate_copy(0) -> 
        <paramtabledef.Name>_icb_candidate_group_by 

    <paramtabledef.Name>_icb_candidate_group_by -> 
        <paramtabledef.Name>_icb_candidate_rename 

    <paramtabledef.Name>_icb_candidate_rename -> 
        <paramtabledef.Name>_icb_candidate_join("left");

    <paramtabledef.Name>_icb_candidate_copy(1) -> 
        <paramtabledef.Name>_icb_candidate_join("right");

  <endif>
  
  
  -- Implement pricelist chaining logic
  -- TODO: Error handling
  <paramtabledef.Name>: expr[program="
      CREATE PROCEDURE ptLookupChainLogic
        @<parentPrefix><paramtabledef.Name>.PORateScheduleID INTEGER
        @<parentPrefix><paramtabledef.Name>.ICBRateScheduleID INTEGER
        <conditions:{c | @<c.Name> <c.Type>}; separator="\n">
        @_ErrorCode INTEGER OUTPUT 
        @_ErrorString NVARCHAR OUTPUT
        @_Plugin NVARCHAR OUTPUT
        @_Module NVARCHAR OUTPUT
        @<paramtabledef.Name>_po_id_sched INTEGER
        @<paramtabledef.Name>_po_n_order INTEGER
        <AllActions:{n | @<paramtabledef.Name>_po_<n.Name> <n.Type>}; 
                     separator = "\n"> 
        @<paramtabledef.Name>_icb_id_sched INTEGER
        @<paramtabledef.Name>_icb_n_order INTEGER
        <AllActions:{n | @<paramtabledef.Name>_icb_<n.Name> <n.Type>}; 
                    separator = "\n"> 
        <AllActions:{n | @<n.Name> <n.Type> OUTPUT}; separator = "\n"> 
      AS
        IF NOT @<paramtabledef.Name>_icb_n_order IS NULL
          BEGIN 
              <AllActions:{n | SET @<n.Name> = 
                  @<paramtabledef.Name>_icb_<n.Name>}; separator = "\n"> 
          END
        ELSE IF NOT @<paramtabledef.Name>_po_n_order IS NULL
          BEGIN
              <AllActions:{n | SET @<n.Name> = 
                  @<paramtabledef.Name>_po_<n.Name>}; separator = "\n"> 
          END
        ELSE
          BEGIN
            SET @_ErrorCode = 0xE1200029
            SET @_ErrorString = N'No rules matched on rate schedule for parameter table <paramtabledef.Name>; ICB Rate Schedule=' + CASE WHEN @<parentPrefix><paramtabledef.Name>.ICBRateScheduleID IS NULL THEN N'NULL' ELSE CAST(@<parentPrefix><paramtabledef.Name>.ICBRateScheduleID AS NVARCHAR) END + N'; PO Rate Schedule=' + CASE WHEN @<parentPrefix><paramtabledef.Name>.PORateScheduleID IS NULL THEN N'NULL' ELSE CAST(@<parentPrefix><paramtabledef.Name>.PORateScheduleID AS NVARCHAR) END <conditions:{c | + N'; <c.Name>=' + CASE WHEN @<c.Name> IS NULL THEN N'NULL' ELSE CAST(@<c.Name> AS NVARCHAR)}>

            SET @_Plugin = N'<compositeInstanceName>'
            SET @_Module = N'rate_calculation'
          END
  "];
  
  <if(NonEquiJoinConditions)>
    <paramtabledef.Name>_icb_candidate_join -> <paramtabledef.Name>;
  <else>
    <paramtabledef.Name>_icb -> <paramtabledef.Name>;
  <endif>
  
  error_switch:switch[program=
      "CREATE FUNCTION ptLookupErrorSwitch (@_ErrorCode INTEGER) 
        RETURNS INTEGER
        AS
        RETURN CASE WHEN @_ErrorCode IS NULL OR @_ErrorCode = 0 THEN 0 
                    ELSE 1 END"];
  <paramtabledef.Name> -> error_switch;
  )
>>
