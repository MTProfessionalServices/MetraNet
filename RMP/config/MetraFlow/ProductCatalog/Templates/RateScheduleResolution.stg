group rateScheduleResolution;

rateScheduleResolutionComposite(operatorName, 
                                compositeInstanceName, 
                                subscriptionField,
                                paramtabledef) ::= <<

operator <operatorName>[
    in  "input"  is usg_sub_part("input"),
    out "output" is error_switch("output(0)"), 
    out "error"  is error_switch("output(1)")]
(
  -- Expected Inputs: 
  --         <subscriptionField>.PriceableItemInstanceID, 
  --         <subscriptionField>.SubscriptionStart, 
  --         <subscriptionField>.SubscriptionEnd, 
  --         <subscriptionField>.SubscriptionID,
  --         Usage.Timestamp

  -- This operator takes as a parameter multiple parameter table names.
  -- Given param table names: <paramtabledef:{n | <n.Name>}; separator = ", ">

  -- For each set of given inputs (priceable item, subscription ID, etc.)
  -- we find the winning rate schedule for each parameter table.
  -- We are collapsing all the records for a single incoming
  -- request to just a single row that contains fields named
  -- parameter table name_PORateScheduleID identifying the winning
  -- rate schedule for that parameter table.


  -- We repartition usage on subscription
  -- prior to pricelist resolution.
  -- Possible downsides are data skew (unlikely
  -- in large volume residential).
  -- More serious downside is that this doesn't support
  -- subscriptionless rating in a scalable way (I suppose there
  -- could be a default pricelist lookup for that case).
  -- TODO:  Would it make sense to keep the input partitioned on _AccountID
  -- at this point; the downside of that is that it requires copying
  -- ICB rates for every member of a group subscription and may not scale up
  -- (since every partition is likely to have some member of each 
  -- group sub hence every rate).

  -- Get parameter tables internal IDs for the all the parameter
  -- table names we were given.

  all_rate_schedules_parameter_table_ids: select[baseQuery=
    "select 
     <paramtabledef:{n | bp<i>.id_prop as id_paramtable_<n.Name>}; 
                     separator = ",\n">,
     1 as tmp_id_paramtable
     from 
     <paramtabledef:{n | t_base_props bp<i>}; separator = ",\n">
     where 
     <paramtabledef:{n | bp<i>.n_kind = 140 and 
                         bp<i>.nm_name='<n.FQN>'}; separator = " and\n"> ",
     mode="sequential"];

  all_rate_schedules_parameter_table_ids_part: broadcast[mode="sequential"];
  
  -- Send the parameter table IDs for the parameter table names
  -- we were given to all partitions. This should be a small amount
  -- of data.

  all_rate_schedules_parameter_table_ids -> 
    all_rate_schedules_parameter_table_ids_part;

  -- Read all the rate schedules in the database.
  -- Some of the rate schedules are ICB and some are non-ICB.
  -- You can tell the difference by the subscriber (id_sub)
  -- being 0 (non-ICB) or not.
  -- Historic David B note:
  --     Read non-ICB rate schedules and read ICB rate schedules 
  --     (possibly for a particular user)
  --     Do this for a particular priceable item type.

  all_rate_schedules: select[
    baseQuery="select plm.id_pi_instance as all_rs_id_pi_instance, 
                      plm.id_po          as all_rs_id_po, 
                      plm.id_sub         as all_rs_id_sub, 
                      plm.id_pricelist   as all_rs_pricelist,
                      plm.id_paramtable  as all_rs_paramtable,
                      rs.id_sched        as all_rs_rs,
                      ed.n_begintype     as all_rs_rs_begintype, 
                      ed.n_beginoffset   as all_rs_rs_beginoffset,
                      ed.dt_start        as all_rs_rs_beginbase, 
                      ed.n_endtype       as all_rs_rs_endtype,
                      ed.n_endoffset     as all_rs_rs_endoffset,
                      ed.dt_end          as all_rs_rs_endbase,
                      1 as tmp_id_pi_instance
               from t_pl_map plm 
               inner join t_base_props bp1 on bp1.id_prop=plm.id_pi_type 
               inner join t_base_props bp2 on bp2.id_prop=plm.id_paramtable 
               inner join t_rsched rs on rs.id_pricelist = plm.id_pricelist and
                                         rs.id_pt = plm.id_paramtable and 
                                         rs.id_pi_template = plm.id_pi_template
               inner join t_effectivedate ed on ed.id_eff_date = rs.id_eff_date
               WHERE
               {fn mod(plm.id_pi_instance,%%NUMPARTITIONS%%)} = %%PARTITION%%"];

  -- Join the information we just read with 
  -- the parameter table ID's we read earlier.

  all_rate_schedules_parameter_table_ids_join: inner_hash_join[
                                                 tableKey="tmp_id_paramtable", 
                                                 probeKey="tmp_id_pi_instance"];

  all_rate_schedules -> all_rate_schedules_parameter_table_ids_join("probe(0)");

  all_rate_schedules_parameter_table_ids_part -> 
    all_rate_schedules_parameter_table_ids_join("table");

  -- Now we have the rate schedule information for the parameter
  -- tables we were given.
  -- Split off icb and non-icb. 
  -- We can identify non-icb by all_rs_id_sub (id_sub field in t_pl_map)
  -- being 0 (meaning we don't have a subscriber).

  all_rate_schedules_split_icb: switch[program="
    CREATE FUNCTION rateScheduleSplit (@all_rs_id_sub INTEGER) RETURNS INTEGER
    AS
    RETURN 
      CASE WHEN @all_rs_id_sub IS NULL THEN 0 
           ELSE 1 END"];

  all_rate_schedules_parameter_table_ids_join -> all_rate_schedules_split_icb;

  -- Broadcast the non-icb records to everyone.

  all_rate_schedules_non_icb_part: broadcast[];
  all_rate_schedules_non_icb_coll: coll[];

  all_rate_schedules_split_icb(0) -> all_rate_schedules_non_icb_part 
                                  -> all_rate_schedules_non_icb_coll;

  -- Repartition the icb records by the subscriber id

  all_rate_schedules_icb_part: hashpart[key="all_rs_id_sub"];
  all_rate_schedules_split_icb(1) -> all_rate_schedules_icb_part 

  all_rate_schedules_icb_coll: coll[];
  all_rate_schedules_icb_part -> all_rate_schedules_icb_coll;

  -- Rejoin these two branches.
  -- I'm not sure what the point of all that was.

  all_rate_schedules_all_rs: union_all[];
  all_rate_schedules_non_icb_coll -> all_rate_schedules_all_rs(0);
  all_rate_schedules_icb_coll -> all_rate_schedules_all_rs(1);

  -- We are going to use this switch statement to throw away
  -- the rate schedules that aren't referencing the parameter
  -- table names we were given.

  all_rate_schedules_switch_on_paramtable: switch[program="
    CREATE FUNCTION rateScheduleSwitch (
      @all_rs_paramtable INTEGER 
      <paramtabledef:{n | @id_paramtable_<n.Name> INTEGER}; separator = "\n">) 
    RETURNS INTEGER
    AS
    RETURN CASE 
       WHEN 
       <paramtabledef:{n | @all_rs_paramtable = @id_paramtable_<n.Name>}; 
        separator = " OR\n"> THEN 1
       ELSE 0 END"];

  all_rate_schedules_all_rs -> all_rate_schedules_switch_on_paramtable;

  -- Throw away the rate schedules that we don't care about
  -- (the ones that didn't refer to our given parameter table names).

  unreferenced_rate_schedules:devNull[];
  all_rate_schedules_switch_on_paramtable(0) -> unreferenced_rate_schedules;

  -- Create two constants.  One is the beginning of time, the
  -- other is way into the future (2038).

  rs_create_dawn_and_sunset: expr[program=
                         "CREATE PROCEDURE rateScheduleDawn 
                          @dawn_of_time DATETIME OUTPUT 
                          @sunset_of_time DATETIME OUTPUT
                          AS
                          SET @dawn_of_time = CAST('1970-01-01' AS DATETIME)
                          SET @sunset_of_time = CAST('2038-01-01' AS DATETIME)"
                        ];

  all_rate_schedules_switch_on_paramtable(1) -> rs_create_dawn_and_sunset;

  -- We've already split the rate schedules earlier by ICB and
  -- non-ICB.  We're are spliting them again here.  An improvement
  -- would be remove this double splitting (TODO).

  rs_split_icb: switch[program="
   CREATE FUNCTION f (@all_rs_id_sub INTEGER) RETURNS INTEGER
   AS
   RETURN CASE WHEN @all_rs_id_sub IS NULL THEN 0 ELSE 1 END"];

  rs_create_dawn_and_sunset -> rs_split_icb;


  -- Branch and calculate the maximum score for each input record
  -- Having selected the maximum score, pick out the rate schedule(s) 
  -- that match that score.

  -- We are going to feed the input to our operator into this join.
  -- Using the incoming timestamp (Usage.Timestamp), we are going
  -- to throw away all rate schedules that don't include that time.
  -- So we are joining to find all rate schedules that are in effect 
  -- for the CDR (including promotions etc.)

  rs_filter_by_timestamp: inner_hash_join[
    tableKey="all_rs_id_pi_instance", 
    probeKey="<subscriptionField>.PriceableItemInstanceID",
    residual="
      CREATE FUNCTION rateScheduleInnerJoin 
      (@dawn_of_time                   DATETIME 
       @sunset_of_time                 DATETIME 
       @Usage.Timestamp                DATETIME 
       @<subscriptionField>.SubscriptionStart DATETIME 
       @<subscriptionField>.SubscriptionEnd   DATETIME 
       @all_rs_rs_begintype            INTEGER 
       @all_rs_rs_beginbase            DATETIME 
       @all_rs_rs_beginoffset          INTEGER 
       @all_rs_rs_endtype              INTEGER 
       @all_rs_rs_endbase              DATETIME 
       @all_rs_rs_endoffset            INTEGER) 
      RETURNS BOOLEAN
      AS
      DECLARE @rs_start_date DATETIME
      DECLARE @rs_end_date   DATETIME
      SET @rs_start_date = CASE @all_rs_rs_begintype 
        WHEN 4 THEN @dawn_of_time 
        WHEN 2 THEN dateadd('d', @all_rs_rs_beginoffset, 
                          @<subscriptionField>.SubscriptionStart) 
        WHEN 1 THEN @all_rs_rs_beginbase 
      END
      SET @rs_end_date = CASE @all_rs_rs_endtype 
        WHEN 4 THEN @sunset_of_time 
        WHEN 2 THEN dateadd('d', @all_rs_rs_endoffset, 
                                 @<subscriptionField>.SubscriptionStart) 
        WHEN 1 THEN @all_rs_rs_endbase 
      END
      RETURN @Usage.Timestamp >= @rs_start_date AND 
             @Usage.Timestamp \<= @rs_end_date"];

  rs_split_icb(0) -> rs_filter_by_timestamp("table");

  -- Finally we are using the records we are being passed in.
  -- This is the first time we are using this information.
  -- Everything above this point was just driven by the parameter
  -- table names.

  -- Repartition the input on subscription ID
  -- The input into this operator feeds into usg_sub_part.
  -- See the operator declaration at the top.

  usg_sub_part: hashpart[key="<subscriptionField>.SubscriptionID"];

  usg_sub_coll: coll[];

  usg_sub_part -> usg_sub_coll;

  -- We need to create a unique identifier for each 
  -- input record, because we'll be doing some aggregation later
  -- on this identifer.

  generate_rs_input_id:generate[
        program="CREATE PROCEDURE rateScheduleInputID @id_rs_request BIGINT OUTPUT
                 AS
                 SET @id_rs_request = @@RECORDCOUNT"];

  usg_sub_coll -> generate_rs_input_id;

  -- For each given parameter table name, we are going to
  -- add a variable containing the parameter table name.
  -- Later we will promote this variable into a record.
  addParameterTableName: expr[program=
    "CREATE PROCEDURE rateScheduleAddParamTable 
     <paramtabledef:{n | @<n.Name>_parameterTableName NVARCHAR OUTPUT}; separator = "\n">
     AS
     <paramtabledef:{n | SET @<n.Name>_parameterTableName = N'<n.Name>'}; separator = "\n"> "];
  generate_rs_input_id -> addParameterTableName;

  -- Copy input records for ICB and non-ICB processing
  -- We're going to using two copies of the data.

  usg_copy: copy[columnList=[column="id_rs_request", 
                             column="<subscriptionField>", 
                             column="Usage"]];

  addParameterTableName -> usg_copy;


  usg_copy(0) -> rs_filter_by_timestamp("probe(0)");

  -- Calculate a score for each rate schedule.
  -- The score is constructed by scoring the start time
  -- of the schedule and the type of schedule (the
  -- type counts more than the date).
  po_rs_determine_score: expr[program="
    CREATE PROCEDURE rateScheduleScore 
      @<subscriptionField>.SubscriptionStart DATETIME 
      @all_rs_rs_begintype            INTEGER 
      @all_rs_rs_beginbase            DATETIME 
      @all_rs_rs_beginoffset          INTEGER 
      @dawn_of_time                   DATETIME  
      @po_rs_score                    BIGINT   OUTPUT
   AS
     DECLARE @dateScore INTEGER
     DECLARE @typeScore INTEGER
     DECLARE @rs_start_date DATETIME
     SET @rs_start_date = CASE @all_rs_rs_begintype 
       WHEN 4 THEN @dawn_of_time 
       WHEN 2 THEN dateadd('d', @all_rs_rs_beginoffset, 
                                @<subscriptionField>.SubscriptionStart) 
       WHEN 1 THEN @all_rs_rs_beginbase 
     END
     SET @dateScore = datediff('s', @dawn_of_time, @rs_start_date)
     SET @typeScore = CASE @all_rs_rs_begintype 
      WHEN 2 THEN 2 
      WHEN 4 THEN 0 
      ELSE 1 
     END
  SET @po_rs_score = CAST(@typeScore AS BIGINT)*4294967296LL + 
                     CAST(@dateScore AS BIGINT)"];

  rs_filter_by_timestamp -> po_rs_determine_score 

  -- For a given request (subscriber, timestamp)
  -- we find the winning rate schedule for each parameter table
  -- we were given.

  -- Find the max score and the parameter table associated with 
  -- that max score.  We pivot them into a single record for in 
  -- downstream processing (do we really
  -- need to do that pivoting now?)  At some point pivoting 
  -- needs to happen because we need all rates on a single record.
  -- Nested records (putting matching records in the join into 
  -- a subcollection) and a final unnest might provide a better 
  -- way to organize this in the future.
  -- Also, something that would be very useful is a hybrid 
  -- sort/hash group by in which some keys are sorted and some 
  -- are hashed.  In effect we are implementing
  -- a hash table on the paramtable name in our update program below.

  po_calculate_max_score: sort_group_by[key="id_rs_request", 
    initialize=
      "CREATE PROCEDURE rateScheduleCalcMaxInit 
       <paramtabledef:{n | @<n.Name>_po_max_score BIGINT 
                           @<n.Name>_PORateScheduleID INTEGER}; separator = "\n">
       AS 
       <paramtabledef:{n | SET @<n.Name>_po_max_score = -1LL
       SET @<n.Name>_PORateScheduleID = NULL}; separator = "\n">",
    update=
      "CREATE PROCEDURE rateScheduleCalcMaxUpdate 
         @all_rs_paramtable INTEGER 
         @all_rs_rs         INTEGER 
         @po_rs_score       BIGINT 
         <paramtabledef:{n | @<n.Name>_po_max_score BIGINT 
                             @<n.Name>_PORateScheduleID INTEGER 
                             @id_paramtable_<n.Name> INTEGER}; 
                         separator = "\n">
       AS
       <first(paramtabledef):{n | 
          IF @all_rs_paramtable = @id_paramtable_<n.Name> AND 
             @<n.Name>_po_max_score \< @po_rs_score
          BEGIN
             SET @<n.Name>_po_max_score = @po_rs_score
             SET @<n.Name>_PORateScheduleID = @all_rs_rs
          END}; separator = "\n">

       <rest(paramtabledef):{n | 
          ELSE IF @all_rs_paramtable = @id_paramtable_<n.Name> AND 
                  @<n.Name>_po_max_score \< @po_rs_score
          BEGIN
             SET @<n.Name>_po_max_score = @po_rs_score
             SET @<n.Name>_PORateScheduleID = @all_rs_rs
          END}; separator = "\n">
  "];

  po_rs_determine_score -> po_calculate_max_score 

  -- Now we have produced a table that contains a incoming request id
  -- and the associated winning rate schedules.  We want to join this
  -- table with our original input. Before we do this, we have a 
  -- name collision so we are renaming id_rs_request in 
  -- the scored table to id_rs_request_max_score

  po_max_score_rename: rename[from="id_rs_request", 
                              to="id_rs_request_max_score"];

  po_calculate_max_score -> po_max_score_rename 

  -- Join together our original input with the scored rate schedules.
  -- This gives us the winning rate schedule for each parameter table
  -- we were given.

  po_rs_winner: right_outer_merge_join[leftKey="id_rs_request_max_score", 
                                       rightKey="id_rs_request"];

  po_max_score_rename -> po_rs_winner("left");

  usg_copy(1) -> po_rs_winner("right");

  -- Now we are going to work on the ICB branch of
  -- the flow.  Ultimately, we'll join
  -- po_rs_winner with icb winner.

  -- ICB Case ------------------------------------------------------------
  -- We are throwing away the ICB cases here.
  -- We earlier split the date by ICB and non-ICB.

  icb_rs_filter_by_timestamp: inner_hash_join[
    tableKey="all_rs_id_pi_instance", 
    probeKey="<subscriptionField>.PriceableItemInstanceID",
    residual="
      CREATE FUNCTION rateScheduleFilterByTime 
      (@dawn_of_time                   DATETIME 
       @sunset_of_time                 DATETIME 
       @Usage.Timestamp                DATETIME 
       @<subscriptionField>.SubscriptionStart DATETIME 
       @<subscriptionField>.SubscriptionEnd   DATETIME 
       @all_rs_rs_begintype            INTEGER 
       @all_rs_rs_beginbase            DATETIME 
       @all_rs_rs_beginoffset          INTEGER 
       @all_rs_rs_endtype              INTEGER 
       @all_rs_rs_endbase              DATETIME 
       @all_rs_rs_endoffset            INTEGER) 
      RETURNS BOOLEAN
      AS
      DECLARE @rs_start_date DATETIME
      DECLARE @rs_end_date   DATETIME
      SET @rs_start_date = CASE @all_rs_rs_begintype 
        WHEN 4 THEN @dawn_of_time 
        WHEN 2 THEN dateadd('d', @all_rs_rs_beginoffset, 
                          @<subscriptionField>.SubscriptionStart) 
        WHEN 1 THEN @all_rs_rs_beginbase 
      END
      SET @rs_end_date = CASE @all_rs_rs_endtype 
        WHEN 4 THEN @sunset_of_time 
        WHEN 2 THEN dateadd('d', @all_rs_rs_endoffset, 
                                 @<subscriptionField>.SubscriptionStart) 
        WHEN 1 THEN @all_rs_rs_endbase 
      END
      RETURN @Usage.Timestamp >= @rs_start_date AND 
             @Usage.Timestamp \<= @rs_end_date"];

  rs_split_icb(1) -> icb_rs_filter_by_timestamp("table");
      usg_copy(2) -> icb_rs_filter_by_timestamp("probe(0)");

  icb_rs_determine_score: expr[program="
    CREATE PROCEDURE rateScheduleDetermineScore 
      @<subscriptionField>.SubscriptionStart DATETIME 
      @all_rs_rs_begintype            INTEGER 
      @all_rs_rs_beginbase            DATETIME 
      @all_rs_rs_beginoffset          INTEGER 
      @dawn_of_time                   DATETIME  
      @icb_rs_score                    BIGINT   OUTPUT
   AS
     DECLARE @dateScore INTEGER
     DECLARE @typeScore INTEGER
     DECLARE @rs_start_date DATETIME
     SET @rs_start_date = CASE @all_rs_rs_begintype 
       WHEN 4 THEN @dawn_of_time 
       WHEN 2 THEN dateadd('d', @all_rs_rs_beginoffset, 
                                @<subscriptionField>.SubscriptionStart) 
       WHEN 1 THEN @all_rs_rs_beginbase 
     END
     SET @dateScore = datediff('s', @dawn_of_time, @rs_start_date)
     SET @typeScore = CASE @all_rs_rs_begintype 
      WHEN 2 THEN 2 
      WHEN 4 THEN 0 
      ELSE 1 
     END
  SET @icb_rs_score = CAST(@typeScore AS BIGINT)*4294967296LL + 
                     CAST(@dateScore AS BIGINT)"];

  icb_rs_filter_by_timestamp -> icb_rs_determine_score 

  -- For a given request (subscriber, timestamp)
  -- we find the winning rate schedule for each parameter table
  -- we were given.

  -- Find the max score and the parameter table associated with 
  -- that max score.  We pivot them into a single record for in 
  -- downstream processing (do we really
  -- need to do that pivoting now?)  At some point pivoting 
  -- needs to happen because we need all rates on a single record.
  -- Nested records (putting matching records in the join into 
  -- a subcollection) and a final unnest might provide a better 
  -- way to organize this in the future.
  -- Also, something that would be very useful is a hybrid 
  -- sort/hash group by in which some keys are sorted and some 
  -- are hashed.  In effect we are implementing
  -- a hash table on the paramtable name in our update program below.

  icb_calculate_max_score: sort_group_by[key="id_rs_request", 
    initialize=
      "CREATE PROCEDURE rateScheduleIcbCalcMaxScoreInit
       <paramtabledef:{n | @<n.Name>_icb_max_score BIGINT 
                           @<n.Name>_ICBRateScheduleID INTEGER}; separator = "\n">
       AS 
       <paramtabledef:{n | SET @<n.Name>_icb_max_score = -1LL
       SET @<n.Name>_ICBRateScheduleID = NULL}; separator = "\n">",
    update=
      "CREATE PROCEDURE rateScheduleIcbCalcMaxScoreUpdate 
         @all_rs_paramtable INTEGER 
         @all_rs_rs         INTEGER 
         @icb_rs_score       BIGINT 
         <paramtabledef:{n | @<n.Name>_icb_max_score BIGINT 
                             @<n.Name>_ICBRateScheduleID INTEGER 
                             @id_paramtable_<n.Name> INTEGER}; 
                         separator = "\n">
       AS
       <first(paramtabledef):{n | 
          IF @all_rs_paramtable = @id_paramtable_<n.Name> AND 
             @<n.Name>_icb_max_score \< @icb_rs_score
          BEGIN
             SET @<n.Name>_icb_max_score = @icb_rs_score
             SET @<n.Name>_ICBRateScheduleID = @all_rs_rs
          END}; separator = "\n">

       <rest(paramtabledef):{n | 
          ELSE IF @all_rs_paramtable = @id_paramtable_<n.Name> AND 
                  @<n.Name>_icb_max_score \< @icb_rs_score
          BEGIN
             SET @<n.Name>_icb_max_score = @icb_rs_score
             SET @<n.Name>_ICBRateScheduleID = @all_rs_rs
          END}; separator = "\n">
  "];

  icb_rs_determine_score -> icb_calculate_max_score 

  -- Now we have produced a table that contains a incoming request id
  -- and the associated winning rate schedules.  We want to join this
  -- table with our original input. Before we do this, we have a 
  -- name collision so we are renaming id_rs_request in 
  -- the scored table to id_rs_request_max_score

  icb_max_score_rename: rename[from="id_rs_request", 
                              to="id_rs_request_max_score"];

  icb_calculate_max_score -> icb_max_score_rename 

  -- Join together our original input with the scored rate schedules.
  -- This gives us the winning rate schedule for each parameter table
  -- we were given.

  icb_rs_winner: right_outer_merge_join[leftKey="id_rs_request_max_score", 
                                       rightKey="id_rs_request"];

  icb_max_score_rename -> icb_rs_winner("left");

  usg_copy(3) -> icb_rs_winner("right");

  -- Discard the fields we don't really need
  icbDiscardTemps: project[
     column="id_rs_request",
     <paramtabledef:{n | column="<n.Name>_ICBRateScheduleID"}; 
                     separator = ",\n"> 
                          ];

  icb_rs_winner -> icbDiscardTemps;

  icbRenameRequestField: rename[from = "id_rs_request",
                                to = "icb_id_rs_request"];
  icbDiscardTemps -> icbRenameRequestField;

  -- Now we are going to join together the ICB and non-ICB
  -- case.

  joinICBandPO: right_outer_hash_join[probeKey="icb_id_rs_request",
                                      tableKey="id_rs_request"];

  icbRenameRequestField -> joinICBandPO("probe(0)");
           po_rs_winner -> joinICBandPO("table");
  
  -- Throw away the fields that we don't need
  throwAwayFields: project[inverse=true,
                           column="id_rs_request_max_score",
                           column="icb_id_rs_request",
                           <paramtabledef:{n | column="<n.Name>_po_max_score"}; 
                            separator = ",\n">
                          ];

  joinICBandPO -> throwAwayFields;

  -- If no rate schedules were found for one of these rate schedules, 
  -- then this is an error.

  -- Check for errors.

  error_detect: expr[program="
    CREATE PROCEDURE rateScheduleErrorDetect
      <paramtabledef:{n | @<n.Name>.PORateScheduleID INTEGER}; separator = "\n">
      <paramtabledef:{n | @<n.Name>.ICBRateScheduleID INTEGER}; separator = "\n">
      @<subscriptionField>.PriceableItemInstanceID INTEGER
      @Usage.Timestamp                      DATETIME
      @<subscriptionField>.SubscriptionID          INTEGER
      @_ErrorCode                           INTEGER  OUTPUT
      @_ErrorString                         NVARCHAR OUTPUT
      @_Plugin                              NVARCHAR OUTPUT
      @_Module                              NVARCHAR OUTPUT
    AS
      <paramtabledef:{n | IF @<n.Name>.PORateScheduleID IS NULL AND @<n.Name>.ICBRateScheduleID IS NULL
    BEGIN
      SET @_ErrorCode = 0xE1200028
      SET @_ErrorString = 
        N'No rate schedule found for parameter table=<n.FQN>; PriceableItemInstanceID=' + 
        CASE WHEN @<subscriptionField>.PriceableItemInstanceID IS NULL THEN N'NULL' 
        ELSE CAST(@<subscriptionField>.PriceableItemInstanceID AS NVARCHAR) END + N'; 
      Timestamp=' + CASE WHEN @Usage.Timestamp IS NULL THEN N'NULL' 
      ELSE CAST(@Usage.Timestamp AS NVARCHAR) END + N'; 
      SubscriptionID = ' + CASE WHEN @<subscriptionField>.SubscriptionID IS NULL THEN N'NULL' 
      ELSE CAST(@<subscriptionField>.SubscriptionID AS NVARCHAR) END
      SET @_Plugin = N'<compositeInstanceName>'
      SET @_Module = N'rate_schedule_lookup'
    END}; separator = "\n">"];

  -- We are going to promote the individual
  -- parameter table variables to records.
  -- Here are the rename operators premoting the variables to records.

  <paramtabledef:{n | rename<i>: rename[
              from="<n.Name>_PORateScheduleID",
              to=  "<n.Name>.PORateScheduleID",
              from="<n.Name>_ICBRateScheduleID",
              to=  "<n.Name>.ICBRateScheduleID",
              from="<n.Name>_parameterTableName",
              to=  "<n.Name>.ParameterTableName"
              ];}>

  -- This wires up all the renames into the flows
  throwAwayFields -> <paramtabledef:{n | rename<i> ->}> error_detect;

  error_switch: switch[program="
    CREATE FUNCTION rateScheduleErrorSwitch (@_ErrorCode INTEGER) 
    RETURNS INTEGER
    AS
    RETURN CASE WHEN @_ErrorCode IS NULL OR @_ErrorCode = 0 THEN 0 
    ELSE 1 END"];

  error_detect -> error_switch;


)
>>
