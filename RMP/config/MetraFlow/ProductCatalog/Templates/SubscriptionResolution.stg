group subscriptionResolution;

subscriptionResolutionComposite(operatorName,
priceableItemNameField,
priceableItemNameLiteral,
accountIDField,
timestampField,
priceableItemTypeIDField,
priceableItemTemplateIDField,
subscriptionField) ::= <<
operator <operatorName> [in  "input"  is ums_sub_probe_part("input"),
                         out "output" is error_switch(0),
                         out "error"  is error_switch(1)]
(
  -- Inputs: 
  --   <if(priceableItemNameField)><priceableItemNameField><else><priceableItemNameLiteral><endif>
  --   <accountIDField>
  --   <timestampField>
  -- Outputs:
  --   <priceableItemTypeIDField>
  --   <priceableItemTemplateIDField>
  --   <subscriptionField> (contains PriceableItemInstanceID, 
  --                                 PriceableItemTemplateID,
  --                                 PriceableItemTypeID,    
  --                                 ProductOfferingID, 
  --                                 SubscriptionID, 
  --                                 SubscriptionStart, 
  --                                 SubscriptionEnd)
  
  -- ums = usage monthly summary
  
  -- Resolve PIType and Subscription based on _PriceableItemType
  
  -- Redistribute the data based on accountIDField
  ums_sub_probe_part: hashpart[key="<accountIDField>"];
  ums_sub_probe_coll: coll[];
  
  ums_sub_probe_part -> ums_sub_probe_coll;
  
  -- Convert the priceableItemNameField to lower case

  -- The right side of this join is our single record
  -- for the given priceable item.
  ums_pitype_name_convert:
	  expr[program="CREATE PROCEDURE subscriptionResolutionConvert 
		  <if(priceableItemNameField)>@<priceableItemNameField> NVARCHAR<endif> 
		  @umsPriceableItemName NVARCHAR OUTPUT
		  AS
		  SET @umsPriceableItemName = lower(
			  <if(priceableItemNameField)>@<priceableItemNameField>
			  <else>N'<priceableItemNameLiteral>'<endif>)"];
  
  ums_sub_probe_coll-> ums_pitype_name_convert

  -- Get id_prop and nm_name from t_base_props
  -- Join with t_pi
  ums_pitype_select: 
	            select[baseQuery="SELECT bp.id_prop as ums_id_prop, 
				                        lower(bp.nm_name) as ums_nm_name
			                          FROM
				                        t_base_props bp 
			                          INNER JOIN t_pi p on bp.id_prop=p.id_pi",
                                       mode="sequential"];
  
  -- Rename id_prop to the name the caller wants for this.
  ums_pitype_rename: 
	  rename[from="ums_id_prop", to="<priceableItemTypeIDField>",
                 mode="sequential"];
  
  ums_pitype_select -> ums_pitype_rename

  -- Broadcast the pi info we have to everyone
  ums_pitype_broadcast: broadcast[mode="sequential"];
  
  ums_pitype_rename -> ums_pitype_broadcast

  -- With this join we reduce our records down to a single record.
  -- This record is for the given priceable item.
  ums_pitype_join: 
	  right_outer_hash_join[tableKey="ums_nm_name", 
                          probeKey="umsPriceableItemName"];
  
  ums_pitype_broadcast -> ums_pitype_join("table");
  
  ums_pitype_name_convert -> ums_pitype_join("probe(0)");
  
  ums_is: select[baseQuery="select id_sub   as ums_s_id_sub, 
                                   id_acc   as ums_s_id_acc, 
                                   id_po    as ums_s_id_po, 
                                   vt_start as ums_s_vt_start, 
                                   vt_end   as ums_s_vt_end 
                           from t_sub 
                           where 
                               id_group is null 
                           and 
                          {fn mod(id_acc, %%NUMPARTITIONS%%)} = %%PARTITION%%"];

  ums_gs: select[baseQuery="select s.id_sub     as ums_s_id_sub, 
                                   gsm.id_acc   as ums_s_id_acc, 
                                   s.id_po      as ums_s_id_po, 
                                   gsm.vt_start as ums_s_vt_start, 
                                   gsm.vt_end   as ums_s_vt_end 
                            from 
                              t_gsubmember gsm 
                            inner join t_sub s on s.id_group=gsm.id_group 
                            where 
                      {fn mod(gsm.id_acc, %%NUMPARTITIONS%%)} = %%PARTITION%%"];

  ums_su: union_all[];
  ums_is -> ums_su(0);
  ums_gs -> ums_su(1);
  
  ums_sub_part: hashpart[key="ums_s_id_acc"];
  ums_sub_coll: coll[];

  ums_subj: right_outer_hash_join[tableKey="ums_s_id_acc", 
                                  probeKey="<accountIDField>", 
                                  residual="
  CREATE FUNCTION f (@<timestampField> 
        DATETIME @ums_s_vt_start 
        DATETIME @ums_s_vt_end DATETIME) RETURNS BOOLEAN 
  AS
        RETURN @<timestampField> >= @ums_s_vt_start AND 
               @<timestampField> \<= @ums_s_vt_end"];

  -- The left-side contains account/po subscription information
  -- for all accounts.
  ums_su -> ums_sub_part -> ums_sub_coll -> ums_subj("table");

  -- The right side of this join is our single record
  -- for the given priceable item and input information
  -- to the operator (account ID, timestamp, etc).

  ums_pitype_join -> ums_subj("probe(0)");
  
  -- TODO : reverse the order of PO and subscription lookup?
  -- Note that we are using the pi to figure out which 
  -- POs (hence which subscriptions) are of interest
  -- Assume a "small" number of product offerings, so we broadcast 
  -- without repartitioning of usage stream

  ums_plm: select[baseQuery=
    "select plm.id_pi_type     as ums_plm_id_pi_type, 
            plm.id_pi_template as ums_plm_id_pi_template, 
            plm.id_pi_instance as ums_plm_id_pi_instance, 
            plm.id_po          as ums_plm_id_po 
     from t_pl_map plm 
     inner join t_base_props bp on bp.id_prop=plm.id_pi_template 
     where id_paramtable is null and 
    {fn mod(plm.id_pi_instance, %%NUMPARTITIONS%%)} = %%PARTITION%%"];

  ums_plm_part: broadcast[];
  ums_plm_coll: coll[];

  -- We are using an inner_hash_join because we want to
  -- eliminate some records from the right hand side.
  -- The right hand side has all the PO subscriptions for this
  -- user.  In each row we've also added the priceable item we're
  -- interested in.  But this priceable item is not necessarily
  -- in the PO.  We need a match with the left hand side (contains
  -- PO/PI relationship) to prove it exists.
  ums_plmj: inner_hash_join[
              tableKey="ums_plm_id_po", 
              tableKey="ums_plm_id_pi_type", 
              probeKey="ums_s_id_po", 
              probeKey="<priceableItemTypeIDField>"];
  
  ums_copy_templateID: expr [program=
      "CREATE PROCEDURE subscriptionResolutionCopyTemplateID
	@ums_plm_id_pi_template INTEGER 
	@<priceableItemTypeIDField> INTEGER 
        @ums_plm_id_pi_template2 INTEGER OUTPUT
	@ums_plm_id_pi_type2 INTEGER OUTPUT
       AS
       SET @ums_plm_id_pi_template2 = @ums_plm_id_pi_template
       SET @ums_plm_id_pi_type2     = @<priceableItemTypeIDField>"
     ];


  ums_rename_final: rename[
    from="ums_plm_id_pi_instance", to="<subscriptionField>.PriceableItemInstanceID",
    from="ums_plm_id_po",          to="<subscriptionField>.ProductOfferingID",
    from="ums_s_id_sub",           to="<subscriptionField>.SubscriptionID",
    from="ums_s_vt_start",         to="<subscriptionField>.SubscriptionStart",
    from="ums_s_vt_end",           to="<subscriptionField>.SubscriptionEnd",
    from="ums_plm_id_pi_type2",    to="<subscriptionField>.PriceableItemTypeID",
    from="ums_plm_id_pi_template", to="<subscriptionField>.PriceableItemTemplateID",
    from="ums_plm_id_pi_template2",to="<priceableItemTemplateIDField>"
  ];
  
  -- The left-side of this join contains information about
  -- the priceable item type (like the PO it belongs to).
  -- The right-side contains the subscription that this account has.
  ums_plm-> ums_plm_part -> ums_plm_coll -> ums_plmj("table");
  ums_subj -> ums_plmj("probe(0)");
  ums_plmj -> ums_copy_templateID -> ums_rename_final;

  -- Discard temporary fields
  discardTemps: project[inverse=true,
                        column="ums_plm_id_pi_type",
                        column="ums_s_id_acc",
                        column="ums_s_id_po",
                        column="ums_nm_name",
                        column="umsPriceableItemName"];

  ums_rename_final -> discardTemps;

  error_switch: 
    switch[program="CREATE FUNCTION f (@<priceableItemTypeIDField> INTEGER) 
                    RETURNS INTEGER
                    AS
                    RETURN 0"];

  discardTemps -> error_switch;
)
>>
