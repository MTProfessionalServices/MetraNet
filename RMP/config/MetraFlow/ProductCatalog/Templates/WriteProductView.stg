group writeProductView;

BOOLEANsetDefaultValue(p) ::= <<
IF @<p.Name> IS NULL
  SET @<p.Name> = <p.DefaultValue>

>>

ENUMsetDefaultValue(p) ::= <<
IF @<p.Name> IS NULL
  SET @<p.Name> = CAST('<p.DefaultValue>' AS ENUM)

>>

INTEGERsetDefaultValue(p) ::= <<
IF @<p.Name> IS NULL
  SET @<p.Name> = <p.DefaultValue>

>>

BIGINTsetDefaultValue(p) ::= <<
IF @<p.Name> IS NULL
  SET @<p.Name> = <p.DefaultValue>LL

>>

VARCHARsetDefaultValue(p) ::= <<
IF @<p.Name> IS NULL
  SET @<p.Name> = '<p.DefaultValue>'

>>

NVARCHARsetDefaultValue(p) ::= <<
IF @<p.Name> IS NULL
  SET @<p.Name> = N'<p.DefaultValue>'

>>

DECIMALsetDefaultValue(p) ::= <<
IF @<p.Name> IS NULL
  SET @<p.Name> = <p.DefaultValue>

>>

DATETIMEsetDefaultValue(p) ::= <<
IF @<p.Name> IS NULL
  SET @<p.Name> = CAST('<p.DefaultValue>' AS DATETIME)

>>

dispatchDefaultValue(p) ::= <<
<p.Type>setDefaultValue
>>

setDefaultValue(p) ::= <<
<if(p.DefaultValue)>
<(dispatchDefaultValue(p))(p)>
<endif>
>>

BOOLEANcheckLengthConstraint(p) ::= <<
>>

ENUMcheckLengthConstraint(p) ::= <<
>>

INTEGERcheckLengthConstraint(p) ::= <<
>>

BIGINTcheckLengthConstraint(p) ::= <<
>>

VARCHARcheckLengthConstraint(p) ::= <<
IF NOT @<p.Name> IS NULL AND len(@<p.Name>) > <p.Length>
BEGIN
  SET @_ErrorCode = 0xE1200013
  SET @_ErrorString = N'Field <p.Name> has length ' + CAST(len(@<p.Name>) AS NVARCHAR) + N' which exceeds maximum length of <p.Length>'
  SET @_Plugin = N'<compositeInstanceName>'
  SET @_Module = N'write_product_view'
END

>>

NVARCHARcheckLengthConstraint(p) ::= <<
IF NOT @<p.Name> IS NULL AND len(@<p.Name>) > <p.Length>
BEGIN
  SET @_ErrorCode = 0xE1200013
  SET @_ErrorString = N'Field <p.Name> has length ' + CAST(len(@<p.Name>) AS NVARCHAR) + N' which exceeds maximum length of <p.Length>'
  SET @_Plugin = N'<compositeInstanceName>'
  SET @_Module = N'write_product_view'
END

>>

DECIMALcheckLengthConstraint(p) ::= <<
>>

DATETIMEcheckLengthConstraint(p) ::= <<
>>

dispatchCheckLengthConstraint(p) ::= <<
<p.Type>checkLengthConstraint
>>

checkLengthConstraint(p) ::= <<
<(dispatchCheckLengthConstraint(p))(p)>
>>


writeProductViewComposite(operatorName, compositeInstanceName, productViewName, productViewTable, Properties, isMultipointParent, isMultipointChild) ::= <<

operator <operatorName> [
    in "input"   is WriteProductView_allfields("input"),
    out "output" is copyAll(0),
    out "error"  is errorSwitch(1)]
(
  -- Make sure all fields exist
  WriteProductView_allfields: expr[
        program="CREATE PROCEDURE writeProductViewAllFields
                @Usage.PayingAccountID         INTEGER 
                @Usage.Timestamp               DATETIME 
                @Usage.PriceableItemInstanceID INTEGER 
                @Usage.PriceableItemTemplateID INTEGER 
                @Usage.ProductOfferingID       INTEGER 
                @Usage.AccountID               INTEGER 
                @Usage.SessionID               BINARY 
                @Usage.Amount                  DECIMAL 
                @Usage.Currency                NVARCHAR 
                @Usage.FedTax                  DECIMAL 
                @Usage.StateTax                DECIMAL 
                @Usage.CountyTax               DECIMAL 
                @Usage.LocalTax                DECIMAL 
                @Usage.OtherTax                DECIMAL 
                @Usage.IntervalID              INTEGER 
                @Usage.SubscriptionEntity      INTEGER 
                @Usage.CollectionID            BINARY 
                @_ErrorCode                    INTEGER OUTPUT
                @_ErrorString                  NVARCHAR OUTPUT
                @_Plugin                       NVARCHAR OUTPUT
                @_Module                       NVARCHAR OUTPUT
                <Properties:{p | @<p.Name> <p.Type> OUTPUT}; separator = "\n"> 
        AS
        IF @Usage.PayingAccountID IS NULL
          BEGIN
            SET @_ErrorCode = 0xE1200013
            SET @_ErrorString = N'Usage.PayingAccountID must not be NULL'
            SET @_Plugin = N'<compositeInstanceName>'
            SET @_Module = N'write_product_view'
          END
        ELSE IF @Usage.AccountID IS NULL
          BEGIN
            SET @_ErrorCode = 0xE1200013
            SET @_ErrorString = N'Usage.AccountID must not be NULL'
            SET @_Plugin = N'<compositeInstanceName>'
            SET @_Module = N'write_product_view'
          END
        ELSE IF @Usage.IntervalID IS NULL
          BEGIN
            SET @_ErrorCode = 0xE1200013
            SET @_ErrorString = N'Usage.IntervalID must not be NULL'
            SET @_Plugin = N'<compositeInstanceName>'
            SET @_Module = N'write_product_view'
          END
        ELSE IF @Usage.Amount IS NULL
          BEGIN
            SET @_ErrorCode = 0xE1200013
            SET @_ErrorString = N'Usage.Amount must not be NULL'
            SET @_Plugin = N'<compositeInstanceName>'
            SET @_Module = N'write_product_view'
          END
        ELSE IF @Usage.Currency IS NULL
          BEGIN
            SET @_ErrorCode = 0xE1200013
            SET @_ErrorString = N'Usage.Currency must not be NULL'
            SET @_Plugin = N'<compositeInstanceName>'
            SET @_Module = N'write_product_view'
          END
        ELSE IF len(@Usage.Currency) > 3
          BEGIN
            SET @_ErrorCode = 0xE1200013
            SET @_ErrorString = N'Usage.Currency must be 3 characters or less: '
                                + @Usage.Currency
            SET @_Plugin = N'<compositeInstanceName>'
            SET @_Module = N'write_product_view'
          END
        ELSE IF @Usage.Timestamp IS NULL
          BEGIN
            SET @_ErrorCode = 0xE1200013
            SET @_ErrorString = N'Usage.Timestamp must not be NULL'
            SET @_Plugin = N'<compositeInstanceName>'
            SET @_Module = N'write_product_view'
          END
      "];

  /*
  -- The following code is commented out because
  -- project[] doesn't support column="Usage"
  -- (giving the name of the subrecord.)
  -- Project restricts the fields that are in the dataflow
    WriteProductView_project:project[
      column="Usage"
      ,column="_ErrorCode"
      ,column="_ErrorString"
      ,column="_Plugin"
      ,column="_Module"
      <Properties:{p | ,column="<p.Name>"}; separator = "\n">
      ];
      WriteProductView_allfields -> WriteProductView_project;
  */

  -- Set default values for fields.
  checkDefaults: expr[
        program="CREATE PROCEDURE writeProductViewCheckDefaults 
                <Properties:{p | @<p.Name> <p.Type> OUTPUT}; separator = "\n"> 
                AS
                <Properties:{p | <setDefaultValue(p)>}>"]; 

  /* WriteProductView_project -> checkDefaults; */

  WriteProductView_allfields -> checkDefaults;

  -- Verify the input fields
  checkConstraints:expr[program="CREATE PROCEDURE writeProductViewCheckConstraints
                      <Properties:{p | @<p.Name> <p.Type>}; separator = "\n">
                      @_ErrorCode INTEGER
                      @_ErrorString NVARCHAR
                      @_Plugin NVARCHAR
                      @_Module NVARCHAR
                      AS
                      <Properties:{p | <checkLengthConstraint(p)>}>"];

  checkDefaults -> checkConstraints;

  -- The switch statement branches the dataflow.
  -- If there is no error, then after this operator executes the 
  -- flow will continue to errorSwitch(0).
  -- But if there is an error, the flow will go to errorSwitch(1)
  -- which is an output port of the operator.

  errorSwitch: switch[
        program="CREATE FUNCTION f (@_ErrorCode INTEGER) RETURNS INTEGER
                 AS
                 RETURN CASE WHEN @_ErrorCode IS NULL OR @_ErrorCode = 0 THEN 0 
                 ELSE 1 END"];

  checkConstraints -> errorSwitch;

  -- Range partition and sort on the _PayingAccountID before assigning id_sess.
  -- Default behavior here is to partition evenly on the entire 32-bit integer
  -- key range.  This will work well for new customers but rather poorly for
  -- upgrades.  Perhaps better would be to do a sample from paying accounts in
  -- the database and generate range that way.

  WriteProductView_sort_acc_ui_view_part: rangepart[key="Usage.PayingAccountID"];


  -- This is the flowpath if there was NOT an error
  errorSwitch(0) -> WriteProductView_sort_acc_ui_view_part(0);

  -- This code is generating a uniform partitioning of positive 
  -- signed int32 values and then sending partition values to 
  -- every instance of range partitioner.

  WriteProductView_generate_uniform_histogram: generate[
        program= "CREATE PROCEDURE p @value INTEGER 
                  AS SET @value = @@PARTITION*(2147483647/@@PARTITIONCOUNT)",
        numRecords=1];

  -- We send this value we came up with to help us partition to
  -- all the partitions.
  WriteProductView_generate_uniform_histogram_part: broadcast[];

  -- The dataflow for generating the value and sending it out to everyone.
  WriteProductView_generate_uniform_histogram -> WriteProductView_generate_uniform_histogram_part;

  -- We collect the partitioning helper value sent to us.
  WriteProductView_generate_uniform_histogram_coll:coll[];

  WriteProductView_generate_uniform_histogram_part -> WriteProductView_generate_uniform_histogram_coll;

  -- Remove all records where the partitioning helper value is 0.
  -- I don't understand that (Allan).
  WriteProductView_generate_uniform_histogram_filter: filter[
        program="CREATE FUNCTION f (@value INTEGER) RETURNS BOOLEAN
                 AS RETURN @value \<> 0"];

  WriteProductView_generate_uniform_histogram_coll -> WriteProductView_generate_uniform_histogram_filter;

  -- Finally we have the partitioning helper value.  
  -- We feed that into our range partitioner.
  -- This is partitioning based on ranges of PayerAccount
  WriteProductView_generate_uniform_histogram_filter -> WriteProductView_sort_acc_ui_view_part(1); 

  -- We need to collect the redistributed data based on this partitioning.
  WriteProductView_sort_acc_ui_view_coll: coll[];

  WriteProductView_sort_acc_ui_view_part -> WriteProductView_sort_acc_ui_view_coll;

  -- We now know we have all the data for a particular PayerAccount.
  -- We sort by the billing interval and sub-sort on accountID.
  WriteProductView_sort_acc_ui_view: sort[key="Usage.IntervalID", 
                                          key="Usage.AccountID", 
                                          allowedMemory=50000000];

  WriteProductView_sort_acc_ui_view_coll -> WriteProductView_sort_acc_ui_view;

  -- We generate a unique session ID
  WriteProductView_idgen: id_generator[id="id_sess", 
                                       sequence="id_sess", 
                                       blockSize=1000];

  WriteProductView_sort_acc_ui_view -> WriteProductView_idgen;

<if(isMultipointParent)>
  -- We are writing a parent record
  -- The value to use for id_sess should be in parentID

  WriteProductView_setprops:generate[
        program="CREATE PROCEDURE p @id_sess        BIGINT 
                                    @parentID       BIGINT
                                    @id_parent_sess BIGINT OUTPUT 
                                    @id_commit_unit INTEGER OUTPUT 
                                    @id_svc         INTEGER OUTPUT 
                                    @id_view        INTEGER OUTPUT 
                                    @dt_crt         DATETIME OUTPUT 
                                    @Usage.SubscriptionEntity INTEGER OUTPUT 
                                    @Usage.AccountID INTEGER
                AS
                SET @id_sess = @parentID
                SET @id_parent_sess = NULL
                SET @id_commit_unit = CAST(@@RECORDCOUNT / 50000LL AS INTEGER)
                SET @id_svc = CAST(#<productViewName># AS INTEGER)
                SET @id_view = CAST(#<productViewName># AS INTEGER)
                SET @dt_crt = getutcdate()
                IF @Usage.SubscriptionEntity IS NULL
                        SET @Usage.SubscriptionEntity = @Usage.AccountID"];
<else>
<if(isMultipointChild)>
  -- We are writing a child record.
  -- The value to use for id_parent_sess should be in parentID

  WriteProductView_setprops:generate[
        program="CREATE PROCEDURE p @id_sess        BIGINT 
                                    @parentID       BIGINT
                                    @id_parent_sess BIGINT OUTPUT 
                                    @id_commit_unit INTEGER OUTPUT 
                                    @id_svc         INTEGER OUTPUT 
                                    @id_view        INTEGER OUTPUT 
                                    @dt_crt         DATETIME OUTPUT 
                                    @Usage.SubscriptionEntity INTEGER OUTPUT 
                                    @Usage.AccountID INTEGER
                AS
                SET @id_sess = CAST(@@PARTITION AS BIGINT)*18014398509481983LL 
                               + @id_sess
                SET @id_parent_sess = @parentID
                SET @id_commit_unit = CAST(@@RECORDCOUNT / 50000LL AS INTEGER)
                SET @id_svc = CAST(#<productViewName># AS INTEGER)
                SET @id_view = CAST(#<productViewName># AS INTEGER)
                SET @dt_crt = getutcdate()
                IF @Usage.SubscriptionEntity IS NULL
                        SET @Usage.SubscriptionEntity = @Usage.AccountID"];
<else>
  -- We are writing a singlepoint record
  WriteProductView_setprops:generate[
        program="CREATE PROCEDURE p @id_sess        BIGINT 
                                    @id_parent_sess BIGINT OUTPUT 
                                    @id_commit_unit INTEGER OUTPUT 
                                    @id_svc         INTEGER OUTPUT 
                                    @id_view        INTEGER OUTPUT 
                                    @dt_crt         DATETIME OUTPUT 
                                    @Usage.SubscriptionEntity INTEGER OUTPUT 
                                    @Usage.AccountID INTEGER
                AS
                SET @id_sess = CAST(@@PARTITION AS BIGINT)*18014398509481983LL 
                               + @id_sess
                SET @id_parent_sess = NULL
                SET @id_commit_unit = CAST(@@RECORDCOUNT / 50000LL AS INTEGER)
                SET @id_svc = CAST(#<productViewName># AS INTEGER)
                SET @id_view = CAST(#<productViewName># AS INTEGER)
                SET @dt_crt = getutcdate()
                IF @Usage.SubscriptionEntity IS NULL
                        SET @Usage.SubscriptionEntity = @Usage.AccountID"];
<endif>
<endif>

junkPrint: print[numToPrint=10, label="Pre SetProps"];

  WriteProductView_idgen -> junkPrint -> WriteProductView_setprops;

  -- Now we will rename columns in preparation for
  -- inserting into the database.

  liftUsageProperties: rename[from="Usage.*", to="_"];

  renameProperties:rename[from="_PayingAccountID", to="id_acc",
                          from="_Timestamp", to="dt_session",
                          from="_PriceableItemInstanceID", to="id_pi_instance",
                          from="_PriceableItemTemplateID", to="id_pi_template",
                          from="_ProductOfferingID", to="id_prod",
                          from="_AccountID", to="id_payee",
                          from="_SessionID", to="tx_UID",
                          from="_Amount", to="amount",
                          from="_FedTax", to="tax_federal",
                          from="_StateTax", to="tax_state",
                          from="_CountyTax", to="tax_county",
                          from="_LocalTax", to="tax_local",
                          from="_OtherTax", to="tax_other",
                          from="_IntervalID", to="id_usage_interval",
                          from="_Currency", to="am_currency",
                          from="_SubscriptionEntity", to="id_se",
                          from="_CollectionID", to="tx_batch"
      <Properties:{p | ,from="<p.Name>", to="c_<p.Name>"}; separator = "\n">
                           ];

  WriteProductView_setprops -> liftUsageProperties;

  liftUsageProperties -> renameProperties;

  -- Write the records to the database
  -- We are going to need a copy of everything
  -- One copy is connected to the output of this operator.

  copyAll: copy[];

  renameProperties -> copyAll;

  -- Right now the inserter only writes to NetMeterStage so we have
  -- to execute some SQL from MetraFlow to move the data into the NetMeter
  -- database.  This is actually a bit subtle because we have to mimic control
  -- flow (e.g. write to NetMeterStage and when you are done, execute the SQL)
  -- using dataflow.  This is done using a control flow token which is the
  -- id_commit_unit column we create.
  -- Essentially this token identifies a transactional
  -- unit of work that we want the sql_exec_direct operator use.  Note that this
  -- is exactly what the meter operator is doing under the wraps.
  --
  -- Bucket all of the data into a single unit of work
  -- which is identified by the integer 1

  -- Note: the commit unit should not be 0.
  -- It should really be a modulus operators so we're doing more than one
  -- record
  createCommitUnit: generate[program=
                      "CREATE PROCEDURE p @id_commit_unit INTEGER
                      AS
                      SET @id_commit_unit = CAST(@@RECORDCOUNT /6 AS INTEGER)"];

  copyAll(1) -> createCommitUnit;

  -- Copy because we need the data to insert and
  -- we need to create the control token/record. 

  copyAllPlusCommitUnit: copy[]

  createCommitUnit -> copyAllPlusCommitUnit;

  -- Now we are going to gather all the records that have
  -- the same commit unit into a single record.  
  -- We also count the size of the gather records.
  -- This record becomes a control record for the final commiting of the
  -- data (by copying the table).  There is another path
  -- that will contain the data to write.

  gatherCommitUnit: sort_group_by[key="id_commit_unit",
                               initialize="CREATE PROCEDURE i @size_0 INTEGER
                                           AS
                                           SET @size_0 = 0",
                               update="CREATE PROCEDURE u @size_0 INTEGER
                                       AS
                                       SET @size_0 = @size_0 + 1"];

  copyAllPlusCommitUnit(0) -> gatherCommitUnit;

  -- We're going to use two copies of this gatheredCommitUnit.
  -- One for committing t_acc_usage, the other for committing
  -- the product view table.
  copyOfGatherCommitUnit: copy[];
  
  gatherCommitUnit -> copyOfGatherCommitUnit;

  -- Now we turn our attention to the other path (the one
  -- containing the data to write).  We need to restrict the 
  -- columns to just the ones we want to insert into t_acc_usage.

  projectForAccUsage: project[
    column = "id_sess",
    column = "tx_UID",
    column = "id_acc",
    column = "id_payee",
    column = "id_view",
    column = "id_usage_interval",
    column = "id_parent_sess",
    column = "id_prod",
    column = "id_svc",
    column = "dt_session",
    column = "amount",
    column = "am_currency",
    column = "dt_crt",
    column = "tx_batch",
    column = "tax_federal",
    column = "tax_state",
    column = "tax_county",
    column = "tax_local",
    column = "tax_other",
    column = "id_pi_instance",
    column = "id_pi_template",
    column = "id_se",
    column = "id_commit_unit"];
		
  copyAllPlusCommitUnit(1) -> projectForAccUsage;

  -- Now we insert.
  -- Unfortunately, the insert operator only inserts in to the 
  -- staging database.  So we are going to have to first creat
  -- the table there and then copy it into NetMeter.
  -- We'll do that with a sql_exec_direct operator.
  --
  -- Note that we don't support createTable=true with this model.
  -- So the table in the staging database and in the NetMeter database must
  -- be created ahead of time.  Which is not a problem since these tables
  -- have already been created.
  --
  -- Note that the insert will not actually put any data
  -- in the staging database table you create though
  -- (it will use some additional temporary
  -- tables that are dynamically created
  -- from it).

  insertIntoAccUsage: insert[table="t_acc_usage",
                            schema="NetMeter", 
			    transactionKey="id_commit_unit",
                            batchSize=7, 
			    createTable=false];

  printAccUsage: print[];

  projectForAccUsage -> printAccUsage -> insertIntoAccUsage;

  -- Copy from the staging area to NetMeter.
  -- As previously mentioned, the actual data will be placed into temporary
  -- tables that are created dynamically,
  -- the insert will pass that name to this operator
  -- which will INSERT INTO SELECT FROM and delete the dynamic table.
  -- Note: this is for SQL Server only.

  commitAccUsage:sql_exec_direct[
    statementList=[
      query=
      "INSERT INTO NetMeter..t_acc_usage SELECT * FROM %%%NETMETERSTAGE_PREFIX%%%%1%",
      postprocess= "DROP TABLE %%%NETMETERSTAGE_PREFIX%%%%1%"]
    ];

  -- Notice how the "control" path restricts writing to the database
  -- until all the records in the commit unit have been gathered.

  copyOfGatherCommitUnit(0) -> commitAccUsage("control");
  insertIntoAccUsage  -> commitAccUsage("input(0)");

  -- We've written t_acc_usage, now we will write the product view.

  projectForProductView: project[
    column = "id_sess",
    column = "id_usage_interval",
    column = "id_commit_unit"
    <Properties:{p | ,column="c_<p.Name>"}; separator = "\n">
    ];
		
  copyAllPlusCommitUnit(2) -> projectForProductView;

  printProductView: print[];
  projectForProductView -> printProductView;

  insertIntoProductView: insert[table="<productViewTable>",
                            schema="NetMeter", 
			    transactionKey="id_commit_unit",
                            batchSize=7, 
			    createTable=false];

  printProductView -> insertIntoProductView;

  commitProductView:sql_exec_direct[
    statementList=[
      query=
      "INSERT INTO NetMeter..<productViewTable> SELECT * FROM %%%NETMETERSTAGE_PREFIX%%%%1%",
      postprocess= "DROP TABLE %%%NETMETERSTAGE_PREFIX%%%%1%"]
    ];

   insertIntoProductView -> commitProductView("input(0)");
   copyOfGatherCommitUnit(1) -> commitProductView("control");

)
>>
