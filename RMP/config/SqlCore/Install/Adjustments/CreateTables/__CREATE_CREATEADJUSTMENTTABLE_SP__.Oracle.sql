CREATE OR REPLACE PROCEDURE CREATEADJUSTMENTTABLE(
  p_id_pi_type         integer,
  p_status       out   integer,
  p_err_msg      out   varchar2,
  p_replace            boolean := false   /* drop and create flag */
)
as
  
  /* var decls */
  ntabs    int;
  ncols    int;
  ddl      varchar2(32767);
  colsep   varchar2(5)    := ',' || chr(10) || '   ';
  descriptions     nvarchar2(32767);
  descriptions_array dbms_sql.varchar2_table;
begin
  p_status := 0;

  for x in
  ( select pi1.nm_productview as pv, 
           bp.nm_name as piname,
           bpnew.nm_name as newpiname,  
           pi2.id_pi id_pi, 
           pi1.id_pi new_pi
    from t_pi pi1 
           inner join t_pi pi2 on pi1.nm_productview = pi2.nm_productview
           inner join t_base_props bp on bp.id_prop = pi2.id_pi
           inner join t_base_props bpnew on bpnew.id_prop = pi1.id_pi
    where pi1.id_pi = p_id_pi_type and pi2.id_pi <> pi1.id_pi
  ) 
  loop
      -- Looping through each PV that is associated with two PIs (known as x.new_pi and x.id_pi)

      -- p_status will be set to 0 if the two PIs with the same PV have the same set of charges,
      -- greater than 0 if they have different charges.
      select count(*) into p_status
      from (

          -- Fast way to compare two tables, from
          -- http://weblogs.sqlteam.com/jeffs/archive/2004/11/10/2737.aspx
          -- Look for rows that are in one table, but not the other.
          select min(TableName) as TableName, colname, coltype
          from
          (

              select 'Table A' as TableName, a.colname, a.coltype
              from
              (
                  -- Select name and type of PV properties for charges associated with x.new_pi 
                  select prop.nm_column_name as colname, 
                         prop.nm_data_type as coltype
                  from t_charge join t_prod_view_prop prop 
                  on prop.id_prod_view_prop = t_charge.id_amt_prop
                  where id_pi = x.new_pi
              ) a

              UNION ALL

              select 'Table B' as TableName, b.colname, b.coltype
              from
              (
                  -- Select name and type of PV properties for charges associated with x.id_pi 
                  select prop.nm_column_name as colname, 
                         prop.nm_data_type as coltype
                  from t_charge join t_prod_view_prop prop 
                  on prop.id_prod_view_prop = t_charge.id_amt_prop
                  where id_pi = x.id_pi
              ) b
      
          ) y
          group by colname, coltype
          having count(*) = 1

      ) z;

      if p_status <> 0 
      then 
        p_err_msg :=
          'Product View [' || x.pv || '] is shared between [' || x.newpiname
          || '] and [' || x.piname || ']' || '. If ['  || x.newpiname 
          || '] is adjustable, make sure that charges in these priceable' 
          || ' item types are the same.';
      end if;
      
  end loop;

  /* all of the product views referenced by priceable items */
  /* BP changed next join on t_charge to 'left outer' from 'inner'
     in order to support Amount adjustments for PIs that don't
     have any charges */
  ntabs := 0;

  for tab in (select distinct pv.nm_table_name as pvname,
                              't_aj_'
                              || substr(pv.nm_table_name, 6) as adjname,
                              t_pi.id_pi as idpi
                         from t_pi inner join t_prod_view pv on upper(pv.nm_name) =
                                                                 upper(t_pi.nm_productview)
                              left outer join t_charge on t_charge.id_pi =
                                                                    t_pi.id_pi
                        where t_pi.id_pi = p_id_pi_type) loop
    ntabs := ntabs + 1;
    /* start create stable dll stmt */
    ddl := 'create table ' || tab.adjname || '(' || chr(10)
           || '   id_adjustment number(10)';
    /* get columns for table */
    ncols := 0;
                descriptions := ' begin ';
                descriptions := descriptions || ' execute immediate ''COMMENT ON TABLE ' || tab.adjname || ' IS ''''Autogenerated adjustment table. Contains adjustments for charges in product view table "' || tab.pvname || '"'''' ''; ';
                descriptions := descriptions || 'end; ';
  descriptions_array(ncols) := descriptions;
    for col in (select prop.nm_column_name as colname,
                       prop.nm_data_type as coltype
                  from t_charge join t_prod_view_prop prop on prop.id_prod_view_prop =
                                                               t_charge.id_amt_prop
                 where id_pi = tab.idpi) loop
      ncols := ncols + 1;

      /* all columns are expected to have type numeric(22,10). all
      other type are disallowed */
      if replace(col.coltype, ' ') <> 'numeric(22,10)' and replace(col.coltype, ' ') <> 'decimal' then
        p_status := 1;
        p_err_msg := 'Column type of ' || tab.pvname || '.' || col.colname
                     || ' must be numeric(22,10)' || ', not ' || col.coltype;
        return;
      end if;

      /* add column to ddl statement; transform c_ prefix to c_aj_ */
      ddl := ddl || colsep || 'c_aj_' || substr(col.colname, 3)
             || ' number(22,10)';
                                                                                                
                descriptions := 'declare columComment varchar2(256); BEGIN ';
                  descriptions := descriptions || ' BEGIN select comments into columComment from user_col_comments where table_name like '''
                  || tab.pvname || ''' and column_name like ''' || col.colname || ''';'
                || '  EXCEPTION WHEN NO_DATA_FOUND THEN columComment := NULL; END; if(columComment != NULL) then execute immediate ''COMMENT ON COLUMN ' || tab.adjname || '.c_aj_' || substr(col.colname, 3) || 'IS columComment''; end if;';
  descriptions := descriptions || ' end;';
  descriptions_array(ncols) := descriptions;

    end loop;   /* over columns */

    /* close ddl stmt and create this table */
    ddl := ddl || ')';

    if p_replace and table_exists(tab.adjname) then
      exec_ddl2('drop table ' || tab.adjname, p_status, p_err_msg);

      dbms_output.put_line('dropping: ' || tab.adjname);
    end if;

    if not table_exists(tab.adjname) then
      exec_ddl2(ddl, p_status, p_err_msg);
      if (p_status = 0) then
        for i in descriptions_array.FIRST .. descriptions_array.LAST loop
        exec_ddl2(descriptions_array(i), p_status, p_err_msg);
        if (p_status <> 0) then
          return;
        end if;
        end loop;
                  end if; 
      dbms_output.put_line('creating: ' || tab.adjname);
    end if;
  end loop;   /* over tables */
end createadjustmenttable;


