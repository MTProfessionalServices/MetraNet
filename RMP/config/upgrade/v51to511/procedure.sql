/****** Object:  StoredProcedure [dbo].[InsertChargeProperty]    Script Date: 06/02/2008 11:43:50 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertChargeProperty]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[InsertChargeProperty]
GO
/****** Object:  StoredProcedure [dbo].[mtsp_BackoutInvoices]    Script Date: 06/02/2008 11:44:01 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mtsp_BackoutInvoices]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[mtsp_BackoutInvoices]
GO
/****** Object:  StoredProcedure [dbo].[CompleteReMaterialization]    Script Date: 06/02/2008 11:43:21 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CompleteReMaterialization]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CompleteReMaterialization]
GO
/****** Object:  StoredProcedure [dbo].[UpdateBatchStatus]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateBatchStatus]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdateBatchStatus]
GO
/****** Object:  StoredProcedure [dbo].[StartUserDefinedGroupCreation]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[StartUserDefinedGroupCreation]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[StartUserDefinedGroupCreation]
GO
/****** Object:  StoredProcedure [dbo].[sp_InsertCompositeCapType]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_InsertCompositeCapType]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sp_InsertCompositeCapType]
GO
/****** Object:  StoredProcedure [dbo].[ModifyBatchStatus]    Script Date: 06/02/2008 11:44:00 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ModifyBatchStatus]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ModifyBatchStatus]
GO
/****** Object:  StoredProcedure [dbo].[sp_InsertAtomicCapType]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_InsertAtomicCapType]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sp_InsertAtomicCapType]
GO
/****** Object:  StoredProcedure [dbo].[sp_InsertBaseProps]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_InsertBaseProps]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sp_InsertBaseProps]
GO
/****** Object:  StoredProcedure [dbo].[MTSP_RATE_AGGREGATE_CHARGE]    Script Date: 06/02/2008 11:44:04 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTSP_RATE_AGGREGATE_CHARGE]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[MTSP_RATE_AGGREGATE_CHARGE]
GO
/****** Object:  StoredProcedure [dbo].[OpenBillingGroup]    Script Date: 06/02/2008 11:44:04 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[OpenBillingGroup]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[OpenBillingGroup]
GO
/****** Object:  StoredProcedure [dbo].[DeleteAccounts]    Script Date: 06/02/2008 11:43:35 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteAccounts]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DeleteAccounts]
GO
/****** Object:  StoredProcedure [dbo].[HardCloseBillingGroup]    Script Date: 06/02/2008 11:43:47 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[HardCloseBillingGroup]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[HardCloseBillingGroup]
GO
/****** Object:  StoredProcedure [dbo].[sp_InsertCapabilityInstance]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_InsertCapabilityInstance]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sp_InsertCapabilityInstance]
GO
/****** Object:  StoredProcedure [dbo].[SelectAccountsToBeDeleted]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SelectAccountsToBeDeleted]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SelectAccountsToBeDeleted]
GO
/****** Object:  StoredProcedure [dbo].[UpdateUnassignedAccounts]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateUnassignedAccounts]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdateUnassignedAccounts]
GO
/****** Object:  StoredProcedure [dbo].[sp_InsertRole]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_InsertRole]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sp_InsertRole]
GO
/****** Object:  StoredProcedure [dbo].[UpdIntervalBlockedForNewAccts]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdIntervalBlockedForNewAccts]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdIntervalBlockedForNewAccts]
GO
/****** Object:  StoredProcedure [dbo].[CloneSecurityPolicy]    Script Date: 06/02/2008 11:43:20 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CloneSecurityPolicy]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CloneSecurityPolicy]
GO
/****** Object:  StoredProcedure [dbo].[InsertAcctUsageWithUID]    Script Date: 06/02/2008 11:43:49 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertAcctUsageWithUID]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[InsertAcctUsageWithUID]
GO
/****** Object:  StoredProcedure [dbo].[UpdIntervalStatusToHardClosed]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdIntervalStatusToHardClosed]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdIntervalStatusToHardClosed]
GO
/****** Object:  StoredProcedure [dbo].[GrantAllCapabilityToAccount]    Script Date: 06/02/2008 11:43:47 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GrantAllCapabilityToAccount]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GrantAllCapabilityToAccount]
GO
/****** Object:  UserDefinedFunction [dbo].[IsActive]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsActive]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[IsActive]
GO
/****** Object:  StoredProcedure [dbo].[CreateAndPopulateTempAccts]    Script Date: 06/02/2008 11:43:23 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateAndPopulateTempAccts]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateAndPopulateTempAccts]
GO
/****** Object:  StoredProcedure [dbo].[AddMemberToRole]    Script Date: 06/02/2008 11:43:02 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddMemberToRole]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AddMemberToRole]
GO
/****** Object:  UserDefinedFunction [dbo].[IsSuspended]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsSuspended]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[IsSuspended]
GO
/****** Object:  StoredProcedure [dbo].[UpdExpiredIntervalsToBlocked]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdExpiredIntervalsToBlocked]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdExpiredIntervalsToBlocked]
GO
/****** Object:  StoredProcedure [dbo].[RemoveMemberFromRole]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[RemoveMemberFromRole]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[RemoveMemberFromRole]
GO
/****** Object:  UserDefinedFunction [dbo].[IsPendingFinalBill]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsPendingFinalBill]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[IsPendingFinalBill]
GO
/****** Object:  StoredProcedure [dbo].[HardCloseExpiredIntervals_npa]    Script Date: 06/02/2008 11:43:47 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[HardCloseExpiredIntervals_npa]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[HardCloseExpiredIntervals_npa]
GO
/****** Object:  StoredProcedure [dbo].[SatisfyConstraintsForPullList]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SatisfyConstraintsForPullList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SatisfyConstraintsForPullList]
GO
/****** Object:  StoredProcedure [dbo].[ReversePayments]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReversePayments]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReversePayments]
GO
/****** Object:  UserDefinedFunction [dbo].[mtconcat]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mtconcat]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[mtconcat]
GO
/****** Object:  StoredProcedure [dbo].[DeleteBillGroupData]    Script Date: 06/02/2008 11:43:35 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteBillGroupData]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DeleteBillGroupData]
GO
/****** Object:  StoredProcedure [dbo].[ApprovePayments]    Script Date: 06/02/2008 11:43:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ApprovePayments]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ApprovePayments]
GO
/****** Object:  UserDefinedFunction [dbo].[MTHexFormat]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTHexFormat]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[MTHexFormat]
GO
/****** Object:  StoredProcedure [dbo].[CreatePopTmpBillGroupStatus]    Script Date: 06/02/2008 11:43:30 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreatePopTmpBillGroupStatus]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreatePopTmpBillGroupStatus]
GO
/****** Object:  StoredProcedure [dbo].[CompleteBillGroupConstraints]    Script Date: 06/02/2008 11:43:20 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CompleteBillGroupConstraints]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CompleteBillGroupConstraints]
GO
/****** Object:  UserDefinedFunction [dbo].[IsInVisableState]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsInVisableState]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[IsInVisableState]
GO
/****** Object:  StoredProcedure [dbo].[ResetBillingGroupConstraints]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ResetBillingGroupConstraints]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ResetBillingGroupConstraints]
GO
/****** Object:  StoredProcedure [dbo].[GetRecurringEventDepsByInst]    Script Date: 06/02/2008 11:43:46 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetRecurringEventDepsByInst]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetRecurringEventDepsByInst]
GO
/****** Object:  StoredProcedure [dbo].[DelSuccessfullyResubmittedFT]    Script Date: 06/02/2008 11:43:38 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DelSuccessfullyResubmittedFT]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DelSuccessfullyResubmittedFT]
GO
/****** Object:  StoredProcedure [dbo].[MT_sys_analyze_all_tables]    Script Date: 06/02/2008 11:44:01 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MT_sys_analyze_all_tables]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[MT_sys_analyze_all_tables]
GO
/****** Object:  StoredProcedure [dbo].[CanExecuteEventDeps]    Script Date: 06/02/2008 11:43:15 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CanExecuteEventDeps]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CanExecuteEventDeps]
GO
/****** Object:  StoredProcedure [dbo].[CanReverseEventDeps]    Script Date: 06/02/2008 11:43:16 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CanReverseEventDeps]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CanReverseEventDeps]
GO
/****** Object:  StoredProcedure [dbo].[MTSP_INSERTINVOICE]    Script Date: 06/02/2008 11:44:02 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTSP_INSERTINVOICE]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[MTSP_INSERTINVOICE]
GO
/****** Object:  StoredProcedure [dbo].[CompleteChildGroupCreation]    Script Date: 06/02/2008 11:43:20 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CompleteChildGroupCreation]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CompleteChildGroupCreation]
GO
/****** Object:  StoredProcedure [dbo].[InsertProductView]    Script Date: 06/02/2008 11:43:54 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertProductView]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[InsertProductView]
GO
/****** Object:  StoredProcedure [dbo].[AddCounterType]    Script Date: 06/02/2008 11:43:01 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddCounterType]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AddCounterType]
GO
/****** Object:  StoredProcedure [dbo].[InsertProductViewUniqueKey]    Script Date: 06/02/2008 11:43:56 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertProductViewUniqueKey]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[InsertProductViewUniqueKey]
GO
/****** Object:  StoredProcedure [dbo].[AddCounterParamPredicate]    Script Date: 06/02/2008 11:43:00 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddCounterParamPredicate]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AddCounterParamPredicate]
GO
/****** Object:  StoredProcedure [dbo].[InsertIntoEventTable]    Script Date: 06/02/2008 11:43:52 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertIntoEventTable]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[InsertIntoEventTable]
GO
/****** Object:  UserDefinedFunction [dbo].[WarnOnEBCRMemberStartDateChang]    Script Date: 06/02/2008 11:44:11 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[WarnOnEBCRMemberStartDateChang]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[WarnOnEBCRMemberStartDateChang]
GO
/****** Object:  StoredProcedure [dbo].[UpdateCounterInstance]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateCounterInstance]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdateCounterInstance]
GO
/****** Object:  StoredProcedure [dbo].[InsertIntoCatalogTable]    Script Date: 06/02/2008 11:43:52 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertIntoCatalogTable]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[InsertIntoCatalogTable]
GO
/****** Object:  UserDefinedFunction [dbo].[WarnOnEBCRStartDateChange]    Script Date: 06/02/2008 11:44:11 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[WarnOnEBCRStartDateChange]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[WarnOnEBCRStartDateChange]
GO
/****** Object:  StoredProcedure [dbo].[DeleteCounterParamInstances]    Script Date: 06/02/2008 11:43:35 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteCounterParamInstances]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DeleteCounterParamInstances]
GO
/****** Object:  StoredProcedure [dbo].[InsertProductViewProperty]    Script Date: 06/02/2008 11:43:55 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertProductViewProperty]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[InsertProductViewProperty]
GO
/****** Object:  StoredProcedure [dbo].[GenerateAdjustmentTables]    Script Date: 06/02/2008 11:43:41 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GenerateAdjustmentTables]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GenerateAdjustmentTables]
GO
/****** Object:  StoredProcedure [dbo].[DeleteCounterParamTypes]    Script Date: 06/02/2008 11:43:36 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteCounterParamTypes]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DeleteCounterParamTypes]
GO
/****** Object:  StoredProcedure [dbo].[AddUniqueKeyMetadata]    Script Date: 06/02/2008 11:43:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddUniqueKeyMetadata]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AddUniqueKeyMetadata]
GO
/****** Object:  StoredProcedure [dbo].[AddCounterInstance]    Script Date: 06/02/2008 11:42:59 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddCounterInstance]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AddCounterInstance]
GO
/****** Object:  StoredProcedure [dbo].[DeleteUniqueKeyMetadata]    Script Date: 06/02/2008 11:43:37 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteUniqueKeyMetadata]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DeleteUniqueKeyMetadata]
GO
/****** Object:  StoredProcedure [dbo].[AddCounterParamType]    Script Date: 06/02/2008 11:43:01 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddCounterParamType]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AddCounterParamType]
GO
/****** Object:  StoredProcedure [dbo].[GetUniqueKeyMetadata]    Script Date: 06/02/2008 11:43:47 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetUniqueKeyMetadata]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetUniqueKeyMetadata]
GO
/****** Object:  StoredProcedure [dbo].[RemoveCounterInstance]    Script Date: 06/02/2008 11:44:06 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[RemoveCounterInstance]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[RemoveCounterInstance]
GO
/****** Object:  StoredProcedure [dbo].[GetMaterializedViewQueryTags]    Script Date: 06/02/2008 11:43:45 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetMaterializedViewQueryTags]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetMaterializedViewQueryTags]
GO
/****** Object:  StoredProcedure [dbo].[CreateAdjustmentTable]    Script Date: 06/02/2008 11:43:23 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateAdjustmentTable]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateAdjustmentTable]
GO
/****** Object:  StoredProcedure [dbo].[UpsertListener]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpsertListener]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpsertListener]
GO
/****** Object:  StoredProcedure [dbo].[CreateCalculationFormula]    Script Date: 06/02/2008 11:43:24 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateCalculationFormula]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateCalculationFormula]
GO
/****** Object:  StoredProcedure [dbo].[DelPVRecordsForAcct]    Script Date: 06/02/2008 11:43:38 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DelPVRecordsForAcct]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DelPVRecordsForAcct]
GO
/****** Object:  StoredProcedure [dbo].[GetBalances]    Script Date: 06/02/2008 11:43:42 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetBalances]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetBalances]
GO
/****** Object:  UserDefinedFunction [dbo].[MessageQueueLength]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MessageQueueLength]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[MessageQueueLength]
GO
/****** Object:  StoredProcedure [dbo].[CreateCompositeAdjustmentType]    Script Date: 06/02/2008 11:43:25 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateCompositeAdjustmentType]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateCompositeAdjustmentType]
GO
/****** Object:  StoredProcedure [dbo].[PIResolutionByID]    Script Date: 06/02/2008 11:44:05 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[PIResolutionByID]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[PIResolutionByID]
GO
/****** Object:  StoredProcedure [dbo].[CreateCompositeAdjDetails]    Script Date: 06/02/2008 11:43:25 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateCompositeAdjDetails]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateCompositeAdjDetails]
GO
/****** Object:  StoredProcedure [dbo].[PIResolutionByName]    Script Date: 06/02/2008 11:44:05 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[PIResolutionByName]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[PIResolutionByName]
GO
/****** Object:  StoredProcedure [dbo].[archive_queue]    Script Date: 06/02/2008 11:43:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[archive_queue]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[archive_queue]
GO
/****** Object:  StoredProcedure [dbo].[RemoveCompositeAdjDetails]    Script Date: 06/02/2008 11:44:06 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[RemoveCompositeAdjDetails]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[RemoveCompositeAdjDetails]
GO
/****** Object:  StoredProcedure [dbo].[ExecSpProcOnKind]    Script Date: 06/02/2008 11:43:40 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ExecSpProcOnKind]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ExecSpProcOnKind]
GO
/****** Object:  StoredProcedure [dbo].[CreateReportingDB]    Script Date: 06/02/2008 11:43:31 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateReportingDB]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateReportingDB]
GO
/****** Object:  StoredProcedure [dbo].[Analyze]    Script Date: 06/02/2008 11:43:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Analyze]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[Analyze]
GO
/****** Object:  StoredProcedure [dbo].[GetNonBillAccountsWithBalance]    Script Date: 06/02/2008 11:43:45 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetNonBillAccountsWithBalance]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetNonBillAccountsWithBalance]
GO
/****** Object:  StoredProcedure [dbo].[Backout]    Script Date: 06/02/2008 11:43:11 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Backout]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[Backout]
GO
/****** Object:  View [dbo].[VW_ADJUSTMENT_SUMMARY]    Script Date: 06/02/2008 11:44:16 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[VW_ADJUSTMENT_SUMMARY]'))
DROP VIEW [dbo].[VW_ADJUSTMENT_SUMMARY]
GO
/****** Object:  StoredProcedure [dbo].[AddDatabaseProperty]    Script Date: 06/02/2008 11:43:02 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddDatabaseProperty]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AddDatabaseProperty]
GO
/****** Object:  StoredProcedure [dbo].[BackoutUniqueKeys]    Script Date: 06/02/2008 11:43:11 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BackoutUniqueKeys]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[BackoutUniqueKeys]
GO
/****** Object:  View [dbo].[VW_ADJUSTMENT_DETAILS]    Script Date: 06/02/2008 11:44:16 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[VW_ADJUSTMENT_DETAILS]'))
DROP VIEW [dbo].[VW_ADJUSTMENT_DETAILS]
GO
/****** Object:  StoredProcedure [dbo].[GetRateSchedules]    Script Date: 06/02/2008 11:43:46 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetRateSchedules]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetRateSchedules]
GO
/****** Object:  StoredProcedure [dbo].[GetDatabaseProperty]    Script Date: 06/02/2008 11:43:43 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetDatabaseProperty]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetDatabaseProperty]
GO
/****** Object:  StoredProcedure [dbo].[DeleteSourceData]    Script Date: 06/02/2008 11:43:37 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteSourceData]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DeleteSourceData]
GO
/****** Object:  View [dbo].[VW_NOTDELETED_ADJ_DETAILS]    Script Date: 06/02/2008 11:44:17 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[VW_NOTDELETED_ADJ_DETAILS]'))
DROP VIEW [dbo].[VW_NOTDELETED_ADJ_DETAILS]
GO
/****** Object:  UserDefinedFunction [dbo].[MTDateInRange]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTDateInRange]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[MTDateInRange]
GO
/****** Object:  StoredProcedure [dbo].[GetDatabaseVersionInfo]    Script Date: 06/02/2008 11:43:43 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetDatabaseVersionInfo]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetDatabaseVersionInfo]
GO
/****** Object:  StoredProcedure [dbo].[resubmit]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[resubmit]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[resubmit]
GO
/****** Object:  StoredProcedure [dbo].[RemoveAdjustmentTypeProps]    Script Date: 06/02/2008 11:44:06 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[RemoveAdjustmentTypeProps]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[RemoveAdjustmentTypeProps]
GO
/****** Object:  StoredProcedure [dbo].[CreateCounterPropDef]    Script Date: 06/02/2008 11:43:26 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateCounterPropDef]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateCounterPropDef]
GO
/****** Object:  StoredProcedure [dbo].[UpdateProductViewProperty]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateProductViewProperty]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdateProductViewProperty]
GO
/****** Object:  StoredProcedure [dbo].[DropAndCreateAdjustmentTable]    Script Date: 06/02/2008 11:43:39 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DropAndCreateAdjustmentTable]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DropAndCreateAdjustmentTable]
GO
/****** Object:  StoredProcedure [dbo].[UpdateCounterPropDef]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateCounterPropDef]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdateCounterPropDef]
GO
/****** Object:  StoredProcedure [dbo].[InsertMeteredBatch]    Script Date: 06/02/2008 11:43:54 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertMeteredBatch]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[InsertMeteredBatch]
GO
/****** Object:  StoredProcedure [dbo].[UpsertPipeline]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpsertPipeline]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpsertPipeline]
GO
/****** Object:  StoredProcedure [dbo].[DropAdjustmentTables]    Script Date: 06/02/2008 11:43:39 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DropAdjustmentTables]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DropAdjustmentTables]
GO
/****** Object:  StoredProcedure [dbo].[RemoveCounterPropDef]    Script Date: 06/02/2008 11:44:06 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[RemoveCounterPropDef]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[RemoveCounterPropDef]
GO
/****** Object:  StoredProcedure [dbo].[UpdateMeteredCount]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateMeteredCount]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdateMeteredCount]
GO
/****** Object:  StoredProcedure [dbo].[PopFirstMessage]    Script Date: 06/02/2008 11:44:06 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[PopFirstMessage]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[PopFirstMessage]
GO
/****** Object:  StoredProcedure [dbo].[CreateAdjustmentType]    Script Date: 06/02/2008 11:43:23 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateAdjustmentType]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateAdjustmentType]
GO
/****** Object:  StoredProcedure [dbo].[DeleteProductViewRecords]    Script Date: 06/02/2008 11:43:36 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteProductViewRecords]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DeleteProductViewRecords]
GO
/****** Object:  UserDefinedFunction [dbo].[ConvertIntegerToUID]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ConvertIntegerToUID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[ConvertIntegerToUID]
GO
/****** Object:  StoredProcedure [dbo].[Abandon]    Script Date: 06/02/2008 11:42:55 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Abandon]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[Abandon]
GO
/****** Object:  View [dbo].[VW_AR_ACC_MAPPER]    Script Date: 06/02/2008 11:44:16 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[VW_AR_ACC_MAPPER]'))
DROP VIEW [dbo].[VW_AR_ACC_MAPPER]
GO
/****** Object:  StoredProcedure [dbo].[AddCounterParam]    Script Date: 06/02/2008 11:43:00 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddCounterParam]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AddCounterParam]
GO
/****** Object:  StoredProcedure [dbo].[InsertProductViewUniqueKeyCol]    Script Date: 06/02/2008 11:43:56 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertProductViewUniqueKeyCol]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[InsertProductViewUniqueKeyCol]
GO
/****** Object:  UserDefinedFunction [dbo].[ConvertUIDToInteger]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ConvertUIDToInteger]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[ConvertUIDToInteger]
GO
/****** Object:  StoredProcedure [dbo].[ReRunCreate]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReRunCreate]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ReRunCreate]
GO
/****** Object:  StoredProcedure [dbo].[GetIdBlock]    Script Date: 06/02/2008 11:43:43 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetIdBlock]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetIdBlock]
GO
/****** Object:  StoredProcedure [dbo].[CalculateRegularMessages]    Script Date: 06/02/2008 11:43:14 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CalculateRegularMessages]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CalculateRegularMessages]
GO
/****** Object:  StoredProcedure [dbo].[CalculateLargeMessages]    Script Date: 06/02/2008 11:43:14 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CalculateLargeMessages]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CalculateLargeMessages]
GO
/****** Object:  StoredProcedure [dbo].[account_bucket_mapping]    Script Date: 06/02/2008 11:42:55 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[account_bucket_mapping]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[account_bucket_mapping]
GO
/****** Object:  StoredProcedure [dbo].[CalculateAtomicMessages]    Script Date: 06/02/2008 11:43:13 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CalculateAtomicMessages]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CalculateAtomicMessages]
GO
/****** Object:  UserDefinedFunction [dbo].[MTComputeEffectiveBeginDate]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTComputeEffectiveBeginDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[MTComputeEffectiveBeginDate]
GO
/****** Object:  StoredProcedure [dbo].[archive_export]    Script Date: 06/02/2008 11:43:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[archive_export]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[archive_export]
GO
/****** Object:  StoredProcedure [dbo].[CalculateLargestCompoundSize]    Script Date: 06/02/2008 11:43:14 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CalculateLargestCompoundSize]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CalculateLargestCompoundSize]
GO
/****** Object:  UserDefinedFunction [dbo].[MTComputeEffectiveEndDate]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTComputeEffectiveEndDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[MTComputeEffectiveEndDate]
GO
/****** Object:  StoredProcedure [dbo].[archive_delete]    Script Date: 06/02/2008 11:43:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[archive_delete]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[archive_delete]
GO
/****** Object:  UserDefinedFunction [dbo].[MTRateScheduleScore]    Script Date: 06/02/2008 11:44:11 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTRateScheduleScore]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[MTRateScheduleScore]
GO
/****** Object:  StoredProcedure [dbo].[archive_trash]    Script Date: 06/02/2008 11:43:11 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[archive_trash]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[archive_trash]
GO
/****** Object:  StoredProcedure [dbo].[dearchive_files]    Script Date: 06/02/2008 11:43:34 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[dearchive_files]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[dearchive_files]
GO
/****** Object:  View [dbo].[t_partition_interval_map]    Script Date: 06/02/2008 11:44:11 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_partition_interval_map]'))
DROP VIEW [dbo].[t_partition_interval_map]
GO
/****** Object:  StoredProcedure [dbo].[PropagateProperties]    Script Date: 06/02/2008 11:44:06 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[PropagateProperties]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[PropagateProperties]
GO
/****** Object:  StoredProcedure [dbo].[GetMetaDataForProps]    Script Date: 06/02/2008 11:43:45 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetMetaDataForProps]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetMetaDataForProps]
GO
/****** Object:  StoredProcedure [dbo].[CreateUsageIntervals]    Script Date: 06/02/2008 11:43:33 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateUsageIntervals]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateUsageIntervals]
GO
/****** Object:  StoredProcedure [dbo].[GetPCViewHierarchy]    Script Date: 06/02/2008 11:43:46 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetPCViewHierarchy]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetPCViewHierarchy]
GO
/****** Object:  StoredProcedure [dbo].[DeleteProductViewMetadata]    Script Date: 06/02/2008 11:43:36 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteProductViewMetadata]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DeleteProductViewMetadata]
GO
/****** Object:  StoredProcedure [dbo].[CreateUsageIntervalsForAccount]    Script Date: 06/02/2008 11:43:33 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateUsageIntervalsForAccount]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateUsageIntervalsForAccount]
GO
/****** Object:  StoredProcedure [dbo].[BulkSubscriptionChange]    Script Date: 06/02/2008 11:43:13 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BulkSubscriptionChange]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[BulkSubscriptionChange]
GO
/****** Object:  StoredProcedure [dbo].[UpdateDataForEnumToString]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateDataForEnumToString]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdateDataForEnumToString]
GO
/****** Object:  StoredProcedure [dbo].[SoftCloseUsageIntervals]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SoftCloseUsageIntervals]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SoftCloseUsageIntervals]
GO
/****** Object:  StoredProcedure [dbo].[AddOwnedFolder]    Script Date: 06/02/2008 11:43:06 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddOwnedFolder]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AddOwnedFolder]
GO
/****** Object:  StoredProcedure [dbo].[UpdateDataForStringToEnum]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateDataForStringToEnum]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdateDataForStringToEnum]
GO
/****** Object:  StoredProcedure [dbo].[OpenUsageInterval]    Script Date: 06/02/2008 11:44:05 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[OpenUsageInterval]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[OpenUsageInterval]
GO
/****** Object:  View [dbo].[VW_MPS_ACC_MAPPER]    Script Date: 06/02/2008 11:44:16 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[VW_MPS_ACC_MAPPER]'))
DROP VIEW [dbo].[VW_MPS_ACC_MAPPER]
GO
/****** Object:  StoredProcedure [dbo].[InsertIntoQueryLog]    Script Date: 06/02/2008 11:43:53 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertIntoQueryLog]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[InsertIntoQueryLog]
GO
/****** Object:  StoredProcedure [dbo].[DetermineExecutableEvents]    Script Date: 06/02/2008 11:43:39 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DetermineExecutableEvents]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DetermineExecutableEvents]
GO
/****** Object:  View [dbo].[vw_mps_or_system_acc_mapper]    Script Date: 06/02/2008 11:44:16 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[vw_mps_or_system_acc_mapper]'))
DROP VIEW [dbo].[vw_mps_or_system_acc_mapper]
GO
/****** Object:  StoredProcedure [dbo].[RetrieveEnumCode]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[RetrieveEnumCode]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[RetrieveEnumCode]
GO
/****** Object:  StoredProcedure [dbo].[DetermineReversibleEvents]    Script Date: 06/02/2008 11:43:39 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DetermineReversibleEvents]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DetermineReversibleEvents]
GO
/****** Object:  StoredProcedure [dbo].[AddICBMapping]    Script Date: 06/02/2008 11:43:02 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddICBMapping]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AddICBMapping]
GO
/****** Object:  StoredProcedure [dbo].[Dearchive_account]    Script Date: 06/02/2008 11:43:34 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Dearchive_account]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[Dearchive_account]
GO
/****** Object:  StoredProcedure [dbo].[UpdProductViewPropertyFromName]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdProductViewPropertyFromName]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdProductViewPropertyFromName]
GO
/****** Object:  StoredProcedure [dbo].[SubmitEventForExecution]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SubmitEventForExecution]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SubmitEventForExecution]
GO
/****** Object:  UserDefinedFunction [dbo].[DiffHour]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DiffHour]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[DiffHour]
GO
/****** Object:  StoredProcedure [dbo].[MoveDataToPartitions]    Script Date: 06/02/2008 11:44:01 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MoveDataToPartitions]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[MoveDataToPartitions]
GO
/****** Object:  StoredProcedure [dbo].[SubmitEventForReversal]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SubmitEventForReversal]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SubmitEventForReversal]
GO
/****** Object:  StoredProcedure [dbo].[InstantiateScheduledEvent]    Script Date: 06/02/2008 11:43:57 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InstantiateScheduledEvent]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[InstantiateScheduledEvent]
GO
/****** Object:  StoredProcedure [dbo].[CanBulkSubscribe]    Script Date: 06/02/2008 11:43:15 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CanBulkSubscribe]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CanBulkSubscribe]
GO
/****** Object:  StoredProcedure [dbo].[CreateUniqueKeyTable]    Script Date: 06/02/2008 11:43:32 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateUniqueKeyTable]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateUniqueKeyTable]
GO
/****** Object:  StoredProcedure [dbo].[CreateTestRecurEventInst]    Script Date: 06/02/2008 11:43:32 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateTestRecurEventInst]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateTestRecurEventInst]
GO
/****** Object:  StoredProcedure [dbo].[InsertAuditEvent]    Script Date: 06/02/2008 11:43:50 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertAuditEvent]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[InsertAuditEvent]
GO
/****** Object:  StoredProcedure [dbo].[DeployAllPartitionedTables]    Script Date: 06/02/2008 11:43:38 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeployAllPartitionedTables]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DeployAllPartitionedTables]
GO
/****** Object:  StoredProcedure [dbo].[CancelSubmittedEvent]    Script Date: 06/02/2008 11:43:15 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CancelSubmittedEvent]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CancelSubmittedEvent]
GO
/****** Object:  StoredProcedure [dbo].[AddCalendarWeekday]    Script Date: 06/02/2008 11:42:59 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddCalendarWeekday]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AddCalendarWeekday]
GO
/****** Object:  UserDefinedFunction [dbo].[GetUsageIntervalID]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetUsageIntervalID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[GetUsageIntervalID]
GO
/****** Object:  StoredProcedure [dbo].[MarkEventAsSucceeded]    Script Date: 06/02/2008 11:43:59 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MarkEventAsSucceeded]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[MarkEventAsSucceeded]
GO
/****** Object:  StoredProcedure [dbo].[AddCalendarHoliday]    Script Date: 06/02/2008 11:42:58 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddCalendarHoliday]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AddCalendarHoliday]
GO
/****** Object:  StoredProcedure [dbo].[AddPartitionStoragePath]    Script Date: 06/02/2008 11:43:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddPartitionStoragePath]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AddPartitionStoragePath]
GO
/****** Object:  StoredProcedure [dbo].[MarkEventAsFailed]    Script Date: 06/02/2008 11:43:58 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MarkEventAsFailed]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[MarkEventAsFailed]
GO
/****** Object:  StoredProcedure [dbo].[MarkEventAsNotYetRun]    Script Date: 06/02/2008 11:43:59 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MarkEventAsNotYetRun]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[MarkEventAsNotYetRun]
GO
/****** Object:  StoredProcedure [dbo].[AddCalendarPeriod]    Script Date: 06/02/2008 11:42:58 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddCalendarPeriod]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AddCalendarPeriod]
GO
/****** Object:  StoredProcedure [dbo].[CanExecuteEvents]    Script Date: 06/02/2008 11:43:16 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CanExecuteEvents]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CanExecuteEvents]
GO
/****** Object:  StoredProcedure [dbo].[RemoveSubscription]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[RemoveSubscription]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[RemoveSubscription]
GO
/****** Object:  StoredProcedure [dbo].[CanReverseEvents]    Script Date: 06/02/2008 11:43:16 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CanReverseEvents]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CanReverseEvents]
GO
/****** Object:  StoredProcedure [dbo].[AddNewAccount]    Script Date: 06/02/2008 11:43:05 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddNewAccount]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AddNewAccount]
GO
/****** Object:  StoredProcedure [dbo].[RemoveGroupSubscription]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[RemoveGroupSubscription]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[RemoveGroupSubscription]
GO
/****** Object:  StoredProcedure [dbo].[CreateUsagePartitions]    Script Date: 06/02/2008 11:43:33 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateUsagePartitions]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateUsagePartitions]
GO
/****** Object:  StoredProcedure [dbo].[FailZombieRecurringEvents]    Script Date: 06/02/2008 11:43:41 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[FailZombieRecurringEvents]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[FailZombieRecurringEvents]
GO
/****** Object:  UserDefinedFunction [dbo].[POContainsOnlyAbsoluteRates]    Script Date: 06/02/2008 11:44:11 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[POContainsOnlyAbsoluteRates]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[POContainsOnlyAbsoluteRates]
GO
/****** Object:  StoredProcedure [dbo].[DeployPartitionedTable]    Script Date: 06/02/2008 11:43:38 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeployPartitionedTable]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DeployPartitionedTable]
GO
/****** Object:  StoredProcedure [dbo].[AddAccountToGroupSub]    Script Date: 06/02/2008 11:42:57 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddAccountToGroupSub]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AddAccountToGroupSub]
GO
/****** Object:  StoredProcedure [dbo].[AdjustSubDates]    Script Date: 06/02/2008 11:43:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AdjustSubDates]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AdjustSubDates]
GO
/****** Object:  StoredProcedure [dbo].[DupPartitionedTable]    Script Date: 06/02/2008 11:43:40 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DupPartitionedTable]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DupPartitionedTable]
GO
/****** Object:  StoredProcedure [dbo].[CreateGroupSubscription]    Script Date: 06/02/2008 11:43:27 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateGroupSubscription]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateGroupSubscription]
GO
/****** Object:  StoredProcedure [dbo].[GetNextStoragePath]    Script Date: 06/02/2008 11:43:45 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetNextStoragePath]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetNextStoragePath]
GO
/****** Object:  StoredProcedure [dbo].[UpdateGroupSubscription]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateGroupSubscription]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdateGroupSubscription]
GO
/****** Object:  StoredProcedure [dbo].[SetPartitionOptions]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SetPartitionOptions]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SetPartitionOptions]
GO
/****** Object:  StoredProcedure [dbo].[Backup_partitions_log]    Script Date: 06/02/2008 11:43:12 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Backup_partitions_log]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[Backup_partitions_log]
GO
/****** Object:  StoredProcedure [dbo].[RemoveGroupSubMember]    Script Date: 06/02/2008 11:44:06 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[RemoveGroupSubMember]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[RemoveGroupSubMember]
GO
/****** Object:  StoredProcedure [dbo].[sp_DeletePricelist]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_DeletePricelist]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sp_DeletePricelist]
GO
/****** Object:  StoredProcedure [dbo].[UpdateGroupSubMembership]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateGroupSubMembership]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdateGroupSubMembership]
GO
/****** Object:  StoredProcedure [dbo].[UpdateAccountState]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateAccountState]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdateAccountState]
GO
/****** Object:  StoredProcedure [dbo].[CheckAccountStateDateRules]    Script Date: 06/02/2008 11:43:17 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckAccountStateDateRules]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CheckAccountStateDateRules]
GO
/****** Object:  StoredProcedure [dbo].[UpdStateFromClosedToArchived]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdStateFromClosedToArchived]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdStateFromClosedToArchived]
GO
/****** Object:  StoredProcedure [dbo].[SequencedUpsertGsubRecur]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SequencedUpsertGsubRecur]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SequencedUpsertGsubRecur]
GO
/****** Object:  View [dbo].[VW_HIERARCHYNAME]    Script Date: 06/02/2008 11:44:16 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[VW_HIERARCHYNAME]'))
DROP VIEW [dbo].[VW_HIERARCHYNAME]
GO
/****** Object:  StoredProcedure [dbo].[SubscribeBatchGroupSub]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SubscribeBatchGroupSub]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SubscribeBatchGroupSub]
GO
/****** Object:  View [dbo].[VW_MPS_OR_SYSTEM_HIERARCHYNAME]    Script Date: 06/02/2008 11:44:17 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[VW_MPS_OR_SYSTEM_HIERARCHYNAME]'))
DROP VIEW [dbo].[VW_MPS_OR_SYSTEM_HIERARCHYNAME]
GO
/****** Object:  UserDefinedFunction [dbo].[GetCurrentIntervalID]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetCurrentIntervalID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[GetCurrentIntervalID]
GO
/****** Object:  StoredProcedure [dbo].[UpdateAccount]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateAccount]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdateAccount]
GO
/****** Object:  UserDefinedFunction [dbo].[IsIntervalOpen]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsIntervalOpen]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[IsIntervalOpen]
GO
/****** Object:  StoredProcedure [dbo].[copytemplate]    Script Date: 06/02/2008 11:43:22 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[copytemplate]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[copytemplate]
GO
/****** Object:  UserDefinedFunction [dbo].[DeriveEBCRCycle]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeriveEBCRCycle]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[DeriveEBCRCycle]
GO
/****** Object:  StoredProcedure [dbo].[DeleteTemplate]    Script Date: 06/02/2008 11:43:37 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteTemplate]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DeleteTemplate]
GO
/****** Object:  UserDefinedFunction [dbo].[CheckEBCRCycleTypeCompatibility]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckEBCRCycleTypeCompatibility]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[CheckEBCRCycleTypeCompatibility]
GO
/****** Object:  StoredProcedure [dbo].[IsAccBillableNPayingForOthers]    Script Date: 06/02/2008 11:43:58 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsAccBillableNPayingForOthers]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[IsAccBillableNPayingForOthers]
GO
/****** Object:  StoredProcedure [dbo].[CreateSubscriptionRecord]    Script Date: 06/02/2008 11:43:31 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateSubscriptionRecord]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateSubscriptionRecord]
GO
/****** Object:  StoredProcedure [dbo].[CheckForNotClosedDescendents]    Script Date: 06/02/2008 11:43:18 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckForNotClosedDescendents]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CheckForNotClosedDescendents]
GO
/****** Object:  StoredProcedure [dbo].[CheckGroupSubBusinessRules]    Script Date: 06/02/2008 11:43:19 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckGroupSubBusinessRules]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CheckGroupSubBusinessRules]
GO
/****** Object:  StoredProcedure [dbo].[Backup_partitions_Differential]    Script Date: 06/02/2008 11:43:12 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Backup_partitions_Differential]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[Backup_partitions_Differential]
GO
/****** Object:  StoredProcedure [dbo].[UpdateStateFromPFBToClosed]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateStateFromPFBToClosed]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdateStateFromPFBToClosed]
GO
/****** Object:  StoredProcedure [dbo].[UpdateStateFromClosedToPFB]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateStateFromClosedToPFB]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdateStateFromClosedToPFB]
GO
/****** Object:  UserDefinedFunction [dbo].[IsAccountFolder]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsAccountFolder]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[IsAccountFolder]
GO
/****** Object:  StoredProcedure [dbo].[Rev_UpdateStateFromPFBToClosed]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Rev_UpdateStateFromPFBToClosed]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[Rev_UpdateStateFromPFBToClosed]
GO
/****** Object:  StoredProcedure [dbo].[Rev_Updatestatefromclosedtopfb]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Rev_Updatestatefromclosedtopfb]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[Rev_Updatestatefromclosedtopfb]
GO
/****** Object:  StoredProcedure [dbo].[Rev_UpdStateFromClosedToArchiv]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Rev_UpdStateFromClosedToArchiv]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[Rev_UpdStateFromClosedToArchiv]
GO
/****** Object:  StoredProcedure [dbo].[CheckAccountCreationBusinessRules]    Script Date: 06/02/2008 11:43:17 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckAccountCreationBusinessRules]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CheckAccountCreationBusinessRules]
GO
/****** Object:  StoredProcedure [dbo].[CheckForNotArchivedDescendents]    Script Date: 06/02/2008 11:43:18 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckForNotArchivedDescendents]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CheckForNotArchivedDescendents]
GO
/****** Object:  StoredProcedure [dbo].[UpsertAccountType]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpsertAccountType]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpsertAccountType]
GO
/****** Object:  StoredProcedure [dbo].[UpsertAccountTypeServiceDefMap]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpsertAccountTypeServiceDefMap]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpsertAccountTypeServiceDefMap]
GO
/****** Object:  StoredProcedure [dbo].[SequencedUpsertAccOwnership]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SequencedUpsertAccOwnership]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SequencedUpsertAccOwnership]
GO
/****** Object:  UserDefinedFunction [dbo].[GetAllDescendentAccountTypes]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetAllDescendentAccountTypes]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[GetAllDescendentAccountTypes]
GO
/****** Object:  View [dbo].[T_VW_ACCTRES_BYID]    Script Date: 06/02/2008 11:44:11 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[T_VW_ACCTRES_BYID]'))
DROP VIEW [dbo].[T_VW_ACCTRES_BYID]
GO
/****** Object:  View [dbo].[t_vw_base_props]    Script Date: 06/02/2008 11:44:16 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_base_props]'))
DROP VIEW [dbo].[t_vw_base_props]
GO
/****** Object:  UserDefinedFunction [dbo].[GetBillingGroupDescendants]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetBillingGroupDescendants]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[GetBillingGroupDescendants]
GO
/****** Object:  View [dbo].[t_vw_allrateschedules_po_icb]    Script Date: 06/02/2008 11:44:15 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_allrateschedules_po_icb]'))
DROP VIEW [dbo].[t_vw_allrateschedules_po_icb]
GO
/****** Object:  StoredProcedure [dbo].[InsertEnumData]    Script Date: 06/02/2008 11:43:51 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertEnumData]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[InsertEnumData]
GO
/****** Object:  View [dbo].[t_vw_allrateschedules_po_noicb]    Script Date: 06/02/2008 11:44:16 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_allrateschedules_po_noicb]'))
DROP VIEW [dbo].[t_vw_allrateschedules_po_noicb]
GO
/****** Object:  View [dbo].[T_VW_ACCTRES]    Script Date: 06/02/2008 11:44:11 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[T_VW_ACCTRES]'))
DROP VIEW [dbo].[T_VW_ACCTRES]
GO
/****** Object:  View [dbo].[t_vw_expanded_sub]    Script Date: 06/02/2008 11:44:16 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_expanded_sub]'))
DROP VIEW [dbo].[t_vw_expanded_sub]
GO
/****** Object:  StoredProcedure [dbo].[InsertUsageIntervalInfo]    Script Date: 06/02/2008 11:43:57 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertUsageIntervalInfo]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[InsertUsageIntervalInfo]
GO
/****** Object:  View [dbo].[t_vw_allrateschedules]    Script Date: 06/02/2008 11:44:11 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_allrateschedules]'))
DROP VIEW [dbo].[t_vw_allrateschedules]
GO
/****** Object:  StoredProcedure [dbo].[InsertUsageCycleInfo]    Script Date: 06/02/2008 11:43:56 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertUsageCycleInfo]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[InsertUsageCycleInfo]
GO
/****** Object:  View [dbo].[vw_interval_billgroup_counts]    Script Date: 06/02/2008 11:44:16 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[vw_interval_billgroup_counts]'))
DROP VIEW [dbo].[vw_interval_billgroup_counts]
GO
/****** Object:  View [dbo].[t_vw_pilookup]    Script Date: 06/02/2008 11:44:16 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_pilookup]'))
DROP VIEW [dbo].[t_vw_pilookup]
GO
/****** Object:  StoredProcedure [dbo].[InsertAcctToIntervalMapping]    Script Date: 06/02/2008 11:43:48 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertAcctToIntervalMapping]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[InsertAcctToIntervalMapping]
GO
/****** Object:  StoredProcedure [dbo].[CreateBillGroupMaterialization]    Script Date: 06/02/2008 11:43:24 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateBillGroupMaterialization]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateBillGroupMaterialization]
GO
/****** Object:  View [dbo].[t_vw_rc_arrears_fixed]    Script Date: 06/02/2008 11:44:16 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_rc_arrears_fixed]'))
DROP VIEW [dbo].[t_vw_rc_arrears_fixed]
GO
/****** Object:  StoredProcedure [dbo].[MTSP_INSERTINVOICE_DEFLTINVNUM]    Script Date: 06/02/2008 11:44:03 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTSP_INSERTINVOICE_DEFLTINVNUM]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[MTSP_INSERTINVOICE_DEFLTINVNUM]
GO
/****** Object:  StoredProcedure [dbo].[CompleteMaterialization]    Script Date: 06/02/2008 11:43:21 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CompleteMaterialization]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CompleteMaterialization]
GO
/****** Object:  View [dbo].[t_vw_rc_arrears_relative]    Script Date: 06/02/2008 11:44:16 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_rc_arrears_relative]'))
DROP VIEW [dbo].[t_vw_rc_arrears_relative]
GO
/****** Object:  StoredProcedure [dbo].[UndoAccounts]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UndoAccounts]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UndoAccounts]
GO
/****** Object:  StoredProcedure [dbo].[SoftCloseBillingGroups]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SoftCloseBillingGroups]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SoftCloseBillingGroups]
GO
/****** Object:  View [dbo].[vw_acc_po_restrictions]    Script Date: 06/02/2008 11:44:16 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[vw_acc_po_restrictions]'))
DROP VIEW [dbo].[vw_acc_po_restrictions]
GO
/****** Object:  StoredProcedure [dbo].[SetTariffs]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SetTariffs]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SetTariffs]
GO
/****** Object:  StoredProcedure [dbo].[ValidateBillGroupAssignments]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ValidateBillGroupAssignments]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ValidateBillGroupAssignments]
GO
/****** Object:  View [dbo].[vw_audit_log]    Script Date: 06/02/2008 11:44:16 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[vw_audit_log]'))
DROP VIEW [dbo].[vw_audit_log]
GO
/****** Object:  StoredProcedure [dbo].[InsertDefaultTariff]    Script Date: 06/02/2008 11:43:51 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertDefaultTariff]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[InsertDefaultTariff]
GO
/****** Object:  StoredProcedure [dbo].[StartChildGroupCreation]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[StartChildGroupCreation]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[StartChildGroupCreation]
GO
/****** Object:  StoredProcedure [dbo].[PurgeAuditTable]    Script Date: 06/02/2008 11:44:06 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[PurgeAuditTable]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[PurgeAuditTable]
GO
/****** Object:  StoredProcedure [dbo].[CopyAdapterInstances]    Script Date: 06/02/2008 11:43:21 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CopyAdapterInstances]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CopyAdapterInstances]
GO
/****** Object:  UserDefinedFunction [dbo].[GetBillingGroupAncestor]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetBillingGroupAncestor]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[GetBillingGroupAncestor]
GO
/****** Object:  View [dbo].[vw_all_billing_groups_status]    Script Date: 06/02/2008 11:44:16 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[vw_all_billing_groups_status]'))
DROP VIEW [dbo].[vw_all_billing_groups_status]
GO
/****** Object:  StoredProcedure [dbo].[CleanupMaterialization]    Script Date: 06/02/2008 11:43:19 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CleanupMaterialization]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CleanupMaterialization]
GO
/****** Object:  View [dbo].[vw_unassigned_accounts]    Script Date: 06/02/2008 11:44:17 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[vw_unassigned_accounts]'))
DROP VIEW [dbo].[vw_unassigned_accounts]
GO
/****** Object:  StoredProcedure [dbo].[UpdateBillingGroupStatus]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateBillingGroupStatus]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdateBillingGroupStatus]
GO
/****** Object:  StoredProcedure [dbo].[sp_InsertPolicy]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_InsertPolicy]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sp_InsertPolicy]
GO
/****** Object:  UserDefinedFunction [dbo].[GetExpiredIntervals]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetExpiredIntervals]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[GetExpiredIntervals]
GO
/****** Object:  StoredProcedure [dbo].[InsertBaseProps]    Script Date: 06/02/2008 11:43:50 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertBaseProps]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[InsertBaseProps]
GO
/****** Object:  StoredProcedure [dbo].[UpdateBaseProps]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateBaseProps]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdateBaseProps]
GO
/****** Object:  StoredProcedure [dbo].[GetLastBalance]    Script Date: 06/02/2008 11:43:44 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetLastBalance]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetLastBalance]
GO
/****** Object:  StoredProcedure [dbo].[MTSP_INSERTINVOICE_BALANCES]    Script Date: 06/02/2008 11:44:02 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTSP_INSERTINVOICE_BALANCES]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[MTSP_INSERTINVOICE_BALANCES]
GO
/****** Object:  View [dbo].[VW_AJ_INFO]    Script Date: 06/02/2008 11:44:16 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[VW_AJ_INFO]'))
DROP VIEW [dbo].[VW_AJ_INFO]
GO
/****** Object:  UserDefinedFunction [dbo].[MTEndOfDay]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTEndOfDay]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[MTEndOfDay]
GO
/****** Object:  StoredProcedure [dbo].[ExtendedUpsert]    Script Date: 06/02/2008 11:43:41 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ExtendedUpsert]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[ExtendedUpsert]
GO
/****** Object:  StoredProcedure [dbo].[AddNewSub]    Script Date: 06/02/2008 11:43:06 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddNewSub]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AddNewSub]
GO
/****** Object:  StoredProcedure [dbo].[AcknowledgeCheckpoint]    Script Date: 06/02/2008 11:42:56 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AcknowledgeCheckpoint]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AcknowledgeCheckpoint]
GO
/****** Object:  UserDefinedFunction [dbo].[GetPartitionPredicate]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetPartitionPredicate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[GetPartitionPredicate]
GO
/****** Object:  StoredProcedure [dbo].[UnacknowledgeCheckpoint]    Script Date: 06/02/2008 11:44:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UnacknowledgeCheckpoint]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UnacknowledgeCheckpoint]
GO
/****** Object:  StoredProcedure [dbo].[GetCurrentID]    Script Date: 06/02/2008 11:43:42 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetCurrentID]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetCurrentID]
GO
/****** Object:  StoredProcedure [dbo].[GetLocalizedSiteInfo]    Script Date: 06/02/2008 11:43:44 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetLocalizedSiteInfo]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GetLocalizedSiteInfo]
GO
/****** Object:  UserDefinedFunction [dbo].[LookupAccount]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[LookupAccount]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[LookupAccount]
GO
/****** Object:  StoredProcedure [dbo].[AddAccToHierarchy]    Script Date: 06/02/2008 11:42:57 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddAccToHierarchy]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AddAccToHierarchy]
GO
/****** Object:  StoredProcedure [dbo].[GeneratePartitionSequence]    Script Date: 06/02/2008 11:43:41 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GeneratePartitionSequence]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[GeneratePartitionSequence]
GO
/****** Object:  StoredProcedure [dbo].[CreateDefaultPartition]    Script Date: 06/02/2008 11:43:26 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateDefaultPartition]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateDefaultPartition]
GO
/****** Object:  StoredProcedure [dbo].[CreatePartitionDatabase]    Script Date: 06/02/2008 11:43:28 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreatePartitionDatabase]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreatePartitionDatabase]
GO
/****** Object:  StoredProcedure [dbo].[CreatePartitionedView]    Script Date: 06/02/2008 11:43:28 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreatePartitionedView]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreatePartitionedView]
GO
/****** Object:  StoredProcedure [dbo].[CreateUniqueKeyTables]    Script Date: 06/02/2008 11:43:32 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateUniqueKeyTables]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateUniqueKeyTables]
GO
/****** Object:  StoredProcedure [dbo].[CreateGSubMemberRecord]    Script Date: 06/02/2008 11:43:28 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateGSubMemberRecord]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateGSubMemberRecord]
GO
/****** Object:  StoredProcedure [dbo].[addsubscriptionbase]    Script Date: 06/02/2008 11:43:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[addsubscriptionbase]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[addsubscriptionbase]
GO
/****** Object:  StoredProcedure [dbo].[updatesub]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[updatesub]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[updatesub]
GO
/****** Object:  UserDefinedFunction [dbo].[POContainsDiscount]    Script Date: 06/02/2008 11:44:11 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[POContainsDiscount]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[POContainsDiscount]
GO
/****** Object:  UserDefinedFunction [dbo].[IsAccountAndPOSameCurrency]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsAccountAndPOSameCurrency]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[IsAccountAndPOSameCurrency]
GO
/****** Object:  StoredProcedure [dbo].[Backup_partitions_full]    Script Date: 06/02/2008 11:43:12 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Backup_partitions_full]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[Backup_partitions_full]
GO
/****** Object:  StoredProcedure [dbo].[sp_DeleteRateSchedule]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_DeleteRateSchedule]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[sp_DeleteRateSchedule]
GO
/****** Object:  StoredProcedure [dbo].[AdjustGsubMemberDates]    Script Date: 06/02/2008 11:43:08 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AdjustGsubMemberDates]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[AdjustGsubMemberDates]
GO
/****** Object:  StoredProcedure [dbo].[CreateAccountStateRecord]    Script Date: 06/02/2008 11:43:22 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateAccountStateRecord]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreateAccountStateRecord]
GO
/****** Object:  StoredProcedure [dbo].[UpdateStateRecordSet]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateStateRecordSet]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdateStateRecordSet]
GO
/****** Object:  StoredProcedure [dbo].[SequencedDeleteGsubRecur]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SequencedDeleteGsubRecur]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SequencedDeleteGsubRecur]
GO
/****** Object:  StoredProcedure [dbo].[SequencedInsertGsubRecur]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SequencedInsertGsubRecur]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SequencedInsertGsubRecur]
GO
/****** Object:  StoredProcedure [dbo].[UpdatePaymentRecord]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdatePaymentRecord]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpdatePaymentRecord]
GO
/****** Object:  UserDefinedFunction [dbo].[DoesAccountHavePayees]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DoesAccountHavePayees]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[DoesAccountHavePayees]
GO
/****** Object:  StoredProcedure [dbo].[MoveAccount]    Script Date: 06/02/2008 11:44:00 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MoveAccount]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[MoveAccount]
GO
/****** Object:  UserDefinedFunction [dbo].[IsBillingCycleUpdateProhibitedByGroupEBCR]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsBillingCycleUpdateProhibitedByGroupEBCR]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[IsBillingCycleUpdateProhibitedByGroupEBCR]
GO
/****** Object:  UserDefinedFunction [dbo].[IsAccountPayingForOthers]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsAccountPayingForOthers]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[IsAccountPayingForOthers]
GO
/****** Object:  StoredProcedure [dbo].[Reverse_UpdateStateRecordSet]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Reverse_UpdateStateRecordSet]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[Reverse_UpdateStateRecordSet]
GO
/****** Object:  StoredProcedure [dbo].[SequencedInsertAccOwnership]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SequencedInsertAccOwnership]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SequencedInsertAccOwnership]
GO
/****** Object:  StoredProcedure [dbo].[SequencedDeleteAccOwnership]    Script Date: 06/02/2008 11:44:07 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SequencedDeleteAccOwnership]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SequencedDeleteAccOwnership]
GO
/****** Object:  UserDefinedFunction [dbo].[MTMinDate]    Script Date: 06/02/2008 11:44:11 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTMinDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[MTMinDate]
GO
/****** Object:  View [dbo].[t_vw_allrateschedules_po]    Script Date: 06/02/2008 11:44:13 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_allrateschedules_po]'))
DROP VIEW [dbo].[t_vw_allrateschedules_po]
GO
/****** Object:  View [dbo].[t_vw_allrateschedules_pl]    Script Date: 06/02/2008 11:44:12 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_allrateschedules_pl]'))
DROP VIEW [dbo].[t_vw_allrateschedules_pl]
GO
/****** Object:  View [dbo].[T_VW_EFFECTIVE_SUBS]    Script Date: 06/02/2008 11:44:16 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[T_VW_EFFECTIVE_SUBS]'))
DROP VIEW [dbo].[T_VW_EFFECTIVE_SUBS]
GO
/****** Object:  UserDefinedFunction [dbo].[GetEventReversalDeps]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetEventReversalDeps]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[GetEventReversalDeps]
GO
/****** Object:  View [dbo].[vw_paying_accounts]    Script Date: 06/02/2008 11:44:17 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[vw_paying_accounts]'))
DROP VIEW [dbo].[vw_paying_accounts]
GO
/****** Object:  UserDefinedFunction [dbo].[GetEventExecutionDeps]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetEventExecutionDeps]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[GetEventExecutionDeps]
GO
/****** Object:  StoredProcedure [dbo].[UpsertDescription]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpsertDescription]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[UpsertDescription]
GO
/****** Object:  StoredProcedure [dbo].[DeleteBaseProps]    Script Date: 06/02/2008 11:43:35 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteBaseProps]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DeleteBaseProps]
GO
/****** Object:  UserDefinedFunction [dbo].[NextDateAfterBillingCycle]    Script Date: 06/02/2008 11:44:11 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[NextDateAfterBillingCycle]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[NextDateAfterBillingCycle]
GO
/****** Object:  UserDefinedFunction [dbo].[checksubscriptionconflicts]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[checksubscriptionconflicts]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[checksubscriptionconflicts]
GO
/****** Object:  UserDefinedFunction [dbo].[MTMinOfTwoDates]    Script Date: 06/02/2008 11:44:11 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTMinOfTwoDates]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[MTMinOfTwoDates]
GO
/****** Object:  UserDefinedFunction [dbo].[MTMaxOfTwoDates]    Script Date: 06/02/2008 11:44:11 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTMaxOfTwoDates]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[MTMaxOfTwoDates]
GO
/****** Object:  UserDefinedFunction [dbo].[IsSystemPartitioned]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsSystemPartitioned]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[IsSystemPartitioned]
GO
/****** Object:  UserDefinedFunction [dbo].[IsCorporateAccount]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsCorporateAccount]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[IsCorporateAccount]
GO
/****** Object:  UserDefinedFunction [dbo].[IsArchived]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsArchived]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[IsArchived]
GO
/****** Object:  UserDefinedFunction [dbo].[IsClosed]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsClosed]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[IsClosed]
GO
/****** Object:  StoredProcedure [dbo].[CreatePaymentRecord]    Script Date: 06/02/2008 11:43:29 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreatePaymentRecord]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreatePaymentRecord]
GO
/****** Object:  UserDefinedFunction [dbo].[MTMaxDate]    Script Date: 06/02/2008 11:44:11 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTMaxDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[MTMaxDate]
GO
/****** Object:  UserDefinedFunction [dbo].[CSVToInt]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CSVToInt]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[CSVToInt]
GO
/****** Object:  StoredProcedure [dbo].[DeleteDescription]    Script Date: 06/02/2008 11:43:36 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteDescription]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DeleteDescription]
GO
/****** Object:  UserDefinedFunction [dbo].[OverlappingDateRange]    Script Date: 06/02/2008 11:44:11 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[OverlappingDateRange]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[OverlappingDateRange]
GO
/****** Object:  UserDefinedFunction [dbo].[SubtractSecond]    Script Date: 06/02/2008 11:44:11 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SubtractSecond]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[SubtractSecond]
GO
/****** Object:  UserDefinedFunction [dbo].[AddSecond]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddSecond]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[AddSecond]
GO
/****** Object:  UserDefinedFunction [dbo].[IsInSameCorporateAccount]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsInSameCorporateAccount]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[IsInSameCorporateAccount]
GO
/****** Object:  UserDefinedFunction [dbo].[MTStartOfDay]    Script Date: 06/02/2008 11:44:11 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTStartOfDay]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[MTStartOfDay]
GO
/****** Object:  UserDefinedFunction [dbo].[poConstrainedCycleType]    Script Date: 06/02/2008 11:44:11 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[poConstrainedCycleType]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[poConstrainedCycleType]
GO
/****** Object:  UserDefinedFunction [dbo].[CheckGroupMembershipEBCRConstraint]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckGroupMembershipEBCRConstraint]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[CheckGroupMembershipEBCRConstraint]
GO
/****** Object:  UserDefinedFunction [dbo].[CheckGroupReceiverEBCRConstraint]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckGroupReceiverEBCRConstraint]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[CheckGroupReceiverEBCRConstraint]
GO
/****** Object:  UserDefinedFunction [dbo].[CheckGroupMembershipCycleConstraint]    Script Date: 06/02/2008 11:44:09 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckGroupMembershipCycleConstraint]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[CheckGroupMembershipCycleConstraint]
GO
/****** Object:  StoredProcedure [dbo].[CreatePaymentRecordBitemporal]    Script Date: 06/02/2008 11:43:30 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreatePaymentRecordBitemporal]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[CreatePaymentRecordBitemporal]
GO
/****** Object:  UserDefinedFunction [dbo].[EnclosedDateRange]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[EnclosedDateRange]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[EnclosedDateRange]
GO
/****** Object:  UserDefinedFunction [dbo].[IsAccountBillable]    Script Date: 06/02/2008 11:44:10 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsAccountBillable]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[IsAccountBillable]
GO
/****** Object:  UserDefinedFunction [dbo].[POContainsBillingCycleRelative]    Script Date: 06/02/2008 11:44:11 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[POContainsBillingCycleRelative]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[POContainsBillingCycleRelative]
GO
/****** Object:  StoredProcedure [dbo].[sp_InsertPolicy]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_InsertPolicy]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
        
						create procedure [dbo].[sp_InsertPolicy]
						(@aPrincipalColumn VARCHAR(255),
						 @aPrincipalID int,
						 @aPolicyType VARCHAR(2),
             @ap_id_prop int OUTPUT)
		        as
		        
            declare @args NVARCHAR(255)
		        declare @str nvarchar(2000)
						declare @selectstr nvarchar(2000)
            begin
						 select @selectstr = N''SELECT @ap_id_prop = id_policy  FROM t_principal_policy WHERE '' + 
																CAST(@aPrincipalColumn AS nvarchar(255))
																+  N'' = '' + CAST(@aPrincipalID AS nvarchar(38)) + N'' AND '' + N''policy_type='''''' 
																+ CAST(@aPolicyType AS nvarchar(2)) + ''''''''
						 select @str = N''INSERT INTO t_principal_policy ('' + CAST(@aPrincipalColumn AS nvarchar(255)) + N'',
						               policy_type)'' + N'' VALUES ( '' + CAST(@aPrincipalID AS nvarchar(38)) + N'', '''''' + 
						               CAST(@aPolicyType AS nvarchar(2))	+ N'''''')'' 
            select @args = ''@ap_id_prop INT OUTPUT''
            exec sp_executesql @selectstr, @args, @ap_id_prop OUTPUT
             if (@ap_id_prop is null)
	            begin
              exec sp_executesql @str
  	          select @ap_id_prop = @@identity
              end
            end
         
        ' 
END
GO
/****** Object:  StoredProcedure [dbo].[SelectAccountsToBeDeleted]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SelectAccountsToBeDeleted]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      
			CREATE PROC [dbo].[SelectAccountsToBeDeleted]
				@accountIDList varchar(4000),
				@tablename nvarchar(4000)
			AS
			set nocount on
			declare @sql nvarchar(4000)
	/*
			How to run this stored procedure
			exec SelectAccountsToBeDeleted @accountIDList=''123,124'',@tablename=null
			or
			exec SelectAccountsToBeDeleted @accountIDList=null,@tablename=''tmp_t_account''
	*/
				-- Break down into simple account IDs
				-- This block of SQL can be used as an example to get 
				-- the account IDs from the list of account IDs that are
				-- passed in
				CREATE TABLE #AccountIDsTable (
				  ID int NOT NULL,
					status int NULL,
					message varchar(255) NULL)

				PRINT ''------------------------------------------------''
				PRINT ''-- Start of Account Deletion Stored Procedure --''
				PRINT ''------------------------------------------------''

				if ((@accountIDList is not null and @tablename is not null) or 
				(@accountIDList is null and @tablename is null))
				begin
					print ''ERROR--Delete account operation failed-->Either accountIDList or tablename should be specified''
					return -1
				END

				if (@accountIDList is not null)
				begin
					PRINT ''-- Parsing Account IDs passed in and inserting in tmp table --''
					WHILE CHARINDEX('','', @accountIDList) > 0
					BEGIN
						INSERT INTO #AccountIDsTable (ID, status, message)
	 					SELECT SUBSTRING(@accountIDList,1,(CHARINDEX('','', @accountIDList)-1)), 1, ''Okay to delete''
	 					SET @accountIDList = 
	 						SUBSTRING (@accountIDList, (CHARINDEX('','', @accountIDList)+1),
	  										(LEN(@accountIDList) - (CHARINDEX('','', @accountIDList))))
					END
	 						INSERT INTO #AccountIDsTable (ID, status, message) 
							SELECT @accountIDList, 1, ''Okay to delete''
					-- SELECT ID as one FROM #AccountIDsTable
	
					-- Transitive Closure (check for folder/corporation)
					PRINT ''-- Inserting children (if any) into the tmp table --''
					INSERT INTO #AccountIDsTable (ID, status, message)
					SELECT DISTINCT 
					  aa.id_descendent,
						1,
						''Okay to delete''
					FROM 
					  t_account_ancestor aa INNER JOIN #AccountIDsTable tmp ON 
						tmp.ID = aa.id_ancestor AND
						aa.num_generations > 0 AND
					NOT EXISTS (
					  SELECT 
						  ID 
						FROM 
						  #AccountIDsTable tmp1 
						WHERE 
						  tmp1.ID = aa.id_descendent)
	
					INSERT INTO #AccountIDsTable (ID, status, message)
					SELECT DISTINCT 
					  aa.id_descendent,
						1,
						''Okay to delete''
					FROM 
					  t_account_ancestor aa where id_ancestor in (select id from  #AccountIDsTable)
						AND
						aa.num_generations > 0 AND
					NOT EXISTS (
					  SELECT 
						  ID 
						FROM 
						  #AccountIDsTable tmp1 
						WHERE 
						  tmp1.ID = aa.id_descendent)
				end
				else
				begin
					set @sql = ''INSERT INTO #AccountIDsTable (ID, status, message) SELECT id_acc, 
							1, ''''Okay to delete'''' from '' + @tablename
					exec (@sql)
					INSERT INTO #AccountIDsTable (ID, status, message)
					SELECT DISTINCT 
					  aa.id_descendent,
						1,
						''Okay to delete''
					FROM 
					  t_account_ancestor aa INNER JOIN #AccountIDsTable tmp ON 
						tmp.ID = aa.id_ancestor AND
						aa.num_generations > 0 AND
					NOT EXISTS (
					  SELECT 
						  ID 
						FROM 
						  #AccountIDsTable tmp1 
						WHERE 
						  tmp1.ID = aa.id_descendent)
				end
				PRINT ''-- Account does not exists check --''
				UPDATE 
					tmp
				SET
					status = 0, -- failure
					message = ''Account does not exists!''
				FROM
					#AccountIDsTable tmp
				WHERE
					not EXISTS (
						SELECT 
							1
						FROM 
							t_account acc 
						WHERE
							acc.id_acc = tmp.ID )
							
				-- SELECT * from #AccountIDsTable			
					
				-- Print out the accounts with their login names
				SELECT 
					ID as accountID, 
					nm_login as LoginName,
					message
				FROM 
					#AccountIDsTable a left outer join
					t_account_mapper b
				on
					a.ID = b.id_acc
			
			' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[IsActive]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsActive]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
                  create FUNCTION [dbo].[IsActive](@state varchar(2)) returns int
                  as
                  begin
                  declare @retval as int
	          if (@state = ''AC'')
                        begin
		        select @retval = 1
                        end
	          else
                        begin
		        select @retval = 0
                        end 
	          return @retval
                  end
  ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[IsSuspended]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsSuspended]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
                 CREATE FUNCTION [dbo].[IsSuspended](@state varchar(2)) returns int
                 as
                 begin
									declare @retval int
									if (@state = ''SU'')
                     begin
												select @retval = 1
                     end
								 else
										 begin
												select @retval = 0
										 end 
								 return @retval
                 end
  ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[IsPendingFinalBill]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsPendingFinalBill]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
            CREATE FUNCTION [dbo].[IsPendingFinalBill](@state varchar(2)) returns int
              as
              begin
              declare @retval int
	      if (@state = ''PF'')
                  begin
		  select @retval = 1
	          end
              else
                  begin
                  select @retval = 0
        	  end
	      return @retval
              end
  ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[IsClosed]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsClosed]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
             CREATE FUNCTION [dbo].[IsClosed](@state varchar(2)) returns int
             as
             begin
             declare @retval int
	     if (@state = ''CL'')
                begin
	        select @retval = 1
                end
	     else
		begin
                select @retval = 0
	        end
             return @retval
             end
  ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[IsInVisableState]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsInVisableState]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
              CREATE FUNCTION [dbo].[IsInVisableState](@state varchar(2)) returns int
              as
              begin
              declare @retval int
           -- if the account is closed or archived
	      if (@state <> ''CL'' AND @state <> ''AR'')
                begin
		select @retval = 1
	        end
              else
		begin
                select @retval = 0
	        end 
	      return @retval        
              end
        ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[IsArchived]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsArchived]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
             CREATE FUNCTION [dbo].[IsArchived](@state varchar(2)) returns integer
             as
             begin
             declare @retval int
	     if (@state = ''AR'')
                 begin
		 select @retval = 1
                 end
	     else
                 begin
		 select @retval = 0
	     end 
             return @retval
             end
  ' 
END
GO
/****** Object:  StoredProcedure [dbo].[ReversePayments]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReversePayments]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      
			CREATE PROCEDURE [dbo].[ReversePayments]
						@id_interval int,
						@id_acc int,
						@id_enum int,
						@status int OUTPUT
			AS
			BEGIN
			  /*************************************************
				** Procedure Name: MTSP_REVERSE_PAYMENT_BILLING
				** 
				** Procedure Description: 
				**
				** Parameters: 
				**
				** Returns: 0 if successful
				**          -1 if fatal error occurred
				**
				** Created By: Ning Zhuang
				** Created On: 12/10/2002
				** Last Modified On: 
				**************************************************/
				SET @status = -1
	
				-- It is not necessary to use the temp table here.
				-- However, since there is currently no index on the 
				-- t_acc_uage.id_usage_interval column, to improve the 
				-- performance, the temp table is used so that the 
				-- id_sess be looked up only once for the two deletions.

				-- Delete only those records that are still in pending approval
				-- status
				SELECT pv.id_sess
				INTO #tmp
				FROM t_pv_ps_paymentscheduler pv
				INNER JOIN t_acc_usage au
				ON au.id_sess = pv.id_sess 
				AND (au.id_acc = @id_acc OR @id_acc = -1)
				AND pv.c_originalintervalid = @id_interval
				AND pv.c_currentstatus = @id_enum
				IF @@ERROR <> 0 GOTO FatalError
					
				DELETE FROM t_acc_usage
				WHERE id_sess IN (SELECT id_sess FROM #tmp)
				IF @@ERROR <> 0 GOTO FatalError
				
				DELETE FROM t_pv_ps_paymentscheduler
				WHERE id_sess IN (SELECT id_sess FROM #tmp)
				IF @@ERROR <> 0 GOTO FatalError
				
				DROP TABLE #tmp
				IF @@ERROR <> 0 GOTO FatalError
				
				SET @status = 0
				RETURN 0
				
				FatalError:
			  	SET @status = -1
					RETURN -1
				END
      	
      ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[mtconcat]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mtconcat]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
create function [dbo].[mtconcat](@str1 varchar(4000),@str2 varchar(4000)) returns varchar(4000)
as
begin
return @str1 + @str2
end
	' 
END
GO
/****** Object:  StoredProcedure [dbo].[DeleteBillGroupData]    Script Date: 06/02/2008 11:43:35 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteBillGroupData]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
Delete billing group data
=========================================================== */
CREATE PROCEDURE [dbo].[DeleteBillGroupData]
(
  @tableName VARCHAR(20)
)
AS
BEGIN
   BEGIN TRAN
   
   DECLARE @sql NVARCHAR(4000)
 
   /* Hold the specified billing group id''s in  @billgroups */
   /* Insert the billgroup id''s in the table specified by @tableName into @billgroups such
        that pull lists come first */
   SET @sql = N''DECLARE @billgroups TABLE ''+
                        ''( '' + 
                        ''  id_billgroup INT NOT NULL, ''+
                        ''  id_usage_interval INT NOT NULL '' +
                        '') '' +
                        ''INSERT INTO  @billgroups '' + 
                        ''SELECT t.id_billgroup, bg.id_usage_interval '' +
                        ''FROM '' +
                        @tableName + '' t '' +
                        ''INNER JOIN t_billgroup bg '' +
                        ''ON bg.id_billgroup = t.id_billgroup '' +
                        ''ORDER BY bg.id_parent_billgroup DESC '' +

                         -- delete from t_billgroup_member
                        ''DELETE bgm '' +
                        ''FROM t_billgroup_member bgm '' +
                        ''INNER JOIN t_billgroup bg '' +
                        ''ON bg.id_billgroup = bgm.id_billgroup '' +
                        ''INNER JOIN @billgroups bgt '' +
                        ''ON bgt.id_billgroup = bgm.id_billgroup AND '' +
                        ''bgt.id_usage_interval = bg.id_usage_interval '' +

                        -- delete from t_billgroup_member_history
		 ''DELETE bgmh '' +
		 ''FROM t_billgroup_member_history bgmh '' +
		 ''INNER JOIN t_billgroup bg '' +
		 ''  ON bg.id_billgroup = bgmh.id_billgroup '' +
		 ''INNER JOIN @billgroups bgt '' +
		 ''  ON bgt.id_billgroup = bgmh.id_billgroup AND '' +
		 ''        bgt.id_usage_interval = bg.id_usage_interval '' +

		-- delete from t_billgroup
		''DELETE bg '' +
		''FROM t_billgroup bg '' +
		''INNER JOIN @billgroups bgt '' +
		''  ON bgt.id_billgroup = bg.id_billgroup AND '' +
		''        bgt.id_usage_interval = bg.id_usage_interval '' +
		 
   		-- delete from t_recevent_run_details
		 ''DELETE rrd '' +
		 ''FROM t_recevent_run_details rrd '' +
                         ''INNER JOIN t_recevent_run rr '' +
                         '' ON rr.id_run = rrd.id_run '' +
		 ''INNER JOIN t_recevent_inst ri '' +
                         '' ON ri.id_instance = rr.id_instance '' +
                         ''INNER JOIN @billgroups bgt '' +
                         '' ON bgt.id_billgroup = ri.id_arg_billgroup AND '' +
                         ''       bgt.id_usage_interval = ri.id_arg_interval '' +

                         -- delete from t_recevent_run_batch
		 ''DELETE rrb '' +
		 ''FROM t_recevent_run_batch rrb '' +
                         ''INNER JOIN t_recevent_run rr '' +
                         '' ON rr.id_run = rrb.id_run '' +
                         ''INNER JOIN t_recevent_inst ri '' +
                         '' ON ri.id_instance = rr.id_instance '' +
                         ''INNER JOIN @billgroups bgt '' +
                         '' ON bgt.id_billgroup = ri.id_arg_billgroup AND '' +
                         ''       bgt.id_usage_interval = ri.id_arg_interval '' +

                         -- delete from t_recevent_run_failure_acc
		 ''DELETE rrf '' +
		 ''FROM t_recevent_run_failure_acc rrf '' +
                         ''INNER JOIN t_recevent_run rr '' +
                         '' ON rr.id_run = rrf.id_run '' +
		 ''INNER JOIN t_recevent_inst ri '' +
                         '' ON ri.id_instance = rr.id_instance '' +
                         ''INNER JOIN @billgroups bgt '' +
                         '' ON bgt.id_billgroup = ri.id_arg_billgroup AND '' +
                         ''       bgt.id_usage_interval = ri.id_arg_interval '' +

                         -- delete from t_recevent_run
		 ''DELETE rr '' +
		 ''FROM t_recevent_run rr '' +
                         ''INNER JOIN t_recevent_inst ri '' +
                         '' ON ri.id_instance = rr.id_instance '' +
                         ''INNER JOIN @billgroups bgt '' +
                         '' ON bgt.id_billgroup = ri.id_arg_billgroup AND '' +
                         ''       bgt.id_usage_interval = ri.id_arg_interval '' +
   
                         -- delete from t_recevent_inst_audit
		 ''DELETE ria '' +
		 ''FROM t_recevent_inst_audit ria '' +
                         ''INNER JOIN t_recevent_inst ri '' +
                         '' ON ri.id_instance = ria.id_instance '' +
                         ''INNER JOIN @billgroups bgt '' +
                         '' ON bgt.id_billgroup = ri.id_arg_billgroup AND '' +
                         ''       bgt.id_usage_interval = ri.id_arg_interval '' +
  
 	             -- delete from t_recevent_inst
		 ''DELETE ri '' +
		 ''FROM t_recevent_inst ri '' +
                         ''INNER JOIN @billgroups bgt '' +
                         '' ON bgt.id_billgroup = ri.id_arg_billgroup AND '' +
                         ''       bgt.id_usage_interval = ri.id_arg_interval '' 

   PRINT @sql
   EXEC sp_executesql @sql 

   COMMIT TRAN
END
' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[MTHexFormat]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTHexFormat]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
create function [dbo].[MTHexFormat](@value integer) returns varchar(255)
as
begin
 declare @binvalue varbinary(255)
	      ,@charvalue varchar(255)
        ,@i int
        ,@length int
        ,@hexstring char(16)
 select @charvalue = ''''
       ,@i=1
       ,@binvalue = cast(@value as varbinary(4))
       ,@length=datalength(@binvalue)
       ,@hexstring = ''0123456789abcdef''
 WHILE (@i<=@length)
   begin
     declare @tempint int
            ,@firstint int
            ,@secondint int
     select @tempint=CONVERT(int, SUBSTRING(@binvalue,@i,1))
     select @firstint=FLOOR(@tempint/16)
     select @secondint=@tempint - (@firstint*16)
     select @charvalue=@charvalue
           +SUBSTRING(@hexstring,@firstint+1,1)
           +SUBSTRING(@hexstring, @secondint+1, 1)
    select @i=@i+1
   end
 return @charvalue
end	' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreatePopTmpBillGroupStatus]    Script Date: 06/02/2008 11:43:30 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreatePopTmpBillGroupStatus]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
Used in __GET_EOP_EVENT_INSTANCES_FOR_DISPLAY__
===========================================================*/
CREATE PROCEDURE [dbo].[CreatePopTmpBillGroupStatus]
(
   @tx_tableName NVARCHAR(50),
   @id_interval INT,
   @status INT OUTPUT
)
AS

BEGIN     
   SET @status = -1

   DECLARE @sql nvarchar (4000)
   
   /* Drop the table @tx_tableName if it exists*/
   SET @sql = N''IF EXISTS (SELECT 1 FROM dbo.sysobjects WHERE id = object_id(N''''''
			                    + @tx_tableName 
			                    + N'''''') AND OBJECTPROPERTY(id, N''''IsUserTable'''') = 1)''
			                    + N'' DROP TABLE '' + @tx_tableName 
   EXEC sp_executesql @sql
   
   /* Create the table @tx_tableName */
   SET @sql = N''CREATE TABLE '' + @tx_tableName +
	            N''(id_billgroup INT NOT NULL, '' +
              N'' id_usage_interval INT NOT NULL, '' +
              N'' status CHAR(1) NOT NULL )'' 

   EXEC sp_executesql @sql

  /* Insert data from vw_all_billing_groups_status into @tx_tableName */
  IF (@id_interval IS NULL)
  BEGIN
   SET @sql = N''INSERT INTO '' + @tx_tableName +
	            N'' SELECT * FROM vw_all_billing_groups_status ''
  END
  ELSE
  BEGIN
    SET @sql = N''INSERT INTO '' + @tx_tableName +
	             N'' SELECT * FROM vw_all_billing_groups_status WHERE id_usage_interval = '' + CAST( @id_interval  AS NVARCHAR(30)) 
  END

  EXEC sp_executesql @sql
 
  SET @status = 0
END
         ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[poConstrainedCycleType]    Script Date: 06/02/2008 11:44:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[poConstrainedCycleType]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
	
-- returns the required cycle type of a BCR Constrained PO or zero if there is none
CREATE FUNCTION [dbo].[poConstrainedCycleType](@offeringID INTEGER)
RETURNS INTEGER
AS
BEGIN
	DECLARE @retval AS INTEGER

  SELECT 
    @retval = MAX(result.id_cycle_type)
  FROM (
    SELECT
      CASE WHEN t_recur.id_cycle_type IS NOT NULL AND
                t_recur.tx_cycle_mode = ''BCR Constrained'' THEN
        t_recur.id_cycle_type 
      ELSE
        CASE WHEN t_discount.id_cycle_type IS NOT NULL THEN
      t_discount.id_cycle_type
        ELSE 
          CASE WHEN t_aggregate.id_cycle_type IS NOT NULL THEN
            t_aggregate.id_cycle_type 
          ELSE
            NULL
          END
        END
      END AS id_cycle_type
    FROM t_pl_map
      LEFT OUTER JOIN t_recur ON t_recur.id_prop = t_pl_map.id_pi_template OR
                                 t_recur.id_prop = t_pl_map.id_pi_instance
      LEFT OUTER JOIN t_discount ON t_discount.id_prop = t_pl_map.id_pi_template OR
                                    t_discount.id_prop = t_pl_map.id_pi_instance
      LEFT OUTER JOIN t_aggregate ON t_aggregate.id_prop = t_pl_map.id_pi_template OR
                                     t_aggregate.id_prop = t_pl_map.id_pi_instance
	WHERE
  t_pl_map.id_po = @offeringID
  and t_pl_map.id_paramtable is null
  ) result

  IF (@retval is NULL) BEGIN
   	SET @retval = 0
  END
  RETURN @retval
END
	
	' 
END
GO
/****** Object:  StoredProcedure [dbo].[GetRecurringEventDepsByInst]    Script Date: 06/02/2008 11:43:46 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetRecurringEventDepsByInst]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
create  PROCEDURE [dbo].[GetRecurringEventDepsByInst]( 
  @dep_type varchar(30),
  @dt_now datetime,
  @id_instances varchar(4000),
  @status_filter varchar(4000)
)
AS
BEGIN
	declare @sql varchar(4000)
	declare @dt varchar(30)

	set @dt = convert(varchar, @dt_now, 21)


	set @sql = ''SELECT 
  deps.id_orig_instance OriginalInstanceID,
	  deps.tx_orig_name OriginalEventName,
	  deps.tx_orig_billgroup_support OriginalBillGroupSupportType,
	  deps.tx_name EventName,
	  evt.tx_type EventType,
	  deps.id_instance InstanceID,
	  deps.id_arg_interval ArgIntervalID,
	  deps.dt_arg_start ArgStartDate,
	  deps.dt_arg_end ArgEndDate,
	  deps.tx_status Status,
	  deps.id_orig_billgroup OriginalBillingGroupID,
	  deps.id_billgroup BillingGroupID,
	  deps.b_critical_dependency IsCriticalDependency,
	  deps.tx_billgroup_support BillGroupSupportType
	FROM dbo.GetEvent'' + @dep_type + ''Deps(''''''+ @dt + '''''', '''''' + @id_instances + '''''') deps 
	INNER JOIN t_recevent evt ON evt.id_event = deps.id_event
	WHERE 
	  /* excludes identity dependencies */
	  (deps.id_orig_instance <> deps.id_instance OR
	  /* allows missing instances in case of execution deps */
	  deps.id_instance IS NULL)
	  '' + @status_filter + ''
	/* this ordering is expected by usm for display purposes */
	ORDER BY OriginalInstanceID ASC, ArgIntervalID DESC, 
		EventType ASC, EventName ASC, ArgStartDate DESC''

	exec(@sql)

end
    ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[IsInSameCorporateAccount]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsInSameCorporateAccount]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
create function [dbo].[IsInSameCorporateAccount](@acc1 int,@acc2 int,@refdate datetime) returns int
as
begin
 
  declare @retval int

  declare @id_corp1 int
  select @id_corp1 = id_ancestor
  from t_account_ancestor anc
  inner join t_account acc
  on anc.id_ancestor = acc.id_acc
  inner join t_account_type atype
  on acc.id_type = atype.id_type
  where anc.id_descendent = @acc1
  and @refdate between anc.vt_start AND anc.vt_end
  and atype.b_iscorporate = ''1''


  declare @id_corp2 int
  select @id_corp2 = id_ancestor
  from t_account_ancestor anc
  inner join t_account acc
  on anc.id_ancestor = acc.id_acc
  inner join t_account_type atype
  on acc.id_type = atype.id_type
  where anc.id_descendent = @acc2
  and @refdate between anc.vt_start AND anc.vt_end
  and atype.b_iscorporate = ''1''


if (@id_corp1 = @id_corp2)
  select @retval = 1
else if (@id_corp1 is null AND @id_corp2 is null)
	select @retval = 1
else 
	select @retval = 0

  

	return @retval

  
	return @retval
end
	' 
END
GO
/****** Object:  StoredProcedure [dbo].[InsertProductViewUniqueKey]    Script Date: 06/02/2008 11:43:56 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertProductViewUniqueKey]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			create proc [dbo].[InsertProductViewUniqueKey] 
				@id_prod_view int,
				@constraint_name varchar(100),
				@nm_table_name varchar(100),
				@id_unique_cons int OUTPUT
			as
			insert into t_unique_cons
				(id_prod_view, constraint_name, nm_table_name)
			values
				(@id_prod_view, @constraint_name, @nm_table_name)

			select @id_unique_cons = @@identity
	' 
END
GO
/****** Object:  StoredProcedure [dbo].[DeleteUniqueKeyMetadata]    Script Date: 06/02/2008 11:43:37 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteUniqueKeyMetadata]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      /*
      	DeleteUniqueKeyMetadata
      
      	Deletes the metadata for a unique key.  Removes all
      	rows for a given unique key in the tables: t_unqiue_cons &
      	t_unique_cons_columns.
      	
      	@consname - name of unique key 
      
      */
      create proc [dbo].[DeleteUniqueKeyMetadata](
      	@consname varchar(200)
      	) as
      begin
      
      -- Env set up
      set nocount on
      declare @err int
      
      declare @localtran int
      set @localtran = 0
      if (@@trancount = 0) begin
      	begin tran
      	set @localtran = 1
      end
      
      -- Delete key colums first
      --
      delete from t_unique_cons_columns
      where id_unique_cons in (
      	select id_unique_cons from t_unique_cons
      	where lower(constraint_name) = lower(@consname))
      set @err = @@error
      
      if (@err <> 0) begin
      	raiserror(''Cannot delete key [%s].'', 16, 1, @consname)
      	if (@localtran = 1) rollback
      	return 1
      end
      
      -- Delete key name 
      --
      delete from t_unique_cons
      where lower(constraint_name) = lower(@consname)
      set @err = @@error
      
      if (@err <> 0) begin
      	raiserror(''Cannot delete key [%s].'', 16, 1, @consname)
      	if (@localtran = 1) rollback
      	return 1
      end
      
      if (@localtran = 1)
      	commit
      
      end --proc
 	' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[CheckGroupReceiverEBCRConstraint]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckGroupReceiverEBCRConstraint]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
  
CREATE FUNCTION [dbo].[CheckGroupReceiverEBCRConstraint]
(
  @dt_now DATETIME, -- system date
  @id_group INT     -- group ID to check
)
RETURNS INT  -- 1 for success, negative HRESULT for failure
AS
BEGIN
  -- checks to see if a group subscription and all of its''
  -- receivers'' payers comply with the EBCR payer cycle constraints:
  -- 1) that all receivers'' payers must have the same billing cycle
  -- 2) that billing cycle must be EBCR compatible.

  DECLARE @results TABLE 
  (
    id_acc INT, -- receiver account
    id_usage_cycle INT, -- payer''s cycle
    b_compatible INT -- EBCR compatibility: 1 or 0
  )

  -- store intermediate results away for later use since different groupings will need to be made
  INSERT INTO @results
  SELECT gsrm.id_acc, payercycle.id_usage_cycle, dbo.CheckEBCRCycleTypeCompatibility(payercycle.id_cycle_type, rc.id_cycle_type)
  FROM t_gsub_recur_map gsrm
  INNER JOIN t_group_sub gs ON gs.id_group = gsrm.id_group
  INNER JOIN t_sub sub ON sub.id_group = gs.id_group
  INNER JOIN t_pl_map plmap ON plmap.id_po = sub.id_po AND
                               plmap.id_pi_instance = gsrm.id_prop
  INNER JOIN t_recur rc ON rc.id_prop = plmap.id_pi_instance
  INNER JOIN t_payment_redirection payer ON 
    payer.id_payee = gsrm.id_acc AND
    -- checks all payer''s who overlap with the group sub
    payer.vt_end >= sub.vt_start AND
    payer.vt_start <= sub.vt_end
  INNER JOIN t_acc_usage_cycle auc ON auc.id_acc = payer.id_payer
  INNER JOIN t_usage_cycle payercycle ON payercycle.id_usage_cycle = auc.id_usage_cycle
  WHERE 
    rc.tx_cycle_mode = ''EBCR'' AND
    rc.b_charge_per_participant = ''N'' AND
    -- checks only the requested group
    gs.id_group = @id_group AND
    plmap.id_paramtable IS NULL AND
    -- only consider receivers based on wall-clock transaction time
    @dt_now BETWEEN gsrm.tt_start AND gsrm.tt_end AND
    -- TODO: it would be better if we didn''t consider subscriptions that ended
    --       in a hard closed interval so that retroactive changes would be properly guarded.
    -- only consider current or future group subs
    -- don''t worry about group subs in the past
    ((@dt_now BETWEEN sub.vt_start AND sub.vt_end) OR
     (sub.vt_start > @dt_now))

  -- checks that receivers'' payers are compatible with the EBCR cycle type
  IF EXISTS 
  (
    SELECT NULL
    FROM @results
    WHERE b_compatible = 0
    GROUP BY id_acc
  )
    RETURN -289472441 -- MTPCUSER_EBCR_CYCLE_CONFLICTS_WITH_PAYER_OF_RECEIVER


  -- checks that only one payer cycle was found
  DECLARE @count INT
  SELECT @count = COUNT(*)
  FROM
  ( 
    SELECT 1 a
    FROM @results
    GROUP BY id_usage_cycle 
  ) cycles
  IF (@count > 1)
    RETURN -289472440 -- MTPCUSER_EBCR_RECEIVERS_CONFLICT_WITH_EACH_OTHER

  RETURN 1 -- success
END
  
	' 
END
GO
/****** Object:  StoredProcedure [dbo].[GetUniqueKeyMetadata]    Script Date: 06/02/2008 11:43:47 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetUniqueKeyMetadata]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			/*
				Proc: GetUniqueKeyMetadata

				Returns unique key columns for all unique keys defined on a table.

				@tabname - table name
			*/
			create proc [dbo].[GetUniqueKeyMetadata]
				@tabname varchar(300)
			as
			begin


			select 
				uc.constraint_name,
				ucc.position as ordinal_position,
				pvp.nm_column_name as column_name
			from t_prod_view pv
			join t_unique_cons uc
				on pv.id_prod_view = uc.id_prod_view
			join t_unique_cons_columns ucc
				on uc.id_unique_cons = ucc.id_unique_cons
			join t_prod_view_prop pvp
				on ucc.id_prod_view_prop = pvp.id_prod_view_prop
			where pv.nm_table_name = @tabname
			order by constraint_name, ordinal_position, column_name

			end
 	' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[CheckGroupMembershipEBCRConstraint]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckGroupMembershipEBCRConstraint]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
  

CREATE FUNCTION [dbo].[CheckGroupMembershipEBCRConstraint]
(
  @dt_now DATETIME, -- system date
  @id_group INT     -- group ID to check
)
RETURNS INT  -- 1 for success, negative HRESULT for failure
AS
BEGIN

  -- checks to see if a group subscription and all of its
  -- members comply with EBCR payer cycle constraints:
  --   1) that for a member, all of its payers have the same billing cycle
  --   2) that this billing cycle is EBCR compatible.

  DECLARE @results TABLE 
  (
    id_acc INT, -- member account (payee)
    id_usage_cycle INT, -- payer''s cycle
    b_compatible INT -- EBCR compatibility: 1 or 0
  )

  -- checks group member''s payers
  INSERT INTO @results
  SELECT 
    pay.id_payee,
    payercycle.id_usage_cycle,
    dbo.CheckEBCRCycleTypeCompatibility(payercycle.id_cycle_type, rc.id_cycle_type)
  FROM t_group_sub gs
  INNER JOIN t_sub sub ON sub.id_group = gs.id_group
  INNER JOIN t_pl_map plmap ON plmap.id_po = sub.id_po
  INNER JOIN t_recur rc ON rc.id_prop = plmap.id_pi_instance
  INNER JOIN t_gsubmember gsm ON gs.id_group = gsm.id_group
  INNER JOIN t_payment_redirection pay ON 
    pay.id_payee = gsm.id_acc AND
    -- checks all payer''s who overlap with the group sub
    pay.vt_end >= sub.vt_start AND
    pay.vt_start <= sub.vt_end
  INNER JOIN t_acc_usage_cycle auc ON auc.id_acc = pay.id_payer
  INNER JOIN t_usage_cycle payercycle ON payercycle.id_usage_cycle = auc.id_usage_cycle
  WHERE 
    rc.tx_cycle_mode = ''EBCR'' AND
    rc.b_charge_per_participant = ''Y'' AND
    gs.id_group = @id_group AND
    plmap.id_paramtable IS NULL AND
    -- TODO: it would be better if we didn''t consider subscriptions that ended
    --       in a hard closed interval so that retroactive changes would be properly guarded.
    -- only consider current or future group subs
    -- don''t worry about group subs in the past
    ((@dt_now BETWEEN sub.vt_start AND sub.vt_end) OR
     (sub.vt_start > @dt_now))
  OPTION (FORCE ORDER)
 -- checks that members'' payers are compatible with the EBCR cycle type
  IF EXISTS 
  (
    SELECT NULL
    FROM @results
    WHERE b_compatible = 0
  )
    RETURN -289472443 -- MTPCUSER_EBCR_CYCLE_CONFLICTS_WITH_PAYER_OF_MEMBER

  -- checks for each member there is only one payer cycle across all payers
  IF EXISTS
  (
    SELECT NULL
    FROM @results r
    INNER JOIN @results r2 ON r2.id_acc = r.id_acc AND
                              r2.id_usage_cycle <> r.id_usage_cycle
  )
    RETURN -289472442 -- MTPCUSER_EBCR_MEMBERS_CONFLICT_WITH_EACH_OTHER

  RETURN 1 -- success
END
  
	' 
END
GO
/****** Object:  StoredProcedure [dbo].[InsertProductViewUniqueKeyCol]    Script Date: 06/02/2008 11:43:56 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertProductViewUniqueKeyCol]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			create proc [dbo].[InsertProductViewUniqueKeyCol] 
				@id_unique_cons int,
				@id_prod_view_prop int,
				@position int
			as
			insert into t_unique_cons_columns
				(id_unique_cons, id_prod_view_prop, position)
			values
				(@id_unique_cons, @id_prod_view_prop, @position)
		' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[IsBillingCycleUpdateProhibitedByGroupEBCR]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsBillingCycleUpdateProhibitedByGroupEBCR]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
  
CREATE FUNCTION [dbo].[IsBillingCycleUpdateProhibitedByGroupEBCR]
(
  @dt_now DATETIME,
  @id_acc INT
)
RETURNS INT 
BEGIN

  -- checks if the account pays for a member of a group subscription
  -- associated with a Per Participant EBCR RC
  IF EXISTS 
  (
    SELECT NULL
    FROM t_gsubmember gsm
    INNER JOIN t_group_sub gs ON gs.id_group = gsm.id_group
    INNER JOIN t_sub sub ON sub.id_group = gs.id_group
    INNER JOIN t_pl_map plmap ON plmap.id_po = sub.id_po
    INNER JOIN t_recur rc ON rc.id_prop = plmap.id_pi_instance
    INNER JOIN t_payment_redirection payer ON 
    payer.id_payee = gsm.id_acc AND
    -- checks all payer''s who overlap with the group sub
    payer.vt_end >= sub.vt_start AND
    payer.vt_start <= sub.vt_end
    INNER JOIN t_acc_usage_cycle payercycle ON payercycle.id_acc = payer.id_payer
    WHERE 
      rc.tx_cycle_mode = ''EBCR'' AND
      rc.b_charge_per_participant = ''Y'' AND
      payer.id_payer = @id_acc AND
      plmap.id_paramtable IS NULL AND
      -- TODO: it would be better if we didn''t consider subscriptions that ended
      --       in a hard closed interval so that retroactive changes would be properly guarded.
      -- only consider current or future group subs
      -- don''t worry about group subs in the past
      ((@dt_now BETWEEN sub.vt_start AND sub.vt_end) OR
       (sub.vt_start > @dt_now))
  )
    RETURN -289472439  -- MTPCUSER_CANNOT_CHANGE_BILLING_CYCLE_EBCR_PAYER_OF_MEMBER


  -- checks if the account pays for a receiver of a group subscription
  -- associated with a Per Subscriber EBCR RC
  IF EXISTS
  (
    SELECT NULL
    FROM t_gsub_recur_map gsrm
    INNER JOIN t_group_sub gs ON gs.id_group = gsrm.id_group
    INNER JOIN t_sub sub ON sub.id_group = gs.id_group
    INNER JOIN t_pl_map plmap ON plmap.id_po = sub.id_po AND
                                 plmap.id_pi_instance = gsrm.id_prop
    INNER JOIN t_recur rc ON rc.id_prop = plmap.id_pi_instance
    INNER JOIN t_payment_redirection payer ON 
      payer.id_payee = gsrm.id_acc AND
      -- checks all payer''s who overlap with the group sub
      payer.vt_end >= sub.vt_start AND
      payer.vt_start <= sub.vt_end
    INNER JOIN t_acc_usage_cycle payercycle ON payercycle.id_acc = payer.id_payer
    WHERE 
      rc.tx_cycle_mode = ''EBCR'' AND
      rc.b_charge_per_participant = ''N'' AND
      -- checks only the requested group
      payer.id_payer = @id_acc AND
      plmap.id_paramtable IS NULL AND
      -- only consider receivers based on wall-clock transaction time
      @dt_now BETWEEN gsrm.tt_start AND gsrm.tt_end AND
      -- TODO: it would be better if we didn''t consider subscriptions that ended
      --       in a hard closed interval so that retroactive changes would be properly guarded.
      -- only consider current or future group subs
      -- don''t worry about group subs in the past
      ((@dt_now BETWEEN sub.vt_start AND sub.vt_end) OR
       (sub.vt_start > @dt_now))
  )
    RETURN -289472438  -- MTPCUSER_CANNOT_CHANGE_BILLING_CYCLE_EBCR_PAYER_OF_RECEIVER
	
  RETURN 1 -- success, can update the billing cycle
END
  
	' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[WarnOnEBCRMemberStartDateChang]    Script Date: 06/02/2008 11:44:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[WarnOnEBCRMemberStartDateChang]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
				
CREATE FUNCTION [dbo].[WarnOnEBCRMemberStartDateChang]
(
  @id_sub INT, -- subscription ID
  @id_acc INT  -- member account ID
)
RETURNS INT  -- 1 if a warning should be raised, 0 otherwise
AS
BEGIN

  -- checks to see if the subscription is associated with an EBCR RC
  -- and that the EBCR cycle type and the subscriber''s billing cycle
  -- are such that the start date would be used in derivations
  IF EXISTS 
    (
      SELECT *
      FROM t_sub sub 
      INNER JOIN t_group_sub gs ON gs.id_group = sub.id_group
      INNER JOIN t_gsubmember gsm ON gsm.id_group = gs.id_group
      INNER JOIN t_pl_map plmap ON plmap.id_po = sub.id_po
      INNER JOIN t_recur rc ON rc.id_prop = plmap.id_pi_instance
      INNER JOIN t_payment_redirection pay ON 
        pay.id_payee = gsm.id_acc AND
        -- checks all payer''s who overlap with the group sub
        pay.vt_end >= sub.vt_start AND
        pay.vt_start <= sub.vt_end
      INNER JOIN t_acc_usage_cycle auc ON auc.id_acc = pay.id_payer
      INNER JOIN t_usage_cycle payercycle ON payercycle.id_usage_cycle = auc.id_usage_cycle
      WHERE 
        rc.tx_cycle_mode = ''EBCR'' AND
        rc.b_charge_per_participant = ''Y'' AND
        sub.id_sub = @id_sub AND
        gsm.id_acc = @id_acc AND
        plmap.id_paramtable IS NULL AND
        payercycle.id_cycle_type = 1 AND -- the subscriber is Monthly
        rc.id_cycle_type IN (7, 8) -- and the EBCR cycle type is either Quarterly or Annually
    )
      RETURN 1 -- warn the user!

  RETURN 0 -- don''t warn
END
				
			 ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[MTMaxDate]    Script Date: 06/02/2008 11:44:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTMaxDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
				create function [dbo].[MTMaxDate]() returns datetime
				as
				begin
					return ''2038''
				end
		' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[MTMinDate]    Script Date: 06/02/2008 11:44:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTMinDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
			create function [dbo].[MTMinDate]() returns datetime
			as
			begin
				return ''1753''
			end
			' 
END
GO
/****** Object:  StoredProcedure [dbo].[DeleteProductViewRecords]    Script Date: 06/02/2008 11:43:36 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteProductViewRecords]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
				CREATE PROC [dbo].[DeleteProductViewRecords]
										@nm_productview varchar(255),
										@id_pi_template int,
										@id_interval int,
										@id_view int
				AS
				DECLARE @pv_delete_stmt varchar(1000)
 				DECLARE @usage_delete_stmt varchar(1000)
 				DECLARE @strInterval varchar(255)
 				DECLARE @strPITemplate varchar(255)
				DECLARE @strView varchar(255)
 				DECLARE @WhereClause varchar(255)

				--convert int to strings
				SELECT @strInterval = CONVERT(varchar(255), @id_interval)
				SELECT @strPITemplate = CONVERT(varchar(255), @id_pi_template)
				SELECT @strView = CONVERT(varchar(255), @id_view)
				SELECT @WhereClause = '' WHERE id_usage_interval='' + @strInterval + '' AND id_pi_template='' + 
				@strPITemplate + '' AND id_view='' + @strView

				SELECT 
					@pv_delete_stmt = ''DELETE FROM '' + @nm_productview +  '' WHERE 
					exists (select 1 from t_acc_usage au ''
					 + @WhereClause +
					'' and au.id_sess = '' 
					+ @nm_productview + ''.id_sess and au.id_usage_interval = ''
					+ @nm_productview + ''.id_usage_interval)''
				SELECT 
					@usage_delete_stmt = ''DELETE FROM t_acc_usage''  + @WhereClause
				BEGIN TRAN
					EXECUTE(@pv_delete_stmt)
					EXECUTE(@usage_delete_stmt)
				COMMIT TRAN
				
' 
END
GO
/****** Object:  StoredProcedure [dbo].[DelPVRecordsForAcct]    Script Date: 06/02/2008 11:43:38 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DelPVRecordsForAcct]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
				CREATE PROC [dbo].[DelPVRecordsForAcct]
										@nm_productview varchar(255),
										@id_pi_template int,
										@id_interval int,
										@id_view int,
										@id_acc int
				AS
				DECLARE @pv_delete_stmt varchar(1000)
 				DECLARE @usage_delete_stmt varchar(1000)
 				DECLARE @strInterval varchar(255)
 				DECLARE @strPITemplate varchar(255)
 				DECLARE @strView varchar(255)
 				DECLARE @strAccount varchar(255)
 				DECLARE @WhereClause varchar(255)

				--convert int to strings
				SELECT @strInterval = CONVERT(varchar(255), @id_interval)
				SELECT @strPITemplate = CONVERT(varchar(255), @id_pi_template)
				SELECT @strView = CONVERT(varchar(255), @id_view)
				SELECT @strAccount = CONVERT(varchar(255), @id_acc)
				SELECT @WhereClause = '' WHERE id_usage_interval='' + @strInterval + '' AND id_pi_template='' + @strPITemplate + '' AND id_view='' + @strView + '' AND id_acc='' + @strAccount

				SELECT 
					@pv_delete_stmt = ''DELETE FROM '' + @nm_productview +  '' WHERE 
					exists (select 1 from t_acc_usage au ''
					 + @WhereClause +
					'' and au.id_sess = '' 
					+ @nm_productview + ''.id_sess and au.id_usage_interval = ''
					+ @nm_productview + ''.id_usage_interval)''
				SELECT 
					@usage_delete_stmt = ''DELETE FROM t_acc_usage''  + @WhereClause
				BEGIN TRAN
					EXECUTE(@pv_delete_stmt)
					EXECUTE(@usage_delete_stmt)
				COMMIT TRAN
			
' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreateReportingDB]    Script Date: 06/02/2008 11:43:31 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateReportingDB]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
    
	   create procedure [dbo].[CreateReportingDB] (
                    @strDBName nvarchar(100),
                    @strNetmeterDBName nvarchar(100),
                    @strDataLogFilePath nvarchar(255),
                    @dbSize integer,
					@return_code integer output
                   )
as
  set @return_code = 0
  declare @strDataFileName    nvarchar(255);
  declare @strLogFileName     nvarchar(255);
  declare @strDBCreateQuery   nvarchar(2000);
  declare @strAddDbToBackupQuery nvarchar(2000);
  declare @strProcess         nvarchar(100)
  declare @nSQLRetCode        int

  declare @bDebug tinyint
  set @bDebug = 1

  declare @strsize nvarchar(5);
  set @strsize = CAST(@dbSize AS nvarchar(5))
  set  @strDataFileName = @strDataLogFilePath + ''\'' + @strDBName + ''_Data'';
  set  @strLogFileName =  @strDataLogFilePath + ''\'' + @strDBName + ''_Log'';


  set @strDBCreateQuery = ''CREATE DATABASE ['' + @strDBName + '']  ON 
                           ( 
                                    NAME = N'''''' + @strDBName + ''_Data'' + '''''', 
                                FILENAME = N'''''' + @strDataFileName + ''.MDF'' + '''''' , 
                                    SIZE = '' + @strsize + '', 
                              FILEGROWTH = 20%
                            ) 
                            LOG ON 
                            (
                                    NAME = N'''''' + @strDBName + ''_Log'' + '''''', 
                                FILENAME = N'''''' + @strLogFileName + ''.LDF'' + '''''' , 
                                    SIZE = '' + @strsize + '', 
                              FILEGROWTH = 10%
                            )''
  set @strAddDbToBackupQuery = ''insert into '' + @strNetmeterDBName + ''..t_ReportingDBLog(NameOfReportingDB, doBackup)
							    Values('''''' + @strDBName + '''''', ''''Y'''')'';
                             
  if ( @bDebug = 1 )
      print ''About to execute create DB Query : '' + @strDBCreateQuery;  

  exec sp_executesql @strDBCreateQuery
  select @nSQLRetCode = @@ERROR
  if ( @nSQLRetCode <> 0 )
  begin
    set @strProcess = object_name(@@procid)
    print ''An error occured while creating the database. Procedure ('' + @strProcess + '')'';
    set @return_code = -1
    return -1        
  end
  -- set the simple log option for database.
  SET @strDBCreateQuery = ''Alter Database '' + @strDBName + '' SET RECOVERY SIMPLE'';
  exec sp_executesql @strDBCreateQuery
  select @nSQLRetCode = @@ERROR
  if ( @nSQLRetCode <> 0 )
  begin
    set @strProcess = object_name(@@procid)
    print ''An error occured while setting the recovery option to Bulk-Logged to the created database. Procedure ('' + @strProcess + '')'';
    set @return_code = -1
    return -1        
  end

  if ( @bDebug = 1 )
      print ''About to execute add DB to backup table Query : '' + @strAddDBToBackupQuery;  
  
  exec sp_executesql @strAddDBToBackupQuery
  select @nSQLRetCode = @@ERROR
  if ( @nSQLRetCode <> 0 )
  begin
    set @strProcess = object_name(@@procid)
    print ''An error occured while adding database to t_ReportingDBLog table. Procedure ('' + @strProcess + '')'';
    set @return_code = -1
    return -1        
  end
  
  return 0
			
			' 
END
GO
/****** Object:  StoredProcedure [dbo].[Backout]    Script Date: 06/02/2008 11:43:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Backout]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
    
		Create Procedure [dbo].[Backout](@rerun_table_name nvarchar(30), @delete_failed_records VARCHAR(1)) as
		begin
			declare @sql nvarchar(4000)

			-- values we get from the cursor
			declare @tablename varchar(255)
			declare @id_view int

			-- update the state in t_session_state

			-- delete from the productviews.
			set @sql = N''DECLARE tablename_cursor CURSOR FOR
			select rr.id_view, pv.nm_table_name from 
				t_prod_view pv
				inner join '' + @rerun_table_name + N'' rr on rr.id_view = pv.id_view
				where rr.tx_state = ''''A''''
				group by rr.id_view, pv.nm_table_name''
			EXEC sp_executesql @sql

			OPEN tablename_cursor
			FETCH NEXT FROM tablename_cursor into @id_view, @tablename
			WHILE @@FETCH_STATUS = 0
			BEGIN
				set @sql = N''DELETE pv from '' + @tablename
					+ N'' pv inner join '' + @rerun_table_name +
					N'' rerun on pv.id_sess = rerun.id_sess and pv.id_usage_interval = rerun.id_interval
						where rerun.tx_state = ''''A''''''
				exec (@sql)

				-- delete from the prod view unique key tables
				exec BackoutUniqueKeys @rerun_table_name, @tablename

				FETCH NEXT FROM tablename_cursor into @id_view, @tablename
			END
			CLOSE tablename_cursor
			DEALLOCATE tablename_cursor

			-- delete from t_acc_usage
			set @sql = N''delete acc from t_acc_usage acc '' +
				N'' inner join '' + @rerun_table_name +
				N'' rerun on acc.id_sess = rerun.id_sess and acc.id_usage_interval = rerun.id_interval
				where tx_state = ''''A''''''

			EXEC sp_executesql @sql

			-- delete from t_acc_usage unique key tables
			exec BackoutUniqueKeys @rerun_table_name, ''t_acc_usage''

			if (@delete_failed_records = ''Y'')
			BEGIN
				-- delete errors from t_failed_transaction and t_failed_transaction_msix
				set @sql = N''delete t_failed_transaction_msix from t_failed_transaction_msix msix
   					inner join t_failed_transaction ft on 
       			ft.id_failed_transaction = msix.id_failed_transaction
  					inner join '' + @rerun_table_name + N'' rr on
       			rr.id_source_sess = ft.tx_failurecompoundid
  					where rr.tx_state = ''''E''''''
		 	
				EXEC sp_executesql @sql

				set @sql = N''delete t_failed_transaction from 
					t_failed_transaction ft
  					inner join '' + @rerun_table_name + N'' rr
					on ft.tx_failurecompoundid = rr.id_source_sess
  					where rr.tx_state = ''''E''''''

				EXEC sp_executesql @sql
			END

		-- update the rerun table so we know these have been backed out
		set @sql = N''update '' + @rerun_table_name + N'' set tx_state = ''''B'''' where (tx_state = ''''A'''' or tx_state = ''''E'''')''
		EXEC sp_executesql @sql
		end
    
  ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[MTEndOfDay]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTEndOfDay]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
				create function [dbo].[MTEndOfDay](@indate as datetime) returns datetime
				as
				begin
					declare @retval as datetime
					set @retval =
						DATEADD(s,-1,
							DATEADD(d,1,	
								DATEADD(hh,-DATEPART(hh,@indate),
									DATEADD(mi,-DATEPART(mi,@indate),
										DATEADD(s,-DATEPART (s,@indate),
											DATEADD(ms,-DATEPART (ms,@indate),@indate)
										)
									)
								)
							)
						)
					return @retval
				end
	' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[MTStartOfDay]    Script Date: 06/02/2008 11:44:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTStartOfDay]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
      
              create FUNCTION [dbo].[MTStartOfDay] (@indate datetime) returns datetime
              as
              begin
                -- This commented line of code also works.  I have commented
                -- it out until we get a chance to test it and see which of
                -- these two ways is fastest.
                --
                -- return CAST(ROUND(CAST(@indate AS FLOAT), 0, 1) AS DATETIME)
                declare @retval as datetime
                select @retval =  DATEADD(hh,-DATEPART(hh, @indate),
                                  DATEADD(mi,-DATEPART(mi, @indate),
                                  DATEADD(s,-DATEPART (s, @indate),
                                  DATEADD(ms,-DATEPART(ms, @indate), @indate))))
                return @retval
              end
      
    ' 
END
GO
/****** Object:  StoredProcedure [dbo].[BackoutUniqueKeys]    Script Date: 06/02/2008 11:43:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BackoutUniqueKeys]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
    
		create proc [dbo].[BackoutUniqueKeys] (
				@rerun_tab nvarchar(30), 
				@usage_tab nvarchar(30)
				) as
		begin

			-- Quit nicely if partitioning is off
			if (dbo.IsSystemPartitioned() <> 1) begin
				return 0
			end
			
			declare @sql nvarchar(4000)
			declare @keytab varchar(255)
			
			-- get list of unique key table names 
			set @sql = N''declare keycur cursor for
				select uc.nm_table_name 
				from t_unique_cons uc
				join t_prod_view pv on uc.id_prod_view = pv.id_prod_view
				where pv.nm_table_name = '''''' + @usage_tab + ''''''''
			EXEC sp_executesql @sql
			
			-- delete from the unique key tables
			open keycur
			fetch next from keycur into @keytab
			while @@fetch_status = 0
			begin
				set @sql = ''delete uk '' + 
						''from '' + @keytab + '' uk '' +
						''join '' + @rerun_tab + '' rr '' +
		    			''  on uk.id_sess = rr.id_sess where rr.tx_state = ''''a''''''

				exec (@sql)
				fetch next from keycur into @keytab
			end
			deallocate keycur

		end
    
  ' 
END
GO
/****** Object:  StoredProcedure [dbo].[DeleteSourceData]    Script Date: 06/02/2008 11:43:37 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteSourceData]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
    
    Create   Procedure [dbo].[DeleteSourceData](@rerun_table_name nvarchar(30), @metradate nvarchar(30)) as
    begin
    declare @sql nvarchar(4000)

	  -- values we get from the cursor
	  declare @tablename varchar(255)
	  declare @id_svc int

	  -- delete from the service tables.
	  set @sql = N''DECLARE tablename_cursor CURSOR FOR
	    select rr.id_svc, svc.nm_table_name from 
		  t_enum_data ed
		  inner join '' + @rerun_table_name + N'' rr 
		  on rr.id_svc = ed.id_enum_data
		  inner join t_service_def_log svc
		  on svc.nm_service_def = ed.nm_enum_data
		  where (rr.tx_state = ''''B'''' OR
			rr.tx_state = ''''NA'''')
		  group by rr.id_svc, svc.nm_table_name''


	  EXEC sp_executesql @sql

	  OPEN tablename_cursor
	  FETCH NEXT FROM tablename_cursor into @id_svc, @tablename
	  WHILE @@FETCH_STATUS = 0
	  BEGIN
	   set @sql = N''DELETE from '' + @tablename
			+ N'' where id_source_sess in (select id_source_sess from '' + @rerun_table_name +
			N'' where id_svc = '' + CAST(@id_svc AS VARCHAR(10))
			+ N'' and (tx_state = ''''B'''' or tx_state = ''''NA''''))''

	   exec (@sql)
	   FETCH NEXT FROM tablename_cursor into @id_svc, @tablename
	  END
	  CLOSE tablename_cursor
	  DEALLOCATE tablename_cursor

	  -- update t_session_state
	  set @sql = N''update t_session_state
		  set dt_end =  '''''' + @metradate + N''''''
		  from '' + @rerun_table_name + N'' rr
		  inner join t_session_state ss
		  on rr.id_source_sess = ss.id_sess
		  where ss.dt_end = dbo.MTMaxDate()
		  and rr.tx_state = ''''B'''' ''

	  EXEC sp_executesql @sql

	  set @sql = N''INSERT INTO t_session_state (id_sess, dt_start, dt_end, tx_state) 
		    SELECT rr.id_source_sess, '''''' + @metradate + N'''''', dbo.MTMaxDate(), ''''D''''
		    from '' + @rerun_table_name + N'' rr
		    where rr.tx_state = ''''B'''' ''

	  EXEC sp_executesql @sql

	-- update t_message for pending and suspended transactions
	-- for pending, the dt_assigned and dt_completed are
	-- set to MTMAXDate, for suspended, the dt_completed 
	-- to MTMaxDate

	set @sql = N''update t_message
			set dt_assigned = dbo.MTMaxDate() 
			where id_message in (
			select ss.id_message from '' + @rerun_table_name + N'' rr
			inner join t_session sess WITH (READCOMMITTED)
			on sess.id_source_sess = rr.id_source_sess
			inner join t_session_set ss WITH (READCOMMITTED)
			on sess.id_ss = ss.id_ss
			inner join t_message msg WITH (READCOMMITTED)
			on msg.id_message = ss.id_message
			where rr.tx_state = ''''NA'''')
			and dt_assigned is null''

	EXEC sp_executesql @sql
	set @sql = N''update t_message
			set dt_completed = dbo.MTMaxDate()
			where id_message in (
			select ss.id_message from '' + @rerun_table_name + N'' rr
			inner join t_session sess WITH (READCOMMITTED)
			on sess.id_source_sess = rr.id_source_sess
			inner join t_session_set ss WITH (READCOMMITTED)
			on sess.id_ss = ss.id_ss
			inner join t_message msg WITH (READCOMMITTED)
			on msg.id_message = ss.id_message
			where rr.tx_state = ''''NA'''')
			and dt_completed is null''

	EXEC sp_executesql @sql

 end


    
    ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[MTDateInRange]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTDateInRange]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
			create function [dbo].[MTDateInRange] (
                                    @startdate datetime,
                                    @enddate datetime,
                                    @CompareDate datetime)
				returns int
			as
			begin
                                  declare @abc as int
                                  if @startdate <= @CompareDate AND @CompareDate < @enddate 
                                   begin
                                   select @abc = 1
                                   end 
                                else
                                   begin
                                   select @abc = 0
                                   end 
			   return @abc
                           end
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[GetDatabaseVersionInfo]    Script Date: 06/02/2008 11:43:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetDatabaseVersionInfo]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			
CREATE  PROCEDURE [dbo].[GetDatabaseVersionInfo]
(
  @DatabaseVersionInfo VARCHAR(4096) OUTPUT
)
AS
BEGIN
  -- This stored procedure returns a text string that represents version and other information about the database server.
  -- It is only displayed to the user and so the text string can be modified or added to as necessary
  DECLARE @temp_info VARCHAR(2048)
  DECLARE @inferred_info VARCHAR(2048)

  -- gets the version of the database
  SELECT @temp_info =@@VERSION

  SELECT @inferred_info=
    CASE
      WHEN CHARINDEX(''8.00.194'', @temp_info) <> 0 THEN ''*8.00.194 indicates no SQL Server 2000 Service Pack has been applied''
      WHEN CHARINDEX(''8.00.384'', @temp_info) <> 0 THEN ''*8.00.384 indicates SQL Server 2000 Service Pack 1 applied''
      WHEN CHARINDEX(''8.00.534'', @temp_info) <> 0 THEN ''*8.00.534 indicates SQL Server 2000 Service Pack 2 applied''
      WHEN CHARINDEX(''8.00.760'', @temp_info) <> 0 THEN ''*8.00.760 indicates SQL Server 2000 Service Pack 3 applied''
      WHEN CHARINDEX(''8.00.818'', @temp_info) <> 0 THEN ''*8.00.818 indicates SQL Server 2000 Service Pack 3a and Hotfix Q815495 applied''
      ELSE ''*Unable to determine from version number what SQL Server 2000 Service Packs have been applied''
    END

  SELECT @DatabaseVersionInfo = @temp_info + @inferred_info
END
			
		' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[MTMaxOfTwoDates]    Script Date: 06/02/2008 11:44:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTMaxOfTwoDates]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
	-- Function returns the maximum of two dates.  A null date is considered
	-- to be infinitely small.
	create function [dbo].[MTMaxOfTwoDates](@chargeIntervalLeft datetime, @subIntervalLeft datetime) returns datetime
	as
	begin
	return case when @subIntervalLeft is null or @chargeIntervalLeft > @subIntervalLeft then @chargeIntervalLeft else @subIntervalLeft end
	end
		' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[ConvertIntegerToUID]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ConvertIntegerToUID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
    
	CREATE  function [dbo].[ConvertIntegerToUID](@id_sess integer) returns varbinary(16)
	as
	begin
		declare @uid varbinary(16)
		set @uid = cast(@id_sess % 256 as varbinary(1)) +
			   cast((@id_sess/256) % 256 as varbinary(1)) +
			   cast((@id_sess/65536) % 256 as varbinary(1)) +
			   cast((@id_sess/16777216) % 256 as varbinary(1)) 
		return @uid

	end
    
    ' 
END
GO
/****** Object:  StoredProcedure [dbo].[Abandon]    Script Date: 06/02/2008 11:42:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Abandon]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
    
	Create  procedure [dbo].[Abandon] @rerun_table_name nvarchar(30),  @id_rerun int, @return_code int OUTPUT
	as
	Begin
		declare @sql nvarchar(1000)
		set @sql = N''drop table '' + @rerun_table_name
		EXEC sp_executesql @sql

		declare @source_table_name nvarchar(100)
		set @source_table_name = N''t_source_rerun_session_'' + cast(@id_rerun AS nvarchar(40))
		set @sql = N''IF EXISTS (SELECT 1 FROM dbo.sysobjects WHERE id = object_id(N'''''' + @source_table_name + N'''''') 
			and OBJECTPROPERTY(id, N''''IsUserTable'''') = 1) DROP TABLE '' + @source_table_name

      		EXEC sp_executesql @sql

		declare @UIDTableName nvarchar(100)
      		set @UIDTableName = N''t_UIDList_'' + cast(@id_rerun AS nvarchar(40))
      		set @sql = N''IF EXISTS (SELECT 1 FROM dbo.sysobjects WHERE id = object_id(N'''''' + @UIDTableName + N'''''') 
			and OBJECTPROPERTY(id, N''''IsUserTable'''') = 1) DROP TABLE '' + @UIDTableName

    		EXEC sp_executesql @sql   

      		set @return_code = 0

	End
    
    ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[MTMinOfTwoDates]    Script Date: 06/02/2008 11:44:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTMinOfTwoDates]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
	-- Function returns the minimum of two dates.  A null date is considered
	-- to be infinitely large.
	create function [dbo].[MTMinOfTwoDates](@chargeIntervalLeft datetime, @subIntervalLeft datetime) returns datetime
	as
	begin
	return case when @subIntervalLeft is null or @chargeIntervalLeft < @subIntervalLeft then @chargeIntervalLeft else @subIntervalLeft end
	end		
	' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[ConvertUIDToInteger]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ConvertUIDToInteger]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
    
	CREATE  function [dbo].[ConvertUIDToInteger] (@UID varbinary(16)) returns int
	as
	begin
	declare @intID int
	set @intID = cast(substring(@UID, 1, 1) as integer) |
		cast(substring(@UID, 2, 1) as integer) * 256 |
		cast(substring(@UID, 3, 1) as integer) * 65536 | 
		cast(substring(@UID, 4, 1) as integer) * 16777216
	return @intID
	end

    
    ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[OverlappingDateRange]    Script Date: 06/02/2008 11:44:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[OverlappingDateRange]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
		create function [dbo].[OverlappingDateRange](@dt_start as datetime,
		  @dt_end as datetime,
			@dt_checkstart as datetime,
			@dt_checkend as datetime) returns integer
			as 
			begin
               if (@dt_start is not null and @dt_start > @dt_checkend) OR
               (@dt_checkstart is not null and @dt_checkstart > @dt_end)
               begin			   
               return (0)
               end
               return (1)
               end
	' 
END
GO
/****** Object:  StoredProcedure [dbo].[CalculateLargeMessages]    Script Date: 06/02/2008 11:43:14 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CalculateLargeMessages]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
create procedure [dbo].[CalculateLargeMessages](@rerunID int,
      @num_large_messages int OUTPUT,
      @num_large_session_sets int OUTPUT)
as
begin
   declare @sql nvarchar(4000);
   declare @temp_table_name nvarchar(50);
   declare @args nvarchar(100);
   
   
   select @num_large_messages = count(*) from #aggregate_large;

   set @sql = N''insert into #child_session_sets (id_parent_sess, id_svc, cnt)
                select prnt.id_sess, rr.id_svc, count(*)
                from  t_rerun_session_'' + CAST(@rerunID AS NVARCHAR(10)) + N'' rr
                inner join #aggregate_large prnt
                on prnt.id_parent_source_sess=rr.id_parent_source_sess
				group by prnt.id_sess, rr.id_svc '';

   EXEC sp_executesql @sql

   select @num_large_session_sets = isnull(max(id_sess), 0) + @num_large_messages from #child_session_sets;
 
end;
    ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[NextDateAfterBillingCycle]    Script Date: 06/02/2008 11:44:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[NextDateAfterBillingCycle]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
		create function [dbo].[NextDateAfterBillingCycle](@id_acc as int,@datecheck as datetime) returns datetime
		as
		begin
			return(
			select DATEADD(s, 1, tpc.dt_end)
	    from
        t_payment_redirection redir
	      inner join t_acc_usage_cycle auc
	      on auc.id_acc = redir.id_payer
	      inner join t_pc_interval tpc
	      on tpc.id_cycle = auc.id_usage_cycle
	      where redir.id_payee = @id_acc
	      AND
	      tpc.dt_start <= @datecheck AND @datecheck <= tpc.dt_end
	      AND
	      redir.vt_start <= @datecheck AND @datecheck <= redir.vt_end
		)
		end
	' 
END
GO
/****** Object:  StoredProcedure [dbo].[CalculateRegularMessages]    Script Date: 06/02/2008 11:43:14 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CalculateRegularMessages]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
create procedure [dbo].[CalculateRegularMessages](@message_size int,
      @num_regular_messages int OUTPUT)
as

   declare @total_sess int;
   declare @total_parents int;
   declare @numParentsInMessage int;
   declare @bucket int;
   declare @average int;
   declare @num_regular_session_sets int;
begin   
   select @total_sess = sum(sessions_in_compound) from #aggregate;

   select @total_parents = max(id_sess) from #aggregate;
       
   if(@total_sess > 0) 
   begin
    if (@total_sess > @message_size) 
        begin
          select @average = AVG(sessions_in_compound) from #aggregate;
   
          set @numParentsInMessage =  @message_size/@average;
          if (@numParentsInMessage = 0) 
            set @bucket = @total_parents;
          else  
            set @bucket = (@total_parents/@numParentsInMessage) + 1;
     	end;
     else
            set @bucket = 1;

     
   end;        
   else
  	set @bucket = 0;
  		  	
   set @num_regular_messages = @bucket;
end;

    ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CalculateAtomicMessages]    Script Date: 06/02/2008 11:43:13 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CalculateAtomicMessages]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
create procedure [dbo].[CalculateAtomicMessages](@message_size int,
      @num_atomic_messages int OUTPUT)
as
begin
   declare @id_max_sess int;
   declare @bucket int;
   
   select @id_max_sess = ISNull(max(id_sess),0) from #aggregate;
   if(@id_max_sess > @message_size)
    begin
      if ((@id_max_sess % @message_size)>0) 
        set @bucket = (@id_max_sess/@message_size) + 1;
      else
        set @bucket = (@id_max_sess/@message_size); 
   
    end;        
   else
  	set @bucket = 1;

    		  	
   set @num_atomic_messages = @bucket;
   end;

    ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CalculateLargestCompoundSize]    Script Date: 06/02/2008 11:43:14 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CalculateLargestCompoundSize]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
            
create procedure [dbo].[CalculateLargestCompoundSize](
      @largest_compound int OUTPUT )
as
begin
   declare @cnt_large int;
   declare @cnt int;
   
  select @cnt_large = ISNull(max(ISNull(sessions_in_compound,0)), 0) from #aggregate_large;
  select @cnt = ISNull(max(ISNULL(sessions_in_compound, 0)), 0) from #aggregate;
  
  if (@cnt_large > @cnt) 
	set @largest_compound = @cnt_large;
  else
    set @largest_compound = @cnt;
	
end;
            
            ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[MTRateScheduleScore]    Script Date: 06/02/2008 11:44:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTRateScheduleScore]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
  
	create function [dbo].[MTRateScheduleScore](@type as int, @begindate datetime) returns int  
	as
	begin  
	declare @datescore int  
	set @datescore = case @type when 4 then 0 else datediff(s, ''1970-01-01'', isnull(@begindate, ''1970-01-01'')) end  
	declare @typescore int  
	set @typescore = case @type   
	when 2 then 2   
	when 4 then 0   
	else 1   
	end  
	return cast(@typescore as int) * 0x20000000 + (cast(@datescore as int) / 8)
	end 
		
' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[CSVToInt]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CSVToInt]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
CREATE FUNCTION [dbo].[CSVToInt] (@array VARCHAR(4000)) 
RETURNS @IntTable TABLE (value INT)
AS
BEGIN
  DECLARE @separator CHAR(1)
  SET @separator = '',''

	DECLARE @separator_position INT 
	DECLARE @array_value VARCHAR(100) 
	
	SET @array = @array + '',''
	
	WHILE PATINDEX(''%,%'' , @array) <> 0 
	BEGIN
	  SELECT @separator_position = PATINDEX(''%,%'' , @array)
	  SELECT @array_value = LEFT(@array, @separator_position - 1)
	
		INSERT @IntTable
		VALUES (CAST(@array_value AS INT))

	  SELECT @array = STUFF(@array, 1, @separator_position, '''')
	END

	RETURN
END
  ' 
END
GO
/****** Object:  StoredProcedure [dbo].[ExtendedUpsert]    Script Date: 06/02/2008 11:43:41 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ExtendedUpsert]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			create proc [dbo].[ExtendedUpsert](@table_name as varchar(100),
											@update_list as varchar(8000),
											@insert_list as varchar(8000),
											@clist as varchar(8000),
											@id_prop as int,
											@status int output)
			as
			declare @rowcount as int
			exec(''update '' + @table_name + '' set '' + 
			@update_list + '' where '' + @table_name + ''.id_prop = '' + @id_prop)
			set @rowcount = @@rowcount
			set @status = @@error
			if @rowcount = 0 begin
				exec(''insert into '' + @table_name + '' (id_prop,'' + @clist + '') values( '' + @id_prop + '','' + @insert_list + '')'')
				set @status = @@error
			end
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[GetMetaDataForProps]    Script Date: 06/02/2008 11:43:45 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetMetaDataForProps]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'	
			CREATE PROCEDURE [dbo].[GetMetaDataForProps]
			@tableName varchar(200),
			@columnName varchar(200) = null
			AS

			declare @sql varchar(1000)

			SET @sql = ''SELECT so.name name, systypes.name type, so.prec length, so.scale decplaces, (case so.isnullable WHEN 0 THEN ''''TRUE''''  WHEN 1 THEN ''''FALSE''''  END ) AS required,  ''
			SET @sql = @sql + ''(SELECT count(si.name) from syscolumns si inner join sysobjects on si.id = sysobjects.id where si.name like (so.name+'''''' +''_op'' +'''''') AND sysobjects.name = '' +'''''''' +@tableName  +'''''') As isRowType''
			SET @sql = @sql + ''  from syscolumns so inner join sysobjects on so.id = sysobjects.id inner join systypes on systypes.xtype = so.xtype and systypes.xusertype = so.xusertype where ''
			SET @sql = @sql + '' sysobjects.name = '' +'''''''' +@tableName +''''''''

			IF (@columnName is not null and @columnName <> '''')
			BEGIN
				SET @sql = @sql + '' AND so.name = '' +'''''''' +@columnName +''''''''
			END

			SET @sql = @sql + '' ORDER BY so.colorder''

			exec (@sql)
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdateDataForEnumToString]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateDataForEnumToString]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'	
			CREATE PROCEDURE [dbo].[UpdateDataForEnumToString]
			@table varchar(200),
			@column varchar(200)
			AS

			DECLARE @query varchar(1000)

			SET @query = ''update '' +@table +'' set '' +@column +''= (select ''
			SET @query = @query + ''REVERSE(SUBSTRING( REVERSE(nm_enum_data),1, CHARINDEX(''''/'''',REVERSE(nm_enum_data))-1) )''
			SET @query = @query +  '' from t_enum_data WHERE id_enum_data = '' +@column +'')''

			exec (@query)
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdateDataForStringToEnum]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateDataForStringToEnum]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      CREATE PROCEDURE [dbo].[UpdateDataForStringToEnum]
      @table varchar(200),
      @column varchar(200),
      @enum_string varchar(200)
      AS
      -- Check for NULLs
      DECLARE @query varchar(1000)
      DECLARE  @query1 varchar(1000)
      SET  @query1 = ''IF (select sum(case when '' +@column +'' is null then 0 else 1 end)  from (select distinct '' +'''''''' +@enum_string +''/'' +''''''+'' +@column +'' mydata, '' +@column +'' from '' +@table +'' ) data ''
      SET  @query1 = @query1 +'' where not exists (select ''''x'''' from t_enum_data where nm_enum_data = data.mydata)) is not null BEGIN RAISERROR(''''NULL or invalid value found for column '' + @column + '' while converting string to enum'''',16,1)  END''
      exec(@query1)
      SET @query = ''update '' + @table +'' set '' + @column +''= (select id_enum_data from t_enum_data WHERE nm_enum_data = '' +'''''''' + @enum_string + ''/'''' + '' + @column + '')''
      exec (@query)
    ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[GetPartitionPredicate]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetPartitionPredicate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
      /*
      	Returns the partition predicate as an sql clause.
      
      */
      
      create function [dbo].[GetPartitionPredicate] (@start int, @end int)
      returns varchar(200)
      as
      begin
      	declare @pred varchar(200)
      	declare @oper varchar(3)
      	
      	if (@start > @end) 
      		set @oper = ''or''
      	else
      		set @oper = ''and''
      	
      	set @pred = ''(id_usage_interval >= '' + str(@start) + '' ''
      		+ @oper + '' id_usage_interval <= '' + str(@end) + '')''
      	
      	return @pred
      end
      
 	' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[DiffHour]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DiffHour]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
        
      create function [dbo].[DiffHour](@dt_start datetime, @dt_end datetime) 
        returns decimal
      as
      begin
       return datediff(hour, @dt_start, @dt_end)
      end
				
      ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[SubtractSecond]    Script Date: 06/02/2008 11:44:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SubtractSecond]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
        
				create function [dbo].[SubtractSecond](@RefDate datetime) returns datetime 
				as
				begin
				 return (dateadd(s,-1,@RefDate))
				end
				
      ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[AddSecond]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddSecond]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
				create function [dbo].[AddSecond](@RefDate datetime) returns datetime 
				as
				begin
				 return (dateadd(s,1,@RefDate))
				end
				' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[GetUsageIntervalID]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetUsageIntervalID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
      /*
      	GetUsageIntervalID 
      
      	Calculates and interval id from and end_date and cycle id.
      
      	@dt_end  -- end date of interval
      	@id_cycle -- cycle id of interval
      */
      create function [dbo].[GetUsageIntervalID] (
      	@dt_end datetime,
      	@id_cycle int)
      returns int
      as
      begin
      
      	return datediff(day,''1970-01-01'', @dt_end) * power(2,16) + @id_cycle
      
      end
 	' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[EnclosedDateRange]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[EnclosedDateRange]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
				create function [dbo].[EnclosedDateRange](@dt_start datetime,
	      @dt_end datetime,
  			@dt_checkstart datetime,
				@dt_checkend datetime) returns int
				as
				begin
        declare @test as int
				 -- check if the range specified by temp_dt_checkstart and
				 -- temp_dt_checkend is completely inside the range specified
				 -- by temp_dt_start, temp_dt_end
				if (@dt_checkstart >= @dt_start AND @dt_checkend <= @dt_end ) 
					begin
			    select @test=1
			    end
        else
					begin
          select @test=0
				  end
        return(@test)
        end
				' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreatePartitionDatabase]    Script Date: 06/02/2008 11:43:28 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreatePartitionDatabase]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      /*
      	Proc: CreatePartitionDatabase
      
      	Creates a new database given the following:
      
      */
      create proc [dbo].[CreatePartitionDatabase]
      	@dbname varchar(300),  -- name of db to create
      	@p_path varchar(500),  -- where to put the datafiles
      	@p_datasize int = 100, -- size of data file
      	@p_logsize int = 25	  -- size of log file
      AS
      begin
      
      -- error handling
      declare @err int	-- sql errors
      declare @rc int	-- row counts
      declare @ret int 	-- called proc return codes
      
      -- data file specs
      --declare @dbname nvarchar(300)
      declare @dbfile varchar(300)
      declare @dbpath varchar(500)
      declare @dbsize varchar(300)
      declare @dbpctgrow varchar(300)
      
      -- log file specs
      declare @logname varchar(300)
      declare @logfile varchar(300)
      declare @logpath varchar(500)
      declare @logsize varchar(300)
      declare @logpctgrow varchar(300)
      
      -- Abort if database already exists
      if (db_id(@dbname) is not null) 
      begin
      	raiserror(''Database [%s] already exists.'', 0, 1, @dbname)
      	return 0
      end
      
      -- check and fix trailing path sep
      set @p_path = rtrim(@p_path)
      if (right(@p_path, 1) <> ''\'')
      	set @p_path = @p_path + ''\''
      
      -- database specs
      set @dbfile = @dbname + ''.mdf''
      set @dbpath = @p_path + @dbfile
      set @dbsize = cast(@p_datasize as varchar)
      set @dbpctgrow = ''10%''
      
      -- log specs
      set @logname = @dbname
      set @logfile = @logname + ''.ldf''
      set @logpath = @p_path + @logfile
      set @logsize = cast(@p_logsize as varchar)
      set @logpctgrow = ''10%''
      
      -- build sql statement
      declare @cmd varchar(4000)
      set @cmd = ''
      CREATE DATABASE '' + @dbname + ''
      	ON (
      	NAME = '''''' + @dbfile + '''''', 
      	FILENAME = '''''' + @dbpath + '''''' , 
      	SIZE = '' + @dbsize + '', 
      	FILEGROWTH = '' + @dbpctgrow + '') 
      	LOG ON (
      	NAME = '''''' + @logfile + '''''', 
      	FILENAME = '''''' + @logpath + '''''' , 
      	SIZE = '' + @logsize + '', 
      	FILEGROWTH = '' + @logpctgrow + '')
      COLLATE SQL_Latin1_General_CP1_CI_AS''
          
      -- Create it..
      --print @cmd
      exec (@cmd)
      select @err = @@error
      if (@err <> 0) begin
      	raiserror(''Cannot create database [%s]'', 16, 1, @dbname)
      	return 1
      end
      
      -- If needed, make owner of NetMeter the owner of partition
			declare @nmdbo varchar(2000)
			select @nmdbo = suser_sname(sid) from master.dbo.sysdatabases
				where name = db_name()
	
      if (suser_sname() <> @nmdbo) 
      begin 
		-- Not NetMeter owner, try to make nmdbo the owner of the database.  This
		-- allows sa to create a database for NetMeter owner.
			
      	set @cmd = ''use '' + @dbname + char(13) 
		+ ''exec sp_changedbowner ''''nmdbo'''', TRUE''
			
      	--print @cmd
      	exec (@cmd)
      	select @err = @@error
      	if (@err <> 0) begin
			raiserror(''Cannot make [%s] the owner of database [%s]'', 16, 1, 
			@nmdbo, @dbname)
      		return 1
      	end
      end
      
      -- Set database options. Recovery mode is simple till the database 
      -- is loaded, then it''s switched to full
		if objectproperty(object_id(''t_acc_usage''),''istable'') = 1
		begin
      		exec(''alter database '' + @dbname + '' set recovery simple'')
		end
		else
		begin
      		exec(''alter database '' + @dbname + '' set recovery full'')
		end
      exec(''alter database '' + @dbname + '' set torn_page_detection on'')
      exec(''alter database '' + @dbname + '' set arithabort on'')
      exec(''alter database '' + @dbname + '' set ansi_padding on'')
      exec(''alter database '' + @dbname + '' set concat_null_yields_null on'')
      exec(''alter database '' + @dbname + '' set quoted_identifier on'')
      exec(''alter database '' + @dbname + '' set auto_create_statistics on'')
      exec(''alter database '' + @dbname + '' set ansi_nulls on'')
      exec(''alter database '' + @dbname + '' set ansi_warnings on'')
      exec(''alter database '' + @dbname + '' set auto_update_statistics off'')
      
      end
 	' 
END
GO
/****** Object:  StoredProcedure [dbo].[AdjustSubDates]    Script Date: 06/02/2008 11:43:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AdjustSubDates]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
create procedure [dbo].[AdjustSubDates](
@p_id_po integer,
@p_startdate datetime,
@p_enddate datetime,
@p_adjustedstart datetime OUTPUT,
@p_adjustedend datetime OUTPUT,
@p_datemodified char(1) OUTPUT,
@p_status INT OUTPUT
)
as
begin
	select @p_datemodified = ''N''	

	select @p_adjustedstart = dbo.mtmaxoftwodates(@p_startdate,po.dt_start),
	@p_adjustedend = dbo.mtminoftwodates(@p_enddate,po.dt_end) 
	from 
	(select te.dt_start,
	case when te.dt_end is NULL then dbo.mtmaxdate() else te.dt_end end as dt_end
	from t_po
	INNER JOIN t_effectivedate te on te.id_eff_date = t_po.id_eff_date
	where t_po.id_po = @p_id_po) po
	if (@p_adjustedstart <> @p_startdate OR @p_adjustedend <> @p_enddate) begin
		select @p_datemodified = ''Y''
	end
	if @p_adjustedend < @p_adjustedstart begin
		-- hmm.... looks like we are outside the effective date of the product offering
		-- MTPCUSER_PRODUCTOFFERING_NOT_EFFECTIVE
		select @p_status = -289472472
		return
	end
	select @p_status = 1
	return
end
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[SubscribeBatchGroupSub]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SubscribeBatchGroupSub]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
CREATE PROC [dbo].[SubscribeBatchGroupSub] @tmp_subscribe_batch nvarchar(64), @tmp_account_state_rules nvarchar(64), @corp_business_rule_enforced int, @dt_now datetime
AS
declare @stmt nvarchar(1024)
create table #tmp_subscribe_batch_sproc
(
      id_acc int NOT NULL,
      id_po int NOT NULL,
      id_group int NOT NULL,
      vt_start datetime NOT NULL,
      vt_end datetime NULL,
      uncorrected_vt_start datetime NOT NULL,
      uncorrected_vt_end datetime NULL,
      tt_now datetime NOT NULL,
      id_gsub_corp_account int NOT NULL,
      status int NOT NULL,

      -- audit info
      id_audit int NOT NULL,
      id_event int NOT NULL,
      id_userid int NOT NULL,
      id_entitytype int NOT NULL,

      -- Values set by the SQL execution.
      id_sub int NULL,
      nm_display_name nvarchar(255) NULL
)

CREATE CLUSTERED INDEX idx_acc_group_sub ON #tmp_subscribe_batch_sproc(id_acc, id_group)


create table #tmp_account_state_rules_sproc(state char(2), can_subscribe int)
CREATE CLUSTERED INDEX idx_state ON  #tmp_account_state_rules_sproc(state)

-- move data from temporary table whose name is passed in and the temp tables at sproc scope
set @stmt = ''INSERT INTO #tmp_subscribe_batch_sproc SELECT * FROM '' + @tmp_subscribe_batch
exec sp_executesql @stmt
set @stmt = ''INSERT INTO #tmp_account_state_rules_sproc SELECT * FROM '' + @tmp_account_state_rules
exec sp_executesql @stmt


-- If the vt_end is null then use subscription end date
UPDATE #tmp_subscribe_batch_sproc
SET 
#tmp_subscribe_batch_sproc.vt_end=dbo.MTMaxDate(),
#tmp_subscribe_batch_sproc.uncorrected_vt_end=dbo.MTMaxDate()
WHERE
#tmp_subscribe_batch_sproc.vt_end is null

-- First clip the start and end date with the effective date on the subscription
-- and validate that the intersection of the effective date on the sub and the
-- delete interval is non-empty.
UPDATE #tmp_subscribe_batch_sproc
SET
#tmp_subscribe_batch_sproc.vt_start = dbo.MTMaxOfTwoDates(ub.vt_start, s.vt_start),
#tmp_subscribe_batch_sproc.vt_end = dbo.MTMinOfTwoDates(ub.vt_end, s.vt_end),
#tmp_subscribe_batch_sproc.status = case when ub.vt_start < s.vt_end and ub.vt_end > s.vt_start then 0 else -486604712  end,
#tmp_subscribe_batch_sproc.id_sub = s.id_sub,
#tmp_subscribe_batch_sproc.id_po = s.id_po
from 
#tmp_subscribe_batch_sproc ub
inner join t_sub s on s.id_group = ub.id_group

-- Next piece of data massaging is to clip the start date of the request
-- with the creation date of the account (provided the account was created 
-- before the end date of the subscription request).
UPDATE #tmp_subscribe_batch_sproc
SET
#tmp_subscribe_batch_sproc.vt_start = dbo.MTMaxOfTwoDates(ub.vt_start, acc.dt_crt)
FROM
#tmp_subscribe_batch_sproc ub
INNER JOIN t_account acc on ub.id_acc=acc.id_acc AND acc.dt_crt <= ub.vt_end

-- CR 13298: Eliminate duplicates
-- MTPCUSER_DUPLICATE_ITEMS_IN_BATCH -289472432
update args
set status = -289472432 FROM
#tmp_subscribe_batch_sproc args 
inner join 
(
SELECT id_acc, id_group
FROM
#tmp_subscribe_batch_sproc
GROUP BY id_acc, id_group
HAVING count(1) > 1
) args1 on args.id_acc = args1.id_acc AND args.id_group = args1.id_group
WHERE args.status =0

--Check that all potential group subscription members have the same currency on their profiles
--as the product offering.
--TODO: t_po table does not have an index on id_nonshared_pl.
-- if below query affects performance, create it later.
UPDATE #tmp_subscribe_batch_sproc
-- MT_ACCOUNT_PO_CURRENCY_MISMATCH
SET
#tmp_subscribe_batch_sproc.status = -486604729
FROM
#tmp_subscribe_batch_sproc ub
WHERE EXISTS
(
	SELECT 1 FROM 
	t_payment_redirection pr 
	inner join t_av_internal tav ON tav.id_acc = pr.id_payer
	inner join t_po po ON ub.id_po = po.id_po
	inner join t_pricelist pl1 on pl1.id_pricelist = po.id_nonshared_pl
	where 
	(pr.vt_start <= ub.vt_end AND pr.vt_end >= ub.vt_start) 
	AND pr.id_payee = ub.id_acc
	AND tav.c_Currency <> pl1.nm_currency_code
) -- EXISTS
AND ub.status=0

UPDATE #tmp_subscribe_batch_sproc
-- Error out if the account doesn''t exist until after the end date of the 
-- subscription request.  I don''t want to create a new error message for
-- this corner case (porting back to 3.0 for BT); so borrow account state
-- message.
-- MT_ADD_TO_GROUP_SUB_BAD_STATE
SET
#tmp_subscribe_batch_sproc.status = -486604774
FROM
#tmp_subscribe_batch_sproc ub
INNER JOIN t_account acc on ub.id_acc=acc.id_acc AND acc.dt_crt > ub.vt_end
WHERE
ub.status=0

UPDATE #tmp_subscribe_batch_sproc 
-- Check to see if the account is in a state in which we can
-- subscribe it.
-- TODO: This is the business rule as implemented in 3.5 and 3.0 (check only
-- the account state in effect at the wall clock time that the subscription is made).
-- What would be better is to ensure that there is no overlap between
-- the valid time interval of any "invalid" account state and the subscription
-- interval.  
-- MT_ADD_TO_GROUP_SUB_BAD_STATE
SET
#tmp_subscribe_batch_sproc.status = -486604774
FROM
#tmp_subscribe_batch_sproc ar
INNER JOIN t_account_state ast ON ar.id_acc=ast.id_acc AND ast.vt_start <= ar.tt_now AND ast.vt_end >= ar.tt_now
INNER JOIN #tmp_account_state_rules_sproc asr ON ast.status=asr.state
WHERE
asr.can_subscribe=0
AND
ar.status=0

-- Check that we''re not already in the group sub with overlapping date
-- MT_ACCOUNT_ALREADY_IN_GROUP_SUBSCRIPTION
update #tmp_subscribe_batch_sproc
set #tmp_subscribe_batch_sproc.status = -486604790
from
#tmp_subscribe_batch_sproc ar
inner join t_gsubmember s on s.id_acc=ar.id_acc and s.id_group=ar.id_group and s.vt_start <= ar.vt_end and ar.vt_start <= s.vt_end
where
ar.status = 0

-- Check for different subscription to the same PO by the same account with overlapping date
update #tmp_subscribe_batch_sproc 
set #tmp_subscribe_batch_sproc.status = -289472485 
from
#tmp_subscribe_batch_sproc ar 
where 
exists (
 -- Check for conflicting individual sub
 select * from t_sub s 
 where
 s.id_po=ar.id_po and s.id_acc=ar.id_acc and s.id_sub<>ar.id_sub and s.vt_start <= ar.vt_end and ar.vt_start <= s.vt_end
 and
 s.id_group is null
)
or
exists (
 -- Check for conflicting group sub
 select * from t_gsubmember gs
 inner join t_sub s on gs.id_group = s.id_group
 where
 gs.id_acc=ar.id_acc and s.id_po=ar.id_po and s.id_sub<>ar.id_sub and gs.vt_start <= ar.vt_end and ar.vt_start <= gs.vt_end
)
and
ar.status = 0 

-- Check to make sure that effective date of PO intersects the corrected interval
update #tmp_subscribe_batch_sproc 
set #tmp_subscribe_batch_sproc.status = -289472472 
from 
#tmp_subscribe_batch_sproc ar 
inner join t_po p on ar.id_po=p.id_po
inner join t_effectivedate ed on ed.id_eff_date=p.id_eff_date
where 
(ed.dt_start > ar.vt_start or ed.dt_end < ar.vt_end)
and
ar.status = 0

-- Check to see if there is another PO with the same PI template for which an overlapping subscription exists.
-- Only do this if other business rules have passed.
update #tmp_subscribe_batch_sproc 
set #tmp_subscribe_batch_sproc.status = -289472484
where
exists (
	select * 
	from
 	t_pl_map plm1 
	inner join t_vw_effective_subs s2 on s2.id_acc=#tmp_subscribe_batch_sproc.id_acc and s2.id_po<>#tmp_subscribe_batch_sproc.id_po and s2.dt_start < #tmp_subscribe_batch_sproc.vt_end and #tmp_subscribe_batch_sproc.vt_start < s2.dt_end
	inner join t_pl_map plm2 on s2.id_po=plm2.id_po and plm1.id_pi_template = plm2.id_pi_template
	where
	#tmp_subscribe_batch_sproc.id_po=plm1.id_po
	and
	plm1.id_paramtable is null
	and
	plm2.id_paramtable is null
)
and
#tmp_subscribe_batch_sproc.status = 0

-- MT_GSUB_DATERANGE_NOT_IN_SUB_RANGE
update #tmp_subscribe_batch_sproc
set #tmp_subscribe_batch_sproc.status = -486604789
from
#tmp_subscribe_batch_sproc ar
inner join t_sub s on s.id_group=ar.id_group
where
(ar.vt_start < s.vt_start or ar.vt_end > s.vt_end)
and
ar.status = 0

-- Check that the group subscription exists
-- MT_GROUP_SUBSCRIPTION_DOES_NOT_EXIST
update #tmp_subscribe_batch_sproc
set #tmp_subscribe_batch_sproc.status = -486604788
from
#tmp_subscribe_batch_sproc ar
where
not exists (
	select *
	from t_group_sub 
	where
	t_group_sub.id_group=ar.id_group
)
and
ar.status = 0

-- If corp account business rule is enforced, check that
-- all potential gsub members are located in the same corporate hierarchy
-- as group subscription
--bug fix 13689 corporate account need not be under root.
-- MT_ACCOUNT_NOT_IN_GSUB_CORPORATE_ACCOUNT
IF @corp_business_rule_enforced = 1
BEGIN
	update #tmp_subscribe_batch_sproc
	set #tmp_subscribe_batch_sproc.status = -486604769 
	from
	#tmp_subscribe_batch_sproc ar
	inner join t_group_sub gs on ar.id_group=gs.id_group
	inner join t_account_ancestor aa on aa.id_descendent=ar.id_acc and aa.vt_start <= ar.tt_now and ar.tt_now <= aa.vt_end
	inner join t_account acc on aa.id_ancestor = acc.id_acc
	inner join t_account_type atype on atype.id_type = acc.id_type
	where
	atype.b_isCorporate = ''1'' and
	aa.id_ancestor <> gs.id_corporate_account
	and
	ar.status = 0
END

-- MT_GROUP_SUB_MEMBER_CYCLE_MISMATCH
-- Check for billing cycle relative 
update #tmp_subscribe_batch_sproc
set #tmp_subscribe_batch_sproc.status = -486604730
from
#tmp_subscribe_batch_sproc ar
inner join t_sub s on ar.id_group=s.id_group
inner join t_group_sub gs on ar.id_group=gs.id_group
where
s.vt_end >= ar.tt_now
and
(
	-- Only consider this business rule when the target PO
	-- has a billing cycle relative instance
	exists (
		select * 
		from 
		t_pl_map plm 
		inner join t_discount piinst on piinst.id_prop=plm.id_pi_instance
		where
		plm.id_po=s.id_po
		and
		plm.id_paramtable is null
		and
		piinst.id_usage_cycle is null
	)
	or
	exists (
		select * 
		from 
		t_pl_map plm
		inner join t_recur piinst on piinst.id_prop=plm.id_pi_instance
		where
		plm.id_po=s.id_po
		and
		plm.id_paramtable is null
		and
		piinst.tx_cycle_mode IN (''BCR'', ''BCR Constrained'')
	) 
	or
	exists (
		select * 
		from 
		t_pl_map plm 
		inner join t_aggregate piinst on piinst.id_prop=plm.id_pi_instance
		where
		plm.id_po=s.id_po
		and
		plm.id_paramtable is null
		and
		piinst.id_usage_cycle is null
	)
)
and
exists (
	-- All payers must have the same cycle as the cycle as the group sub itself
	select * 
	from 
	t_payment_redirection pr 
	inner join t_acc_usage_cycle auc on auc.id_acc=pr.id_payer
	where
	pr.id_payee=ar.id_acc 
	and 
	pr.vt_start <= s.vt_end 
	and 
	s.vt_start <= pr.vt_end
	and
	auc.id_usage_cycle <> gs.id_usage_cycle
)
and
ar.status = 0

--
-- EBCR membership business rules
--

DECLARE @ebcrResults TABLE 
(
  id_acc INT, -- member account (payee)
  id_usage_cycle INT, -- payer''s cycle
  b_compatible INT -- EBCR compatibility: 1 or 0
)

-- fills the results table with a row for each member/payer combination
INSERT INTO @ebcrResults
SELECT 
  batch.id_acc,
  payercycle.id_usage_cycle,
  dbo.CheckEBCRCycleTypeCompatibility(payercycle.id_cycle_type, rc.id_cycle_type)
FROM #tmp_subscribe_batch_sproc batch
INNER JOIN t_group_sub gs ON gs.id_group = batch.id_group
INNER JOIN t_sub sub ON sub.id_group = gs.id_group
INNER JOIN t_pl_map plmap ON plmap.id_po = sub.id_po
INNER JOIN t_recur rc ON rc.id_prop = plmap.id_pi_instance
INNER JOIN t_payment_redirection pay ON 
  pay.id_payee = batch.id_acc AND
  -- checks all payer''s who overlap with the group sub
  pay.vt_end >= sub.vt_start AND
  pay.vt_start <= sub.vt_end
INNER JOIN t_acc_usage_cycle auc ON auc.id_acc = pay.id_payer
INNER JOIN t_usage_cycle payercycle ON payercycle.id_usage_cycle = auc.id_usage_cycle
WHERE 
  rc.tx_cycle_mode = ''EBCR'' AND
  rc.b_charge_per_participant = ''Y'' AND
  plmap.id_paramtable IS NULL AND
  -- TODO: it would be better if we didn''t consider subscriptions that ended
  --       in a hard closed interval so that retroactive changes would be properly guarded.
  -- only consider current or future group subs
  -- don''t worry about group subs in the past
  ((@dt_now BETWEEN sub.vt_start AND sub.vt_end) OR
   (sub.vt_start > @dt_now)) AND
  batch.status = 0

-- checks that members'' payers are compatible with the EBCR cycle type
UPDATE #tmp_subscribe_batch_sproc 
SET status = -289472443 -- MTPCUSER_EBCR_CYCLE_CONFLICTS_WITH_PAYER_OF_MEMBER
FROM #tmp_subscribe_batch_sproc batch
INNER JOIN @ebcrResults res ON res.id_acc = batch.id_acc
WHERE res.b_compatible = 0

-- checks that each member has only one billing cycle across all payers
UPDATE #tmp_subscribe_batch_sproc 
SET status = -289472442 -- MTPCUSER_EBCR_MEMBERS_CONFLICT_WITH_EACH_OTHER
FROM #tmp_subscribe_batch_sproc batch
INNER JOIN @ebcrResults res ON res.id_acc = batch.id_acc
INNER JOIN @ebcrResults res2 ON res2.id_acc = res.id_acc AND
                                res2.b_compatible = res.b_compatible AND
                                res2.id_usage_cycle <> res.id_usage_cycle
WHERE 
  res.b_compatible = 1 AND
  batch.status = 0
  

-- check that account type of each member is compatible with the product offering
-- since the absense of ANY mappings for the product offering means that PO is "wide open"
-- we need to do 2 EXISTS queries.

UPDATE #tmp_subscribe_batch_sproc 
set #tmp_subscribe_batch_sproc.status = -289472435 -- MTPCUSER_CONFLICTING_PO_ACCOUNT_TYPE
from
#tmp_subscribe_batch_sproc ar 
where
(
exists (

SELECT 1
FROM t_po_account_type_map atmap
WHERE atmap.id_po = ar.id_po

)

--PO is not wide open - see if susbcription is permitted for the account type

AND
not exists (

SELECT 1
FROM t_account tacc
INNER JOIN t_po_account_type_map atmap ON atmap.id_account_type = tacc.id_type
WHERE atmap.id_po = ar.id_po AND ar.id_acc = tacc.id_acc

)
)

AND status = 0

-- Check MTPCUSER_ACCOUNT_TYPE_CANNOT_PARTICIPATE_IN_GSUB 0xEEBF004FL -289472433
update #tmp_subscribe_batch_sproc
set #tmp_subscribe_batch_sproc.status = -289472433
from
#tmp_subscribe_batch_sproc ar
inner join t_account acc ON ar.id_acc = acc.id_acc
inner join t_account_type acctype on acc.id_type = acctype.id_type
where
acctype.b_CanParticipateInGSub = ''0'' AND status = 0



-- This is a sequenced insert.  For sequenced updates/upsert, run the delete (unsubscribe) first.
INSERT INTO t_gsubmember_historical (id_group, id_acc, vt_start, vt_end, tt_start, tt_end)
SELECT ar.id_group, ar.id_acc, ar.vt_start, ar.vt_end, ar.tt_now, dbo.MTMaxDate()
FROM
#tmp_subscribe_batch_sproc ar
WHERE
ar.status=0;
INSERT INTO t_gsubmember (id_group, id_acc, vt_start, vt_end)
SELECT ar.id_group, ar.id_acc, ar.vt_start, ar.vt_end
FROM
#tmp_subscribe_batch_sproc ar
WHERE
ar.status=0;

-- Coalecse to merge abutting records
-- Implement coalescing to merge any gsubmember records to the
-- same subscription that are adjacent.  Still need to work on
-- what a bitemporal coalesce looks like.
WHILE 1=1
BEGIN
update t_gsubmember
set t_gsubmember.vt_end = (
	select max(aa2.vt_end)
	from
	t_gsubmember as aa2
	where
	t_gsubmember.id_group=aa2.id_group
	and
	t_gsubmember.id_acc=aa2.id_acc
	and
	t_gsubmember.vt_start < aa2.vt_start
	and
	dateadd(s,1,t_gsubmember.vt_end) >= aa2.vt_start
	and
	t_gsubmember.vt_end < aa2.vt_end
)
where
exists (
	select *
	from
	t_gsubmember as aa2
	where
	t_gsubmember.id_group=aa2.id_group
	and
	t_gsubmember.id_acc=aa2.id_acc
	and
	t_gsubmember.vt_start < aa2.vt_start
	and
	dateadd(s,1,t_gsubmember.vt_end) >= aa2.vt_start
	and
	t_gsubmember.vt_end < aa2.vt_end
)
and
exists (
  select * from #tmp_subscribe_batch_sproc ar 
  where ar.id_group = t_gsubmember.id_group and ar.id_acc = t_gsubmember.id_acc
)

IF @@rowcount <= 0 BREAK
END

delete 
from t_gsubmember 
where
exists (
	select *
	from t_gsubmember aa2
	where
	t_gsubmember.id_group=aa2.id_group
	and
	t_gsubmember.id_acc=aa2.id_acc
	and
 	(
	(aa2.vt_start < t_gsubmember.vt_start and t_gsubmember.vt_end <= aa2.vt_end)
	or
	(aa2.vt_start <= t_gsubmember.vt_start and t_gsubmember.vt_end < aa2.vt_end)
	)
)
and
exists (
  select * from #tmp_subscribe_batch_sproc ar 
  where ar.id_group = t_gsubmember.id_group and ar.id_acc = t_gsubmember.id_acc
)

if object_id( ''tempdb..#coalesce_args'' ) is not null
  DROP TABLE #coalesce_args

CREATE TABLE #coalesce_args(id_acc int, id_group int, vt_start datetime, vt_end datetime, tt_start datetime, tt_end datetime, update_tt_start datetime, update_tt_end datetime, update_vt_end datetime)

CREATE CLUSTERED INDEX idx_acc_group ON #coalesce_args(id_acc, id_group)

-- Here is another approach.
-- Select a record that can be extended in valid time direction.
-- Issue an update statement to extend the vt_end and to set the
-- [tt_start, tt_end] to be the intersection of the original records
-- transaction time interval and the transaction time interval of the
-- extender.
-- Issue an insert statement to create 0,1 or 2 records that have the
-- same valid time interval as the original record but that have a new
-- tt_end or tt_start in the case that their associated tt_start or tt_end
-- extends beyond that of the extending record.
--
--  --------
--  |      |
--  |      |
--  |   ---------
--  |   |  |    |
--  |   |  |    |
--  |   |  |    |
--  --------    |
--      |       | 
--      |       |  
--      ---------
WHILE 1=1
BEGIN
insert into #coalesce_args(id_group, id_acc, vt_start, vt_end, tt_start, tt_end, update_tt_start, update_tt_end, update_vt_end)
select 
gsm.id_group,
gsm.id_acc,
gsm.vt_start,
gsm.vt_end,
gsm.tt_start,
gsm.tt_end,
dbo.MTMaxOfTwoDates(gsm.tt_start, gsm2.tt_start) as update_tt_start,
dbo.MTMinOfTwoDates(gsm.tt_end, gsm2.tt_end) as update_tt_end,
max(gsm2.vt_end) as update_vt_end
from 
t_gsubmember_historical gsm
inner join t_gsubmember_historical gsm2 on
gsm.id_group=gsm2.id_group
and
gsm.id_acc=gsm2.id_acc
and
gsm.vt_start < gsm2.vt_start
and
gsm2.vt_start <= dateadd(s, 1, gsm.vt_end)
and
gsm.vt_end < gsm2.vt_end
and
gsm.tt_start <= gsm2.tt_end
and
gsm2.tt_start <= gsm.tt_end
where
exists (
  select * from #tmp_subscribe_batch_sproc ar 
  where ar.id_group = gsm.id_group and ar.id_acc = gsm.id_acc
)
group by
gsm.id_group,
gsm.id_acc,
gsm.vt_start,
gsm.vt_end,
gsm.tt_start,
gsm.tt_end,
dbo.MTMaxOfTwoDates(gsm.tt_start, gsm2.tt_start),
dbo.MTMinOfTwoDates(gsm.tt_end, gsm2.tt_end)

IF @@rowcount <= 0 BREAK

-- These are the records whose extender transaction time ends strictly within the record being
-- extended
insert into t_gsubmember_historical(id_group, id_acc, vt_start, vt_end, tt_start, tt_end)
select 
gsm.id_group, gsm.id_acc, gsm.vt_start, gsm.vt_end, dateadd(s, 1, gsm2.vt_end) as tt_start, gsm.tt_end
from 
t_gsubmember_historical gsm
inner join t_gsubmember_historical gsm2 on
gsm.id_group=gsm2.id_group
and
gsm.id_acc=gsm2.id_acc
and
gsm.vt_start < gsm2.vt_start
and
gsm2.vt_start <= dateadd(s, 1, gsm.vt_end)
and
gsm.vt_end < gsm2.vt_end
and
gsm.tt_start <= gsm2.tt_end
and
gsm2.tt_end < gsm.tt_end
where
exists (
  select * from #tmp_subscribe_batch_sproc ar 
  where ar.id_group = gsm.id_group and ar.id_acc = gsm.id_acc
)

-- These are the records whose extender starts strictly within the record being
-- extended
insert into t_gsubmember_historical(id_group, id_acc, vt_start, vt_end, tt_start, tt_end)
select 
gsm.id_group, gsm.id_acc, gsm.vt_start, gsm.vt_end, gsm.tt_start, dateadd(s, -1, gsm2.tt_start) as tt_end
from 
t_gsubmember_historical gsm
inner join t_gsubmember_historical gsm2 on
gsm.id_group=gsm2.id_group
and
gsm.id_acc=gsm2.id_acc
and
gsm.vt_start < gsm2.vt_start
and
gsm2.vt_start <= dateadd(s, 1, gsm.vt_end)
and
gsm.vt_end < gsm2.vt_end
and
gsm.tt_start < gsm2.tt_start
and
gsm2.tt_start <= gsm.tt_end
where
exists (
  select * from #tmp_subscribe_batch_sproc ar 
  where ar.id_group = gsm.id_group and ar.id_acc = gsm.id_acc
)

update  t_gsubmember_historical
set t_gsubmember_historical.vt_end = ca.update_vt_end,
t_gsubmember_historical.tt_start = ca.update_tt_start,
t_gsubmember_historical.tt_end = ca.update_tt_end
from 
t_gsubmember_historical gsm
inner join #coalesce_args ca on
gsm.id_group=ca.id_group
and
gsm.id_acc=ca.id_acc
and
gsm.vt_start=ca.vt_start
and
gsm.vt_end=ca.vt_end
and
gsm.tt_start=ca.tt_start
and
gsm.tt_end=ca.tt_end

TRUNCATE TABLE #coalesce_args
END

-- Don''t need #coalesce_args table anymore, delete it here.  There are some goofy
-- interactions between temp tables and DTC that we want to avoid.
DROP TABLE #coalesce_args

-- Here we select stuff to "delete"
-- In all cases we have containment invalid time.
-- Consider the four overlapping cases for transaction time.
-- 
update t_gsubmember_historical
set
t_gsubmember_historical.tt_start = (
	select dateadd(s, 1, max(tt_end))
	from
	t_gsubmember_historical gsm
	where
	t_gsubmember_historical.id_group=gsm.id_group
	and
	t_gsubmember_historical.id_acc=gsm.id_acc
	and
	gsm.vt_start <= t_gsubmember_historical.vt_start 
	and 
	t_gsubmember_historical.vt_end <= gsm.vt_end
	and
	gsm.tt_end >= t_gsubmember_historical.tt_start
	and
	gsm.tt_end < t_gsubmember_historical.tt_end
)
where
exists (
	select *
	from
	t_gsubmember_historical gsm
	where
	t_gsubmember_historical.id_group=gsm.id_group
	and
	t_gsubmember_historical.id_acc=gsm.id_acc
	and
	gsm.vt_start <= t_gsubmember_historical.vt_start 
	and 
	t_gsubmember_historical.vt_end <= gsm.vt_end
	and
	gsm.tt_end >= t_gsubmember_historical.tt_start
	and
	gsm.tt_end < t_gsubmember_historical.tt_end
)
and
exists (
  select * from #tmp_subscribe_batch_sproc ar 
  where ar.id_group = t_gsubmember_historical.id_group and ar.id_acc = t_gsubmember_historical.id_acc
)

update t_gsubmember_historical
set
t_gsubmember_historical.tt_end = (
	select dateadd(s, -1, min(tt_start))
	from
	t_gsubmember_historical gsm
	where
	t_gsubmember_historical.id_group=gsm.id_group
	and
	t_gsubmember_historical.id_acc=gsm.id_acc
	and
	gsm.vt_start <= t_gsubmember_historical.vt_start 
	and 
	t_gsubmember_historical.vt_end <= gsm.vt_end
	and
	gsm.tt_start > t_gsubmember_historical.tt_start
	and
	gsm.tt_start <= t_gsubmember_historical.tt_end
)
where
exists (
	select *
	from
	t_gsubmember_historical gsm
	where
	t_gsubmember_historical.id_group=gsm.id_group
	and
	t_gsubmember_historical.id_acc=gsm.id_acc
	and
	gsm.vt_start <= t_gsubmember_historical.vt_start 
	and 
	t_gsubmember_historical.vt_end <= gsm.vt_end
	and
	gsm.tt_start > t_gsubmember_historical.tt_start
	and
	gsm.tt_start <= t_gsubmember_historical.tt_end
)
and
exists (
  select * from #tmp_subscribe_batch_sproc ar 
  where ar.id_group = t_gsubmember_historical.id_group and ar.id_acc = t_gsubmember_historical.id_acc
)

delete gsm
--select *
from 
t_gsubmember_historical gsm
inner join t_gsubmember_historical gsm2 on
gsm.id_group=gsm2.id_group
and
gsm.id_acc=gsm2.id_acc
and
(
(gsm2.vt_start < gsm.vt_start and gsm.vt_end <= gsm2.vt_end)
or
(gsm2.vt_start <= gsm.vt_start and gsm.vt_end < gsm2.vt_end)
)
and
gsm2.tt_start <= gsm.tt_start
and
gsm.tt_end <= gsm2.tt_end
where
exists (
  select * from #tmp_subscribe_batch_sproc ar 
  where ar.id_group = gsm.id_group and ar.id_acc = gsm.id_acc
)

-- Update audit information.

UPDATE tmp
SET tmp.nm_display_name = gsub.tx_name
FROM #tmp_subscribe_batch_sproc tmp
  INNER JOIN t_group_sub gsub ON gsub.id_group = tmp.id_group
WHERE tmp.status = 0

INSERT INTO t_audit(id_audit,      id_event,  id_userid,
                    id_entitytype, id_entity, dt_crt)
SELECT tmp.id_audit,      tmp.id_event, tmp.id_userid,
       tmp.id_entitytype, tmp.id_acc,   tmp.tt_now
FROM #tmp_subscribe_batch_sproc tmp WITH(READCOMMITTED)
WHERE tmp.status = 0

INSERT INTO t_audit_details(id_audit, tx_details)
SELECT tmp.id_audit, tmp.nm_display_name
FROM #tmp_subscribe_batch_sproc tmp WITH(READCOMMITTED)
WHERE tmp.status = 0


-- move data from temp tables at sproc scope to input table
set @stmt = ''TRUNCATE TABLE '' + @tmp_subscribe_batch
exec sp_executesql @stmt
set @stmt = ''INSERT INTO '' + @tmp_subscribe_batch + '' SELECT * FROM #tmp_subscribe_batch_sproc ''
exec sp_executesql @stmt
		
		' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[CheckEBCRCycleTypeCompatibility]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckEBCRCycleTypeCompatibility]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
  
CREATE FUNCTION [dbo].[CheckEBCRCycleTypeCompatibility]
  (@EBCRCycleType INT, @OtherCycleType INT)
RETURNS INT 
BEGIN
  -- checks weekly based cycle types
  IF (((@EBCRCycleType = 4) OR (@EBCRCycleType = 5)) AND
      ((@OtherCycleType = 4) OR (@OtherCycleType = 5)))
    RETURN 1   -- success

  -- checks monthly based cycle types
  IF (((@EBCRCycleType = 1) OR (@EBCRCycleType = 7) OR (@EBCRCycleType = 8)) AND
      ((@OtherCycleType = 1) OR (@OtherCycleType = 7) OR (@OtherCycleType = 8)))
    RETURN 1   -- success

  RETURN 0     -- failure
END
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreatePaymentRecordBitemporal]    Script Date: 06/02/2008 11:43:30 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreatePaymentRecordBitemporal]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
     
create Procedure [dbo].[CreatePaymentRecordBitemporal] (
@p_id_payer int,
@p_id_payee int,
@startdate  datetime,
@enddate datetime,
@p_systemdate datetime,
@status int OUTPUT
)
as
declare @realstartdate datetime
declare @realenddate datetime
declare @varMaxDateTime datetime
declare @tempStartDate datetime
declare @tempEndDate datetime
declare @onesecond_systemdate datetime
declare @temp_id_payer int
declare @temp_id_payee int

begin

-- detect directly adjacent records with a adjacent start and end date.  If the
-- key comparison matches successfully, use the start and/or end date of the original record 
-- instead.

select @realstartdate = @startdate,@realenddate = @enddate,@varMaxDateTime = dbo.mtmaxdate(),
  @onesecond_systemdate = dbo.subtractsecond(@p_systemdate)

 -- Someone changes the start date of an existing record so that it creates gaps in time
 -- Existing Record      |---------------------|
 -- modified record       	|-----------|
 -- modified record      |-----------------|
 -- modified record         |------------------|
	begin
		
		-- find the start and end dates of the original interval
		select 
		@tempstartdate = vt_start,
		@tempenddate = vt_end
    from
    t_payment_redir_history
    where dbo.encloseddaterange(vt_start,vt_end,@realstartdate,@realenddate) = 1 AND
    id_payer = @p_id_payer AND id_payee = @p_id_payee and tt_end = @varMaxDateTime 

		-- the original date range is no longer true
		update t_payment_redir_history
    set tt_end = @onesecond_systemdate
		where id_payer = @p_id_payer AND id_payee = @p_id_payee AND vt_start = @tempstartdate AND
		@tempenddate = vt_end AND tt_end = @varMaxDateTime

		-- adjust the two records end dates that are adjacent on the start and
		-- end dates; these records are no longer true
		update t_payment_redir_history 
		set tt_end = @onesecond_systemdate where
		id_payee = @p_id_payee AND tt_end = @varMaxDateTime AND
		(vt_end = dbo.subtractSecond(@tempstartdate) OR vt_start = dbo.addsecond(@tempenddate))
    if (@@error <> 0 )
		begin
    select @status = 0
		end

		insert into t_payment_redir_history 
		(id_payer,id_payee,vt_start,vt_end,tt_start,tt_end)
		select 
			id_payer,id_payee,vt_start,dbo.subtractsecond(@realstartdate),@p_systemdate,@varMaxDateTime
			from t_payment_redir_history 
			where
			id_payee = @p_id_payee AND vt_end = dbo.subtractSecond(@tempstartdate)
		UNION ALL
		select
			id_payer,id_payee,@realenddate,vt_end,@p_systemdate,@varMaxDateTime
			from t_payment_redir_history
			where
			id_payee = @p_id_payee  AND vt_start = dbo.addsecond(@tempenddate)

	end

	-- detect directly adjacent records with a adjacent start and end date.  If the
	-- key comparison matches successfully, use the start and/or end date of the original record 
	-- instead.
	
	select @realstartdate = vt_start
	from 
	t_payment_redir_history  where id_payer = @p_id_payer AND id_payee = @p_id_payee AND
		@startdate between vt_start AND dbo.addsecond(vt_end) and tt_end = @varMaxDateTime
	if @realstartdate is NULL begin
		select @realstartdate = @startdate
	end
	--CR 10620 fix: Do not add a second to end date
	select @realenddate = vt_end
	from
	t_payment_redir_history  where id_payer = @p_id_payer AND id_payee = @p_id_payee AND
	@enddate between vt_start AND vt_end and tt_end = @varMaxDateTime
	if @realenddate is NULL begin
		select @realenddate = @enddate
	end

 -- step : delete a range that is entirely in the new date range
 -- existing record:      |----|
 -- new record:      |----------------|
 update  t_payment_redir_history 
 set tt_end = @onesecond_systemdate
 where dbo.EnclosedDateRange(@realstartdate,@realenddate,vt_start,vt_end) =1 AND
 id_payee = @p_id_payee  AND tt_end = @varMaxDateTime 

 -- create two new records that are on around the new interval        
 -- existing record:          |-----------------------------------|
 -- new record                        |-------|
 --
 -- adjusted old records      |-------|       |--------------------|
  begin
    select
		@temp_id_payer = id_payer,
@temp_id_payee = id_payee

		,@tempstartdate = vt_start,
		@tempenddate = vt_end
    from
    t_payment_redir_history
    where dbo.encloseddaterange(vt_start,vt_end,@realstartdate,@realenddate) = 1 AND
    id_payee = @p_id_payee and tt_end = @varMaxDateTime AND  id_payer <> @p_id_payer
    update     t_payment_redir_history 
    set tt_end = @onesecond_systemdate where
    dbo.encloseddaterange(vt_start,vt_end,@realstartdate,@realenddate) = 1 AND
    id_payee = @p_id_payee AND tt_end = @varMaxDateTime AND  id_payer <> @p_id_payer
   
-- CR 14491 - Primary keys can not be null
if ((@temp_id_payee is not null))
begin

insert into t_payment_redir_history 
   (id_payer,id_payee,vt_start,vt_end,tt_start,tt_end)
   select 
    @temp_id_payer,@temp_id_payee,@tempStartDate,dbo.subtractsecond(@realstartdate),
    @p_systemdate,@varMaxDateTime
    where @tempstartdate is not NULL AND @tempStartDate <> @realstartdate
    -- the previous statement may fail
		if @realenddate <> @tempendDate AND @realenddate <> @varMaxDateTime begin
			insert into t_payment_redir_history 
			(id_payer,id_payee,vt_start,vt_end,tt_start,tt_end)
	    select
	    @temp_id_payer,@temp_id_payee,@realenddate,@tempEndDate,
	    @p_systemdate,@varMaxDateTime
		end
      
end

  -- the previous statement may fail
  end
 -- step 5: update existing payment records that are overlapping on the start
 -- range
 -- Existing Record |--------------|
 -- New Record: |---------|
 insert into t_payment_redir_history
 (id_payer,id_payee,vt_start,vt_end,tt_start,tt_end)
 select 
 id_payer,id_payee,@realenddate,vt_end,@p_systemdate,@varMaxDateTime
 from 
 t_payment_redir_history  where
 id_payee = @p_id_payee AND 
 vt_start > @realstartdate and vt_start < @realenddate 
 and tt_end = @varMaxDateTime
 
 update t_payment_redir_history
 set tt_end = @onesecond_systemdate
 where
 id_payee = @p_id_payee AND 
 vt_start > @realstartdate and vt_start < @realenddate 
 and tt_end = @varMaxDateTime
 -- step 4: update existing payment records that are overlapping on the end
 -- range
 -- Existing Record |--------------|
 -- New Record:             |-----------|
 insert into t_payment_redir_history
 (id_payer,id_payee,vt_start,vt_end,tt_start,tt_end)
 select
 id_payer,id_payee,vt_start,dbo.subtractsecond(@realstartdate),@p_systemdate,@varMaxDateTime
 from t_payment_redir_history
 where
 id_payee = @p_id_payee AND 
 vt_end > @realstartdate AND vt_end < @realenddate
 AND tt_end = @varMaxDateTime
 update t_payment_redir_history
 set tt_end = @onesecond_systemdate
 where id_payee = @p_id_payee AND 
  vt_end > @realstartdate AND vt_end < @realenddate
 AND tt_end = @varMaxDateTime
 -- used to be realenddate
 -- step 7: create the new payment redirection record.  If the end date 
 -- is not max date, make sure the enddate is subtracted by one second
 insert into t_payment_redir_history 
 (id_payer,id_payee,vt_start,vt_end,tt_start,tt_end)
 select 
 @p_id_payer,@p_id_payee,@realstartdate,
  case when @realenddate = dbo.mtmaxdate() then @realenddate else 
  dbo.subtractsecond(@realenddate) end,
  @p_systemdate,@varMaxDateTime
  
delete from t_payment_redirection where id_payee = @p_id_payee
insert into t_payment_redirection (id_payer,id_payee,vt_start,vt_end)
select id_payer,id_payee,vt_start,vt_end
from t_payment_redir_history  where
id_payee = @p_id_payee and tt_end = @varMaxDateTime
 select @status = 1
 end
			' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreateAccountStateRecord]    Script Date: 06/02/2008 11:43:22 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateAccountStateRecord]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
     
create Procedure [dbo].[CreateAccountStateRecord] (
@p_id_acc int,
@p_status varchar(2),
@startdate  datetime,
@enddate datetime,
@p_systemdate datetime,
@status int OUTPUT
)
as
declare @realstartdate datetime
declare @realenddate datetime
declare @varMaxDateTime datetime
declare @tempStartDate datetime
declare @tempEndDate datetime
declare @onesecond_systemdate datetime
declare @temp_id_acc int
declare @temp_status varchar(2)

begin

-- detect directly adjacent records with a adjacent start and end date.  If the
-- key comparison matches successfully, use the start and/or end date of the original record 
-- instead.

select @realstartdate = @startdate,@realenddate = @enddate,@varMaxDateTime = dbo.mtmaxdate(),
  @onesecond_systemdate = dbo.subtractsecond(@p_systemdate)

 -- Someone changes the start date of an existing record so that it creates gaps in time
 -- Existing Record      |---------------------|
 -- modified record       	|-----------|
 -- modified record      |-----------------|
 -- modified record         |------------------|
	begin
		
		-- find the start and end dates of the original interval
		select 
		@tempstartdate = vt_start,
		@tempenddate = vt_end
    from
    t_account_state_history
    where dbo.encloseddaterange(vt_start,vt_end,@realstartdate,@realenddate) = 1 AND
    id_acc = @p_id_acc AND status = @p_status and tt_end = @varMaxDateTime 

		-- the original date range is no longer true
		update t_account_state_history
    set tt_end = @onesecond_systemdate
		where id_acc = @p_id_acc AND status = @p_status AND vt_start = @tempstartdate AND
		@tempenddate = vt_end AND tt_end = @varMaxDateTime

		-- adjust the two records end dates that are adjacent on the start and
		-- end dates; these records are no longer true
		update t_account_state_history 
		set tt_end = @onesecond_systemdate where
		id_acc = @p_id_acc AND tt_end = @varMaxDateTime AND
		(vt_end = dbo.subtractSecond(@tempstartdate) OR vt_start = dbo.addsecond(@tempenddate))
    if (@@error <> 0 )
		begin
    select @status = 0
		end

		insert into t_account_state_history 
		(id_acc,status,vt_start,vt_end,tt_start,tt_end)
		select 
			id_acc,status,vt_start,dbo.subtractsecond(@realstartdate),@p_systemdate,@varMaxDateTime
			from t_account_state_history 
			where
			id_acc = @p_id_acc AND vt_end = dbo.subtractSecond(@tempstartdate)
		UNION ALL
		select
			id_acc,status,@realenddate,vt_end,@p_systemdate,@varMaxDateTime
			from t_account_state_history
			where
			id_acc = @p_id_acc  AND vt_start = dbo.addsecond(@tempenddate)

	end

	-- detect directly adjacent records with a adjacent start and end date.  If the
	-- key comparison matches successfully, use the start and/or end date of the original record 
	-- instead.
	
	select @realstartdate = vt_start
	from 
	t_account_state_history  where id_acc = @p_id_acc AND status = @p_status AND
		@startdate between vt_start AND dbo.addsecond(vt_end) and tt_end = @varMaxDateTime
	if @realstartdate is NULL begin
		select @realstartdate = @startdate
	end
	--CR 10620 fix: Do not add a second to end date
	select @realenddate = vt_end
	from
	t_account_state_history  where id_acc = @p_id_acc AND status = @p_status AND
	@enddate between vt_start AND vt_end and tt_end = @varMaxDateTime
	if @realenddate is NULL begin
		select @realenddate = @enddate
	end

 -- step : delete a range that is entirely in the new date range
 -- existing record:      |----|
 -- new record:      |----------------|
 update  t_account_state_history 
 set tt_end = @onesecond_systemdate
 where dbo.EnclosedDateRange(@realstartdate,@realenddate,vt_start,vt_end) =1 AND
 id_acc = @p_id_acc  AND tt_end = @varMaxDateTime 

 -- create two new records that are on around the new interval        
 -- existing record:          |-----------------------------------|
 -- new record                        |-------|
 --
 -- adjusted old records      |-------|       |--------------------|
  begin
    select
		@temp_id_acc = id_acc,
@temp_status = status

		,@tempstartdate = vt_start,
		@tempenddate = vt_end
    from
    t_account_state_history
    where dbo.encloseddaterange(vt_start,vt_end,@realstartdate,@realenddate) = 1 AND
    id_acc = @p_id_acc and tt_end = @varMaxDateTime AND  status <> @p_status
    update     t_account_state_history 
    set tt_end = @onesecond_systemdate where
    dbo.encloseddaterange(vt_start,vt_end,@realstartdate,@realenddate) = 1 AND
    id_acc = @p_id_acc AND tt_end = @varMaxDateTime AND  status <> @p_status
   
-- CR 14491 - Primary keys can not be null
if ((@temp_id_acc is not null))
begin

insert into t_account_state_history 
   (id_acc,status,vt_start,vt_end,tt_start,tt_end)
   select 
    @temp_id_acc,@temp_status,@tempStartDate,dbo.subtractsecond(@realstartdate),
    @p_systemdate,@varMaxDateTime
    where @tempstartdate is not NULL AND @tempStartDate <> @realstartdate
    -- the previous statement may fail
		if @realenddate <> @tempendDate AND @realenddate <> @varMaxDateTime begin
			insert into t_account_state_history 
			(id_acc,status,vt_start,vt_end,tt_start,tt_end)
	    select
	    @temp_id_acc,@temp_status,@realenddate,@tempEndDate,
	    @p_systemdate,@varMaxDateTime
		end
      
end

  -- the previous statement may fail
  end
 -- step 5: update existing payment records that are overlapping on the start
 -- range
 -- Existing Record |--------------|
 -- New Record: |---------|
 insert into t_account_state_history
 (id_acc,status,vt_start,vt_end,tt_start,tt_end)
 select 
 id_acc,status,@realenddate,vt_end,@p_systemdate,@varMaxDateTime
 from 
 t_account_state_history  where
 id_acc = @p_id_acc AND 
 vt_start > @realstartdate and vt_start < @realenddate 
 and tt_end = @varMaxDateTime
 
 update t_account_state_history
 set tt_end = @onesecond_systemdate
 where
 id_acc = @p_id_acc AND 
 vt_start > @realstartdate and vt_start < @realenddate 
 and tt_end = @varMaxDateTime
 -- step 4: update existing payment records that are overlapping on the end
 -- range
 -- Existing Record |--------------|
 -- New Record:             |-----------|
 insert into t_account_state_history
 (id_acc,status,vt_start,vt_end,tt_start,tt_end)
 select
 id_acc,status,vt_start,dbo.subtractsecond(@realstartdate),@p_systemdate,@varMaxDateTime
 from t_account_state_history
 where
 id_acc = @p_id_acc AND 
 vt_end > @realstartdate AND vt_end < @realenddate
 AND tt_end = @varMaxDateTime
 update t_account_state_history
 set tt_end = @onesecond_systemdate
 where id_acc = @p_id_acc AND 
  vt_end > @realstartdate AND vt_end < @realenddate
 AND tt_end = @varMaxDateTime
 -- used to be realenddate
 -- step 7: create the new payment redirection record.  If the end date 
 -- is not max date, make sure the enddate is subtracted by one second
 insert into t_account_state_history 
 (id_acc,status,vt_start,vt_end,tt_start,tt_end)
 select 
 @p_id_acc,@p_status,@realstartdate,
  case when @realenddate = dbo.mtmaxdate() then @realenddate else 
  dbo.subtractsecond(@realenddate) end,
  @p_systemdate,@varMaxDateTime
  
delete from t_account_state where id_acc = @p_id_acc
insert into t_account_state (id_acc,status,vt_start,vt_end)
select id_acc,status,vt_start,vt_end
from t_account_state_history  where
id_acc = @p_id_acc and tt_end = @varMaxDateTime
 select @status = 1
 end
			' 
END
GO
/****** Object:  StoredProcedure [dbo].[MTSP_INSERTINVOICE_DEFLTINVNUM]    Script Date: 06/02/2008 11:44:03 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTSP_INSERTINVOICE_DEFLTINVNUM]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'	
CREATE PROCEDURE [dbo].[MTSP_INSERTINVOICE_DEFLTINVNUM]
@invoice_date DATETIME
AS
BEGIN
SELECT 
	tmp.id_acc,
	tmp.namespace,
	tins.invoice_prefix
	 + ISNULL(REPLICATE(''0'', tins.invoice_num_digits - LEN(RTRIM(CONVERT(nvarchar,tmp.tmp_seq + tins.id_invoice_num_last + 1 - 1)))),'''')
	 + RTRIM(CONVERT(nvarchar,tmp_seq + tins.id_invoice_num_last + 1 - 1))
	 + tins.invoice_suffix,
	@invoice_date+tins.invoice_due_date_offset,
	tmp.tmp_seq + tins.id_invoice_num_last
FROM #tmp_all_accounts tmp
INNER JOIN t_invoice_namespace tins ON tins.namespace = tmp.namespace
END
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[CompleteBillGroupConstraints]    Script Date: 06/02/2008 11:43:20 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CompleteBillGroupConstraints]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
	
/* ===========================================================
This is executed after the adapters have created billing group constraints in
t_billgroup_constraint_tmp.

1) Fill in missing payers 
If any of the accounts in t_billgroup_source_acc do not exist
in t_billgroup_constraint_tmp after the adapters have created
their constraint groups, then create one group per account for
the remaining accounts.

2) Validate that the id_group in t_billgroup_constraint_tmp is correctly named 
ie. it must be any one of the account IDs in the constraint group

3) Prunes (must be regular) and coalesces constraint groups. 
If constraint groups intersect, they will be coalesced into 
larger groups containing a union of the intersecting groups. 
Worst case, all groups will coalesce into one supergroup 
representing every payer in the interval. 
By the end of this process, there will be one row for 
every payer and every payer will belong to exactly one constraint group.

Returns:
-1 if an unknown error has occurred
-2 if the accounts in t_billgroup_constraint_tmp are not paying accounts
-3 if the id_group is not named as one of the accounts in the group
-4 if there are duplicate id_acc for the given @id_materialization
============================================================== */
CREATE PROCEDURE [dbo].[CompleteBillGroupConstraints]
(
   @id_materialization INT,
   @status INT OUTPUT
)
AS

BEGIN 
   -- initialize @status to failure (-1)
   SET @status = -1 

   BEGIN TRAN
  
   /* Store the id_usage_interval */
   DECLARE @id_usage_interval INT
   SELECT @id_usage_interval = id_usage_interval
   FROM t_billgroup_materialization
   WHERE id_materialization = @id_materialization

   /* Validate that the accounts in t_billgroup_constraint_tmp are paying accounts */
   IF (EXISTS (SELECT 1
                    FROM t_billgroup_constraint_tmp bctmp
                    WHERE id_usage_interval = @id_usage_interval AND
                                NOT exists (select 1  FROM t_acc_usage_interval aui
											INNER JOIN t_account_mapper amap ON amap.id_acc = aui.id_acc
											  INNER JOIN t_namespace nmspace ON nmspace.nm_space = amap.nm_space
											  WHERE  nmspace.tx_typ_space = ''system_mps'' 
											  and aui.id_acc = bctmp.id_acc
											  and aui.id_usage_interval = @id_usage_interval)))
    BEGIN
       SET @status = -2
       ROLLBACK
       RETURN 
    END

    /* Validate that the id_group in t_billgroup_constraint_tmp is correctly named 
       ie. it must be any one of the account IDs in the constraint group */
    IF (EXISTS (SELECT 1 
	         FROM t_billgroup_constraint_tmp t1
	         WHERE t1.id_group NOT IN (SELECT id_acc
					     FROM t_billgroup_constraint_tmp
					     WHERE id_group = t1.id_group)))
     BEGIN
       SET @status = -3
       ROLLBACK
       RETURN 
    END

    /* coalesces constraint groups into a set of unique, disjoint supergroups  */
DECLARE group_cursor CURSOR FOR
	select distinct id_group from t_billgroup_constraint_tmp
	where id_acc in
	(
	   select id_acc from
		t_billgroup_constraint_tmp
		group by id_acc,id_usage_interval
		having count(id_group) > 1
	)
OPEN group_cursor
DECLARE @group INT
FETCH NEXT FROM group_cursor INTO @group
WHILE @@FETCH_STATUS = 0
BEGIN

  -- check if group still exists 
  IF NOT EXISTS(SELECT * FROM t_billgroup_constraint_tmp where id_group = @group)
  BEGIN
    FETCH NEXT FROM group_cursor into @group
    CONTINUE
  END

  -- figure out which other groups reference accounts from this group
  DECLARE @otherGroups TABLE (id_group int)
  INSERT INTO @otherGroups
  SELECT distinct c2.id_group
  FROM t_billgroup_constraint_tmp c
  INNER JOIN t_billgroup_constraint_tmp c2 
      ON c2.id_acc = c.id_acc AND
            c2.id_usage_interval = c.id_usage_interval
  WHERE c.id_group = @group AND c2.id_group <> @group

  -- adds the additional groups'' members to the group we are currently processing
  INSERT INTO t_billgroup_constraint_tmp (id_usage_interval, id_group, id_acc)
  SELECT DISTINCT
    @id_usage_interval,
    @group,
    id_acc
  FROM t_billgroup_constraint_tmp 
  WHERE 
    id_group IN (SELECT * FROM @otherGroups) AND
    id_acc NOT IN (SELECT id_acc 
                            FROM t_billgroup_constraint_tmp 
                            WHERE id_group = @group AND
                                        id_usage_interval = @id_usage_interval) AND
    id_usage_interval = @id_usage_interval

  -- deletes the additional groups now that we''ve copied their members
  DELETE FROM t_billgroup_constraint_tmp WHERE id_group IN (SELECT * FROM @otherGroups)

  FETCH NEXT FROM group_cursor into @group
END
CLOSE group_cursor
DEALLOCATE group_cursor

 /* Fill in missing payers.
      Adds in the remaining constraint groups of single payers
      that don''t already exist in any other constraint groups */
   INSERT INTO t_billgroup_constraint_tmp(id_usage_interval, id_group, id_acc)
   SELECT @id_usage_interval,
               id_acc,
               id_acc
   FROM t_billgroup_source_acc
   WHERE id_materialization = @id_materialization AND
               id_acc NOT IN (SELECT id_acc 
                                       FROM t_billgroup_constraint_tmp 
                                       WHERE id_usage_interval = @id_usage_interval)

   /* Check for duplicate accounts */
   IF EXISTS (SELECT id_acc 
                   FROM t_billgroup_constraint_tmp
	       WHERE id_usage_interval = @id_usage_interval 
	       GROUP BY id_acc
	       HAVING COUNT(id_acc) > 1)
   BEGIN
     SET @status = -4
     ROLLBACK
     RETURN 
   END

  SET @status = 0
  COMMIT
END

 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[GrantAllCapabilityToAccount]    Script Date: 06/02/2008 11:43:47 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GrantAllCapabilityToAccount]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
        
						CREATE PROCEDURE [dbo].[GrantAllCapabilityToAccount]
						(@aLoginName NVARCHAR(255), @aNameSpace NVARCHAR(255)) 
						as
						
						declare @polID INT
						declare @dummy int
            declare @aAccountID INT
        			begin
              SELECT @aAccountID = id_acc FROM t_account_mapper WHERE nm_login = @aLoginName AND nm_space = @aNameSpace
              IF @aAccountID IS NULL
              BEGIN
                RAISERROR(''No Records found in t_account_mapper for Login Name %s and NameSpace %s'', 16, 2, @aLoginName,  @aNameSpace)
              END
							SELECT @polID  = id_policy FROM T_PRINCIPAL_POLICY WHERE id_acc = @aAccountID AND policy_type = ''A''
							if (@polID is null)
								begin
								exec sp_Insertpolicy ''id_acc'', @aAccountID, ''A'', @polID output
								end
							end
							begin
							SELECT @dummy = id_policy FROM T_CAPABILITY_INSTANCE WHERE id_policy = @polID
							if (@dummy is null)
								begin		         
								INSERT INTO T_CAPABILITY_INSTANCE(tx_guid,id_parent_cap_instance,id_policy,id_cap_type) 
								SELECT cast(''ABCD'' as varbinary(16)), NULL,@polID,id_cap_type FROM T_COMPOSITE_CAPABILITY_TYPE WHERE 
								tx_name = ''Unlimited Capability''
								end
							end
				 
        ' 
END
GO
/****** Object:  View [dbo].[vw_mps_or_system_acc_mapper]    Script Date: 06/02/2008 11:44:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[vw_mps_or_system_acc_mapper]'))
EXEC dbo.sp_executesql @statement = N'
					  
				create view [dbo].[vw_mps_or_system_acc_mapper] as
        select 
				mapper.nm_login,
				mapper.nm_space,
				mapper.id_acc,
				case when tac.id_acc is NULL then '''' else
				  (c_firstname + ('' '' + c_lastname)) end as fullname,
        case when (tac.c_firstname is NULL or tac.c_firstname = '''') and (tac.c_lastname is NULL or tac.c_lastname ='''') then 
           (mapper.nm_login + ('' ('' + (cast(mapper.id_acc as varchar(255)) + '')'')))
        else
            case when tac.c_firstname is null or tac.c_firstname = '''' then
              (tac.c_lastname + ('' ('' + (cast(mapper.id_acc as varchar(255)) + '')'')))
            else
              case when tac.c_lastname is null or tac.c_lastname ='''' then
                (tac.c_firstname + ('' ('' + (cast(mapper.id_acc as varchar(255)) + '')'')))
              else
                ((tac.c_firstname + ('' '' + tac.c_lastname)) + ('' ('' + (cast(mapper.id_acc as varchar(255)) + '')'')))
              end
            end
        end as displayname,
        case when tac.c_firstname is NULL and tac.c_lastname is NULL then 
          mapper.nm_login
        else
          case when tac.c_firstname is null or tac.c_firstname = '''' then
            tac.c_lastname
          else
            case when tac.c_lastname is null or tac.c_lastname = '''' then
              tac.c_firstname
            else
             (tac.c_firstname + ('' '' + tac.c_lastname))
            end
          end
        end as hierarchydisplayname,
        ns.tx_typ_space
		FROM dbo.t_account_mapper mapper
		INNER JOIN dbo.t_namespace ns on ns.nm_space = mapper.nm_space 
			AND ns.tx_typ_space IN (''system_mps'', ''system_user'', ''system_auth'')
		INNER JOIN dbo.t_enum_data ed on ed.nm_enum_data = ''metratech.com/accountcreation/contacttype/bill-to''
		LEFT OUTER JOIN t_av_contact tac on tac.id_acc = mapper.id_acc AND
			tac.c_contacttype = ed.id_enum_data
				'
GO
/****** Object:  View [dbo].[VW_MPS_ACC_MAPPER]    Script Date: 06/02/2008 11:44:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[VW_MPS_ACC_MAPPER]'))
EXEC dbo.sp_executesql @statement = N'
					  
		create view [dbo].[VW_MPS_ACC_MAPPER] as
        select
				mapper.nm_login,
				mapper.nm_space,
				mapper.id_acc,
				case when tac.id_acc is NULL then '''' else
				  (c_firstname + ('' '' + c_lastname)) end as fullname,
        case when (tac.c_firstname is NULL or tac.c_firstname = '''') and
				  (tac.c_lastname is NULL or tac.c_lastname = '''') then 
			(mapper.nm_login + ('' ('' + (cast(mapper.id_acc as varchar(255)) + '')'')))
        else
            case when (tac.c_firstname is null or tac.c_firstname = '''') then
              (tac.c_lastname + ('' ('' + (cast(mapper.id_acc as varchar(255)) + '')'')))
            else
              case when (tac.c_lastname is null or tac.c_lastname = '''') then
                (tac.c_firstname + ('' ('' + (cast(mapper.id_acc as varchar(255)) + '')'')))
              else
                ((tac.c_firstname + ('' '' + tac.c_lastname)) + ('' ('' + (cast(mapper.id_acc as varchar(255)) + '')'')))
              end
            end
        end as displayname,
        case when (tac.c_firstname is NULL or tac.c_firstname = '''') and (tac.c_lastname is NULL or tac.c_lastname = '''') then 
          mapper.nm_login
        else
          case when tac.c_firstname is null or tac.c_firstname = '''' then
            tac.c_lastname
          else
            case when tac.c_lastname is null or tac.c_lastname = '''' then
              tac.c_firstname
            else
              (tac.c_firstname + ('' '' + tac.c_lastname))
            end
          end
        end as hierarchydisplayname,
        ns.tx_typ_space
		FROM dbo.t_account_mapper mapper
		INNER JOIN dbo.t_namespace ns on ns.nm_space = mapper.nm_space 
			--AND ns.tx_typ_space IN (''system_mps'', ''system_user'', ''system_auth'')
		INNER JOIN dbo.t_enum_data ed on ed.nm_enum_data = ''metratech.com/accountcreation/contacttype/bill-to''
		LEFT OUTER JOIN t_av_contact tac on tac.id_acc = mapper.id_acc AND
			tac.c_contacttype = ed.id_enum_data
		WHERE ns.tx_typ_space = ''system_mps''
        '
GO
/****** Object:  View [dbo].[VW_AR_ACC_MAPPER]    Script Date: 06/02/2008 11:44:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[VW_AR_ACC_MAPPER]'))
EXEC dbo.sp_executesql @statement = N'
        
            CREATE  VIEW [dbo].[VW_AR_ACC_MAPPER]        
            (ID_ACC, ExtAccount, ExtNamespace) 
            AS select am.id_acc, am.nm_login, am.nm_space from t_account_mapper am join t_namespace ns on am.nm_space= ns.nm_space where tx_typ_space=''system_ar''
				 
        '
GO
/****** Object:  View [dbo].[vw_audit_log]    Script Date: 06/02/2008 11:44:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[vw_audit_log]'))
EXEC dbo.sp_executesql @statement = N'
      CREATE VIEW [dbo].[vw_audit_log] AS
        select 	audit.dt_crt as "Time",
        	accmap.nm_login +
					case accmap.nm_login when null then null else ''/'' end + accmap.nm_space as "UserName",
        	audit.id_userid as "UserId",
        	audit.id_Event as "EventId",
        	d.tx_desc as "EventName",
        	EntityName =
                CASE audit.id_entitytype
        	 WHEN 1 THEN (select nm_login from t_account_mapper a,t_namespace n where id_acc=audit.id_entity and a.nm_space=n.nm_space and n.tx_typ_space !=''metered'' and n.tx_typ_space != ''system_ar'')
        	 WHEN 2 THEN (select nm_name from t_base_props where id_prop=audit.id_entity)
        	 WHEN 3 THEN (select tx_name from t_group_sub where id_group=audit.id_entity)
         	 WHEN 5 THEN (select tx_FailureCompoundId_encoded from t_failed_transaction where id_failed_transaction=audit.id_entity)
         	 WHEN 6 THEN (select tx_namespace + ''\'' + tx_name + ''\'' + tx_sequence from t_batch where id_batch=audit.id_entity)                      
        	 ELSE NULL
        	END,
        	audit.id_entity as "EntityId",
        	audit.id_entitytype as "EntityType",
        	auditdetail.tx_details as "Details",
        	audit.*
        from
        	t_audit audit
          inner join t_audit_events auditevent on audit.id_event = auditevent.id_event
          inner join t_description d on auditevent.id_desc = d.id_desc and d.id_lang_code = 840
          left outer join t_account_mapper accmap on audit.id_userid = accmap.id_acc 
          left outer join t_audit_details auditdetail on audit.id_audit = auditdetail.id_audit
 		'
GO
/****** Object:  StoredProcedure [dbo].[UndoAccounts]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UndoAccounts]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
	create proc [dbo].[UndoAccounts] @id_acc int, @nm_login nvarchar(255), @nm_space nvarchar(40) as 
         begin tran 
           if exists (select * from t_account_mapper where id_acc = @id_acc) 
             begin delete from t_account_mapper where id_acc = @id_acc end 

           if exists (select * from t_account where id_acc = @id_acc) 
             begin delete from t_account where id_acc = @id_acc end 

           if exists (select * from t_acc_usage_cycle where id_acc = @id_acc) 
             begin delete from t_acc_usage_cycle where id_acc = @id_acc end 

           if exists (select * from t_user_credentials where nm_login = @nm_login and nm_space = @nm_space)
             begin delete from t_user_credentials where nm_login = @nm_login and nm_space = @nm_space end 

           if exists (select * from t_acc_usage_interval where id_acc = @id_acc) 
             begin delete from t_acc_usage_interval where id_acc = @id_acc end 

           if exists (select * from t_site_user where nm_login = @nm_login)
			       begin delete from t_site_user where nm_login = @nm_login end 

           if exists (select * from t_av_internal where id_acc = @id_acc) 
             begin delete from t_av_internal where id_acc = @id_acc end 
         commit tran
			 ' 
END
GO
/****** Object:  View [dbo].[vw_paying_accounts]    Script Date: 06/02/2008 11:44:17 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[vw_paying_accounts]'))
EXEC dbo.sp_executesql @statement = N'
  
/* ===========================================================
Return the paying accounts for each interval
=========================================================== */
CREATE VIEW [dbo].[vw_paying_accounts] AS
   SELECT aui.id_usage_interval IntervalID,
               aui.id_acc AccountID,
               aui.tx_status State
   FROM t_acc_usage_interval aui
   INNER JOIN t_account_mapper amap ON amap.id_acc = aui.id_acc
   INNER JOIN t_namespace nmspace ON nmspace.nm_space = amap.nm_space
   WHERE  nmspace.tx_typ_space = ''system_mps'' 
   GROUP BY aui.id_usage_interval, aui.id_acc, aui.tx_status
   
'
GO
/****** Object:  View [dbo].[T_VW_ACCTRES]    Script Date: 06/02/2008 11:44:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[T_VW_ACCTRES]'))
EXEC dbo.sp_executesql @statement = N'
CREATE VIEW [dbo].[T_VW_ACCTRES]
(ID_ACC, NM_LOGIN, NM_SPACE, PAYER_ID_USAGE_CYCLE, C_PRICELIST, 
ID_PAYER, PAYER_START, PAYER_END,  STATUS, STATE_START, STATE_END, CURRENCY ) 
AS SELECT
	amap.id_acc, amap.nm_login, amap.nm_space, payer_uc.id_usage_cycle, avi.c_pricelist,
	redir.id_payer, 
	case when redir.vt_start is NULL then dbo.MTMinDate() else redir.vt_start end,
	case when redir.vt_end is NULL then dbo.MTMaxDate() else redir.vt_end end,
	ast.status, ast.vt_start, ast.vt_end, tav.c_currency
FROM dbo.t_account_mapper amap
INNER JOIN dbo.t_av_internal avi ON avi.id_acc = amap.id_acc
INNER JOIN dbo.t_account_state ast ON ast.id_acc = amap.id_acc
INNER JOIN t_payment_redirection redir on redir.id_payee = avi.id_acc
LEFT OUTER JOIN t_av_internal tav on tav.id_acc = redir.id_payer
LEFT OUTER JOIN t_acc_usage_cycle payer_uc on payer_uc.id_acc = redir.id_payer
	'
GO
/****** Object:  View [dbo].[VW_MPS_OR_SYSTEM_HIERARCHYNAME]    Script Date: 06/02/2008 11:44:17 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[VW_MPS_OR_SYSTEM_HIERARCHYNAME]'))
EXEC dbo.sp_executesql @statement = N'
          
            CREATE VIEW [dbo].[VW_MPS_OR_SYSTEM_HIERARCHYNAME] ( hierarchyname, id_acc, icon )
            AS
            SELECT
              CASE
                WHEN (tac.c_firstname IS NULL OR tac.c_firstname = '''') AND (tac.c_lastname IS NULL OR tac.c_lastname = '''') THEN mapper.nm_login
                WHEN tac.c_firstname IS NULL OR tac.c_firstname = '''' THEN tac.c_lastname
                WHEN tac.c_lastname IS NULL OR tac.c_lastname = '''' THEN tac.c_firstname
                ELSE (tac.c_firstname + ('' '' + tac.c_lastname))
              END AS hierarchyname,
              mapper.id_acc id_acc,
              ''account.gif'' AS icon
              FROM dbo.t_account_mapper mapper
              INNER JOIN dbo.t_namespace ns ON ns.nm_space = mapper.nm_space 
              INNER JOIN dbo.t_enum_data ed ON ed.nm_enum_data = ''metratech.com/accountcreation/contacttype/bill-to''
              LEFT OUTER JOIN t_av_contact tac ON tac.id_acc = mapper.id_acc AND tac.c_contacttype = ed.id_enum_data
              WHERE ns.tx_typ_space IN (''SYSTEM_MPS'', ''SYSTEM_USER'')
          
        '
GO
/****** Object:  View [dbo].[VW_HIERARCHYNAME]    Script Date: 06/02/2008 11:44:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[VW_HIERARCHYNAME]'))
EXEC dbo.sp_executesql @statement = N'
          
            CREATE VIEW [dbo].[VW_HIERARCHYNAME] ( hierarchyname, id_acc )
            AS
            SELECT
              CASE
                WHEN (tac.c_firstname IS NULL OR tac.c_firstname = '''') AND
					 (tac.c_lastname IS NULL OR tac.c_lastname = '''') THEN mapper.nm_login
                WHEN tac.c_firstname IS NULL OR tac.c_firstname = '''' THEN tac.c_lastname
                WHEN tac.c_lastname IS NULL OR tac.c_lastname = '''' THEN tac.c_firstname
                ELSE (tac.c_firstname + ('' '' + tac.c_lastname))
              END AS hierarchyname,
              mapper.id_acc id_acc
              FROM dbo.t_account_mapper mapper
              INNER JOIN dbo.t_namespace ns ON ns.nm_space = mapper.nm_space 
              INNER JOIN dbo.t_enum_data ed ON ed.nm_enum_data = ''metratech.com/accountcreation/contacttype/bill-to''
              LEFT OUTER JOIN t_av_contact tac ON tac.id_acc = mapper.id_acc AND tac.c_contacttype = ed.id_enum_data
              WHERE ns.tx_typ_space = ''SYSTEM_MPS''
          
        '
GO
/****** Object:  UserDefinedFunction [dbo].[LookupAccount]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[LookupAccount]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
					create function [dbo].[LookupAccount](@login nvarchar(255),@namespace nvarchar(40)) 
					returns int
					as
					begin
					declare @retval as int
					select @retval = id_acc  from t_account_mapper 
					where nm_login = @login AND
					lower(@namespace) = nm_space
					if @retval is null
					  begin
						set @retval = -1
					  end
					return @retval
					end

				' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[POContainsOnlyAbsoluteRates]    Script Date: 06/02/2008 11:44:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[POContainsOnlyAbsoluteRates]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
  
    create function [dbo].[POContainsOnlyAbsoluteRates](@id_po int) returns int
    as
    begin
    declare @retval as integer
	    select @retval = count(te.id_eff_date)
	    from
	    t_effectivedate te
	    INNER JOIN t_po on t_po.id_po = @id_po
	    INNER JOIN t_pl_map map on map.id_po = t_po.id_po AND id_paramtable is not NULL AND id_sub is NULL
	    LEFT OUTER JOIN t_rsched sched on sched.id_pt = map.id_paramtable AND sched.id_pricelist = map.id_pricelist
	    AND sched.id_pi_template = map.id_pi_template
	    where
	    te.id_eff_date = sched.id_eff_date AND
	    -- only absolute or NULL dates
	    (te.n_begintype in (2,3) OR te.n_endtype in (2,3))
	    if @retval > 0  begin
		    return 0
	    end
	    else begin
		    return 1
	    end
	    return 0
    end
		
' 
END
GO
/****** Object:  View [dbo].[t_vw_allrateschedules_pl]    Script Date: 06/02/2008 11:44:12 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_allrateschedules_pl]'))
EXEC dbo.sp_executesql @statement = N'
        
create view [dbo].[t_vw_allrateschedules_pl]
(
id_po, 
id_paramtable, 
id_pi_instance,
id_pi_template,
id_sub, 
id_sched,
dt_mod,
rs_begintype, 
rs_beginoffset, 
rs_beginbase,
rs_endtype, 
rs_endoffset, 
rs_endbase, 
id_pricelist)
with SCHEMABINDING
as
select 
null as id_po,
mapInner.id_pt as id_paramtable,
null as id_pi_instance,
templateInner.id_template as id_pi_template,
null as id_sub,
trInner.id_sched as id_sched,
trInner.dt_mod as dt_mod,
teInner.n_begintype as rs_begintype, 
teInner.n_beginoffset as rs_beginoffset,
teInner.dt_start as rs_beginbase, 
teInner.n_endtype as rs_endtype,
teInner.n_endoffset as rs_endoffset,
teInner.dt_end as rs_endbase,
trInner.id_pricelist as id_pricelist
from dbo.t_rsched trInner
INNER JOIN dbo.t_effectivedate teInner ON teInner.id_eff_date = trInner.id_eff_date
-- XXX fix this by passing in the instance ID
INNER JOIN dbo.t_pi_template templateInner on templateInner.id_template=trInner.id_pi_template
INNER JOIN dbo.t_pi_rulesetdef_map mapInner ON mapInner.id_pi = templateInner.id_pi and trInner.id_pt = mapInner.id_pt
		'
GO
SET ARITHABORT ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
SET ANSI_PADDING ON
GO
SET ANSI_WARNINGS ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_allrateschedules_pl]') AND name = N'idx_t_vw_allrateschedules_pl')
CREATE UNIQUE CLUSTERED INDEX [idx_t_vw_allrateschedules_pl] ON [dbo].[t_vw_allrateschedules_pl] 
(
	[id_pi_template] ASC,
	[id_pricelist] ASC,
	[id_sched] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ARITHABORT ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
SET ANSI_PADDING ON
GO
SET ANSI_WARNINGS ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_allrateschedules_pl]') AND name = N'idx_t_vw_allrateschedules_pl_param')
CREATE UNIQUE NONCLUSTERED INDEX [idx_t_vw_allrateschedules_pl_param] ON [dbo].[t_vw_allrateschedules_pl] 
(
	[id_sched] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  View [dbo].[t_vw_allrateschedules_po_noicb]    Script Date: 06/02/2008 11:44:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_allrateschedules_po_noicb]'))
EXEC dbo.sp_executesql @statement = N'
        
create view [dbo].[t_vw_allrateschedules_po_noicb]
(
id_po, 
id_paramtable, 
id_pi_instance,
id_pi_template,
id_sub, 
id_sched,
dt_mod,
rs_begintype, 
rs_beginoffset, 
rs_beginbase,
rs_endtype, 
rs_endoffset, 
rs_endbase, 
id_pricelist)
with SCHEMABINDING
as
select
tmInner.id_po as id_po,
tmInner.id_paramtable as id_paramtable,
tmInner.id_pi_instance as id_pi_instance,
tmInner.id_pi_template as id_pi_template,
NULL as id_sub,
rschedInner.id_sched as id_sched,
rschedInner.dt_mod as dt_mod,
teInner.n_begintype as rs_begintype, 
teInner.n_beginoffset as rs_beginoffset,
teInner.dt_start as rs_beginbase, 
teInner.n_endtype as rs_endtype,
teInner.n_endoffset as rs_endoffset,
teInner.dt_end as rs_endbase,
rschedInner.id_pricelist as id_pricelist
from
dbo.t_pl_map tmInner
INNER JOIN dbo.t_rsched rschedInner on 
 rschedInner.id_pricelist = tmInner.id_pricelist 
 AND rschedInner.id_pt =tmInner.id_paramtable 
 AND rschedInner.id_pi_template = tmInner.id_pi_template
INNER JOIN dbo.t_effectivedate teInner on teInner.id_eff_date = rschedInner.id_eff_date
where tmInner.id_sub is null
		'
GO
SET ARITHABORT ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
SET ANSI_PADDING ON
GO
SET ANSI_WARNINGS ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_allrateschedules_po_noicb]') AND name = N'idx_t_vw_allrateschedules_po_noicb')
CREATE UNIQUE CLUSTERED INDEX [idx_t_vw_allrateschedules_po_noicb] ON [dbo].[t_vw_allrateschedules_po_noicb] 
(
	[id_pi_template] ASC,
	[id_po] ASC,
	[id_sched] ASC,
	[id_pi_instance] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ARITHABORT ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
SET ANSI_PADDING ON
GO
SET ANSI_WARNINGS ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_allrateschedules_po_noicb]') AND name = N'idx_t_vw_allrateschedules_po_noicb_pi')
CREATE UNIQUE NONCLUSTERED INDEX [idx_t_vw_allrateschedules_po_noicb_pi] ON [dbo].[t_vw_allrateschedules_po_noicb] 
(
	[id_sched] ASC,
	[id_pi_instance] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  View [dbo].[t_vw_allrateschedules_po_icb]    Script Date: 06/02/2008 11:44:15 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_allrateschedules_po_icb]'))
EXEC dbo.sp_executesql @statement = N'
        
create view [dbo].[t_vw_allrateschedules_po_icb]
(
id_po, 
id_paramtable, 
id_pi_instance,
id_pi_template,
id_sub, 
id_sched,
dt_mod,
rs_begintype, 
rs_beginoffset, 
rs_beginbase,
rs_endtype, 
rs_endoffset, 
rs_endbase, 
id_pricelist)
with SCHEMABINDING
as
select
tmInner.id_po as id_po,
tmInner.id_paramtable as id_paramtable,
tmInner.id_pi_instance as id_pi_instance,
tmInner.id_pi_template as id_pi_template,
tmInner.id_sub as id_sub,
rschedInner.id_sched as id_sched,
rschedInner.dt_mod as dt_mod,
teInner.n_begintype as rs_begintype, 
teInner.n_beginoffset as rs_beginoffset,
teInner.dt_start as rs_beginbase, 
teInner.n_endtype as rs_endtype,
teInner.n_endoffset as rs_endoffset,
teInner.dt_end as rs_endbase,
rschedInner.id_pricelist as id_pricelist
from
dbo.t_pl_map tmInner
INNER JOIN dbo.t_rsched rschedInner on 
 rschedInner.id_pricelist = tmInner.id_pricelist 
 AND rschedInner.id_pt =tmInner.id_paramtable 
 AND rschedInner.id_pi_template = tmInner.id_pi_template
INNER JOIN dbo.t_effectivedate teInner on teInner.id_eff_date = rschedInner.id_eff_date
where tmInner.id_sub is not null
 		'
GO
SET ARITHABORT ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
SET ANSI_PADDING ON
GO
SET ANSI_WARNINGS ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_allrateschedules_po_icb]') AND name = N'idx_t_vw_allrateschedules_po_icb')
CREATE UNIQUE CLUSTERED INDEX [idx_t_vw_allrateschedules_po_icb] ON [dbo].[t_vw_allrateschedules_po_icb] 
(
	[id_pi_template] ASC,
	[id_sub] ASC,
	[id_po] ASC,
	[id_sched] ASC,
	[id_pi_instance] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ARITHABORT ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
SET ANSI_PADDING ON
GO
SET ANSI_WARNINGS ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_allrateschedules_po_icb]') AND name = N'idx_t_vw_allrateschedules_po_icb_sub')
CREATE UNIQUE NONCLUSTERED INDEX [idx_t_vw_allrateschedules_po_icb_sub] ON [dbo].[t_vw_allrateschedules_po_icb] 
(
	[id_sched] ASC,
	[id_pi_instance] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  View [dbo].[t_vw_allrateschedules_po]    Script Date: 06/02/2008 11:44:13 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_allrateschedules_po]'))
EXEC dbo.sp_executesql @statement = N'
        
create view [dbo].[t_vw_allrateschedules_po]
(
id_po, 
id_paramtable, 
id_pi_instance,
id_pi_template,
id_sub, 
id_sched,
dt_mod,
rs_begintype, 
rs_beginoffset, 
rs_beginbase,
rs_endtype, 
rs_endoffset, 
rs_endbase, 
id_pricelist)
with SCHEMABINDING
as
select
tmInner.id_po as id_po,
tmInner.id_paramtable as id_paramtable,
tmInner.id_pi_instance as id_pi_instance,
tmInner.id_pi_template as id_pi_template,
tmInner.id_sub as id_sub,
rschedInner.id_sched as id_sched,
rschedInner.dt_mod as dt_mod,
teInner.n_begintype as rs_begintype, 
teInner.n_beginoffset as rs_beginoffset,
teInner.dt_start as rs_beginbase, 
teInner.n_endtype as rs_endtype,
teInner.n_endoffset as rs_endoffset,
teInner.dt_end as rs_endbase,
rschedInner.id_pricelist as id_pricelist
from
dbo.t_pl_map tmInner
INNER JOIN dbo.t_rsched rschedInner on 
	rschedInner.id_pricelist = tmInner.id_pricelist 
	AND rschedInner.id_pt =tmInner.id_paramtable 
	AND rschedInner.id_pi_template = tmInner.id_pi_template
INNER JOIN dbo.t_effectivedate teInner on teInner.id_eff_date = rschedInner.id_eff_date
		'
GO
SET ARITHABORT ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
SET ANSI_PADDING ON
GO
SET ANSI_WARNINGS ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_allrateschedules_po]') AND name = N'idx_t_vw_allrateschedules_po')
CREATE UNIQUE CLUSTERED INDEX [idx_t_vw_allrateschedules_po] ON [dbo].[t_vw_allrateschedules_po] 
(
	[id_pi_template] ASC,
	[id_sub] ASC,
	[id_po] ASC,
	[id_sched] ASC,
	[id_pi_instance] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ARITHABORT ON
GO
SET CONCAT_NULL_YIELDS_NULL ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
SET ANSI_PADDING ON
GO
SET ANSI_WARNINGS ON
GO
SET NUMERIC_ROUNDABORT OFF
GO
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_allrateschedules_po]') AND name = N'idx_t_vw_allrateschedules_po_param')
CREATE UNIQUE NONCLUSTERED INDEX [idx_t_vw_allrateschedules_po_param] ON [dbo].[t_vw_allrateschedules_po] 
(
	[id_sched] ASC,
	[id_pi_instance] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
/****** Object:  StoredProcedure [dbo].[GetRateSchedules]    Script Date: 06/02/2008 11:43:46 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetRateSchedules]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
					create proc [dbo].[GetRateSchedules] @id_acc as int,
					@acc_cycle_id as int,
					@default_pl as int,
					@RecordDate as datetime,
					@id_pi_template as int
					as

						-- real stored procedure code starts here

						-- only count rows on the final select.
						SET NOCOUNT ON

						declare @winner_type as int
						declare @winner_row as int
						declare @winner_begin as datetime
						-- Don''t actually need the @winner end since it is not used
						-- to test overlapping effective dates

						declare @CursorVar CURSOR
						declare @count as int
						declare @i as int
						set @i = 0

						declare @tempID as int
						declare @tempStartType as int
						declare @temp_begin as datetime
						declare @temp_b_offset as int
						declare @tempEndType as int
						declare @temp_end as datetime
						declare @temp_e_offset as int

						declare @sub_begin as datetime
						declare @sub_end as datetime

						-- unused stuff until temporary table insertion
						declare @id_sched as int
						declare @dt_mod as datetime
						declare @id_po as int
						declare @id_paramtable as int
						declare @id_pricelist as int
						declare @id_sub as int
						declare @id_pi_instance as int

						declare @currentptable as int
						declare @currentpo as int
						declare @currentsub as int

						-- winner variables
						declare @win_id_sched as int
						declare @win_dt_mod as datetime
						declare @win_id_paramtable as int
						declare @win_id_pricelist as int
						declare @win_id_sub as int
						declare @win_id_po as int
						declare @win_id_pi_instance as int

						declare @TempEff table (id_sched int not null,
							dt_modified datetime not null,
							id_paramtable int not null,
							id_pricelist int not null,
							id_sub int null,
							id_po int null,
							id_pi_instance int null)


						-- declare our cursor. Is there anything special here for performance around STATIC vs. DYNAMIC?
						set @CursorVar = CURSOR STATIC
							 FOR 
								-- this query is pretty tricky.  It is the union of all of the possible rate schedules
								-- on the resolved product offering AND the intersection of the 
								-- default account pricelist and parameter tables for the priceable item type.
								select
								t_rsched.id_sched,t_rsched.dt_mod,
								tm.id_po,tm.id_pi_instance,tm.id_paramtable, tm.id_pricelist,tm.id_sub
								,te.n_begintype,te.dt_start, te.n_beginoffset,te.n_endtype,te.dt_end,te.n_endoffset
								,t_sub.vt_start dt_start,t_sub.vt_end dt_end
								from t_pl_map tm
								INNER JOIN t_sub on t_sub.id_acc= @id_acc
								INNER JOIN t_rsched on t_rsched.id_pricelist = tm.id_pricelist AND t_rsched.id_pt =tm.id_paramtable AND
								t_rsched.id_pi_template = @id_pi_template
								INNER JOIN t_effectivedate te on te.id_eff_date = t_rsched.id_eff_date
								where tm.id_po = t_sub.id_po and tm.id_pi_template = @id_pi_template 
								and (tm.id_acc = @id_acc or tm.id_sub is null)
								-- make sure that subscription is currently in effect
								AND (t_sub.vt_start <= @RecordDate AND @RecordDate <= t_sub.vt_end)
								UNION ALL
								select tr.id_sched,tr.dt_mod,
								NULL,NULL,map.id_pt,@default_pl,NULL,
								te.n_begintype,te.dt_start,te.n_beginoffset,te.n_endtype,te.dt_end,te.n_endoffset
								,NULL,NULL
								from t_rsched tr
								INNER JOIN t_effectivedate te ON te.id_eff_date = tr.id_eff_date
								-- throw out any default account pricelist rate schedules that use subscription relative effective dates
								AND te.n_begintype <> 2
								-- XXX fix this by passing in the instance ID
								INNER JOIN t_pi_template on id_template = @id_pi_template
								INNER JOIN t_pi_rulesetdef_map map ON map.id_pi = t_pi_template.id_pi
								where tr.id_pt = map.id_pt AND tr.id_pricelist = @default_pl AND tr.id_pi_template = @id_pi_template
								-- the ordering is very important.  The following algorithm depends on the fact
								-- that ICB rates will show up first (rows that don''t have a NULL subscription value),
								-- normal product offering rates next, and thirdly the default account pricelist rate schedules
								order by tm.id_paramtable,tm.id_sub desc,tm.id_po desc

						OPEN @CursorVar
						select @count = @@cursor_rows

						while @i < @count begin
							FETCH NEXT FROM @CursorVar into 
								-- rate schedule stuff
								@id_sched,@dt_mod
								-- plmap
								,@id_po,@id_pi_instance,@id_paramtable,@id_pricelist,@id_sub
								-- effectivedate rate schedule
								,@tempStartType,@temp_begin,@temp_b_offset,@tempEndType,@temp_end,@temp_e_offset
								-- effective date from subscription
								,@sub_begin,@sub_end

							set @i = (select @i + 1)

							if(@currentptable IS NULL) begin
								set @currentptable = @id_paramtable
								set @currentpo = @id_po
								set @currentsub = @id_sub
							end
							else if(@currentpTable != @id_paramtable
									 OR -- completely new parameter table
									@currentsub != IsNull(@id_sub,-1) OR -- ICB rates
									@currentpo != IsNull(@id_po,-1) -- default account PL
								) begin

								if @winner_row IS NOT NULL begin
									
									-- insert winner record into table variable
									insert into @TempEff values (@win_id_sched,@win_dt_mod,@win_id_paramtable,
									@win_id_pricelist,@win_id_sub,@win_id_po,@win_id_pi_instance)
								end
								-- clear out winner values
								set @winner_type = NULL
								set @winner_row = NULL
								set @winner_begin = NULL
							end
							-- set our current parametertable
							set @currentpTable = @id_paramtable
							set @currentpo = @id_po
							set @currentsub = @id_sub

							-- step : convert non absolute dates into absolute dates.  Only have to 
							-- deal with subscription relative and usage cycle relative

							-- subscription relative.  Add the offset of the rate schedule effective date to the
							-- start date of the subscription.  This code assumes that subscription effective dates
							-- are absolute or have already been normalized
							
							if(@tempStartType = 2) begin
								set @temp_begin = @sub_begin + @temp_b_offset
							end
							if(@tempEndType = 2) begin
								set @temp_end = dbo.MTEndOfDay(@temp_e_offset + @sub_begin)
							end


							-- usage cycle relative
							-- The following query will only return a result if both the beginning 
							-- and the end start dates are somewhere in the past.  We find the date by
							-- finding the interval where our date lies and adding 1 second the end of that 
							-- interval to give us the start of the next.  If the startdate query returns NULL,
							-- we can simply reject the result since the effective date is in the future.  It is 
							-- OK for the enddate to be NULL.  Note: We expect that we will always be able to find
							-- an old interval in t_usage_interval and DO NOT handle purged records
							
							if(@tempStartType = 3) begin
								set @temp_begin = dbo.NextDateAfterBillingCycle(@id_acc,@temp_begin)
								if(@temp_begin IS NULL) begin
									-- restart to the beginning of the while loop
									continue
								end
							end
							if(@tempEndType = 3) begin
								set @temp_end = dbo.NextDateAfterBillingCycle(@id_acc,@temp_end)
							end

							-- step : perform date range check
							if( @RecordDate >= IsNull(@temp_begin,@RecordDate) AND @RecordDate <= IsNull(@temp_end,@RecordDate)) begin
								-- step : check if there is an existing winner

								-- if no winner always populate
								if( (@winner_row IS NULL) OR
									-- start into the complicated winner logic used when there are multiple
									-- effective dates that apply.  The winner is the effective date with the latest
									-- start date

									-- Anything overrides a NULL start date
									(@tempStartType != 4 AND @winner_type = 4) OR
									-- subscription relative overrides anything else
									(@winner_type != 2 AND @tempStartType = 2) OR
									-- check for duplicate subscription relative, pick one with latest start date
									(@winner_type = 2 AND @tempStartType = 2 AND @winner_begin < @temp_begin) OR
									-- check if usage cycle or absolute, treat as equal
									((@winner_type = 1 OR @winner_type = 3) AND (@tempStartType = 1 OR @tempStartType = 3) 
									AND @winner_begin < @temp_begin)
									) -- end if
								begin
									set @winner_type = @tempStartType
									set @winner_row = @i
									set @winner_begin = @temp_begin

									set @win_id_sched = @id_sched
									set @win_dt_mod = @dt_mod
									set @win_id_paramtable = @id_paramtable
									set @win_id_pricelist =@id_pricelist
									set @win_id_sub =@id_sub
									set @win_id_po = @id_po
									set @win_id_pi_instance = @id_pi_instance
								end
							end
						end

						-- step : Dump the last remaining winner into the temporary table
						if @winner_row IS NOT NULL begin
							insert into @TempEff values (@win_id_sched,@win_dt_mod,@win_id_paramtable,
							@win_id_pricelist,@win_id_sub,@win_id_po,@win_id_pi_instance)
						end

						CLOSE @CursorVar
						DEALLOCATE @CursorVar

						-- step : if we have any results, get the results from the temp table
						SET NOCOUNT OFF
						select * from @TempEff
	 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CloneSecurityPolicy]    Script Date: 06/02/2008 11:43:20 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CloneSecurityPolicy]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
        
					  CREATE procedure [dbo].[CloneSecurityPolicy] 
            (@parent_id_acc int,
             @child_id_acc  int ,
             @parent_pol_type varchar(1),
						 @child_pol_type varchar(1))
            as
            
            begin				
            declare @polid INT,			
										@parentPolicy INT,
										@childPolicy INT		
            exec sp_Insertpolicy N''id_acc'', @parent_id_acc,@parent_pol_type, @parentPolicy output
  					exec sp_Insertpolicy N''id_acc'', @child_id_acc, @child_pol_type,@childPolicy output
						DELETE FROM T_POLICY_ROLE WHERE id_policy = @childPolicy
						INSERT INTO T_POLICY_ROLE
						SELECT @childPolicy, pr.id_role FROM T_POLICY_ROLE pr
						INNER JOIN T_PRINCIPAL_POLICY pp ON pp.id_policy = pr.id_policy
						WHERE pp.id_acc = @parent_id_acc AND
						pp.policy_type = @parent_pol_type
						end
         
        ' 
END
GO
/****** Object:  StoredProcedure [dbo].[AddMemberToRole]    Script Date: 06/02/2008 11:43:02 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddMemberToRole]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
        
						CREATE PROCEDURE [dbo].[AddMemberToRole]
						(@aRoleID INT,
						 @aAccountID INT,
						 @status INT OUTPUT)		
						AS
						
						Begin
						declare @accType VARCHAR(40)
						declare @polID INT
						declare @bCSRAssignableFlag VARCHAR(1)
						declare @bSubscriberAssignableFlag VARCHAR(1)
						declare @scratch INT
						select @status = 0
						-- evaluate business rules: role has to
						-- be assignable to the account type
						-- returned errors: MTAUTH_ROLE_CAN_NOT_BE_ASSIGNED_TO_SUBSCRIBER ((DWORD)0xE29F001CL) (-492896228)
						--                  MTAUTH_ROLE_CAN_NOT_BE_ASSIGNED_TO_CSR ((DWORD)0xE29F001DL) (-492896227)
						SELECT @accType = atype.name FROM T_ACCOUNT account inner join t_account_type atype on account.id_type = atype.id_type
						                  WHERE id_acc = @aAccountID
						SELECT @bCSRAssignableFlag = csr_assignable, 
						@bSubscriberAssignableFlag = subscriber_assignable  
						FROM T_ROLE WHERE id_role = @aRoleID
						IF (UPPER(@accType) <> ''SYSTEMACCOUNT'') 
						begin
						IF (UPPER(@bSubscriberAssignableFlag) = ''N'')
							begin
      				  select @status = -492896228
							  RETURN
							END
            END
						ELSE
						  begin
							IF UPPER(@bCSRAssignableFlag) = ''N'' 
								begin
								select @status = -492896227
								RETURN
								END
							END
					
						--Get policy id for this account. sp_InsertPolicy will either
						--insert a new one or get existing one
						exec Sp_Insertpolicy ''id_acc'', @aAccountID,''A'', @polID output
						-- make the stored proc idempotent, only insert mapping record if
						-- it''s not already there
						begin
							SELECT @scratch = id_policy FROM T_POLICY_ROLE WHERE id_policy = @polID AND id_role = @aRoleID
							if @scratch is null
								begin
								INSERT INTO T_POLICY_ROLE (id_policy, id_role) VALUES (@polID, @aRoleID)
								end
						end
						select @status = 1
						END 
        
        ' 
END
GO
/****** Object:  StoredProcedure [dbo].[AddAccToHierarchy]    Script Date: 06/02/2008 11:42:57 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddAccToHierarchy]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
create  procedure
[dbo].[AddAccToHierarchy] (@id_ancestor int,
@id_descendent int,
@dt_start  datetime,
@dt_end  datetime,
@p_acc_startdate datetime,
@ancestor_type varchar(40) OUTPUT,
@acc_type varchar(40) OUTPUT,
@status int OUTPUT)
as
begin
declare @realstartdate datetime
declare @realenddate datetime
declare @varMaxDateTime datetime
declare @ancestor int
declare @descendentIDAsString varchar(50)
declare @ancestorStartDate as datetime
declare @realaccstartdate as datetime
declare @ancestor_acc_type int
declare @descendent_acc_type int
select  @status = 0
-- begin business rules
-- check that the account is not already in the hierarchy
select @varMaxDateTime = dbo.MTMaxDate()
select @descendentIDAsString = CAST(@id_descendent as varchar(50)) 

  -- begin business rule checks.


 select @ancestor_type = atype.name, @ancestor_acc_type = atype.id_type from t_account acc
       inner join t_account_type atype 
       on atype.id_type = acc.id_type
       where acc.id_acc = @id_ancestor

      
  select @acc_type = atype.name, @descendent_acc_type = atype.id_type from t_account acc
       inner join t_account_type atype
       on atype.id_type = acc.id_type
       where acc.id_acc = @id_descendent
              

	SELECT @ancestor = id_acc 
	  from
	  t_account where id_acc = @id_ancestor
	if @ancestor is null begin
		  -- MT_PARENT_NOT_IN_HIERARCHY
		  select @status = -486604771
		  return
	end
	
	if @descendent_acc_type not in (
	  select id_descendent_type from t_acctype_descendenttype_map
	  where id_type = @ancestor_acc_type)
  begin
     select @status = -486604714  -- MT_ANCESTOR_OF_INCORRECT_TYPE
     return
  end 

	if @p_acc_startdate is NULL
	begin
		select @realaccstartdate = dt_crt from t_account where id_acc = @id_descendent
	end
	else
	begin
		select @realaccstartdate = @p_acc_startdate
	end

	select @ancestorStartDate = dt_crt
	from t_account where id_acc = @id_ancestor
	if  dbo.mtstartofday(@realaccstartdate) < dbo.mtstartofday(@ancestorStartDate)
	begin
		-- MT_CANNOT_CREATE_ACCOUNT_BEFORE_ANCESTOR_START
		select @status = -486604746
		return
	end 

  select  @status = count(*)  from t_account_ancestor
    where id_descendent = @id_descendent 
    and id_ancestor = @id_ancestor
    and num_generations = 1
    and (dbo.overlappingdaterange(vt_start,vt_end,@dt_start,@dt_end) = 1 )

  if (@status > 0) 
  begin
    -- MT_ACCOUNT_ALREADY_IN_HIEARCHY
    select @status = -486604785
    return
  end 

-- end business rule checks.

select @realstartdate = dbo.MTStartOfDay(@dt_start)  
if (@dt_end is NULL) 
begin
 select @realenddate = dbo.MTStartOfDay(dbo.mtmaxdate())  
 end
else
 begin
 select @realenddate = dbo.mtstartofday(@dt_end)  
 end 
-- TODO: we need error handling code to detect when the ancestor does 
-- not exist at the time interval!!
-- populate t_account_ancestor (no bitemporal data)
insert into t_account_ancestor (id_ancestor,id_descendent,
num_generations,vt_start,vt_end,tx_path)
select id_ancestor,@id_descendent,num_generations + 1,dbo.MTMaxOfTwoDates(vt_start,@realstartdate),dbo.MTMinOfTwoDates(vt_end,@realenddate),
case when (id_descendent = 1 OR id_descendent = -1) then
tx_path + @descendentIDAsString
else
tx_path + ''/'' + @descendentIDAsString
end 
from t_account_ancestor
where
id_descendent = @id_ancestor AND id_ancestor <> id_descendent  AND
dbo.OverlappingDateRange(vt_start,vt_end,@realstartdate,@realenddate) = 1
UNION ALL
-- the new record to parent.  Note that the 
select @id_ancestor,@id_descendent,1,@realstartdate,@realenddate,
case when (id_descendent = 1 OR id_descendent = -1) then
tx_path + @descendentIDAsString
else
tx_path + ''/'' + @descendentIDAsString
end
from
t_account_ancestor where id_descendent = @id_ancestor AND num_generations = 0
AND dbo.OverlappingDateRange(vt_start,vt_end,@realstartdate,@realenddate) = 1
	-- self pointer
UNION ALL 
select @id_descendent,@id_descendent,0,@realstartdate,@realenddate,@descendentIDAsString
 -- update our parent entry to have children
update t_account_ancestor set b_Children = ''Y'' where
id_descendent = @id_ancestor AND
dbo.OverlappingDateRange(vt_start,vt_end,@realstartdate,@realenddate) = 1
if (@@error <> 0) 
 begin
 select @status = 0
 end
select @status = 1  
end
				' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[IsCorporateAccount]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsCorporateAccount]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
		    create FUNCTION [dbo].[IsCorporateAccount](
				@id_acc int,@RefDate Datetime) returns INT
				as
				begin
				  declare @retval int
          select @retval = b_IsCorporate 
	          from t_account_type atype
     	      inner join t_account acc on acc.id_type = atype.id_type
	          where acc.id_acc = @id_acc
				  return @retval
				end
			 ' 
END
GO
/****** Object:  View [dbo].[T_VW_ACCTRES_BYID]    Script Date: 06/02/2008 11:44:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[T_VW_ACCTRES_BYID]'))
EXEC dbo.sp_executesql @statement = N'
CREATE VIEW [dbo].[T_VW_ACCTRES_BYID]
(ID_ACC, PAYER_ID_USAGE_CYCLE, C_PRICELIST, ID_PAYER, PAYER_START, PAYER_END,  STATUS, STATE_START, STATE_END, CURRENCY ) 

AS SELECT	
 acc.id_acc,
 payer_uc.id_usage_cycle,
 payeeinternal.c_pricelist,
 pr.id_payer,
 case when pr.vt_start is NULL then dbo.MTMinDate() else pr.vt_start end,
 case when pr.vt_end is NULL then dbo.MTMaxDate() else pr.vt_end end, 
 st.status,
 st.vt_start,
 st.vt_end,
 payerinternal.c_currency
from t_account acc
inner join t_payment_redirection pr on acc.id_acc = pr.id_payee	
inner join t_account_state st on st.id_acc = acc.id_acc         
inner join t_av_internal payeeinternal on payeeinternal.id_acc = acc.id_acc
left outer join t_av_internal payerinternal on payerinternal.id_acc = pr.id_payer
left outer join t_acc_usage_cycle payer_uc on payer_uc.id_acc = pr.id_payer
  '
GO
/****** Object:  StoredProcedure [dbo].[SequencedInsertAccOwnership]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SequencedInsertAccOwnership]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
    create procedure [dbo].[SequencedInsertAccOwnership]
		@p_id_owner	int,
		@p_id_owned	int,
		@p_id_relation_type	int,
		@p_percent int,
		@p_vt_start	datetime,
		@p_vt_end	datetime,
		@p_tt_current	datetime,
		@p_tt_max	datetime,
		@p_status	int	OUTPUT
    as
    begin
    DECLARE	@cnt INTEGER
    SET	@p_status	=	0
    -- Check referential integrity upfront without
    -- running multiple	select queries.	I	just took
    -- this	appoach	from SequencedInsertGsubRecur	stored proc
    INSERT INTO	t_acc_ownership(id_owner,	id_owned,	id_relation_type,	n_percent,	vt_start,	vt_end,	tt_start,	tt_end)	
    SELECT owner.id_acc, owned.id_acc, ed.id_enum_data,	@p_percent,	@p_vt_start, @p_vt_end,	@p_tt_current, @p_tt_max
    FROM t_account owner
    CROSS	JOIN t_account owned
    CROSS	JOIN t_enum_data ed
    WHERE	
    owner.id_acc=@p_id_owner
    AND
    owned.id_acc=@p_id_owned
    AND
    ed.id_enum_data=@p_id_relation_type
    IF @@rowcount	<> 1 
    BEGIN
    -- No	row, look	for	specific RI	failure	to give	better message
    SELECT @cnt	=	COUNT(*) FROM	t_account	where	id_acc = @p_id_owner
    IF @cnt	=	0
    BEGIN
    -- KIOSK_ERR_ACCOUNT_NOT_FOUND
    SET	@p_status	=	-515899365
    RETURN
    END
    SELECT @cnt	=	COUNT(*) FROM	t_account	where	id_acc = @p_id_owned
    IF @cnt	=	0
    BEGIN
    -- KIOSK_ERR_ACCOUNT_NOT_FOUND
    SET	@p_status	=	-515899365
    RETURN
    END
    SELECT @cnt	=	COUNT(*) FROM	t_enum_data	where	id_enum_data = @p_id_relation_type
    IF @cnt	=	0
    BEGIN
    -- E_FAIL
    SET	@p_status	=	-2147483607
    RETURN
    END
    END
    END
        ' 
END
GO
/****** Object:  View [dbo].[vw_acc_po_restrictions]    Script Date: 06/02/2008 11:44:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[vw_acc_po_restrictions]'))
EXEC dbo.sp_executesql @statement = N'
				CREATE VIEW [dbo].[vw_acc_po_restrictions] AS
select acc.id_acc, acc.id_type, atm.id_account_type as RestrictedToType, po.id_po
from t_account acc, t_po po
left join t_po_account_type_map atm on po.id_po = atm.id_po
where atm.id_account_type = acc.id_type or atm.id_account_type is null
 		'
GO
/****** Object:  StoredProcedure [dbo].[CheckAccountStateDateRules]    Script Date: 06/02/2008 11:43:17 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckAccountStateDateRules]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				CREATE PROCEDURE [dbo].[CheckAccountStateDateRules] (
				  @p_id_acc integer,
					@p_old_status varchar(2),
					@p_new_status varchar(2),
					@p_ref_date datetime,
					@status integer output)
				AS
				BEGIN
					declare @dt_crt datetime
	
					-- Rule 1: There should be no updates with dates earlier than 
					-- inception date
					SELECT 
					  @dt_crt = dbo.mtstartofday(dt_crt)
					FROM 	
					  t_account 
					WHERE
					  id_acc = @p_id_acc

					IF (dbo.mtstartofday(@p_ref_date) < @dt_crt)
					BEGIN
					  -- MT_SETTING_START_DATE_BEFORE_ACCOUNT_INCEPTION_DATE_NOT_ALLOWED
					  -- (DWORD)0xE2FF002EL
					  SELECT @status = -486604754
					  return
					END

					-- Rule 2: If updating from active to active state and there is usage
					-- and there should be no updates with dates later than the existing date
					IF ((@p_old_status = ''AC'') AND 
							(@p_new_status = ''AC'') AND
							(dbo.mtstartofday(@p_ref_date) > @dt_crt))
					BEGIN
						IF EXISTS (
						SELECT TOP 1 
							id_acc
						FROM
							t_acc_usage
						WHERE
							id_acc = @p_id_acc)
						BEGIN
							-- ACCOUNT_CONTAINS_USAGE_ACTIVE_DATE_MOVE_IN_FUTURE_NOT_ALLOWED
							-- (DWORD)0xE406000EL
							SELECT @status = -469368818
							return
						END
					END

					select @status = 1
				 END
				' 
END
GO
/****** Object:  StoredProcedure [dbo].[SequencedInsertGsubRecur]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SequencedInsertGsubRecur]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
		create procedure [dbo].[SequencedInsertGsubRecur] 
			@p_id_group_sub int,
			@p_id_prop int,
			@p_id_acc int,
			@p_vt_start datetime,
			@p_vt_end datetime,
			@p_tt_current datetime,
			@p_tt_max datetime,
			@p_status int OUTPUT
		as
		begin
		  DECLARE @cnt INTEGER
      SET @p_status = 0
			-- I admit this is a bit wierd, but what I am doing is detecting
			-- a referential integrity failure without generating an error.
			-- This is needed because SQL Server won''t let one suppress the
			-- RI failure (and this causes an exception up in ADO land).
			-- This is a little more concise (and perhaps more performant)
			-- than multiple queries up front.
		  INSERT INTO t_gsub_recur_map(id_group, id_prop, id_acc, vt_start, vt_end, tt_start, tt_end) 
			SELECT s.id_group, r.id_prop, a.id_acc, @p_vt_start, @p_vt_end, @p_tt_current, @p_tt_max
      FROM t_sub s
      CROSS JOIN t_account a
      CROSS JOIN t_recur r
      WHERE 
      s.id_group=@p_id_group_sub
      AND
			a.id_acc=@p_id_acc
      AND
      r.id_prop=@p_id_prop

			IF @@rowcount <> 1 
      BEGIN
			-- No row, look for specific RI failure to give better message
		  SELECT @cnt = COUNT(*) FROM t_recur where id_prop = @p_id_prop
			IF @cnt = 0 
        BEGIN
          -- MTPC_CHARGE_ACCOUNT_ONLY_ON_RC
				  SET @p_status = -490799065
				  RETURN
        END
		  SELECT @cnt = COUNT(*) FROM t_account where id_acc = @p_id_acc
			IF @cnt = 0 
        BEGIN
          -- KIOSK_ERR_ACCOUNT_NOT_FOUND
				  SET @p_status = -515899365
				  RETURN
        END
		  SELECT @cnt = COUNT(*) FROM t_sub where id_group = @p_id_group_sub
			IF @cnt = 0 
        BEGIN
          -- Return E_FAIL absent better info
				  SET @p_status = -2147483607
				  RETURN
        END
			-- Return E_FAIL absent better info
      SET @p_status = -2147483607
      END

      -- post-operation business rule check (relies on rollback of work done up until this point)
      -- checks to make sure the receiver''s payer''s do not violate EBCR cycle constraints
      SELECT @p_status = dbo.CheckGroupReceiverEBCRConstraint(@p_tt_current, @p_id_group_sub)
      IF (@p_status = 1) -- careful... success values between the function and the sproc differ
        SET @p_status = 0

		END
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[RemoveCounterInstance]    Script Date: 06/02/2008 11:44:06 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[RemoveCounterInstance]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
					create proc [dbo].[RemoveCounterInstance]
											@id_prop int
					AS
					BEGIN TRAN
            DELETE FROM T_COUNTER_PARAM_PREDICATE WHERE id_counter_param IN 
              (SELECT id_counter_param FROM t_counter_params WHERE id_counter = @id_prop)
						DELETE FROM T_COUNTER_PARAMS WHERE id_counter = @id_prop
						DELETE FROM T_COUNTER WHERE id_prop = @id_prop
						DELETE FROM T_BASE_PROPS WHERE id_prop = @id_prop
 					COMMIT TRAN
        ' 
END
GO
/****** Object:  StoredProcedure [dbo].[DeleteDescription]    Script Date: 06/02/2008 11:43:36 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteDescription]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      create procedure [dbo].[DeleteDescription](
				@a_id_desc int)
			as
			BEGIN
				IF (@a_id_desc <> 0)
					begin
					delete from t_description where id_desc=@a_id_desc
					delete from t_mt_id where id_mt=@a_id_desc
	     		end 
			END
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpsertDescription]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpsertDescription]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
		create proc [dbo].[UpsertDescription]
			@id_lang_code int,
			@a_nm_desc NVARCHAR(255),
			@a_id_desc_in int, 
			@a_id_desc int OUTPUT
		AS
		begin
      declare @var int
			IF (@a_id_desc_in IS NOT NULL and @a_id_desc_in <> 0)
				BEGIN
					-- there was a previous entry
				UPDATE t_description
					SET
						tx_desc = @a_nm_desc
					WHERE
						id_desc = @a_id_desc_in AND id_lang_code = @id_lang_code

					IF (@@RowCount=0)
					BEGIN
					  -- The entry didn''t previously exist for this language code
						INSERT INTO t_description
							(id_desc, id_lang_code, tx_desc)
						VALUES
							(@a_id_desc_in, @id_lang_code, @a_nm_desc)
					END

					-- continue to use old ID
					select @a_id_desc = @a_id_desc_in
				END

			ELSE
			  begin
				-- there was no previous entry
				IF (@a_nm_desc IS NULL)
				 begin
					-- no new entry
					select @a_id_desc = 0
				 end
				 ELSE
					BEGIN
						-- generate a new ID to use
						INSERT INTO t_mt_id default values
						select @a_id_desc = @@identity

						INSERT INTO t_description
							(id_desc, id_lang_code, tx_desc)
						VALUES
							(@a_id_desc, @id_lang_code, @a_nm_desc)
					 END
			END 
			end
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[InsertEnumData]    Script Date: 06/02/2008 11:43:51 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertEnumData]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				CREATE PROC [dbo].[InsertEnumData]	@nm_enum_data nvarchar(255), 
											@id_enum_data int OUTPUT 
				as
				begin tran 

				if not exists (select * from t_enum_data where nm_enum_data = @nm_enum_data ) 
				begin 
					insert into t_mt_id default values
					select @id_enum_data = @@identity

					insert into t_enum_data (nm_enum_data, id_enum_data) values ( @nm_enum_data, @id_enum_data )
					if ((@@error != 0) OR (@@rowCount != 1)) 
					begin
						rollback transaction 
						select @id_enum_data = -99  
					end 
				end 
				else 
				begin 
					select @id_enum_data = id_enum_data from t_enum_data 
					where nm_enum_data = @nm_enum_data
				end 
				commit transaction
			 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[DeleteCounterParamTypes]    Script Date: 06/02/2008 11:43:36 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteCounterParamTypes]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
						CREATE PROC [dbo].[DeleteCounterParamTypes]			
									@id_counter_type int
			AS
			BEGIN TRAN
				SELECT id_prop INTO #TempCounterType FROM t_counter_params_metadata WHERE id_counter_meta = @id_counter_type
				DELETE FROM t_counter_params_metadata WHERE id_prop IN (SELECT id_prop FROM #TempCounterType)
				DELETE FROM t_base_props WHERE id_prop IN (SELECT id_prop FROM #TempCounterType)
			COMMIT TRAN
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[InsertMeteredBatch]    Script Date: 06/02/2008 11:43:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertMeteredBatch]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			CREATE proc [dbo].[InsertMeteredBatch] (
				@tx_batch varbinary(16),
				@tx_batch_encoded varchar(255),
  			@tx_source varchar(255),
  			@tx_sequence varchar(255),
				@tx_name nvarchar(255),
				@tx_namespace nvarchar(255),
				@tx_status char(1),
				@dt_crt_source datetime,
				@dt_crt datetime,
				@n_completed int,  
				@n_failed int,
				@n_expected int,
				@n_metered int,
				@id_batch INT OUTPUT )
			AS
			BEGIN
			  select @id_batch = -1
				IF NOT EXISTS (SELECT 
				                 * 
											 FROM 
											   t_batch
					             WHERE 
											   tx_name = @tx_name AND 
												 tx_namespace = @tx_namespace AND
												 tx_sequence = @tx_sequence AND
												 tx_status != ''D'')
				BEGIN	
				  INSERT INTO t_batch (
						tx_batch,
						tx_batch_encoded,
  					tx_source,
  					tx_sequence,
						tx_name,
						tx_namespace,
						tx_status,
						dt_crt_source,
						dt_crt,
						n_completed,  
						n_failed,
						n_expected,
						n_metered )
					values (
						@tx_batch,
						@tx_batch_encoded,
  					@tx_source,
  					@tx_sequence,
						@tx_name,
						@tx_namespace,
						UPPER(@tx_status),
						@dt_crt_source,
						@dt_crt,
						@n_completed,  
						@n_failed,
						@n_expected,
						@n_metered )
	
					select @id_batch = @@identity
				END	
				ELSE
				BEGIN
				  -- MTBATCH_BATCH_ALREADY_EXISTS ((DWORD)0xE4020001L)
				  SELECT @id_batch = -469630975
				END	
			END
			' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdateMeteredCount]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateMeteredCount]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
        
			CREATE PROC [dbo].[UpdateMeteredCount]
			  @tx_batch VARBINARY(16),
				@n_metered int,
				@dt_change datetime,
				@status int output
			AS
			BEGIN
			  declare @id_batch int
				declare @batch_status char(1) 
				SELECT
				  @id_batch = id_batch,
					@batch_status = tx_status
				FROM
				  t_batch
				WHERE
				  tx_batch = @tx_batch

				UPDATE 
				  t_batch 
				SET 
				  n_metered = @n_metered 
				WHERE
				  tx_batch = @tx_batch

		    SELECT @status = 1 
				RETURN
			END
			' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdateBatchStatus]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateBatchStatus]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
create procedure [dbo].[UpdateBatchStatus]
	@tx_batch VARBINARY(16),
	@tx_batch_encoded varchar(24),
	@n_completed int,
	@sysdate datetime
as
declare @initialStatus char(1)
declare @finalStatus char(1)

if not exists (select * from t_batch with(updlock) where tx_batch = @tx_batch)
begin
  insert into t_batch (tx_namespace, tx_name, tx_batch, tx_batch_encoded, tx_status, n_completed, n_failed, dt_first, dt_crt)
    values (''pipeline'', @tx_batch_encoded, @tx_batch, @tx_batch_encoded, ''A'', 0, 0, @sysdate, @sysdate)
end

select @initialStatus = tx_status from t_batch with(updlock) where tx_batch = @tx_batch

update t_batch
  set t_batch.n_completed = t_batch.n_completed + @n_completed,
    t_batch.tx_status =
       case when ((t_batch.n_completed + t_batch.n_failed + @n_completed) = t_batch.n_expected
                   or (((t_batch.n_completed + t_batch.n_failed + @n_completed) = t_batch.n_metered) and t_batch.n_expected = 0)) then ''C''
				 when ((t_batch.n_completed + t_batch.n_failed + @n_completed) < t_batch.n_expected
                   or (((t_batch.n_completed + t_batch.n_failed + @n_completed) < t_batch.n_metered) and t_batch.n_expected = 0)) then ''A''
         when ((t_batch.n_completed + t_batch.n_failed + @n_completed) > t_batch.n_expected) and t_batch.n_expected > 0 then ''F''
         else t_batch.tx_status end,
     t_batch.dt_last = @sysdate,
     t_batch.dt_first =
       case when t_batch.n_completed = 0 then @sysdate else t_batch.dt_first end
  where tx_batch = @tx_batch

select @finalStatus = tx_status from t_batch where tx_batch = @tx_batch
			' 
END
GO
/****** Object:  StoredProcedure [dbo].[ModifyBatchStatus]    Script Date: 06/02/2008 11:44:00 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ModifyBatchStatus]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			CREATE PROC [dbo].[ModifyBatchStatus]
			  @tx_batch VARBINARY(16),
				@dt_change datetime,
				@tx_new_status char(1),
				@id_batch int output,
				@tx_current_status char(1) output,
				@status int output
			AS
			BEGIN
				SELECT
				  @id_batch = id_batch,
				  @tx_current_status = tx_status
				FROM
				  t_batch
				WHERE
				  tx_batch = @tx_batch
				-- Batch does not exist	
				IF (@@rowcount = 0)
				BEGIN
				  -- MTBATCH_BATCH_DOES_NOT_EXIST ((DWORD)0xE4020007L)
				  SELECT @status = -469630969
					RETURN
				END

				-- State transition business rules 
				IF (
				    ((@tx_new_status = ''F'') AND 
				     ((@tx_current_status = ''D'') OR (@tx_current_status = ''B'')))
						OR
						((@tx_new_status = ''D'') AND 
						 ((@tx_current_status = ''A'') OR (@tx_current_status = ''C'') OR 
						  (@tx_current_status = ''F'')))
						OR
						((@tx_new_status = ''C'') AND 
						 ((@tx_current_status = ''D'') OR (@tx_current_status = ''B'')))
						OR
						((@tx_new_status = ''A'') AND 
						 ((@tx_current_status = ''D'') OR (@tx_current_status = ''C'') OR 
						  (@tx_current_status = ''F'')))
						OR
						((@tx_new_status = ''B'') AND 
						 ((@tx_current_status = ''A'') OR (@tx_current_status = ''D'') OR
						  (@tx_current_status = ''C'')))
						)
				BEGIN
				 	-- MTBATCH_STATE_CHANGE_NOT_PERMITTED ((DWORD)0xE4020007L)
				 	SELECT @status = -469630968
					RETURN
				END
	
				UPDATE 
			  	t_batch 
				SET 
			  	tx_status = @tx_new_status
				WHERE
			  	tx_batch = @tx_batch

	    	SELECT @status = 1 
				RETURN
			END
			' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreateAdjustmentType]    Script Date: 06/02/2008 11:43:23 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateAdjustmentType]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
						create procedure [dbo].[CreateAdjustmentType]
						(@p_id_prop INT, 
						 @p_tx_guid VARBINARY(16), 
						 @p_id_pi_type INT, 
             @p_n_AdjustmentType INT, 
             @p_b_supportBulk VARCHAR,
             @p_tx_defaultdesc NTEXT,
             @p_id_formula INT
             )
						as
						begin
            	INSERT INTO t_adjustment_type
            	(id_prop, tx_guid,id_pi_type,n_AdjustmentType,b_supportBulk,id_formula, tx_default_desc
            	 ) VALUES (
							@p_id_prop, @p_tx_guid, @p_id_pi_type, @p_n_AdjustmentType, @p_b_supportBulk, @p_id_formula,
							@p_tx_defaultdesc)
        		END
				' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreateCompositeAdjDetails]    Script Date: 06/02/2008 11:43:25 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateCompositeAdjDetails]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			CREATE procedure [dbo].[CreateCompositeAdjDetails]
			(@p_id_prop INT, 
			@p_id_pi_type INT, 
			@p_pi_name VARCHAR(255),
			@p_adjustment_type_name VARCHAR(255)
			)
			as
			declare @id_pi_type int
			declare @id_adjustment_type int
			begin

				set @id_pi_type = (select top 1 t_base_props.id_prop from t_adjustment_type inner join t_base_props on
				t_base_props.id_prop = t_adjustment_type.id_pi_type where nm_name like @p_pi_name)
				
				SET @id_adjustment_type = (select t_adjustment_type.id_prop from t_adjustment_type inner join t_base_props on
				t_base_props.id_prop = t_adjustment_type.id_prop where nm_name like @p_adjustment_type_name and t_adjustment_type.id_pi_type = @id_pi_type ) 


				insert into t_composite_adjustment(id_prop, id_pi_type, id_adjustment_type) values(@p_id_prop, @id_pi_type, @id_adjustment_type )

			end
				' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreateCompositeAdjustmentType]    Script Date: 06/02/2008 11:43:25 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateCompositeAdjustmentType]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			CREATE procedure [dbo].[CreateCompositeAdjustmentType]
			(@p_id_prop INT, 
			@p_tx_guid VARBINARY(16), 
			@p_id_pi_type INT, 
			@p_n_AdjustmentType INT, 
			@p_b_supportBulk VARCHAR,
			@p_tx_defaultdesc NTEXT,
			@p_id_formula INT,
			@p_n_composite_adjustment INT
			)
			as
			begin
     				INSERT INTO t_adjustment_type
      				(id_prop, tx_guid,id_pi_type,n_AdjustmentType,b_supportBulk,id_formula, tx_default_desc,  n_composite_adjustment
					) VALUES ( @p_id_prop, @p_tx_guid, @p_id_pi_type, @p_n_AdjustmentType, @p_b_supportBulk, @p_id_formula,
					@p_tx_defaultdesc, @p_n_composite_adjustment)
			END
				' 
END
GO
/****** Object:  View [dbo].[VW_AJ_INFO]    Script Date: 06/02/2008 11:44:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[VW_AJ_INFO]'))
EXEC dbo.sp_executesql @statement = N'
        create view [dbo].[VW_AJ_INFO]
        -- Returns exactly 1 record	per	usage	record
        -- For adjusment related numeric fields	that come	back as	NULLs
        -- because adjustment	does not exist (eg id_aj_template, id_aj_instance)
        -- return	-1;	For	string fields	(AdjustmentDescription,	AdjustmentTemplateDescription) return	empty	strings
        as
        select 

        au.*,

        -- 1. Return Different Amounts: 

        -- PREBILL ADJUSTMENTS:

        -- CompoundPrebillAdjAmt -- parent and children prebill adjustments for a compound transaction
        -- AtomicPrebillAdjAmt -- parent prebill adjustments for a compound transaction. For an atomic transaction
        --                                 CompoundPrebillAdjAmt always equals AtomicPrebillAdjAmt
        -- CompoundPrebillAdjedAmt -- Charge Amount + CompoundPrebillAdjAmt
        -- AtomicPrebillAdjedAmt -- Charge amount + parent prebill adjustments for a compound transaction. For an atomic transaction
        --                                 CompoundPrebillAdjedAmt always equals AtomicPrebillAdjedAmt


        -- POSTBILL ADJUSTMENTS:

        -- CompoundPostbillAdjAmt -- parent and children postbill adjustments for a compound transaction
        -- AtomicPostbillAdjAmt -- parent postbill adjustments for a compound transaction. For an atomic transaction
        --                                 CompoundPostbillAdjAmt always equals AtomicPostbillAdjAmt
        -- CompoundPostbillAdjedAmt -- Charge Amount + CompoundPrebillAdjAmt + CompoundPostbillAdjedAmt
        -- AtomicPostbillAdjedAmt - Charge amount + parent prebill adjustments for a compound transaction +
        --                                parent postbill adjustments for a compound transaction. For an atomic transaction
        --                                AtomicPostbillAdjedAmt always equals CompoundPostbillAdjedAmt


        -- PREBILL ADJUSTMENTS:

        CASE WHEN (prebillajs.AdjustmentAmount IS NOT NULL AND prebillajs.c_status = ''A'')	
            THEN prebillajs.AdjustmentAmount
            ELSE 0 END
            + 
            {fn IFNULL((tmp.PrebillCompoundAdjAmt), 0.0)} AS CompoundPrebillAdjAmt,

        (au.amount + CASE WHEN (prebillajs.AdjustmentAmount IS NOT NULL AND prebillajs.c_status = ''A'')	
            THEN prebillajs.AdjustmentAmount
            ELSE 0 END + {fn IFNULL((tmp.PrebillCompoundAdjAmt), 0.0)}) AS CompoundPrebillAdjedAmt,
             
        (CASE WHEN (prebillajs.id_adj_trx IS NOT NULL AND prebillajs.c_status = ''A'')	
	            THEN prebillajs.AdjustmentAmount
	            ELSE 0 END) AS AtomicPrebillAdjAmt,
        	    
        (au.amount + (CASE WHEN (prebillajs.AdjustmentAmount IS NOT NULL AND prebillajs.c_status = ''A'')	
	            THEN prebillajs.AdjustmentAmount
	            ELSE 0 END) ) AS AtomicPrebillAdjedAmt,
	            
        (CASE WHEN (prebillajs.id_adj_trx IS NOT NULL AND prebillajs.c_status = ''P'')	
	            THEN prebillajs.AdjustmentAmount
	            ELSE 0 END) AS PendingPrebillAdjAmt,
	            
	      -- COMPOUND PREBILL ADJUSTMENTS TO TAXES:
	      
	      CASE WHEN (prebillajs.AdjustmentAmount IS NOT NULL AND prebillajs.c_status = ''A'')	
            THEN prebillajs.aj_tax_federal
            ELSE 0 END
            + 
            {fn IFNULL((tmp.PrebillCompoundFedTaxAdjAmt), 0.0)} AS CompoundPrebillFedTaxAdjAmt,
            
        CASE WHEN (prebillajs.AdjustmentAmount IS NOT NULL AND prebillajs.c_status = ''A'')	
            THEN prebillajs.aj_tax_state
            ELSE 0 END
            + 
            {fn IFNULL((tmp.PrebillCompoundStateTaxAdjAmt), 0.0)} AS CompoundPrebillStateTaxAdjAmt,
            
        CASE WHEN (prebillajs.AdjustmentAmount IS NOT NULL AND prebillajs.c_status = ''A'')	
            THEN prebillajs.aj_tax_county
            ELSE 0 END
            + 
            {fn IFNULL((tmp.PrebillCompoundCntyTaxAdjAmt), 0.0)} AS CompoundPrebillCntyTaxAdjAmt,
            
        CASE WHEN (prebillajs.AdjustmentAmount IS NOT NULL AND prebillajs.c_status = ''A'')	
            THEN prebillajs.aj_tax_local
            ELSE 0 END
            + 
            {fn IFNULL((tmp.PrebillCompoundLocalTaxAdjAmt), 0.0)} AS CompoundPrebillLocalTaxAdjAmt,
            
        CASE WHEN (prebillajs.AdjustmentAmount IS NOT NULL AND prebillajs.c_status = ''A'')	
            THEN prebillajs.aj_tax_other
            ELSE 0 END
            + 
            {fn IFNULL((tmp.PrebillCompoundOtherTaxAdjAmt), 0.0)} AS CompoundPrebillOtherTaxAdjAmt,
            
        CASE WHEN (prebillajs.AdjustmentAmount IS NOT NULL AND prebillajs.c_status = ''A'')	
            THEN (prebillajs.aj_tax_federal + prebillajs.aj_tax_state + prebillajs.aj_tax_county + prebillajs.aj_tax_local + prebillajs.aj_tax_other)
            ELSE 0 END
            + 
            {fn IFNULL((tmp.PrebillCompoundTotalTaxAdjAmt), 0.0)} AS CompoundPrebillTotalTaxAdjAmt,
            
				-- ATOMIC PREBILL ADJUSTMENTS TO TAXES:
	      
	      (CASE WHEN (prebillajs.AdjustmentAmount IS NOT NULL AND prebillajs.c_status = ''A'')	
            THEN prebillajs.aj_tax_federal
            ELSE 0 END) AS AtomicPrebillFedTaxAdjAmt,
            
        (CASE WHEN (prebillajs.AdjustmentAmount IS NOT NULL AND prebillajs.c_status = ''A'')	
            THEN prebillajs.aj_tax_state
            ELSE 0 END) AS AtomicPrebillStateTaxAdjAmt,
        
        (CASE WHEN (prebillajs.AdjustmentAmount IS NOT NULL AND prebillajs.c_status = ''A'')	
            THEN prebillajs.aj_tax_county
            ELSE 0 END) AS AtomicPrebillCntyTaxAdjAmt,
        
        (CASE WHEN (prebillajs.AdjustmentAmount IS NOT NULL AND prebillajs.c_status = ''A'')	
            THEN prebillajs.aj_tax_local
            ELSE 0 END) AS AtomicPrebillLocalTaxAdjAmt,
            
        (CASE WHEN (prebillajs.AdjustmentAmount IS NOT NULL AND prebillajs.c_status = ''A'')	
            THEN prebillajs.aj_tax_other
            ELSE 0 END) AS AtomicPrebillOtherTaxAdjAmt,
            
        (CASE WHEN (prebillajs.AdjustmentAmount IS NOT NULL AND prebillajs.c_status = ''A'')	
            THEN (prebillajs.aj_tax_federal + prebillajs.aj_tax_state + prebillajs.aj_tax_county + prebillajs.aj_tax_local + prebillajs.aj_tax_other)
            ELSE 0 END) AS AtomicPrebillTotalTaxAdjAmt,
        
        -- POSTBILL ADJUSTMENTS:

        CASE WHEN (postbillajs.AdjustmentAmount IS NOT NULL AND postbillajs.c_status = ''A'')	
            THEN postbillajs.AdjustmentAmount
            ELSE 0 END + {fn IFNULL((tmp.PostbillCompoundAdjAmt), 0.0)} AS CompoundPostbillAdjAmt,


        -- when calculating postbill adjusted amounts, always consider prebill adjusted amounts
        (au.amount + CASE WHEN (postbillajs.AdjustmentAmount IS NOT NULL AND postbillajs.c_status = ''A'')	
            THEN postbillajs.AdjustmentAmount
            ELSE 0 END  + {fn IFNULL((tmp.PostbillCompoundAdjAmt), 0.0)} 
        + 
        --bring in prebill adjustments
        CASE WHEN (prebillajs.AdjustmentAmount IS NOT NULL AND prebillajs.c_status = ''A'')	
            THEN prebillajs.AdjustmentAmount
            ELSE 0 END
            + 
            {fn IFNULL((tmp.PrebillCompoundAdjAmt), 0.0)}
        ) 
            AS CompoundPostbillAdjedAmt,
             
        (CASE WHEN (postbillajs.id_adj_trx IS NOT NULL AND postbillajs.c_status = ''A'')	
	            THEN postbillajs.AdjustmentAmount
	            ELSE 0 END) AS AtomicPostbillAdjAmt, 

        -- when calculating postbill adjusted amounts, always consider prebill adjusted amounts
        (au.amount + (CASE WHEN (postbillajs.AdjustmentAmount IS NOT NULL AND postbillajs.c_status = ''A'')	
	            THEN postbillajs.AdjustmentAmount
	            ELSE 0 END) 
        --bring in prebill adjustments
        +
        (CASE WHEN (prebillajs.AdjustmentAmount IS NOT NULL AND prebillajs.c_status = ''A'')	
	            THEN prebillajs.AdjustmentAmount
	            ELSE 0 END)
        	    
	            ) AS AtomicPostbillAdjedAmt,
	       
       (CASE WHEN (postbillajs.id_adj_trx IS NOT NULL AND postbillajs.c_status = ''P'')	
	            THEN postbillajs.AdjustmentAmount
	            ELSE 0 END) AS PendingPostbillAdjAmt,
	            
	      -- COMPOUND POSTBILL ADJUSTMENTS TO TAXES:
	      
	      CASE WHEN (postbillajs.AdjustmentAmount IS NOT NULL AND postbillajs.c_status = ''A'')	
            THEN postbillajs.aj_tax_federal
            ELSE 0 END
            + 
            {fn IFNULL((tmp.PostbillCompoundFedTaxAdjAmt), 0.0)} AS CompoundPostbillFedTaxAdjAmt,
            
        CASE WHEN (postbillajs.AdjustmentAmount IS NOT NULL AND postbillajs.c_status = ''A'')	
            THEN postbillajs.aj_tax_state
            ELSE 0 END
            + 
            {fn IFNULL((tmp.PostbillCompoundStateTaxAdjAmt), 0.0)} AS CompoundPostbillStateTaxAdjAmt,
            
        CASE WHEN (postbillajs.AdjustmentAmount IS NOT NULL AND postbillajs.c_status = ''A'')	
            THEN postbillajs.aj_tax_county
            ELSE 0 END
            + 
            {fn IFNULL((tmp.PostbillCompoundCntyTaxAdjAmt), 0.0)} AS CompoundPostbillCntyTaxAdjAmt,
            
        CASE WHEN (postbillajs.AdjustmentAmount IS NOT NULL AND postbillajs.c_status = ''A'')	
            THEN postbillajs.aj_tax_local
            ELSE 0 END
            + 
            {fn IFNULL((tmp.PostbillCompoundLocalTaxAdjAmt), 0.0)} AS CompoundPostbillLocalTaxAdjAmt,
            
        CASE WHEN (postbillajs.AdjustmentAmount IS NOT NULL AND postbillajs.c_status = ''A'')	
            THEN postbillajs.aj_tax_other
            ELSE 0 END
            + 
            {fn IFNULL((tmp.PostbillCompoundOtherTaxAdjAmt), 0.0)} AS CompoundPostbillOtherTaxAdjAmt,
            
        CASE WHEN (postbillajs.AdjustmentAmount IS NOT NULL AND postbillajs.c_status = ''A'')	
            THEN (postbillajs.aj_tax_federal + postbillajs.aj_tax_state + 
									postbillajs.aj_tax_county + postbillajs.aj_tax_local + postbillajs.aj_tax_other)
            ELSE 0 END
            + 
            {fn IFNULL((tmp.PostbillCompoundTotalTaxAdjAmt), 0.0)} AS CompoundPostbillTotalTaxAdjAmt,
            
				-- ATOMIC POST ADJUSTMENTS TO TAXES:
	      
	      (CASE WHEN (postbillajs.AdjustmentAmount IS NOT NULL AND postbillajs.c_status = ''A'')	
            THEN postbillajs.aj_tax_federal
            ELSE 0 END) AS AtomicPostbillFedTaxAdjAmt,
            
        (CASE WHEN (postbillajs.AdjustmentAmount IS NOT NULL AND postbillajs.c_status = ''A'')	
            THEN postbillajs.aj_tax_state
            ELSE 0 END) AS AtomicPostbillStateTaxAdjAmt,
        
        (CASE WHEN (postbillajs.AdjustmentAmount IS NOT NULL AND postbillajs.c_status = ''A'')	
            THEN postbillajs.aj_tax_county
            ELSE 0 END) AS AtomicPostbillCntyTaxAdjAmt,
        
        (CASE WHEN (postbillajs.AdjustmentAmount IS NOT NULL AND postbillajs.c_status = ''A'')	
            THEN postbillajs.aj_tax_local
            ELSE 0 END) AS AtomicPostbillLocalTaxAdjAmt,
            
        (CASE WHEN (postbillajs.AdjustmentAmount IS NOT NULL AND postbillajs.c_status = ''A'')	
            THEN postbillajs.aj_tax_other
            ELSE 0 END) AS AtomicPostbillOtherTaxAdjAmt,
            
        (CASE WHEN (postbillajs.AdjustmentAmount IS NOT NULL AND postbillajs.c_status = ''A'')	
            THEN (postbillajs.aj_tax_federal + postbillajs.aj_tax_state + postbillajs.aj_tax_county +
									postbillajs.aj_tax_local + postbillajs.aj_tax_other)
            ELSE 0 END) AS AtomicPostbillTotalTaxAdjAmt,
        


        -- 2. Return Adjustment Transaction IDs for both prebill and postbill adjustments (or -1 if none): 

        (CASE WHEN prebillajs.id_adj_trx IS NULL THEN -1 ELSE prebillajs.id_adj_trx END) AS PrebillAdjustmentID,
        (CASE WHEN postbillajs.id_adj_trx IS NULL THEN -1 ELSE postbillajs.id_adj_trx END) AS PostbillAdjustmentID,

        -- 3. Return Adjustment Template IDs for both prebill and postbill adjustments (or -1 if none): 

        (CASE WHEN prebillajs.id_aj_template IS NULL THEN -1 ELSE prebillajs.id_aj_template END) AS PrebillAdjustmentTemplateID,
        (CASE WHEN postbillajs.id_aj_template IS NULL THEN -1 ELSE postbillajs.id_aj_template END) AS PostbillAdjustmentTemplateID,

        -- 4. Return Adjustment Instance IDs for both prebill and postbill adjustments (or -1 if none): 

        (CASE WHEN prebillajs.id_aj_instance IS NULL THEN -1 ELSE prebillajs.id_aj_instance END) AS PrebillAdjustmentInstanceID,
        (CASE WHEN postbillajs.id_aj_instance IS NULL THEN -1 ELSE postbillajs.id_aj_instance END) AS PostbillAdjustmentInstanceID,

        -- 5. Return Adjustment ReasonCode IDs for both prebill and postbill adjustments (or -1 if none): 

        (CASE WHEN prebillajs.id_reason_code IS NULL THEN -1 ELSE prebillajs.id_reason_code END) AS PrebillAdjustmentReasonCodeID,
        (CASE WHEN postbillajs.id_reason_code IS NULL THEN -1 ELSE postbillajs.id_reason_code END) AS PostbillAdjustmentReasonCodeID,


        -- 6. Return Adjustment Descriptions and default descriptions for both prebill and postbill adjustments (or empty string if none): 

        (CASE WHEN prebillajs.tx_desc IS NULL THEN '''' ELSE prebillajs.tx_desc END) AS PrebillAdjustmentDescription,
        (CASE WHEN postbillajs.tx_desc IS NULL THEN '''' ELSE postbillajs.tx_desc END) AS PostbillAdjustmentDescription,
        (CASE WHEN prebillajs.tx_default_desc IS NULL THEN '''' ELSE prebillajs.tx_default_desc END) AS PrebillAdjDefaultDesc,
        (CASE WHEN postbillajs.tx_default_desc IS NULL THEN '''' ELSE postbillajs.tx_default_desc END) AS PostbillAdjDefaultDesc,
        
        -- 7. Return Adjustment Status as following: If transaction interval is either open or soft closed, return prebill adjustment status or ''NA'' if none;
        --    If transaction interval is hard closed, return post bill adjustment status or ''NA'' if none
        (CASE WHEN (taui.tx_status in (''O'', ''C'') AND  prebillajs.id_adj_trx IS NOT NULL) THEN prebillajs.c_status
         ELSE
        (CASE WHEN (taui.tx_status = ''H'' AND postbillajs.id_adj_trx IS NOT NULL) THEN postbillajs.c_status ELSE ''NA'' END)
        END) AS AdjustmentStatus,


        -- 8. Return Adjustment Template and Instance Display Names for both prebill and postbill adjustments (or empty string if none): 
        --    if needed,  we can return name and descriptions from t_base_props

        -- CASE WHEN (prebillajtemplatedesc.tx_desc IS NULL) THEN '''' ELSE prebillajtemplatedesc.tx_desc END  AS PrebillAdjustmentTemplateDisplayName,
        -- CASE WHEN (postbillajtemplatedesc.tx_desc IS NULL) THEN '''' ELSE postbillajtemplatedesc.tx_desc END  AS PostbillAdjustmentTemplateDisplayName,

        -- CASE WHEN (prebillajinstancedesc.tx_desc IS NULL) THEN '''' ELSE prebillajinstancedesc.tx_desc END  AS PrebillAdjustmentInstanceDisplayName,
        -- CASE WHEN (postbillajinstancedesc.tx_desc IS NULL) THEN '''' ELSE postbillajinstancedesc.tx_desc END  AS PostbillAdjustmentInstanceDisplayName,

        -- 9. Return Reason Code Name, Description, Display Name for both prebill and post bill adjustments (or empty string if none)

        -- CASE WHEN (prebillrcdesc.tx_desc IS NULL) THEN '''' ELSE prebillrcdesc.tx_desc END  AS PrebillAdjReasonCodeDispName,
        -- CASE WHEN (postbillrcdesc.tx_desc IS NULL) THEN '''' ELSE postbillrcdesc.tx_desc END  AS PostbillAdjReasonCodeDispName,



        -- 10. Return different flags indicating status of a transaction in regard to adjustments


        -- Transactions are not considered to be adjusted if status is not ''A''
        -- CR 11785 - Now we are checking for Pending also	

        (CASE WHEN (prebillajs.id_adj_trx IS NOT NULL AND prebillajs.c_status in (''A'',''P''))
			OR (postbillajs.id_adj_trx IS NOT NULL AND postbillajs.c_status in (''A'',''P''))
            THEN ''Y'' ELSE ''N'' END) AS IsAdjusted,
   	    	    
        (CASE WHEN (prebillajs.id_adj_trx IS NOT NULL AND prebillajs.c_status  in (''A'',''P''))	
            THEN ''Y'' ELSE ''N'' END) AS IsPrebillAdjusted,

        (CASE WHEN (postbillajs.id_adj_trx IS NOT NULL AND postbillajs.c_status  in (''A'',''P''))	
            THEN ''Y'' ELSE ''N'' END) AS IsPostbillAdjusted,

        (CASE WHEN (taui.tx_status = ''O'')	
		        THEN ''Y'' 
		        ELSE ''N'' END) AS IsPreBill,

        --can not adjust transactions:
        --1. in soft closed interval
        --2. If transaction is Prebill and it was already prebill adjusted
        --3. If transaction is Post bill and it was already postbill adjusted
        (CASE WHEN	
          (taui.tx_status in (''C'')) OR
          (taui.tx_status = ''O'' AND prebillajs.id_adj_trx IS NOT NULL) OR
          (taui.tx_status = ''H'' AND postbillajs.id_adj_trx IS NOT NULL)
	        then ''N''  else ''Y'' end)	AS CanAdjust,

        -- Can not Rebill transactions:
        -- 1. If they are child transactions
        -- 2. in soft closed interval
        -- 3. If transaction is Prebill and it (or it''s children) have already been adjusted (need to delete adjustments first)
        -- 4. If transaction is Postbill and it (or it''s children) have already been adjusted (need to delete adjustments first)
        --    Above case will take care of possibility of someone trying to do PostBill rebill over and over again.
          (CASE WHEN	
          (au.id_parent_sess IS NOT NULL) 
	        OR
          (taui.tx_status =(''C'')) 
          OR
          (taui.tx_status =	''O'' AND (prebillajs.id_adj_trx IS NOT NULL 
          OR (tmp.NumChildrenPrebillAdjusted IS NOT NULL AND tmp.NumChildrenPrebillAdjusted > 0)) )
          OR
          (taui.tx_status = ''H'' AND (postbillajs.id_adj_trx IS NOT NULL 
          OR (tmp.NumChildrenPostbillAdjusted IS NOT NULL AND tmp.NumChildrenPostbillAdjusted > 0)))
          then ''N'' else ''Y'' end)	AS CanRebill,
        	
        -- Return ''N'' if
        -- 1. Transaction hasn''t been prebill adjusted yet
        -- 2. Transaction has been prebill adjusted but transaction interval is already closed
        -- Otherwise return ''Y''
        (CASE WHEN (prebillajs.id_adj_trx IS NOT NULL) THEN
        (CASE WHEN taui.tx_status in (''C'', ''H'') then ''N''  else ''Y'' end)
        ELSE ''N'' END)
        AS CanManagePrebillAdjustment,
        
        -- Return ''N'' if
        -- 1. If adjustment is postbill rebill
        -- 2. Transaction hasn''t been postbill adjusted
        -- 3. Transaction has been postbill adjusted but payer''s interval is already closed
        -- Otherwise return ''Y''
        
        (CASE WHEN (postbillajs.id_adj_trx IS NOT NULL)
        THEN
				-- CR 11775: we want to allow adjustment management
				-- if adjustment is pending but interval is hard closed
       (CASE WHEN (ajaui.tx_status in (''C'') OR
					(ajaui.tx_status  = ''H'' AND postbillajs.c_status = ''A'') OR
        postbillajtype.n_adjustmenttype = 4) then ''N''  else ''Y'' end)
        ELSE ''N'' END)
        AS CanManagePostbillAdjustment,
        
        -- This calculates the logical AND of the above two flags.
        -- CR 9547 fix: Start with postbillajs. If transaction was both
        -- pre and post bill adjusted, we should be able to manage it
        -- CR 9548 fix: should not be able to manage REBILL adjustment
          
        (CASE WHEN (postbillajs.id_adj_trx IS NOT NULL) THEN
         -- CR 11775: we want to allow adjustment management
				-- if adjustment is pending but interval is hard closed
        (CASE WHEN (ajaui.tx_status in (''C'') OR
					(ajaui.tx_status  = ''H'' AND postbillajs.c_status = ''A'') OR
        postbillajtype.n_adjustmenttype = 4) then ''N''  else ''Y'' end)
        ELSE 
        (CASE WHEN (prebillajs.id_adj_trx IS NOT NULL) THEN
        (CASE WHEN taui.tx_status in (''C'', ''H'') then ''N''  else ''Y'' end)
        ELSE ''N'' END)
        END)

        AS CanManageAdjustments,
        
        
        (CASE WHEN (taui.tx_status = ''C'' ) THEN ''Y'' ELSE ''N'' END) As IsIntervalSoftClosed,
        
        -- return the number of adjusted children
        -- or 0 for child transactions of a compound
        CASE WHEN tmp.NumApprovedChildPrebillAdjed IS NULL 
        THEN 0 
          ELSE tmp.NumApprovedChildPrebillAdjed
        END
        AS NumPrebillAdjustedChildren,
        
        CASE WHEN tmp.NumApprovedChildPostbillAdjed IS NULL 
        THEN 0 
          ELSE tmp.NumApprovedChildPostbillAdjed
        END
        AS NumPostbillAdjustedChildren


        from

        t_acc_usage au 
        left outer join t_adjustment_transaction prebillajs on prebillajs.id_sess=au.id_sess AND prebillajs.c_status IN (''A'', ''P'') AND prebillajs.n_adjustmenttype=0
        left outer join t_adjustment_transaction postbillajs on postbillajs.id_sess=au.id_sess AND postbillajs.c_status IN (''A'', ''P'') AND postbillajs.n_adjustmenttype=1
        -- Damn, this is going to kill us unless we index on id_parent_sess!!!!!!!!!!!!!!!!
        left outer join
        (
        select childau.id_parent_sess, 
        SUM(CASE WHEN (childprebillajs.AdjustmentAmount IS NOT NULL AND childprebillajs.c_status = ''A'')	
	          THEN childprebillajs.AdjustmentAmount
	          ELSE 0 END) PrebillCompoundAdjAmt, 
        SUM(CASE WHEN (childpostbillajs.AdjustmentAmount IS NOT NULL AND childpostbillajs.c_status = ''A'')	
	        THEN childpostbillajs.AdjustmentAmount
	        ELSE 0 END) PostbillCompoundAdjAmt,
	      
	      --adjustments to taxes
	      SUM(CASE WHEN (childprebillajs.AdjustmentAmount IS NOT NULL AND childprebillajs.c_status = ''A'')	
	          THEN childprebillajs.AJ_TAX_FEDERAL
	          ELSE 0 END) PrebillCompoundFedTaxAdjAmt, 
        SUM(CASE WHEN (childpostbillajs.AdjustmentAmount IS NOT NULL AND childpostbillajs.c_status = ''A'')	
	        THEN childpostbillajs.AJ_TAX_FEDERAL
	        ELSE 0 END) PostbillCompoundFedTaxAdjAmt,
	      
	      SUM(CASE WHEN (childprebillajs.AdjustmentAmount IS NOT NULL AND childprebillajs.c_status = ''A'')	
	          THEN childprebillajs.AJ_TAX_STATE
	          ELSE 0 END) PrebillCompoundStateTaxAdjAmt, 
        SUM(CASE WHEN (childpostbillajs.AdjustmentAmount IS NOT NULL AND childpostbillajs.c_status = ''A'')	
	        THEN childpostbillajs.AJ_TAX_STATE
	        ELSE 0 END) PostbillCompoundStateTaxAdjAmt,
	      
	      SUM(CASE WHEN (childprebillajs.AdjustmentAmount IS NOT NULL AND childprebillajs.c_status = ''A'')	
	          THEN childprebillajs.AJ_TAX_COUNTY
	          ELSE 0 END) PrebillCompoundCntyTaxAdjAmt, 
        SUM(CASE WHEN (childpostbillajs.AdjustmentAmount IS NOT NULL AND childpostbillajs.c_status = ''A'')	
	        THEN childpostbillajs.AJ_TAX_COUNTY
	        ELSE 0 END) PostbillCompoundCntyTaxAdjAmt,
	        
	      SUM(CASE WHEN (childprebillajs.AdjustmentAmount IS NOT NULL AND childprebillajs.c_status = ''A'')	
	          THEN childprebillajs.AJ_TAX_LOCAL
	          ELSE 0 END) PrebillCompoundLocalTaxAdjAmt, 
        
        SUM(CASE WHEN (childpostbillajs.AdjustmentAmount IS NOT NULL AND childpostbillajs.c_status = ''A'')	
	        THEN childpostbillajs.AJ_TAX_LOCAL
	        ELSE 0 END) PostbillCompoundLocalTaxAdjAmt,
	        
	      SUM(CASE WHEN (childprebillajs.AdjustmentAmount IS NOT NULL AND childprebillajs.c_status = ''A'')	
	          THEN childprebillajs.AJ_TAX_OTHER
	          ELSE 0 END) PrebillCompoundOtherTaxAdjAmt, 
        
        SUM(CASE WHEN (childpostbillajs.AdjustmentAmount IS NOT NULL AND childpostbillajs.c_status = ''A'')	
	        THEN childpostbillajs.AJ_TAX_OTHER
	        ELSE 0 END) PostbillCompoundOtherTaxAdjAmt,
	      
	      SUM(CASE WHEN (childprebillajs.AdjustmentAmount IS NOT NULL AND childprebillajs.c_status = ''A'')	
	          THEN (childprebillajs.AJ_TAX_FEDERAL + childprebillajs.AJ_TAX_STATE + childprebillajs.AJ_TAX_COUNTY
	          + childprebillajs.AJ_TAX_LOCAL + childprebillajs.AJ_TAX_OTHER)
	          ELSE 0 END) PrebillCompoundTotalTaxAdjAmt, 
        
        SUM(CASE WHEN (childpostbillajs.AdjustmentAmount IS NOT NULL AND childpostbillajs.c_status = ''A'')	
	        THEN (childpostbillajs.AJ_TAX_FEDERAL + childpostbillajs.AJ_TAX_STATE + childpostbillajs.AJ_TAX_COUNTY
	          + childpostbillajs.AJ_TAX_LOCAL + childpostbillajs.AJ_TAX_OTHER)
	        ELSE 0 END) PostbillCompoundTotalTaxAdjAmt,

        -- Approved or Pending adjusted kids
        SUM(CASE WHEN (childprebillajs.AdjustmentAmount IS NULL) THEN 0 ELSE 1 END) NumChildrenPrebillAdjusted,
        SUM(CASE WHEN (childpostbillajs.AdjustmentAmount IS NULL) THEN 0 ELSE 1 END) NumChildrenPostbillAdjusted,
        -- Approved adjusted kids (I didn''t want to change the above flag because it''s used for CanRebill flag calculation)
        SUM(CASE WHEN (childprebillajs.AdjustmentAmount IS NOT NULL AND childprebillajs.c_status =''A'') THEN 1 ELSE 0 END) NumApprovedChildPrebillAdjed,
        SUM(CASE WHEN  (childpostbillajs.AdjustmentAmount IS NOT NULL AND childpostbillajs.c_status =''A'')  THEN 1 ELSE 0 END)AS NumApprovedChildPostbillAdjed


        from
        t_acc_usage childau 
        left outer join t_adjustment_transaction childprebillajs on childprebillajs.id_sess=childau.id_sess AND childprebillajs.c_status IN (''A'', ''P'') AND childprebillajs.n_adjustmenttype=0
        left outer join t_adjustment_transaction childpostbillajs on childpostbillajs.id_sess=childau.id_sess AND childpostbillajs.c_status IN (''A'', ''P'') AND childpostbillajs.n_adjustmenttype=1
        group by childau.id_parent_sess
        ) 
        tmp on tmp.id_parent_sess=au.id_sess
        INNER JOIN t_acc_usage_interval taui on au.id_usage_interval = taui.id_usage_interval AND au.id_acc = taui.id_acc
        LEFT OUTER JOIN t_acc_usage_interval ajaui on postbillajs.id_usage_interval = ajaui.id_usage_interval AND postbillajs.id_acc_payer = ajaui.id_acc
        
        --need to bring in adjustment type in order to set ManageAdjustments flag to false in case
        -- of REBILL adjustment type
        LEFT OUTER JOIN t_adjustment_type prebillajtype on prebillajtype.id_prop = prebillajs.id_aj_type 
        LEFT OUTER JOIN t_adjustment_type postbillajtype on postbillajtype.id_prop = postbillajs.id_aj_type 



        --resolve adjustment template or instance name
        -- This view is used in MPS. So if having those baseprops/desc joins becomes too expensive then
        -- they should be removed from this view

        -- AJ INSTANCE JOINs
        --LEFT OUTER JOIN t_base_props prebillajinstancebp ON prebillajs.id_aj_instance = prebillajinstancebp.id_prop
        --LEFT OUTER JOIN t_description  prebillajinstancedesc ON prebillajinstancebp.n_display_name = prebillajinstancedesc.id_desc

        --LEFT OUTER JOIN t_base_props postbillajinstancebp ON postbillajs.id_aj_instance = postbillajinstancebp.id_prop
        --LEFT OUTER JOIN t_description  postbillajinstancedesc ON postbillajinstancebp.n_display_name = prebillajinstancedesc.id_desc

        -- AJ TEMPLATE JOINs
        -- LEFT OUTER JOIN t_base_props prebillajtemplatebp ON prebillajs.id_aj_template = prebillajtemplatebp.id_prop
        -- LEFT OUTER JOIN t_description  prebillajtemplatedesc ON prebillajtemplatebp.n_display_name = prebillajtemplatedesc.id_desc

        -- LEFT OUTER JOIN t_base_props postbillajtemplatebp ON postbillajs.id_aj_template = postbillajtemplatebp.id_prop
        -- LEFT OUTER JOIN t_description  postbillajtemplatedesc ON postbillajtemplatebp.n_display_name = postbillajtemplatedesc.id_desc

        -- Reason Code JOINs
        -- LEFT OUTER JOIN t_base_props prebillrcbp ON prebillajs.id_reason_code = prebillrcbp.id_prop
        -- LEFT OUTER JOIN t_description  prebillrcdesc ON prebillrcbp.n_display_name = prebillrcdesc.id_desc

        -- LEFT OUTER JOIN t_base_props postbillrcbp ON postbillajs.id_aj_template = postbillrcbp.id_prop
        -- LEFT OUTER JOIN t_description  postbillrcdesc ON postbillrcbp.n_display_name = postbillrcdesc.id_desc

				'
GO
/****** Object:  StoredProcedure [dbo].[DeleteCounterParamInstances]    Script Date: 06/02/2008 11:43:35 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteCounterParamInstances]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
						create proc [dbo].[DeleteCounterParamInstances]
											(@id_counter	int)
						AS
						BEGIN
               -- delete mappings for shared parameters
               DELETE FROM t_counter_param_map WHERE id_counter =  @id_counter
               DELETE FROM T_BASE_PROPS WHERE id_prop IN
              (SELECT id_counter_param FROM t_counter_params WHERE id_counter = @id_counter)
              DELETE FROM T_COUNTER_PARAM_PREDICATE WHERE id_counter_param IN
              (SELECT id_counter_param FROM t_counter_params WHERE id_counter = @id_counter)
						  DELETE FROM T_COUNTER_PARAMS WHERE id_counter = @id_counter
            END
        ' 
END
GO
/****** Object:  StoredProcedure [dbo].[AddCounterParamPredicate]    Script Date: 06/02/2008 11:43:00 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddCounterParamPredicate]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			create proc [dbo].[AddCounterParamPredicate]
									@id_counter_param int,
									@id_pv_prop int,
                  @nm_op nvarchar(2),
									@nm_value nvarchar(255),
									@ap_id_prop int OUTPUT
			AS
			BEGIN TRAN
			INSERT INTO t_counter_param_predicate
				(id_counter_param, id_pv_prop, nm_op, nm_value) 
			VALUES 
				(@id_counter_param, @id_pv_prop, @nm_op, @nm_value)
			SELECT 
				@ap_id_prop = @@identity
			COMMIT TRAN
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[AddOwnedFolder]    Script Date: 06/02/2008 11:43:06 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddOwnedFolder]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
create procedure [dbo].[AddOwnedFolder](
@owner  int,
@folder int,
@p_systemdate datetime,
@p_enforce_same_corporation varchar,
@existing_owner int OUTPUT,
@status int OUTPUT)
as
begin
	declare @bFolder char
	select @status = 0 
	if (@owner = @folder) 
		begin
		--MT_FOLDER_CANNOT_OWN_ITSELF
		select @status = -486604761
		return
		end
	begin
	select @existing_owner = id_owner  from t_impersonate where	id_acc = @folder
	if (@existing_owner is null)
		begin
		select @existing_owner = 0
		end
	end
	if (@existing_owner <> 0 and @existing_owner <> @owner)
		begin
		-- the folder is already owned by another account
		-- MT_EXISTING_FOLDER_OWNER
		select @status = -486604779
		RETURN
		END 
	-- simply exit the stored procedure if the current owner is the owner
	if (@existing_owner = @owner) 
		begin
		select @status = 1
		return
		end
	
		-- check that both the payer and Payee are in the same corporate account
		if @p_enforce_same_corporation = ''1'' AND dbo.IsInSameCorporateAccount(@owner,@folder,@p_systemdate) <> 1 
		begin
			-- MT_CANNOT_OWN_FOLDER_IN_DIFFERENT_CORPORATE_ACCOUNT
			select @status = -486604751
			return
		end
	
	
	if (@existing_owner = 0) 
		begin
		insert into t_impersonate (id_owner,id_acc) values (@owner,@folder)
		select @status = 0
		end
	select @status = 1
end 
			 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[DelSuccessfullyResubmittedFT]    Script Date: 06/02/2008 11:43:38 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DelSuccessfullyResubmittedFT]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE procedure [dbo].[DelSuccessfullyResubmittedFT] (
  @delay_time int,
  @mt_now DATETIME,
  @DeletedCount int OUTPUT
  ) as
	begin
			delete from t_failed_transaction
			WHERE dt_FailureTime is NOT NULL and
			State = ''R'' and
			@mt_now > DATEADD(day, @delay_time, dt_StateLastModifiedTime) ;
			
			set @DeletedCount = @@ROWCOUNT;
			
	end;
 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreateCalculationFormula]    Script Date: 06/02/2008 11:43:24 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateCalculationFormula]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
						create procedure [dbo].[CreateCalculationFormula]
						(@p_tx_formula ntext,
             @p_id_engine INT,
             @op_id_prop int OUTPUT)
						as
						begin
            	INSERT INTO t_calc_formula
            	(tx_formula,id_engine) VALUES (
							@p_tx_formula, @p_id_engine)
							if (@@error <> 0) 
                  begin
                  select @op_id_prop = -99
                  end
                  else
                  begin
                  select @op_id_prop = @@identity
                  end
        		END
				' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[IsAccountBillable]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsAccountBillable]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
				create function [dbo].[IsAccountBillable](@id_acc int) 
        returns varchar
		    as
        begin
	      declare @billableFlag as char(1)
		    select @billableFlag = c_billable  from t_av_internal where 
		    id_acc = @id_acc
		    if (@billableFlag is NULL) 
					begin
		      select @billableFlag = ''0''
          end  
		    return (@billableFlag)
		    end
				' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[IsAccountFolder]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsAccountFolder]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
				create function [dbo].[IsAccountFolder](@id_acc int) 
				returns varchar
				as
				begin 
				declare @folderFlag char(1)
				select @folderFlag = c_folder  from t_av_internal where 
				id_acc = @id_acc
				if (@folderFlag is NULL)
					begin
					select @folderFlag = ''0''
					end  
				return @folderFlag
				end
				' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[IsAccountAndPOSameCurrency]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsAccountAndPOSameCurrency]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
		create function [dbo].[IsAccountAndPOSameCurrency](@id_acc int, @id_po int) 
		returns varchar
		as
		begin 
		declare @sameCurrency char(1)
		select @sameCurrency = 
		CASE WHEN 
		(SELECT COUNT(id_po)  from t_pricelist pl
		inner join t_po po on po.id_nonshared_pl = pl.id_pricelist AND po.id_po = @id_po
		inner join t_av_internal av ON av.c_currency = pl.nm_currency_code AND av.id_acc = @id_acc
		) = 0
		THEN ''0'' ELSE ''1'' END
		return @sameCurrency
		end
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[SetPartitionOptions]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SetPartitionOptions]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			/*
				SetPartitionOptions

				Sets values in t_usage_server.  Also adds metadata to facilitate
				treating t_acc_usage like a product view.

				@enable char(1)  -- Y if partitions enabled
				@type varchar(20) -- partition cycle type
				@datasize int		-- Size of data file in MB
				@logsize int	-- size of log file in MB

			*/
			create proc [dbo].[SetPartitionOptions]
				@enable char(1),  -- Y if partitions enabled
				@type varchar(20), -- partition cycle type
				@datasize int,		-- Size of data file in MB
				@logsize int	-- size of log file in MB
			AS
			begin

			set nocount on

			-- Error reporting and row counts
			declare @err int
			declare @rc int

			-- validate enable flag
			if lower(@enable) not in (''y'', ''n'') begin
				raiserror(''Enbable flag must be "Y" or "N", not "%s"'', 16, 1, @enable)
				return
			end

			-- get cycle id
			declare @cycle int

			-- find cycle id for a supported partition cycle
			select @cycle = uc.id_usage_cycle, @type = uct.tx_desc
			from  t_usage_cycle uc
			join t_usage_cycle_type uct
				on uct.id_cycle_type = uc.id_cycle_type
			where lower(uct.tx_desc) = lower(@type)
				and ((uc.id_cycle_type = 1 -- monthly
						and day_of_month = 31)
					or (uc.id_cycle_type = 4 -- weekly
	  					and day_of_week = 1)
					or (uc.id_cycle_type = 6  -- semi-montly
	  					and first_day_of_month = 14 and second_day_of_month = 31)
					or (uc.id_cycle_type = 7  -- quarterly
	  					and start_day = 1 and start_month = 1))

			if (@cycle is null) begin
				raiserror(''Partition type "%s" not supported.'', 16, 1, @type)
				return
			end


			begin tran

				-- Update t_usage_server
				update t_usage_server set
					b_partitioning_enabled = upper(@enable),
					partition_cycle = @cycle,
					partition_type = @type,
					partition_data_size = @datasize,
					partition_log_size = @logsize
				
				set @err = @@error
				if (@err <> 0) begin
					raiserror(''Cannot update t_usage_server.'',1,1)
					rollback
					return
				end

				-- Treat t_acc_usage kinda like a product view
				if not exists (select * from t_prod_view where nm_table_name = ''t_acc_usage'')
				begin
					declare @prodid int
					declare @enumid int

					-- get the enum id for the acc_usage_table
					select @enumid = id_enum_data
					from t_enum_data
					where lower(nm_enum_data) = ''usage''

					insert t_prod_view 
						(id_view, dt_modified, nm_name, nm_table_name,b_can_resubmit_from)
						values 
						(@enumid, getdate(), ''metratech.com/acc_usage'', ''t_acc_usage'',''N'')
					set @err = @@error
					set @prodid = @@identity
					if (@err <> 0) begin
						raiserror(''Cannot insert to t_prod_view'',1,1)
						rollback
						return
					end

					-- add acc_usage columns to t_prod_view_prop
					insert into t_prod_view_prop( 
						/*id_prod_view_prop, */id_prod_view, nm_name, nm_data_type, nm_column_name, 
						b_required, b_composite_idx, b_single_idx, b_part_of_key, b_exportable, 
						b_filterable, b_user_visible, nm_default_value, n_prop_type, nm_space, 
						nm_enum, b_core) 
					SELECT 
						--d_prod_view_prop,
						@prodid as id_prod_view,
						column_name as nm_name, 
						data_type as nm_data_type, 
						column_name as nm_column_name, 
						''Y'' as b_required, 
						''N'' as b_composite_idx, 
						''N'' as b_single_idx, 
						''N'' as b_part_of_key, 
						''Y'' as b_exportable, 
						''Y'' as b_filterable, 
						''Y'' as b_user_visible, 
						null as nm_default_value, 	
						0 as n_prop_type, 
						null as nm_space, 
						null as nm_enum, 
						case when column_name like ''id%'' then ''Y'' else ''N'' end as b_core 
					from information_schema.columns
					where table_name = ''t_acc_usage''
					
					-- make tx_uid a uniquekey
					declare @ukid int
					declare @pvid int
					
					select @pvid = id_prod_view 
					from t_prod_view
					where nm_table_name = ''t_acc_usage''
					
					insert into t_unique_cons (id_prod_view, constraint_name, nm_table_name)
						values (@pvid, ''uk_acc_usage_tx_uid'', ''t_uk_acc_usage_tx_uid'')
					set @ukid = @@identity

					if (@err <> 0) begin
						raiserror(''Cannot insert to t_unique_cons'',1,1)
						rollback
						return
					end

					insert into t_unique_cons_columns
						select @ukid, id_prod_view_prop, 1
						from t_prod_view_prop
						where id_prod_view = @pvid
							and lower(nm_name) = ''tx_uid''

					if (@err <> 0) begin
						raiserror(''Cannot insert to t_unique_cons_columns'',1,1)
						rollback
						return
					end
				end

			commit

			return

			end
 	' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreateUniqueKeyTable]    Script Date: 06/02/2008 11:43:32 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateUniqueKeyTable]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      /*
      	CreateUniqueKeyTable
      
      	Creates a single unique constraint table for a partitioned 
      	product view and loads it if it''s new.  Also returns the
      	trigger query used to keep this table synchronnized with it''s
      	parent product view.
      
      	@ukname - name of a unique constraint
      */
      create proc [dbo].[CreateUniqueKeyTable] (
      	@ukname varchar(200),
      	@ins varchar(1000) = '''' output,  -- sql for insert stmt
      	@isnew char(1) = ''N'' output  -- Y if the uk needs loading
      	) as
      begin
      
      -- Env set up
      set nocount on
      declare @err int	-- sql errors
      declare @rc int	-- row counts
      declare @ret int	-- called proc return codes
      
      -- Table ddl stubs
      declare @ddl varchar(4000)  -- create table
      declare @pk varchar(500)  -- unique key clause
      declare @uk varchar(500)  -- unique key clause
      declare @dbname varchar(500)  -- current db
      set @dbname = db_name()
      set @ddl = ''create table '' + lower(@ukname) + '' ('' + char(13)
      set @pk = ''   constraint '' + @ukname + ''_pk primary key clustered ('' + char(13)
      set @uk = ''   constraint '' + @ukname + ''_uk unique nonclustered ('' + char(13)
      set @ins = ''insert into '' + @dbname + ''..'' + @ukname + '' select''
      set @isnew = ''N''  -- normally, the uk isn''t created
      
      -- Select unique cons columns and their types
      declare ukcols cursor for
      	select ucc.position*100, ''uk'', nm_column_name,
      		case
      			--
      			-- strings and binary strings
      			when data_type in (''nvarchar'', ''varchar'', ''nchar'', ''char'', 
      									''binary'', ''varbinary'') 
      				then data_type + ''('' + cast(character_maximum_length as varchar) + '')''
      			--
      			-- numerics
      			when data_type in (''numeric'', ''decimal'') 
      				then data_type + ''('' + cast(numeric_precision as varchar) + '',''
      											+ cast(numeric_scale as varchar) + '')''
      			--
      			-- approximate numerics (maybe float should default to max precision?)
      			when data_type in (''float'')
      				then data_type + ''('' + cast(numeric_precision as varchar) + '')''
      			--
      			-- undecorated types
      			when data_type in (''bigint'', ''int'', ''smallint'', ''tinyint'', ''bit'', ''real'',
      									''money'', ''smallmoney'', ''datetime'', ''smalldatetime'',
      									''sql_variant'', ''timestamp'', ''uniqueidentifier'')
      				then data_type
      			--
      			-- unknown or unsupported types
      			else ''Unsupported(''+ data_type + '')''
      		end as type_ddl,
      		case lower(is_nullable)
      			when ''yes'' then ''null'' else ''not null''
      		end as is_nullable
      	from t_unique_cons uc
      	join t_unique_cons_columns ucc
      		on uc.id_unique_cons = ucc.id_unique_cons
      	join t_prod_view_prop pvp
      		on ucc.id_prod_view_prop = pvp.id_prod_view_prop
      	join t_prod_view pv
      		on pv.id_prod_view = pvp.id_prod_view
      	join information_schema.columns isc
      		on isc.column_name = pvp.nm_column_name 
      		and isc.table_name = pv.nm_table_name
      	where uc.nm_table_name = @ukname
      	--order by ucc.position asc
      	union select  0, ''pk'', ''id_sess'', ''bigint'', ''not null''
      	union select  1, ''pk'', ''id_usage_interval'', ''int'', ''not null''
      	order by 1
      
      -- Iterate each column and build the table ddl
      declare @pos int
      declare @keytype varchar(10)
      declare @col varchar(300)
      declare @type varchar(300)
      declare @nulls varchar(10) -- to null or not to null
      declare @cnt int
      set @cnt = 0
      open ukcols
      
      while (1=1)
      begin
      	fetch ukcols into @pos, @keytype, @col, @type, @nulls
      	if (@@fetch_status <> 0)
      		break
      	set @cnt = @cnt + 1
      	--print str(@cnt) + '' '' + str(@pos) + '' '' + @col + '' '' + @type + '' '' + @nulls
      
      	set @ddl = @ddl + ''   '' + @col + '' '' + @type + '' '' + @nulls + '','' + char(13)
      	if (@keytype = ''pk'') begin
      		set @pk = @pk + ''      '' + @col + '', '' + char(13)
      	end 
      	else begin
      		set @uk = @uk + ''      '' + @col + '', '' + char(13)
      	end
      	set @ins = @ins + '' '' + @col + '', ''
      
      end 
      deallocate ukcols
      
      -- Check that the unique constraint is defined
      if (@cnt < 1) begin
      	raiserror(''Constraint [%s] not defined.'', 0, 1, @ukname)
      	return 1
      end
      
      -- Chop trailing comma and finish the insert statement
      set @ins = left(@ins, len(@ins) - 1) + '' from inserted''
      
      -- Chop trailing comma and close the key clauses
      set @pk = left(@pk, len(@pk) - 3) + char(13) + ''   )''
      set @uk = left(@uk, len(@uk) - 3) + char(13) + ''   )''
      
      -- Compose and close the table ddl
      set @ddl = @ddl + @pk + '','' + char(13) + @uk + char(13) + '')'' + char(13)
      --print @ddl
      
      -- If table''s already created, skip and return trigger sql
      if object_id(@ukname) is not null
      begin
      	raiserror(''Unique key table [%s] already exists.'', 0, 1, @ukname)
      	return 0
      end
      
      -- Create the table
      exec (@ddl)
      select @err = @@error, @rc = @@rowcount
      if (@err <> 0) begin
      	raiserror(''Cannot create unique key table [%s]'', 16, 1, @ukname)
      	return 1
      end
      
      raiserror(''Constraint table [%s] created.'', 0, 1, @ukname)
      set @isnew = ''Y''
      
      end --proc
 	' 
END
GO
/****** Object:  StoredProcedure [dbo].[DeleteProductViewMetadata]    Script Date: 06/02/2008 11:43:36 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteProductViewMetadata]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

			/*
				DeleteProductViewMetadata

				Deletes all metadata for a product view.  Removes all
				unique key and propduct view property metadata.
				
				@tabname - name of product view 

			*/
			create proc [dbo].[DeleteProductViewMetadata](
				@tabname varchar(200)
				)
			as

			declare @err int
			declare @rc int
			declare @id_prod_view int
			declare @nm_name varchar(2000)

			print ''Deleting prod view metadata for '' + @tabname

			-- Get prod view id and table name
			select @id_prod_view = id_prod_view, @nm_name = nm_name
			from t_prod_view
			where nm_table_name = @tabname

			if (@id_prod_view is null) begin
				raiserror(''Product view [%s] does not exist.'', 0, 1, @tabname)
				return 1
			end

			delete t_product_view_log
			where nm_product_view = @nm_name

			delete t_unique_cons_columns
			where id_unique_cons in 
				(select id_unique_cons from t_unique_cons
				where id_prod_view = @id_prod_view)

			delete t_unique_cons
			where id_prod_view = @id_prod_view

			delete t_prod_view_prop
			where id_prod_view = @id_prod_view

			delete t_prod_view
			where id_prod_view = @id_prod_view

		' 
END
GO
/****** Object:  StoredProcedure [dbo].[dearchive_files]    Script Date: 06/02/2008 11:43:34 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[dearchive_files]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
    
create procedure [dbo].[dearchive_files]
			(
			@interval int,
			@accountIDList nvarchar(4000),
			@result nvarchar(4000) output
			)
		as
		set nocount on
		declare @sql1 nvarchar(4000)
		declare @tab1 nvarchar(1000)
		declare @tab2 nvarchar(1000)
		declare @var1 nvarchar(100)
		declare @str1 nvarchar(1000)
		declare @str2 nvarchar(2000)
		declare @vartime datetime
		declare @maxtime datetime
		declare @bucket int
		declare	@dbname nvarchar(100)

		begin
		select @vartime = getdate()
		select @maxtime = dbo.mtmaxdate()
		select @dbname = db_name()
		--how to run this procedure
		--declare @result varchar(4000)
		--exec dearchive_files intervalid,''accountid'',@result output
		--print @result

		--Checking following Business rules :
		--Interval should be archived
		--Account is in archived state
		--Verify the database name 
		select @tab2 = table_name from information_schema.tables where table_name=''T_ACC_USAGE'' and table_catalog = @dbname
		if (@tab2 is null)
		begin 
			set @result = ''6000001-dearchive_files operation failed-->check the database name''
			return
		end
		if not exists (select top 1 * from t_archive where id_interval=@interval and status =''A'' and tt_end = @maxtime)
		begin
			set @result = ''6000002-dearchive_files operation failed-->Interval is not archived''
			return
		end
--TO GET LIST OF ACCOUNT
		CREATE TABLE #file (filename nvarchar(4000),id_acc int)
		CREATE TABLE #AccountIDsTable (ID int NOT NULL,bucket int)
		if (@accountIDList is not null)
		begin
			WHILE CHARINDEX('','', @accountIDList) > 0
				BEGIN
					INSERT INTO #AccountIDsTable (ID)
					SELECT SUBSTRING(@accountIDList,1,(CHARINDEX('','', @accountIDList)-1))
					SET @accountIDList = SUBSTRING (@accountIDList, (CHARINDEX('','', @accountIDList)+1),
										(LEN(@accountIDList) - (CHARINDEX('','', @accountIDList))))
					if (@@error <> 0) 
					begin
						set @result = ''6000003-dearchive_files operation failed-->error in insert into #AccountIDsTable''
						return
					end
				END
			INSERT INTO #AccountIDsTable (ID) SELECT @accountIDList
			if (@@error <> 0) 
			begin
				set @result = ''6000004-dearchive_files operation failed-->error in insert into #AccountIDsTable''
				return
			end
	
			update #AccountIDsTable set bucket = act.bucket
			from #AccountIDsTable inner join t_acc_bucket_map act
			on #AccountIDsTable.id = act.id_acc
			where act.id_usage_interval=@interval
			if (@@error <> 0) 
			begin
				set @result = ''6000005-dearchive_files operation failed-->error in update #AccountIDsTable''
				return
			end
		end
		else
		begin
			set @sql1 = ''insert into #AccountIDsTable(id,bucket) select id_acc,bucket from
			t_acc_bucket_map where id_acc not in (select distinct id_acc from t_acc_usage where id_usage_interval = '' + cast(@interval as varchar(20)) + '')
			 and status = ''''A'''' and tt_end = dbo.mtmaxdate()''
			print(@sql1)
			exec (@sql1)
			if (@@error <> 0) 
			begin
				set @result = ''6000006-dearchive_files operation failed-->error in insert into #AccountIDsTable''
				return
			end
		end

		if exists (select 1 from t_acc_bucket_map where id_usage_interval=@interval and status =''D'' and tt_end = @maxtime
				and id_acc in (select id from #AccountIDsTable))
		begin
			set @result = ''6000007-dearchive_files operation failed-->one of the account is already dearchived''
			return
		end
		if EXISTS(SELECT 1 FROM #AccountIDsTable WHERE bucket is null)
		begin
			set @result = ''6000008-dearchive_files operation failed-->one of the account does not have bucket mapping...check the accountid''
			return
		end	

		declare  c1 cursor fast_forward for select distinct id_view from t_archive where id_interval = @interval
		and tt_end = @maxtime and id_view is not null
		declare c2 cursor fast_forward for select distinct bucket from #AccountIDsTable
		open c2
		fetch next from c2 into @bucket
		while (@@fetch_status = 0)
		begin
		--Checking the existence of import files for each table
			declare	@FileName nvarchar(128)
			select  @FileName = ''t_acc_usage'' + ''_'' + cast(@interval as varchar(10)) + ''_'' + cast(@bucket as varchar(10)) + ''.txt''
			insert into #file select @FileName,id from #AccountIDsTable where bucket = @bucket
			if (@@error <> 0)
			begin
				set @result = ''6000009-dearchive_files operation failed-->insert into file table for t_acc_usage''
				close c2
				deallocate c2
				deallocate c1
				return
			end
	
			open c1
			fetch next from c1 into @var1
			while @@fetch_status = 0
			begin
				select @tab1 = nm_table_name from t_prod_view where id_view=@var1
				select @filename = @tab1 + ''_'' + cast(@interval as varchar(10)) + ''_'' + cast(@bucket as varchar(10)) + ''.txt''
				insert into #file select @FileName,id from #AccountIDsTable where bucket = @bucket
				if (@@error <> 0)
				begin
					set @result = ''6000010-dearchive_files operation failed-->insert into file table for product views''
					close c1
					deallocate c1
					close c2
					deallocate c2
					return
				end
			fetch next from c1 into @var1
			end
			close c1
		fetch next from c2 into @bucket
		end
		close c2
		deallocate c1

		if not exists (select top 1 id_adj_trx from t_adjustment_transaction where id_usage_interval = @interval)
		begin 
			select  @FileName = ''t_adjustment_transaction'' + ''_'' + cast(@interval as varchar(10)) + ''.txt''
				insert into #file select @FileName,id from #AccountIDsTable where bucket = @bucket
				if (@@error <> 0)
				begin
				set @result = ''6000011-dearchive_files operation failed-->insert into file table for t_adjustment_transaction''
				return
				end
		
			declare  c1 cursor fast_forward for select distinct adj_name from t_archive where id_interval = @interval and tt_end = @maxtime
			and adj_name is not null and status=''A''
			open c1
			fetch next from c1 into @var1
			while @@fetch_status = 0
			begin
				select @filename = @var1 + ''_'' + cast(@interval as varchar(10)) + ''.txt''
				insert into #file select @FileName,id from #AccountIDsTable where bucket = @bucket
				if (@@error <> 0)
				begin
					set @result = ''6000012-dearchive_files operation failed-->insert into file table for t_aj_tables''
					close c1
					deallocate c1
					return
				end
				fetch next from c1 into @var1
			end
			close c1
			deallocate c1
		end
		select filename,id_acc from #file order by id_acc
		set @result = ''0-dearchive_files operation successful''
		end
    
    ' 
END
GO
/****** Object:  StoredProcedure [dbo].[Dearchive_account]    Script Date: 06/02/2008 11:43:34 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Dearchive_account]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
    
    create procedure [dbo].[Dearchive_account]
			(
			@interval int,
			@accountIDList nvarchar(4000),
			@path nvarchar(1000),
			@constraint nchar(1) = ''Y'',
			@datafiletype nchar(1) = ''n'',
			@result nvarchar(4000) output
			)
		as
/*		How to run this procedure
		declare @result nvarchar(2000)
		exec dearchive_account @interval=827719717,@accountIDList=null,@path=''c:\backup\archive'',@result=@result output
		print @result
*/

		set nocount on
		declare @sql1 nvarchar(4000)
		declare @tab1 nvarchar(1000)
		declare @tab2 nvarchar(1000)
		declare @var1 nvarchar(100)
		declare @str1 nvarchar(1000)
		declare @str2 nvarchar(2000)
		declare @vartime datetime
		declare @maxtime datetime
		declare @bucket int
		declare	@dbname nvarchar(100)
		declare @partition nvarchar(4000)

		select @vartime = getdate()
		select @maxtime = dbo.mtmaxdate()
		select @dbname = db_name()
		--Checking following Business rules :
		--Interval should be archived
		--Account is in archived state
		--Verify the database name 
		if (@datafiletype <> ''c'' and @datafiletype <> ''n'')
		begin
			set @result = ''5000001a-dearchive operation failed-->@datafiletype should be either c or n''
			return
		end
		select @tab2 = table_name from information_schema.tables where table_name=''T_ACC_USAGE'' and table_catalog = @dbname
		if (@tab2 is null)
		begin 
			set @result = ''5000001-dearchive operation failed-->check the database name''
			return
		end
		if not exists (select top 1 * from t_archive where id_interval=@interval and status =''A'' and tt_end = @maxtime)
		begin
			set @result = ''5000002-dearchive operation failed-->Interval is not archived''
			return
		end
--TO GET LIST OF ACCOUNT
		CREATE TABLE #AccountIDsTable (ID int NOT NULL,bucket int)
		if (@accountIDList is not null)
		begin
			WHILE CHARINDEX('','', @accountIDList) > 0
				BEGIN
					INSERT INTO #AccountIDsTable (ID)
					SELECT SUBSTRING(@accountIDList,1,(CHARINDEX('','', @accountIDList)-1))
					SET @accountIDList = SUBSTRING (@accountIDList, (CHARINDEX('','', @accountIDList)+1),
										(LEN(@accountIDList) - (CHARINDEX('','', @accountIDList))))
					if (@@error <> 0) 
					begin
						set @result = ''5000003-dearchive operation failed-->error in insert into #AccountIDsTable''
						return
					end
				END
			INSERT INTO #AccountIDsTable (ID) SELECT @accountIDList
			if (@@error <> 0) 
			begin
				set @result = ''5000004-dearchive operation failed-->error in insert into #AccountIDsTable''
				return
			end
	
			update #AccountIDsTable set bucket = act.bucket
			from #AccountIDsTable inner join t_acc_bucket_map act
			on #AccountIDsTable.id = act.id_acc
			where act.id_usage_interval=@interval
			if (@@error <> 0) 
			begin
				set @result = ''5000005-dearchive operation failed-->error in update #AccountIDsTable''
				return
			end
		end
		else
		begin
			set @sql1 = ''insert into #AccountIDsTable(id,bucket) select id_acc,bucket from
			t_acc_bucket_map where status =''''A'''' and tt_end = dbo.mtmaxdate() and id_acc not in (select distinct id_acc from t_acc_usage where 
			id_usage_interval = '' + cast(@interval as varchar(20)) + '') and id_usage_interval = '' + cast(@interval as varchar(20))
			exec (@sql1)
			if (@@error <> 0) 
			begin
				set @result = ''5000006-dearchive operation failed-->error in insert into #AccountIDsTable''
				return
			end
		end

		if exists (select 1 from t_acc_bucket_map where id_usage_interval=@interval and status =''D'' and tt_end = @maxtime
				and id_acc in (select id from #AccountIDsTable))
		begin
			set @result = ''5000007-dearchive operation failed-->one of the account is already dearchived''
			return
		end
		if EXISTS(SELECT 1 FROM #AccountIDsTable WHERE bucket is null)
		begin
			set @result = ''5000008-dearchive operation failed-->one of the account does not have bucket mapping...check the accountid''
			return
		end	

		declare  c1 cursor fast_forward for select distinct id_view from t_archive where id_interval = @interval
		and tt_end = @maxtime and id_view is not null
		declare c2 cursor fast_forward for select distinct bucket from #AccountIDsTable
		open c2
		fetch next from c2 into @bucket
		while (@@fetch_status = 0)
		begin
		--Checking the existence of import files for each table
			declare	@FileName nvarchar(128)
			select  @FileName = ''t_acc_usage'' + ''_'' + cast(@interval as varchar(10)) + ''_'' + cast(@bucket as varchar(10)) + ''.txt''
			declare @i int
			declare	@File nvarchar(2000)
			select @File = @Path + ''\'' + @FileName
			exec master..xp_fileexist @File, @i out
			if @i <> 1
			begin
				set @result = ''5000009-dearchive operation failed-->bcp usage file does not exist''
				close c2
				deallocate c2
				deallocate c1
				return
			end
	
			open c1
			fetch next from c1 into @var1
			while @@fetch_status = 0
			begin
				select @tab1 = nm_table_name from t_prod_view where id_view=@var1
				select @filename = @tab1 + ''_'' + cast(@interval as varchar(10)) + ''_'' + cast(@bucket as varchar(10)) + ''.txt''
				select @File = @Path + ''\'' + @FileName
				exec master..xp_fileexist @File, @i out
				if @i <> 1
				begin
					set @result = ''5000010-dearchive operation failed-->bcp '' + cast(@FileName as nvarchar(128)) + '' file does not exist''
					close c1
					deallocate c1
					close c2
					deallocate c2
					return
				end
				fetch next from c1 into @var1
			end
			close c1
		fetch next from c2 into @bucket
		end
		close c2
		deallocate c1

		if not exists (select top 1 id_adj_trx from t_adjustment_transaction where id_usage_interval = @interval)
		begin 
			select  @FileName = ''t_adjustment_transaction'' + ''_'' + cast(@interval as varchar(10)) + ''.txt''
			select @File = @Path + ''\'' + @FileName
			exec master..xp_fileexist @File, @i out
			if @i <> 1
			begin
				set @result = ''5000011-dearchive operation failed-->bcp t_adjustment_transaction file does not exist''
				deallocate c2
				return
			end
		
			declare  c1 cursor fast_forward for select distinct adj_name from t_archive where id_interval = @interval and tt_end = @maxtime
			and adj_name is not null and status=''A''
			open c1
			fetch next from c1 into @var1
			while @@fetch_status = 0
			begin
				select @filename = @var1 + ''_'' + cast(@interval as varchar(10)) + ''.txt''
				select @File = @Path + ''\'' + @FileName
				exec master..xp_fileexist @File, @i out
				if @i <> 1
				begin
					set @result = ''5000012-dearchive operation failed-->bcp '' + cast(@FileName as nvarchar(128)) + '' file does not exist''
					close c1
					deallocate c1
					deallocate c2
					return
				end
				fetch next from c1 into @var1
			end
			close c1
			deallocate c1
		end

		begin tran
		--Insert data into t_acc_usage
		open c2
		fetch next from c2 into @bucket
		while (@@fetch_status = 0)
		begin
			if object_id(''tempdb..#tmp_t_acc_usage'') is not null
			drop table #tmp_t_acc_usage
			if (@@error <> 0) 
			begin
				set @result = ''5000012a--dearchive operation failed-->error in dropping #tmp_t_acc_usage''
				rollback tran
				close c2
				deallocate c2
				return			
			end
			select * into #tmp_t_acc_usage from t_acc_usage where 0=1
			if (@@error <> 0) 
			begin
				set @result = ''5000012b-dearchive operation failed-->error in creating #tmp_t_acc_usage''
				rollback tran
				close c2
				deallocate c2
				return
			end
			if (@datafiletype = ''n'')
			begin
			select @sql1 = ''bulk insert #tmp_t_acc_usage from '''''' + @path + ''\t_acc_usage'' + ''_'' + 
					cast(@interval as varchar(10)) + ''_'' + cast(@bucket as varchar(10)) + ''.txt'''' 
					WITH 
	      				(	
					DATAFILETYPE = ''''native'''',
	       				CHECK_CONSTRAINTS
	      				)''
			end
			if (@datafiletype = ''c'')
			begin
			select @sql1 = ''bulk insert #tmp_t_acc_usage from '''''' + @path + ''\t_acc_usage'' + ''_'' + 
					cast(@interval as varchar(10)) + ''_'' + cast(@bucket as varchar(10)) + ''.txt'''' 
					WITH 
	      				(	
					FIELDTERMINATOR = ''''\t'''',
	       				ROWTERMINATOR = ''''\n'''',
	       				CHECK_CONSTRAINTS
	      				)''
			end
			exec (@sql1)
			if (@@error <> 0) 
			begin
				set @result = ''5000013-dearchive operation failed-->error in usage bulk insert operation''
				rollback tran
				close c2
				deallocate c2
				return
			end
			create unique clustered index idx_tmp_t_acc_usage on #tmp_t_acc_usage(id_sess,id_usage_interval)
			create index idx1_tmp_t_acc_usage on #tmp_t_acc_usage(id_acc)
			if (@constraint = ''Y'')
			begin
				if exists (select 1 from #tmp_t_acc_usage where id_pi_template not in ( select id_template from t_pi_template))
				begin
					set @result = ''5000014-dearchive operation failed-->id_pi_template key violation''
					rollback tran
					close c2
					deallocate c2
					return
				end	 
				if exists (select 1 from #tmp_t_acc_usage where id_pi_instance not in ( select id_pi_instance from t_pl_map))
				begin
					set @result = ''5000015-dearchive operation failed-->id_pi_instance key violation''
					rollback tran
					close c2
					deallocate c2
					return
				end
				if exists (select 1 from #tmp_t_acc_usage where id_view not in ( select id_view from t_prod_view))
				begin
					set @result = ''5000016-dearchive operation failed-->id_view key violation''
					rollback tran
					close c2
					deallocate c2
					return
				end	 	 
			end
			insert into t_acc_usage select * from #tmp_t_acc_usage where id_acc in
			(select id from #AccountIDsTable)
			
			--Insert data into product view tables
			declare  c1 cursor fast_forward for select distinct id_view from #tmp_t_acc_usage where id_acc in
			(select id from #AccountIDsTable)
			open c1
			fetch next from c1 into @var1
			while (@@fetch_status = 0)
			begin
				select @tab1 = nm_table_name from t_prod_view where id_view=@var1
				if exists (select 1 from t_query_log pv inner join t_archive arc on
				pv.c_id_view = arc.id_view 
				and pv.c_id_view = @var1
				and pv.c_timestamp > arc.tt_start
				and arc.id_interval = @interval
				and arc.status =''E''
				and not exists (select 1 from t_archive arc1 
				where arc.id_interval = arc1.id_interval
				and arc.id_view = arc1.id_view
				and arc1.status =''E''
				and arc1.tt_start > arc.tt_start))
				begin
					select @sql1 = N''IF object_id(''''tempdb..tmp_'' + @tab1 + '''''') is not null drop table tempdb..tmp_'' + @tab1
					EXEC (@sql1)
					
					declare @create_table varchar(8000)
					select top 1 @create_table = c_old_schema from t_query_log pv inner join t_archive arc on
					pv.c_id_view = arc.id_view 
					and pv.c_id_view = @var1
					and pv.c_timestamp > arc.tt_start
					and arc.id_interval = @interval
					and arc.status =''E''
					and pv.c_old_schema is not null
					order by pv.c_timestamp,c_id
					select @create_table = replace(@create_table,@tab1,''tempdb..tmp_'' + @tab1)
					exec (@create_table)
					if (@@error <> 0) 
					begin
						set @result = ''5000017-dearchive operation failed-->error in creating temp pv table'' + cast(@tab1 as nvarchar(1000)) 
						rollback tran
						close c1
						deallocate c1
						close c2
						deallocate c2
						return
					end
					declare @change nvarchar(4000)
					declare @c_id int
					declare c3 cursor for select distinct c_query,c_id from t_query_log pv inner join t_archive 
					arc on pv.c_id_view = arc.id_view 
					and pv.c_id_view = @var1
					and pv.c_timestamp > arc.tt_start
					and arc.id_interval = @interval
					and arc.status =''E''
					and pv.c_query is not null
					order by c_id
				end
				else
				begin
					select @sql1 = N''IF object_id(''''tempdb..tmp_'' + @tab1 + '''''') is not null drop table tempdb..tmp_'' + @tab1
					EXEC (@sql1)
					select @sql1 = ''select * into  tempdb..tmp_'' + @tab1 + '' from '' + @dbname + ''..'' + @tab1 + '' where 0=1''
					exec (@sql1)
					if (@@error <> 0) 
					begin
						set @result = ''5000018-dearchive operation failed-->error in creating temp pv table from origional '' + cast(@tab1 as nvarchar(1000)) 
						rollback tran
						close c1
						deallocate c1
						close c2
						deallocate c2
						return
					end
				end
				if (@datafiletype = ''n'')
				begin
				select @sql1 = ''bulk insert tempdb..tmp_'' + @tab1 + '' from '''''' + @path + ''\'' + @tab1 + 
						''_'' + cast(@interval as varchar(10)) + ''_'' + cast(@bucket as varchar(10)) + ''.txt'''' WITH 
	      					(
							DATAFILETYPE = ''''native''''
	      					)''
				end
				if (@datafiletype = ''c'')
				begin
				select @sql1 = ''bulk insert tempdb..tmp_'' + @tab1 + '' from '''''' + @path + ''\'' + @tab1 + 
						''_'' + cast(@interval as varchar(10)) + ''_'' + cast(@bucket as varchar(10)) + ''.txt'''' WITH 
	      					(
						FIELDTERMINATOR = ''''\t'''',
	       					ROWTERMINATOR = ''''\n''''
	      					)''
				end
				exec (@sql1)	
				if (@@error <> 0) 
				begin
					set @result = ''5000019-dearchive operation failed-->error in bulk insert operation for table '' + cast(@tab1 as nvarchar(1000)) 
					rollback tran
					close c1
					deallocate c1
					close c2
					deallocate c2
					return
				end
				if exists (select 1 from t_query_log pv inner join t_archive arc on
				pv.c_id_view = arc.id_view 
				and pv.c_id_view = @var1
				and pv.c_timestamp > arc.tt_start
				and arc.id_interval = @interval
				and arc.status =''E'')
				begin
					open c3
					fetch c3 into @change,@c_id
					WHILE (@@FETCH_STATUS = 0)
					BEGIN
						select @change = stuff(@change,charindex(@tab1,@change),len(@tab1),''tempdb..tmp_'' + @tab1)
						exec (@change)					
   						FETCH NEXT FROM c3 into @change,@c_id
					END
					CLOSE c3
					DEALLOCATE c3
				end
 				select @sql1 = ''insert into '' + @dbname + ''..'' + @tab1 + '' select * from tempdb..tmp_'' + @tab1 +'' where id_sess
 						in (select id_sess from #tmp_t_acc_usage where id_acc in (select id from #AccountIDsTable))''
				exec (@sql1)
				if (@@error <> 0) 
				begin
					set @result = ''5000020-dearchive operation failed-->error in insert into pv table from temp table '' + cast(@tab1 as nvarchar(1000)) 
					rollback tran
					close c1
					deallocate c1
					close c2
					deallocate c2
					return
				end
				select @sql1 = N''IF object_id(''''tempdb..tmp_'' + @tab1 + '''''') is not null drop table tempdb..tmp_'' + @tab1
				EXEC (@sql1)
			fetch next from c1 into @var1
			end
			close c1
			deallocate c1
		fetch next from c2 into @bucket
		end
		close c2
		deallocate c2
		if not exists (select top 1 id_adj_trx from t_adjustment_transaction where id_usage_interval = @interval)
		begin 
		--Insert data into t_adjustment_transaction
			if object_id(''tempdb..#tmp_t_adjustment_transaction'') is not null
			drop table #tmp_t_adjustment_transaction
			select * into #tmp_t_adjustment_transaction from t_adjustment_transaction where 0=1
			if (@datafiletype = ''n'')
			begin
			select @sql1 = ''bulk insert #tmp_t_adjustment_transaction from '''''' + @path + ''\t_adjustment_transaction'' + ''_'' + cast (@interval as varchar(10)) + ''.txt'''' WITH 
	      				(	
					DATAFILETYPE = ''''native'''',
		       			CHECK_CONSTRAINTS
	      				)''
			end
			if (@datafiletype = ''c'')
			begin
			select @sql1 = ''bulk insert #tmp_t_adjustment_transaction from '''''' + @path + ''\t_adjustment_transaction'' + ''_'' + cast (@interval as varchar(10)) + ''.txt'''' WITH 
	      					(
						FIELDTERMINATOR = ''''\t'''',
	       					ROWTERMINATOR = ''''\n'''',
			       			CHECK_CONSTRAINTS
	      					)''
			end
			exec (@sql1)
			if (@@error <> 0) 
			begin
				set @result = ''5000021-dearchive operation failed-->error in adjustment bulk insert operation''
				rollback tran
				close c1
				deallocate c1
				return
			end
	
			--update t_adjustment_transaction to copy data from archive_sess to id_sess if usage is already in t_acc_usage
			update trans 
				set id_sess=archive_sess,archive_sess=null
				from #tmp_t_adjustment_transaction trans inner join t_acc_usage au 
				on trans.archive_sess=au.id_sess
				where trans.id_sess is null
			if (@@error <> 0) 
			begin
				set @result = ''5000022-dearchive operation failed-->error in update adjustment transaction''
				rollback tran
				close c1
				deallocate c1
				return
			end
			--This update is to cover the scenario if post bill adjustments are archived before usage and now dearchive before usage interval
			update trans 
				set archive_sess=id_sess,id_sess=null
				from #tmp_t_adjustment_transaction trans where not exists 
				(select 1 from t_acc_usage au where au.id_sess=trans.id_sess)
				and trans.archive_sess is null
--				and n_adjustmenttype = 1
				and id_usage_interval=@interval
			if (@@error <> 0) 
			begin
				set @result = ''5000023-dearchive operation failed-->error in update adjustment transaction''
				rollback tran
				close c1
				deallocate c1
				return
			end
			insert into t_adjustment_transaction select * from #tmp_t_adjustment_transaction
			if object_id(''tempdb..#tmp_t_adjustment_transaction'') is not null
			drop table #tmp_t_adjustment_transaction
			--Insert data into t_aj tables
			declare  c1 cursor fast_forward for select distinct adj_name from t_archive 
			where id_interval = @interval and tt_end = @maxtime and adj_name is not null and status=''A''
			open c1
			fetch next from c1 into @var1
			while @@fetch_status = 0
			begin
				if (@datafiletype = ''n'')
				begin
				select @sql1 = ''bulk insert '' + @dbname + ''..'' + @var1 + '' from '''''' + @path + ''\'' + @var1 + ''_'' + cast (@interval as varchar(10)) + ''.txt'''' WITH 
	      					(
						DATAFILETYPE = ''''native'''',
		       				CHECK_CONSTRAINTS
	      					)''
				end
				if (@datafiletype = ''c'')
				begin
				select @sql1 = ''bulk insert '' + @dbname + ''..'' + @var1 + '' from '''''' + @path + ''\'' + @var1 + ''_'' + cast (@interval as varchar(10)) + ''.txt'''' WITH 
	      					(
						FIELDTERMINATOR = ''''\t'''',
	       					ROWTERMINATOR = ''''\n'''',
		       				CHECK_CONSTRAINTS
						)''
				end
				exec (@sql1)
				if (@@error <> 0) 
				begin
					set @result = ''5000024-dearchive operation failed-->error in bulk insert operation for table '' + cast(@var1 as nvarchar(1000))
					rollback tran
					close c1
					deallocate c1
					return
				end
				fetch next from c1 into @var1
			end
			close c1
			deallocate c1
		end

		update act set tt_end = dateadd(s,-1,@vartime)
		from t_acc_bucket_map act inner join #AccountIDsTable tmp on act.id_acc = tmp.id
		where act.id_usage_interval=@interval
		and act.status = ''A''
		and act.tt_end=@maxtime
		if (@@error <> 0) 
		begin
			set @result = ''5000025-dearchive operation failed-->error in update t_acc_bucket_map''
			rollback tran
			return
		end
		insert into t_acc_bucket_map(id_usage_interval,id_acc,bucket,status,tt_start,tt_end)
		select @interval,id,bucket,''D'',@vartime,@maxtime from #AccountIDsTable 
		if (@@error <> 0) 
		begin
			set @result = ''5000026-dearchive operation failed-->error in insert into t_acc_bucket_map''
			rollback tran
			return
		end

		if not exists (select 1 from t_acc_bucket_map map left outer join t_acc_usage au on
				map.id_acc = au.id_acc
				and map.id_usage_interval = au.id_usage_interval
				where map.status =''A''
				and map.id_usage_interval = @interval
				and tt_end = @maxtime)
		begin
			--Update t_archive table to record the fact that interval is no longer archived
			update t_archive set tt_end=dateadd(s,-1,@vartime)
			where id_interval=@interval 
			and status=''A'' 
			and tt_end=@maxtime
			if (@@error <> 0) 
			begin
				set @result = ''5000027-dearchive operation failed-->error in update t_archive''
				rollback tran
				return
			end
			insert into t_archive 
			select @interval,id_view,null,''D'',@vartime,@maxtime
			from t_archive where id_interval=@interval 
			and status=''A'' 
			and tt_end=dateadd(s,-1,@vartime)
			and id_view is not null
			union all
			select @interval,null,adj_name,''D'',@vartime,@maxtime
			from t_archive where id_interval=@interval 
			and status=''A'' 
			and tt_end=dateadd(s,-1,@vartime)
			and adj_name is not null
			if (@@error <> 0) 
			begin
				set @result = ''5000028-dearchive operation failed-->error in insert t_archive''
				rollback tran
				return
			end
		end
--Following update will be required for post bill adjustments that are already in system when current usage is dearchived
			update trans 
				set id_sess=archive_sess,archive_sess=null
				from t_adjustment_transaction trans inner join t_acc_usage au 
				on trans.archive_sess=au.id_sess
				where trans.id_sess is null
			if (@@error <> 0) 
			begin
				set @result = ''5000029-dearchive operation failed-->error in update adjustment transaction''
				rollback tran
				return
			end

--If all the intervals of the partition are dearchived then update the t_archive_partition table
		select @partition = partition_name from t_partition part inner join t_partition_interval_map map
		on part.id_partition = map.id_partition where map.id_interval = @interval
		if exists (select 1 from t_partition part inner join t_partition_interval_map map
		on part.id_partition = map.id_partition and part.partition_name = @partition
		inner join  t_archive_partition back on part.partition_name = back.partition_name
		and back.status = ''A'' and tt_end = @maxtime and
		map.id_interval not in (select id_interval from t_archive where status  <> ''D'' 
		and tt_end = @maxtime))
		begin
			update t_archive_partition
			set tt_end = dateadd(s,-1,@vartime)
			where partition_name = @partition 
			and tt_end= @maxtime
			and status = ''A''
			if (@@error <> 0)
			begin
				set @result = ''5000030-archive operation failed-->Error in update t_archive_partition table''
				rollback tran
				return
			end
			insert into t_archive_partition values(@partition,''D'',@vartime,@maxtime)
			if (@@error <> 0)
			begin
				set @result = ''5000031-archive operation failed-->Error in insert into t_archive_partition table''
				rollback tran
				return
			end
			update t_partition set b_active = ''Y'' where partition_name = @partition
			if (@@error <> 0)
			begin
				set @result = ''5000032-archive operation failed-->Error in update t_partition table''
				rollback tran
				return
			end
		end
		set @result = ''0-dearchive operation successful''
		commit tran
    
    ' 
END
GO
/****** Object:  StoredProcedure [dbo].[archive_export]    Script Date: 06/02/2008 11:43:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[archive_export]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
    
Create procedure [dbo].[archive_export] 
			(
			@partition nvarchar(4000)=null,
			@intervalId int=null,
			@path nvarchar(1000),
			@avoid_rerun char(1)  = ''N'',
			@result nvarchar(4000) output
			)
		as
/*
		How to run this stored procedure
		declare @result nvarchar(2000)
		exec archive_export @partition=''N_20040701_20040731'',@path=''c:\backup\archive'',@avoid_rerun = ''N'',@result=@result output
		print @result
		or
		declare @result nvarchar(2000)
		exec archive_export @intervalid=897515523,@path=''c:\backup\archive'',@avoid_rerun = ''N'',@result=@result output
		print @result
*/
		set nocount on
		declare @sql1 nvarchar(4000)
		declare @tab1 nvarchar(1000)
		declare @var1 nvarchar(1000)
		declare @vartime datetime
		declare @maxtime datetime
		declare @acc int
		declare	@servername nvarchar(100)
		declare	@dbname nvarchar(100)
		declare @interval int
		declare @partition1 nvarchar(4000)
--Get the servername and database name from the current connection	
		select @servername = @@servername
		select @dbname = db_name()
		select @vartime = getdate()
		select @maxtime = dbo.mtmaxdate()

		--Checking the Business rules
		--Either Partition or Interval should be specified
		if ((@partition is not null and @intervalId is not null) or (@partition is null and @intervalId is null))
		begin
			set @result = ''1000001-archive_export operation failed-->Either Partition or Interval should be specified''
			return
		END
--Get the list of Intervals that need to be archived
		if (@partition is not null)
		begin
			declare  interval_id cursor fast_forward for 
			select id_interval from t_partition_interval_map map where id_partition 
			= (select id_partition  from t_partition where partition_name = @partition)
		end
		else
		begin
			declare  interval_id cursor fast_forward for select @intervalId
			select @partition1 = partition_name from t_partition part inner join
			t_partition_interval_map map on part.id_partition = map.id_partition
			and map.id_interval = @intervalid
		end
		open interval_id
		fetch next from interval_id into @interval
		while (@@fetch_status = 0)
		begin
			--interal should exists
			if not exists (select 1 from t_usage_interval where id_interval=@interval)
			BEGIN
				set @result = ''1000002-archive operation failed-->Interval does not exist''
				close interval_id
				deallocate interval_id
				return
			END
			--Interval should be hard-closed
			if exists (select 1 from t_usage_interval where id_interval=@interval and tx_interval_status in (''O'',''B''))
			BEGIN
				set @result = ''1000003-archive operation failed-->Interval is not Hard Closed''
				close interval_id
				deallocate interval_id
				return
			END
			--Interval should not be already archived
			if  exists (select 1 from t_archive where id_interval=@interval and status =''A'' and tt_end = @maxtime)
			begin
				set @result = ''1000004-archive operation failed-->Interval is already archived-Deleted''
				close interval_id
				deallocate interval_id
				return
			end
			--Interval should have bucket mapping
			if not exists (select 1 from t_acc_bucket_map where id_usage_interval=@interval)
			BEGIN
				set @result = ''1000005-archive operation failed-->Interval does not have bucket mappings''
				close interval_id
				deallocate interval_id
				return
			END
			--Interval should be Dearchived
			if  exists (select 1 from t_archive where id_interval=@interval and status =''D'' and tt_end = @maxtime)
			begin
				set @result = ''1000006-archive operation failed-->Interval is Dearchived and not be exported..run trash/delete procedure''
				close interval_id
				deallocate interval_id
				return
			end

--Create the temp table that will store the output of the bcp operation
			if object_id(''tempdb..#bcpoutput'') is not null
			drop table #bcpoutput
			create table #bcpoutput(OutputLine nvarchar(4000))
--Get the number of buckets for the interval..we need to have seperate bcp file for each table for each bucket
			declare  c2 cursor fast_forward for select distinct bucket from t_acc_bucket_map where 
			id_usage_interval =  @interval
			and (status = ''U'' or (status = ''E'' and @avoid_rerun = ''N''))
			and tt_end = @maxtime
			open c2
			fetch next from c2 into @acc
			while (@@fetch_status = 0)
			begin		
				--We are creating view to avoid queryout parameter bug
				--(http://support.microsoft.com/default.aspx?scid=kb;en-us;Q309555)
				SET @sql1 = N''IF EXISTS (SELECT 1 FROM dbo.sysobjects WHERE id = object_id(''''bcpview''''))
				 DROP view bcpview''
				EXEC (@sql1)
			--bcp out the t_acc_usage table
				select @sql1 = N''create view bcpview as SELECT top 100 percent au.* FROM '' + @dbname + 
						''..t_acc_usage au inner join t_acc_bucket_map act on 
		 				au.id_usage_interval = act.id_usage_interval and au.id_acc = act.id_acc
						where au.id_usage_interval='' + cast (@interval as varchar(10)) + 
						N'' and act.bucket ='' + cast(@acc as varchar(10)) + '' and act.status = ''''U''''''
						 + '' and act.id_usage_interval ='' + cast(@interval as varchar(10))
				exec (@sql1)
				--BCP out the data from t_acc_usage
				select @sql1 = ''bcp "'' + @dbname + ''..bcpview" out "'' +  @path + ''\t_acc_usage_'' + cast (@interval as varchar (10)) + ''_'' + cast (@acc as varchar (10)) + ''.txt" -n -T -S'' + @servername
				insert into #bcpoutput exec master.dbo.xp_cmdshell @sql1
				--If bcp output file is empty..retrun with the error code
				IF (SELECT count(*) FROM #bcpoutput) = 0 
				BEGIN
					set @result = ''1000007-archive operation failed-->Error in bcp out usage table, check the user permissions''
					close c2
					deallocate c2
					close interval_id
					deallocate interval_id
					return
				END
				--If there is any error in bcp operation..retrun with the error code
				IF EXISTS(SELECT NULL FROM #bcpoutput 
					WHERE OutputLine like ''%Error%'' 
						OR OutputLine like ''%ODBC SQL Server Driver%'')
				BEGIN
					set @result = ''1000008-archive operation failed-->Error in bcp out usage table, check the archive directory or hard disk space or database name or servername''
					select * from #bcpoutput
					close c2
					deallocate c2
					close interval_id
					deallocate interval_id
					return
				END
				--Truncate the temp table after every bcp operation
				truncate table #bcpoutput

				/*Create a temp table to get the list of id_sess that need go in a particular file
				based on account bucket mapping..we are doing this step to avoid to go to the t_acc_usage
				for each product view */
				if object_id(''tempdb..tmp_t_acc_usage'') is not null
				drop table tempdb..tmp_t_acc_usage
				select @sql1 = ''SELECT au.id_sess,au.id_usage_interval,au.id_acc into tempdb..tmp_t_acc_usage FROM '' + @dbname + 
						''..t_acc_usage au inner join t_acc_bucket_map act on au.id_usage_interval = act.id_usage_interval
						 and au.id_acc = act.id_acc where au.id_usage_interval='' + cast (@interval as varchar(10)) 
						+ '' and act.status = ''''U'''' and act.bucket = '' + cast(@acc as varchar(10)) + '' and act.id_usage_interval ='' + cast (@interval as varchar(10))
				exec (@sql1)
				create unique clustered index idx_tmp_t_acc_usage on tempdb..tmp_t_acc_usage(id_sess,id_usage_interval)
				create index idx1_tmp_t_acc_usage on tempdb..tmp_t_acc_usage(id_acc)

				if (select b_partitioning_enabled from t_usage_server) = ''Y''
				begin
					declare  c3 cursor fast_forward for select nm_table_name from t_unique_cons
					open c3
					fetch next from c3 into @tab1
					while (@@fetch_status = 0)
					begin
						SET @sql1 = N''IF EXISTS (SELECT 1 FROM dbo.sysobjects WHERE id = object_id(''''bcpview'''')) DROP view bcpview''
							EXEC sp_executesql @sql1
						select @sql1 = N''create view bcpview as SELECT top 100 percent uq.* FROM '' + 
								@dbname + ''..'' + @tab1 + '' uq 
								inner join tempdb..tmp_t_acc_usage au on 
								uq.id_sess = au.id_sess and uq.id_usage_interval = au.id_usage_interval
								inner join t_acc_bucket_map act on 
								au.id_usage_interval = act.id_usage_interval and au.id_acc = act.id_acc
								where act.bucket ='' + cast(@acc as varchar(10)) + 
								'' and au.id_usage_interval ='' + cast(@interval as varchar(10)) +
								'' and act.id_usage_interval ='' + cast(@interval as varchar(10)) +
								'' and uq.id_usage_interval ='' + cast(@interval as varchar(10)) +
								'' and act.status = ''''U''''''
						exec (@sql1)
						--BCP out the data from product view tables
						select @sql1 = ''bcp "'' + @dbname + ''..bcpview" out "'' + @path + ''\'' + @tab1 + ''_'' + cast (@interval as varchar (10)) + ''_'' + cast (@acc as varchar (10)) + ''.txt" -n -T -S'' + @servername
						truncate table #bcpoutput
						insert into #bcpoutput exec master.dbo.xp_cmdshell @sql1
						IF EXISTS(SELECT NULL FROM #bcpoutput 
			    			WHERE OutputLine like ''%Error%'' 
			        			OR OutputLine like ''%ODBC SQL Server Driver%'')
						BEGIN
							set @result = ''1000018-archive operation failed-->Error in bcp out the '' + cast(@tab1 as varchar(1000)) + '' product view table, check the hard disk space''
							select * from #bcpoutput
							close c3
							deallocate c3
							close c2
							deallocate c2
							close interval_id
							deallocate interval_id
							return
						END
					fetch next from c3 into @tab1
					end
					close c3
					deallocate c3
				end	

				--Get the list of product views that needs to be archived (may be removed later)
				declare  c1 cursor fast_forward for select distinct id_view from t_acc_usage where 
				id_usage_interval = @interval
				open c1
				fetch next from c1 into @var1
				while (@@fetch_status = 0)
				begin
					select @tab1 = nm_table_name from t_prod_view where id_view=@var1 
					SET @sql1 = N''IF EXISTS (SELECT 1 FROM dbo.sysobjects WHERE id = object_id(''''bcpview'''')) DROP view bcpview''
						EXEC sp_executesql @sql1
					select @sql1 = N''create view bcpview as SELECT top 100 percent pv.* FROM '' + 
							@dbname + ''..'' + @tab1 + '' pv inner join tempdb..tmp_t_acc_usage au on 
							pv.id_sess=au.id_sess and 
							au.id_usage_interval = pv.id_usage_interval
							inner join t_acc_bucket_map act on 
							au.id_usage_interval = act.id_usage_interval and au.id_acc = act.id_acc
							where act.bucket ='' + cast(@acc as varchar(10)) + 
							'' and act.id_usage_interval ='' + cast(@interval as varchar(10)) +
							'' and au.id_usage_interval ='' + cast(@interval as varchar(10)) +
							'' and act.status = ''''U''''''
					exec (@sql1)
					--BCP out the data from product view tables
					select @sql1 = ''bcp "'' + @dbname + ''..bcpview" out "'' + @path + ''\'' + @tab1 + ''_'' + cast (@interval as varchar (10)) + ''_'' + cast (@acc as varchar (10)) + ''.txt" -n -T -S'' + @servername
					truncate table #bcpoutput
					insert into #bcpoutput exec master.dbo.xp_cmdshell @sql1
					IF EXISTS(SELECT NULL FROM #bcpoutput 
		    			WHERE OutputLine like ''%Error%'' 
		        			OR OutputLine like ''%ODBC SQL Server Driver%'')
					BEGIN
						set @result = ''1000009-archive operation failed-->Error in bcp out the '' + cast(@tab1 as varchar(1000)) + '' product view table, check the hard disk space''
						select * from #bcpoutput
						close c1
						deallocate c1
						close c2
						deallocate c2
						close interval_id
						deallocate interval_id
						return
					END
				fetch next from c1 into @var1
				end
				close c1
				deallocate c1
				update t_acc_bucket_map 
				set tt_end = dateadd(s,-1,@vartime)
				where id_usage_interval=@interval 
				and status in (''E'',''U'') 
				and tt_end=@maxtime
				and bucket = @acc
				if (@@error <> 0)
				begin
					set @result = ''1000010-archive operation failed-->Error in update t_acc_bucket_map table''
					close c2
					deallocate c2
					close interval_id
					deallocate interval_id
					return
				end
				insert into t_acc_bucket_map(id_usage_interval,id_acc,bucket,status,tt_start,tt_end) 
				select @interval,id_acc,bucket,''E'',@vartime,@maxtime from t_acc_bucket_map
				where id_usage_interval=@interval
				and status in (''E'',''U'') 
				and tt_end=dateadd(s,-1,@vartime)
				and bucket = @acc
				if (@@error <> 0)
				begin
					set @result = ''1000011-archive operation failed-->Error in insert into t_acc_bucket_map table''
					close c2
					deallocate c2
					close interval_id
					deallocate interval_id
					return
				end
			fetch next from c2 into @acc
			end
			close c2
			deallocate c2
		
			SET @sql1 = N''IF EXISTS (SELECT 1 FROM dbo.sysobjects WHERE id = object_id(''''bcpview'''')) DROP view bcpview''
					EXEC sp_executesql @sql1
			select @sql1 = N''create view bcpview as SELECT top 100 percent * FROM '' + @dbname +''..t_adjustment_transaction where id_usage_interval='' + 
					cast (@interval as varchar(10)) + N'' order by id_sess''
					exec (@sql1)
			--BCP out the data from t_adjustment_transaction
			select @sql1 = ''bcp "'' + @dbname + ''..bcpview" out "'' + @path + ''\t_adjustment_transaction'' + ''_'' + cast (@interval as varchar (10)) + ''.txt" -n -T -S'' + @servername
			truncate table #bcpoutput
			insert into #bcpoutput exec master.dbo.xp_cmdshell @sql1
			IF EXISTS(SELECT NULL FROM #bcpoutput 
				WHERE OutputLine like ''%Error%'' 
					OR OutputLine like ''%ODBC SQL Server Driver%'')
			BEGIN
				set @result = ''1000012-archive operation failed-->Error in bcp out adjustment transaction table, check the hard disk space''
				select * from #bcpoutput
				close interval_id
				deallocate interval_id
				return
			END
			truncate table #bcpoutput
	
			if object_id(''tempdb..tmp_t_adjustment_transaction'') is not null
			drop table tempdb..tmp_t_adjustment_transaction
			select @sql1 = N''SELECT id_adj_trx into tempdb..tmp_t_adjustment_transaction FROM '' + @dbname + ''..t_adjustment_transaction where id_usage_interval='' + cast (@interval as varchar(10)) + N'' order by id_sess''
			exec (@sql1)
			create unique clustered index idx_tmp_t_adjustment_transaction on tempdb..tmp_t_adjustment_transaction(id_adj_trx)
	
			if object_id(''tempdb..#adjustment'') is not null
			drop table #adjustment
			create table #adjustment(name nvarchar(2000))
			declare c1 cursor fast_forward for select table_name from information_schema.tables where 
			table_name like ''t_aj_%'' and table_name not in (''T_AJ_TEMPLATE_REASON_CODE_MAP'',''t_aj_type_applic_map'')
			open c1
			fetch next from c1 into @var1
			while (@@fetch_status = 0)
			begin
			--Get the name of t_aj tables that have usage in this interval
			set @sql1 = N''if exists
					(select 1 from '' + @var1 + '' where id_adjustment in 
					(select id_adj_trx from t_adjustment_transaction where id_usage_interval = '' + cast(@interval as varchar(10)) + N'')) 
					insert into #adjustment values('''''' + @var1 + '''''')''
					EXEC sp_executesql @sql1
			SET @sql1 = N''IF EXISTS (SELECT 1 FROM dbo.sysobjects WHERE id = object_id(''''bcpview'''')) DROP view bcpview''
					EXEC sp_executesql @sql1
			fetch next from c1 into @var1
			end
			close c1
			deallocate c1
	
			declare c1 cursor for select name from #adjustment
			open c1
			fetch next from c1 into @var1
			while (@@fetch_status = 0)
			begin
				SET @sql1 = N''IF EXISTS (SELECT 1 FROM dbo.sysobjects WHERE id = object_id(''''bcpview'''')) DROP view bcpview''
					EXEC sp_executesql @sql1
				--BCP out the data from t_aj tables
				select @sql1 = N''create view bcpview as SELECT top 100 percent aj.* FROM '' + @dbname + ''..'' + @var1 
				+ '' aj inner join tempdb..tmp_t_adjustment_transaction trans on aj.id_adjustment=trans.id_adj_trx''
					exec (@sql1)
				select @sql1 = ''bcp "'' + @dbname +''..bcpview" out "'' + @path + ''\'' + @var1 + ''_'' + cast (@interval as varchar (10)) + ''.txt" -n -T -S'' + @servername
				truncate table #bcpoutput
				insert into #bcpoutput exec master.dbo.xp_cmdshell @sql1
				IF EXISTS(SELECT NULL FROM #bcpoutput 
	    			WHERE OutputLine like ''%Error%'' 
	        			OR OutputLine like ''%ODBC SQL Server Driver%'')
				BEGIN
					set @result = ''1000013-archive operation failed-->Error in bcp out '' + cast(@var1 as varchar(1000)) + '' table, check the hard disk space''
					select * from #bcpoutput
					close c1
					deallocate c1
					close interval_id
					deallocate interval_id
					return
				END
				fetch next from c1 into @var1
			end
			close c1
			deallocate c1
		fetch next from interval_id into @interval
		end
		close interval_id
	
		begin tran
--Update the archiving tables...t_archive, t_archive_partition, t_acc_bucket_map
		open interval_id
		fetch next from interval_id into @interval
		while (@@fetch_status = 0)
		begin
			if object_id(''tempdb..#id_view'') is not null
			drop table #id_view
			select distinct id_view into #id_view from t_acc_usage where id_usage_interval = @interval
			update t_archive 
			set tt_end = dateadd(s,-1,@vartime)
			where id_interval=@interval 
			and status=''E'' 
			and tt_end=@maxtime
			if (@@error <> 0)
			begin
				set @result = ''1000014-archive operation failed-->Error in update t_archive table''
				rollback tran
				close interval_id
				deallocate interval_id
				return
			end
			insert into t_archive 
			select @interval,id_view,null,''E'',@vartime,@maxtime from #id_view
			union all
			select @interval,null,name,''E'',@vartime,@maxtime from #adjustment
			if (@@error <> 0)
			begin
				set @result = ''1000015-archive operation failed-->Error in insert t_archive table''
				rollback tran
				close interval_id
				deallocate interval_id
				return
			end
		fetch next from interval_id into @interval
		end
		close interval_id
		deallocate interval_id

		if
		( 
		(
			(@partition is not null) 
			or exists
			(
				select 1 from t_partition_interval_map map where id_partition = (select id_partition
				from t_partition_interval_map where id_interval = @intervalid)
				and not exists (select 1 from t_usage_interval inte where inte.id_interval = map.id_interval
				and tx_interval_status <> ''H'') 
				and not exists (select 1 from t_archive inte where inte.id_interval = map.id_interval
				and tt_end = @maxtime and status <> ''E'') 		
			)
		) 
		and 
			(select b_partitioning_enabled from t_usage_server) = ''Y''
		)
		begin
			update t_archive_partition
			set tt_end = dateadd(s,-1,@vartime)
			where partition_name = isnull(@partition,@partition1)
			and tt_end=@maxtime
			and status = ''E''
			if (@@error <> 0)
			begin
				set @result = ''1000016-archive operation failed-->Error in update t_archive_partition table''
				rollback tran
				return
			end
			insert into t_archive_partition values(isnull(@partition,@partition1),''E'',@vartime,@maxtime)
			if (@@error <> 0)
			begin
				set @result = ''1000017-archive operation failed-->Error in insert into t_archive_partition table''
				rollback tran
				return
			end
		end
		--Drop all the temp tables created in the procedure
		if object_id(''tempdb..tmp_t_acc_usage'') is not null
		drop table tempdb..tmp_t_acc_usage
		if object_id(''tempdb..tmp_t_adjustment_transaction'') is not null
		drop table tempdb..tmp_t_adjustment_transaction
		set @result = ''0-archive_export operation successful''
		commit tran
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[archive_trash]    Script Date: 06/02/2008 11:43:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[archive_trash]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
    
  Create procedure [dbo].[archive_trash]
			(
			@partition nvarchar(4000)=null,
			@intervalId int=null,
			@accountIDList nvarchar(4000),
			@result nvarchar(4000) output
			)
		as
/*		How to run this stored procedure
		declare @result nvarchar(2000)
		exec archive_trash @partition=''N_20040701_20040731'',@accountIDList=null,@result=@result output
		print @result
		or
		declare @result nvarchar(2000)
		exec archive_trash @intervalId=827719717,@accountIDList=null,@result=@result output
		print @result
*/
		set nocount on
		declare @sqlstmt nvarchar(4000)
		declare @tab1 nvarchar(1000)
		declare @var1 nvarchar(1000)
		declare @vartime datetime
		declare @maxtime datetime
		declare	@dbname nvarchar(100)
		declare	@servername nvarchar(100)
		declare @partname nvarchar(4000)
		declare @intervalId1 int

--get the server and the database name
		select @servername = @@servername
		select @dbname = db_name()
		select @vartime = getdate()
		select @maxtime = dbo.mtmaxdate()

		--Either Partition or IntervalId/AccountId can be specified
		if ((@partition is not null and @intervalId is not null) or (@partition is null and @intervalId is null)
		or (@partition is not null and @accountIDList is not null))
		begin
			set @result = ''3000001-archive_trash operation failed-->Either Partition or Interval/AccountId should be specified''
			return
		end

		if (@partition is not null)
		begin
			--Checking the following Business rules
			--partition should be already archived or Dearchived
			if  not exists (select 1 from t_archive_partition where partition_name = @partition and status  in (''A'',''D'') and tt_end = @maxtime)
			begin
				set @result = ''3000002-trash operation failed-->partition is not already archived/dearchived''
				return
			end

			--partition should have atleast 1 Interval that is dearchived
			if  not exists (select 1 from t_archive where 
			status = ''D'' and tt_end = @maxtime and id_interval in (select id_interval from t_partition_interval_map map
			inner join t_partition part on map.id_partition = part.id_partition where part.partition_name= @partition)) 
			begin
				set @result = ''3000002a-trash operation failed-->none of the intervals of partition is dearchived''
				return
			end

		end
		begin tran
			--If partition is specified then apply the Truncate operation
			if (@partition is not null)
			begin
				declare  interval_id cursor fast_forward for select id_interval from t_partition_interval_map map where id_partition 
				in (select id_partition  from t_partition where partition_name = @partition)
				open interval_id
				fetch next from interval_id into @intervalId1
				while (@@fetch_status = 0)
				begin
					if object_id(''tempdb..#adjustment'') is not null
					drop table #adjustment
					create table #adjustment(name nvarchar(2000))
					declare c2 cursor fast_forward for select table_name from information_schema.tables where 
					table_name like ''t_aj_%'' and table_name not in (''T_AJ_TEMPLATE_REASON_CODE_MAP'',''t_aj_type_applic_map'')
					open c2
					fetch next from c2 into @var1
					while (@@fetch_status = 0)
					begin
					--Get the name of t_aj tables that have usage in this interval
					set @sqlstmt = N''if exists
							(select 1 from '' + @var1 + '' where id_adjustment in 
							(select id_adj_trx from t_adjustment_transaction where id_usage_interval = '' + cast(@intervalId1 as varchar(10)) + N'')) 
							insert into #adjustment values('''''' + @var1 + '''''')''
							EXEC sp_executesql @sqlstmt
					SET @sqlstmt = N''IF EXISTS (SELECT 1 FROM dbo.sysobjects WHERE id = object_id(''''bcpview'''')) DROP view bcpview''
							EXEC sp_executesql @sqlstmt
					fetch next from c2 into @var1
					end
					close c2
					deallocate c2
			
					if object_id(''tempdb..##id_view'') is not null
					drop table ##id_view
					select distinct id_view into ##id_view from t_acc_usage where id_usage_interval = @intervalId1
					declare  c1 cursor fast_forward for select id_view from ##id_view 
					open c1
					fetch next from c1 into @var1
					while (@@fetch_status = 0)
					begin
						select @tab1 = nm_table_name from t_prod_view where id_view=@var1 --and nm_table_name not like ''%temp%''
						--Delete from product view tables
						select @sqlstmt = N''truncate table '' + @partition + ''..'' + @tab1
						exec (@sqlstmt)
						if (@@error <> 0)
						begin
							set @result = ''3000003-archive operation failed-->Error in product view Delete operation''
							rollback tran
							close c1
							deallocate c1
							return
						end
					fetch next from c1 into @var1
					end
					close c1
					deallocate c1
			
					if object_id(''tempdb..tmp_t_adjustment_transaction'') is not null
					drop table tempdb..tmp_t_adjustment_transaction
					select @sqlstmt = N''SELECT id_adj_trx into tempdb..tmp_t_adjustment_transaction FROM '' + @dbname + ''..t_adjustment_transaction where id_usage_interval='' + cast (@intervalId1 as varchar(10)) + N'' order by id_sess''
					exec (@sqlstmt)
					create unique clustered index idx_tmp_t_adjustment_transaction on tempdb..tmp_t_adjustment_transaction(id_adj_trx)
					declare  c1 cursor fast_forward for select distinct name from #adjustment
					open c1
					fetch next from c1 into @var1
					while (@@fetch_status = 0)
					begin
						--Delete from t_aj tables
						select @sqlstmt = N''delete aj FROM '' + @dbname + ''..'' + @var1 +  '' aj inner join 
						tempdb..tmp_t_adjustment_transaction tmp on aj.id_adjustment = tmp.id_adj_trx''
						exec (@sqlstmt)
						if (@@error <> 0)
						begin
							set @result = ''3000004-archive operation failed-->Error in t_aj tables Delete operation''
							rollback tran
							close c1
							deallocate c1
							return
						end
					fetch next from c1 into @var1
					end
					close c1
					deallocate c1
				
					--Delete from t_adjustment_transaction table
					select @sqlstmt = N''delete FROM '' + @dbname + ''..t_adjustment_transaction where id_usage_interval='' + cast (@intervalId1 as varchar(10))
					exec (@sqlstmt)
					if (@@error <> 0)
					begin
						set @result = ''3000005-Error in Delete from t_adjustment_transaction table''
						rollback tran
						return
					end
			
					--Checking for post bill adjustments that have corresponding usage archived
					if object_id(''tempdb..#t_adjustment_transaction_temp'') is not null
					drop table #t_adjustment_transaction_temp
					create table #t_adjustment_transaction_temp(id_sess bigint)
					select @sqlstmt =  N''insert into #t_adjustment_transaction_temp select id_sess 
								from t_adjustment_transaction where n_adjustmenttype=1 
								and id_sess in (select id_sess from t_acc_usage where id_usage_interval='' + cast(@intervalId1 as varchar(10)) + '' )''
					execute (@sqlstmt)
					if (@@error <> 0)
					begin
						set @result = ''3000006-archive operation failed-->Error in create adjustment temp table operation''
						rollback tran
						return
					end
					IF ((SELECT count(*) FROM #t_adjustment_transaction_temp) > 0) 
					begin
						update t_adjustment_transaction set archive_sess=id_sess,id_sess=null
						where id_sess in (select id_sess from #t_adjustment_transaction_temp)
						if (@@error <> 0)
						begin
							set @result = ''3000007-archive operation failed-->Error in Update adjustment operation''
							rollback tran
							return
						end
					end
					--Delete from t_acc_usage table
					select @sqlstmt = N''truncate table '' + @partition + ''..t_acc_usage''
					exec (@sqlstmt)
					if (@@error <> 0)
					begin
						set @result = ''3000008-archive operation failed-->Error in Delete t_acc_usage operation''
						rollback tran
						return
					end
		
					update t_archive 
					set tt_end = dateadd(s,-1,@vartime)
					where id_interval=@intervalId1 
					and status=''D''
					and tt_end=@maxtime
					if (@@error <> 0)
					begin
						set @result = ''3000009-archive operation failed-->Error in update t_archive table''
						rollback tran
						return
					end
					insert into t_archive 
					select id_interval,id_view,adj_name,''A'',@vartime,@maxtime from t_archive
					where id_interval = @intervalId1
					and status =''D'' 
					and tt_end=dateadd(s,-1,@vartime)
					if (@@error <> 0)
					begin
						set @result = ''3000010-archive operation failed-->Error in insert t_archive table''
						rollback tran
						return
					end
					update t_acc_bucket_map 
					set tt_end = dateadd(s,-1,@vartime)
					where id_usage_interval=@intervalId1 
					and status = ''D'' 
					and tt_end= @maxtime
					if (@@error <> 0)
					begin
						set @result = ''3000011-archive operation failed-->Error in update t_acc_bucket_map table''
						rollback tran
						return
					end
					insert into t_acc_bucket_map select @intervalId1,id_acc,bucket,''A'',@vartime,@maxtime from t_acc_bucket_map
					where id_usage_interval=@intervalId1
					and status =''D'' 
					and tt_end=dateadd(s,-1,@vartime)
					if (@@error <> 0)
					begin
						set @result = ''3000012-archive operation failed-->Error in insert into t_acc_bucket_map table''
						rollback tran
						return
					end
				fetch next from interval_id into @intervalId1
				end
				close interval_id
				deallocate interval_id
		
				update t_archive_partition
				set tt_end = dateadd(s,-1,@vartime)
				where partition_name = @partition 
				and tt_end= @maxtime
				and status = ''D''
				if (@@error <> 0)
				begin
					set @result = ''3000012a-archive operation failed-->Error in update t_archive_partition table''
					rollback tran
					return
				end
				insert into t_archive_partition values(@partition,''A'',@vartime,@maxtime)
				if (@@error <> 0)
				begin
					set @result = ''3000012b-archive operation failed-->Error in insert into t_archive_partition table''
					rollback tran
					return
				end
				update t_partition set b_active = ''N'' where partition_name = @partition
				if (@@error <> 0)
				begin
					set @result = ''3000012c-archive operation failed-->Error in update t_partition table''
					rollback tran
					return
				end		
				if object_id(''tempdb..tmp_t_adjustment_transaction'') is not null
				drop table tempdb..tmp_t_adjustment_transaction
				if object_id(''tempdb..#adjustment'') is not null
				drop table #adjustment
				if object_id(''tempdb..##id_view'') is not null
				drop table ##id_view
			end
			--If IntervalId is specified then apply the Delete operation	
			if (@intervalId is not null)
			begin
				--Checking the following Business rules
				--Interval should be already archived
				if  not exists (select top 1 * from t_archive where id_interval=@intervalId and status  in (''A'',''D'') and tt_end = @maxtime)
				begin
					set @result = ''3000013-trash operation failed-->Interval is not already archived/dearchived''
					rollback tran
					return
				end
		
				CREATE TABLE #AccountIDsTable (ID int NOT NULL)
				if (@accountIDList is not null)
				begin
					WHILE CHARINDEX('','', @accountIDList) > 0
						BEGIN
							INSERT INTO #AccountIDsTable (ID)
							SELECT SUBSTRING(@accountIDList,1,(CHARINDEX('','', @accountIDList)-1))
							SET @accountIDList = SUBSTRING (@accountIDList, (CHARINDEX('','', @accountIDList)+1),
												(LEN(@accountIDList) - (CHARINDEX('','', @accountIDList))))
						END
					INSERT INTO #AccountIDsTable (ID) SELECT @accountIDList
				end
				else
				begin
					set @sqlstmt = ''insert into #AccountIDsTable select distinct id_acc from t_acc_usage where id_usage_interval = '' + cast(@intervalId as varchar(20))
					exec (@sqlstmt)
				end
		
				if  not exists (select top 1 id_acc from t_acc_bucket_map where id_usage_interval=@intervalId and status =''D'' and tt_end = @maxtime)
				begin
					set @result = ''3000014-trash operation failed-->account in the list is not dearchived''
					rollback tran
					return 
				end
		
				if object_id(''tempdb..tmp_t_acc_usage'') is not null
				drop table tempdb..tmp_t_acc_usage
				if object_id(''tempdb..tmp_t_adjustment_transaction'') is not null
				drop table tempdb..tmp_t_adjustment_transaction
				select @sqlstmt = N''SELECT id_sess,id_acc into tempdb..tmp_t_acc_usage FROM '' + 
				@dbname + ''..t_acc_usage where id_usage_interval='' + cast (@intervalId as varchar(10)) + 
				'' and id_acc in (select id from #AccountIDsTable)''
				exec (@sqlstmt)
				create unique clustered index idx_tmp_t_acc_usage on tempdb..tmp_t_acc_usage(id_sess)
				create index idx1_tmp_t_acc_usage on tempdb..tmp_t_acc_usage(id_acc)
		
				declare  c1 cursor fast_forward for select distinct id_view from t_acc_usage 
				where id_usage_interval = @intervalId
					open c1
					fetch next from c1 into @var1
					while (@@fetch_status = 0)
					begin
						select @tab1 = nm_table_name from t_prod_view where id_view=@var1 --and nm_table_name not like ''%temp%''
						--Delete from product view tables
						select @sqlstmt = N''delete pv FROM '' + @dbname + ''..'' + @tab1 + '' pv inner join 
						tempdb..tmp_t_acc_usage tmp on pv.id_sess = tmp.id_sess''
						exec (@sqlstmt)
						if (@@error <> 0)
						begin
							set @result = ''3000015-trash operation failed-->Error in Delete operation''
							rollback tran
							close c1
							deallocate c1
							return
						end
					fetch next from c1 into @var1
					end
					close c1
					deallocate c1
		
				if not exists (select 1 from t_acc_usage where id_usage_interval = @intervalId and id_acc not in
						(select id from #AccountIDsTable))
				begin 
					if object_id(''tempdb..##id_view1'') is not null
					drop table ##id_view1
					select distinct id_view into ##id_view1 from t_acc_usage where id_usage_interval = @intervalId
					select @sqlstmt = N''SELECT id_adj_trx into tempdb..tmp_t_adjustment_transaction FROM '' 
					+ @dbname + ''..t_adjustment_transaction where id_usage_interval='' + cast (@intervalId as varchar(10))
					exec (@sqlstmt)
					create unique clustered index idx_tmp_t_adjustment_transaction on 
					tempdb..tmp_t_adjustment_transaction(id_adj_trx)
					create table #adjustment1(name nvarchar(2000))
					declare c1 cursor fast_forward for select table_name from information_schema.tables where 
					table_name like ''t_aj_%'' and table_name not in (''T_AJ_TEMPLATE_REASON_CODE_MAP'',''t_aj_type_applic_map'')
					open c1
					fetch next from c1 into @var1
					while (@@fetch_status = 0)
					begin
					--Get the name of t_aj tables that have usage in this interval
					set @sqlstmt = N''if exists
							(select 1 from '' + @var1 + '' where id_adjustment in 
							(select id_adj_trx from t_adjustment_transaction where id_usage_interval = '' + cast(@intervalId as varchar(10)) + N'')) 
							insert into #adjustment1 values('''''' + @var1 + '''''')''
					EXEC (@SQLStmt)
					SET @SQLStmt = N''IF EXISTS (SELECT 1 FROM dbo.sysobjects WHERE id = object_id(''''bcpview'''')) DROP view bcpview''
					EXEC (@SQLStmt)
					fetch next from c1 into @var1
					end
					close c1
					deallocate c1
			
					declare  c1 cursor fast_forward for select distinct name from #adjustment1
					open c1
					fetch next from c1 into @var1
					while (@@fetch_status = 0)
					begin
					--Delete from t_aj tables
						select @sqlstmt = N''delete aj FROM '' + @dbname + ''..'' + @var1 +  
								'' aj inner join tempdb..tmp_t_adjustment_transaction tmp
								on aj.id_adjustment = tmp.id_adj_trx''
						exec (@sqlstmt)
						if (@@error <> 0)
						begin
							set @result = ''3000016-trash operation failed-->Error in Delete from t_aj tables''
							rollback tran
							close c1
							deallocate c1
							return
						end
					fetch next from c1 into @var1
					end
					close c1
					deallocate c1
		
					--Delete from t_adjustment_transaction table
					select @sqlstmt = N''delete FROM '' + @dbname + ''..t_adjustment_transaction where id_usage_interval='' + cast (@intervalId as varchar(10))
						exec (@sqlstmt)
					if (@@error <> 0)
					begin
						set @result = ''3000017-Error in Delete from t_adjustment_transaction table''
						rollback tran
						return
					end
		
					--Checking for post bill adjustments that have corresponding usage archived
					create table #t_adjustment_transaction_temp1(id_sess bigint)
					select @sqlstmt =  N''insert into #t_adjustment_transaction_temp1 select id_sess 
								from t_adjustment_transaction where n_adjustmenttype=1 
								and id_sess in (select id_sess from t_acc_usage where id_usage_interval='' + cast(@intervalId as varchar(10)) + '' )''
					execute (@sqlstmt)
					if (@@error <> 0)
					begin
						set @result = ''3000018-archive operation failed-->Error in create adjustment temp table operation''
						rollback tran
						return
					end
					IF ((SELECT count(*) FROM #t_adjustment_transaction_temp1) > 0) 
					begin
						update t_adjustment_transaction set archive_sess=id_sess,id_sess=null
						where id_sess in (select id_sess from #t_adjustment_transaction_temp1)
						if (@@error <> 0)
						begin
							set @result = ''3000019-trash operation failed-->Error in Update adjustment operation''
							rollback tran
							return
						end
					end
					update t_archive set tt_end = dateadd(s,-1,@vartime)
					where id_interval=@intervalId
					and status = ''D''
					and tt_end= @maxtime
					if (@@error <> 0) 
					begin
						set @result = ''3000020-trash operation failed-->error in update t_acc_bucket_map''
						rollback tran
						return
					end
					insert into t_archive 
					select @intervalId,id_view,null,''A'',@vartime,@maxtime from ##id_view1
					union all
					select distinct @intervalId,null,name,''A'',@vartime,@maxtime from #adjustment1
					if (@@error <> 0) 
					begin
						set @result = ''3000021-trash operation failed-->error in insert into t_acc_bucket_map''
						rollback tran
						return
					end
				end
			
					--Delete from t_acc_usage table
					select @sqlstmt = N''delete au FROM '' + @dbname + ''..t_acc_usage au inner join 
					tempdb..tmp_t_acc_usage tmp on au.id_sess = tmp.id_sess''
					exec (@sqlstmt)
					if (@@error <> 0)
					begin
						set @result = ''3000022-trash operation failed-->Error in Delete t_acc_usage operation''
						rollback tran
						return
					end
				
					update t_acc_bucket_map set tt_end = dateadd(s,-1,@vartime)
					where id_usage_interval=@intervalId and id_acc in (select id from #AccountIDsTable) 
					and status = ''D''
					and tt_end= @maxtime
					if (@@error <> 0) 
					begin
						set @result = ''3000023-trash operation failed-->error in update t_acc_bucket_map''
						rollback tran
						return
					end
					insert into t_acc_bucket_map(id_usage_interval,id_acc,bucket,status,tt_start,tt_end)
					select @intervalId,id,bucket,''A'',@vartime,@maxtime from #AccountIDsTable tmp
					inner join t_acc_bucket_map act on tmp.id = act.id_acc
					and act.id_usage_interval = @intervalId
					and act.status = ''D''
					and tt_end = dateadd(s,-1,@vartime)
					if (@@error <> 0) 
					begin
						set @result = ''3000024-trash operation failed-->error in insert into t_acc_bucket_map''
						rollback tran
						return
					end
				
					if (select b_partitioning_enabled from t_usage_server) = ''Y''
					begin
						select @partname = partition_name from t_partition_interval_map map 
						inner join t_partition part on map.id_partition = part.id_partition
						where id_interval = @intervalId
						if exists (select 1 from t_partition part inner join t_partition_interval_map map
						on part.id_partition = map.id_partition and part.partition_name = @partname
						inner join  t_archive_partition back on part.partition_name = back.partition_name
						and back.status = ''D'' and tt_end = @maxtime and
						map.id_interval not in (select id_interval from t_archive where status  <> ''A'' 
						and tt_end = @maxtime))
						begin			
							update t_archive_partition
							set tt_end = dateadd(s,-1,@vartime)
							where partition_name = @partname 
							and tt_end=@maxtime
							and status = ''D''
							if (@@error <> 0)
							begin
								set @result = ''3000025-archive operation failed-->Error in update t_archive_partition table''
								rollback tran
								return
							end
							insert into t_archive_partition values(@partname,''A'',@vartime,@maxtime)
							if (@@error <> 0)
							begin
								set @result = ''3000026-archive operation failed-->Error in insert into t_archive_partition table''
								rollback tran
								return
							end
							update t_partition set b_active = ''N'' where partition_name = @partname
							if (@@error <> 0)
							begin
								set @result = ''3000027-archive operation failed-->Error in update t_partition table''
								rollback tran
								return
							end
						end
					end
				if object_id(''tempdb..tmp_t_acc_usage'') is not null
				drop table tempdb..tmp_t_acc_usage
				if object_id(''tempdb..tmp_t_adjustment_transaction'') is not null
				drop table tempdb..tmp_t_adjustment_transaction	
			end
			set @result = ''0-archive_trash operation successful''
		commit tran
    
    ' 
END
GO
/****** Object:  StoredProcedure [dbo].[archive_delete]    Script Date: 06/02/2008 11:43:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[archive_delete]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
    
Create procedure [dbo].[archive_delete]
			(
			@partition nvarchar(4000)=null,
			@intervalid int=null,
			@result nvarchar(4000) output
			)
		as
/*
		How to run this stored procedure
		declare @result nvarchar(2000)
		exec archive_delete @partition=''N_20040701_20040731'',@result=@result output
		print @result
		or
		declare @result nvarchar(2000)
		exec archive_delete @intervalid=827719717,@result=@result output
		print @result
*/
		set nocount on
		declare @sql1 nvarchar(4000)
		declare @tab1 nvarchar(1000)
		declare @var1 nvarchar(1000)
		declare @vartime datetime
		declare @maxtime datetime
		declare @acc int
		declare	@servername nvarchar(100)
		declare	@dbname nvarchar(100)
		declare @interval int
		declare @partition1 nvarchar(4000)

		select @servername = @@servername
		select @dbname = db_name()
		select @vartime = getdate()
		select @maxtime = dbo.mtmaxdate()

		--Checking the following Business rules

		--Either partition or Interval should be specified
		if ((@partition is not null and @intervalId is not null) or (@partition is null and @intervalId is null))
		begin
			set @result = ''2000001-archive_delete operation failed-->Either Partition or Interval should be specified''
			return
		END
--Get the list of intervals that need to be archived
		if (@partition is not null)
		begin			
			if ((select count(id_interval) from t_partition_interval_map map where id_partition 
			in (select id_partition  from t_partition where partition_name = @partition))<= 0)
			begin
				set @result = ''2000002-archive_delete operation failed-->None of the Intervals in the Partition needs to be archived''
				return
			END
			--Partition should not already by archived
			if exists (select * from t_archive_partition where partition_name = @partition  
					and status =''A'' and tt_end = @maxtime)
			begin
				set @result = ''2000003-archive_delete operation failed-->Partition already archived''
				return
			END
			declare  interval_id cursor fast_forward for select id_interval from t_partition_interval_map map where id_partition 
			= (select id_partition  from t_partition where partition_name = @partition)
		end
		else
		begin
			declare  interval_id cursor fast_forward for select @intervalId
			if (select b_partitioning_enabled from t_usage_server) = ''Y''
			begin
				select @partition1 = partition_name from t_partition part inner join
				t_partition_interval_map map on part.id_partition = map.id_partition
				and map.id_interval = @intervalid
			end
		end
		open interval_id
		fetch next from interval_id into @interval
		while (@@fetch_status = 0)
		begin
		--Interval should not be already archived
			if  exists (select top 1 * from t_archive where id_interval=@interval and status =''A'' and tt_end = @maxtime)
			begin
				set @result = ''2000004-archive operation failed-->Interval is already archived''
				close interval_id
				deallocate interval_id
				return
			end
			--Interval should exist and in export state
			if  exists (select 1 from t_acc_usage where id_usage_interval = @interval
					 and not exists (select 1 from t_archive where id_interval=@interval and status =''E'' and tt_end = @maxtime))
			begin
				set @result = ''2000005-archive operation failed-->Interval is not exported..run the archive_export procedure''
				close interval_id
				deallocate interval_id
				return
			end
		--Interval should not be already Dearchived
			if  exists (select top 1 * from t_archive where id_interval=@interval and status =''D'' and tt_end = @maxtime)
			begin
				set @result = ''2000006-archive operation failed-->Interval is Dearchived..run the trash procedure''
				close interval_id
				deallocate interval_id
				return
			end
		fetch next from interval_id into @interval
		end
		close interval_id


		begin tran
		open interval_id
		fetch next from interval_id into @interval
		while (@@fetch_status = 0)
		begin
			if object_id(''tempdb..#adjustment'') is not null
			drop table #adjustment
			create table #adjustment(name nvarchar(2000))
			declare c2 cursor fast_forward for select table_name from information_schema.tables where 
			table_name like ''t_aj_%'' and table_name not in (''T_AJ_TEMPLATE_REASON_CODE_MAP'',''t_aj_type_applic_map'')
			open c2
			fetch next from c2 into @var1
			while (@@fetch_status = 0)
			begin
			--Get the name of t_aj tables that have usage in this interval
			set @sql1 = N''if exists
					(select 1 from '' + @var1 + '' where id_adjustment in 
					(select id_adj_trx from t_adjustment_transaction where id_usage_interval = '' + cast(@interval as varchar(10)) + N'')) 
					insert into #adjustment values('''''' + @var1 + '''''')''
					EXEC sp_executesql @sql1
			SET @sql1 = N''IF EXISTS (SELECT 1 FROM dbo.sysobjects WHERE id = object_id(''''bcpview'''')) DROP view bcpview''
					EXEC sp_executesql @sql1
			fetch next from c2 into @var1
			end
			close c2
			deallocate c2

			if object_id(''tempdb..tmp_t_adjustment_transaction'') is not null
			drop table tempdb..tmp_t_adjustment_transaction
			select @sql1 = N''SELECT id_adj_trx into tempdb..tmp_t_adjustment_transaction FROM '' + @dbname + ''..t_adjustment_transaction where id_usage_interval='' + cast (@interval as varchar(10)) + N'' order by id_sess''
			exec (@sql1)
			create unique clustered index idx_tmp_t_adjustment_transaction on tempdb..tmp_t_adjustment_transaction(id_adj_trx)
			declare  c1 cursor fast_forward for select distinct name from #adjustment
			open c1
			fetch next from c1 into @var1
			while (@@fetch_status = 0)
			begin
				--Delete from t_aj tables
				select @sql1 = N''delete aj FROM '' + @dbname + ''..'' + @var1 +  '' aj inner join 
				tempdb..tmp_t_adjustment_transaction tmp on aj.id_adjustment = tmp.id_adj_trx''
				exec (@sql1)
				if (@@error <> 0)
				begin
					set @result = ''2000007-archive operation failed-->Error in t_aj tables Delete operation''
					rollback tran
					close c1
					deallocate c1
					close interval_id
					deallocate interval_id
					return
				end
			fetch next from c1 into @var1
			end
			close c1
			deallocate c1

			--Delete from t_adjustment_transaction table
			select @sql1 = N''delete FROM '' + @dbname + ''..t_adjustment_transaction where id_usage_interval='' + cast (@interval as varchar(10))
			exec (@sql1)
			if (@@error <> 0)
			begin
				set @result = ''2000008-Error in Delete from t_adjustment_transaction table''
				rollback tran
				close interval_id
				deallocate interval_id
				return
			end

			--Delete from Unique constraints table
			if (select b_partitioning_enabled from t_usage_server) = ''Y''
			begin
				declare  c3 cursor fast_forward for select nm_table_name from t_unique_cons
				open c3
				fetch next from c3 into @tab1
				while (@@fetch_status = 0)
				begin
					select @sql1 = N''delete FROM '' + @dbname + ''..'' + @tab1 + '' where id_usage_interval='' + cast (@interval as varchar(10))
					exec (@sql1)
					if (@@error <> 0)
					begin
						set @result = ''2000024-Error in Delete from unique constraint table''
						rollback tran
						close c3
						deallocate c3
						close interval_id
						deallocate interval_id
						return
					end
				fetch next from c3 into @tab1
				end
				close c3
				deallocate c3
			end	
	
			--Checking for post bill adjustments that have corresponding usage archived
			if object_id(''tempdb..#t_adjustment_transaction_temp'') is not null
			drop table #t_adjustment_transaction_temp
			create table #t_adjustment_transaction_temp(id_sess bigint)
			select @sql1 =  N''insert into #t_adjustment_transaction_temp select id_sess 
						from t_adjustment_transaction where n_adjustmenttype=1 
						and id_sess in (select id_sess from t_acc_usage where id_usage_interval='' + cast(@interval as varchar(10)) + '' )''
			execute (@sql1)
			if (@@error <> 0)
			begin
				set @result = ''2000009-archive operation failed-->Error in create adjustment temp table operation''
				rollback tran
				close interval_id
				deallocate interval_id
				return
			end
			IF ((SELECT count(*) FROM #t_adjustment_transaction_temp) > 0) 
			begin
				update t_adjustment_transaction set archive_sess=id_sess,id_sess=null
				where id_sess in (select id_sess from #t_adjustment_transaction_temp)
				if (@@error <> 0)
				begin
					set @result = ''2000010-archive operation failed-->Error in Update adjustment operation''
					rollback tran
					close interval_id
					deallocate interval_id
					return
				end
			end
			update t_acc_bucket_map 
			set tt_end = dateadd(s,-1,@vartime)
			where id_usage_interval=@interval 
			and status = ''E'' 
			and tt_end=@maxtime
			if (@@error <> 0)
			begin
				set @result = ''2000011-archive operation failed-->Error in update t_acc_bucket_map table''
				rollback tran
				close interval_id
				deallocate interval_id
				return
			end
			insert into t_acc_bucket_map (id_usage_interval,id_acc,bucket,status,tt_start,tt_end) 
			select @interval,id_acc,bucket,''A'',@vartime,@maxtime from t_acc_bucket_map
			where id_usage_interval=@interval
			and status =''E'' 
			and tt_end=dateadd(s,-1,@vartime)
			if (@@error <> 0)
			begin
				set @result = ''2000012-archive operation failed-->Error in insert into t_acc_bucket_map table''
				rollback tran
				close interval_id
				deallocate interval_id
				return
			end

			update t_archive 
			set tt_end = dateadd(s,-1,@vartime)
			where id_interval=@interval 
			and status=''E'' 
			and tt_end=@maxtime
			if (@@error <> 0)
			begin
				set @result = ''2000013-archive operation failed-->Error in update t_archive table''
				rollback tran
				close interval_id
				deallocate interval_id
				return
			end
			insert into t_archive 
			select id_interval,id_view,adj_name,''A'',@vartime,@maxtime from t_archive
			where id_interval = @interval
			and status =''E'' 
			and tt_end=dateadd(s,-1,@vartime)
			if (@@error <> 0)
			begin
				set @result = ''2000014-archive operation failed-->Error in insert t_archive table''
				rollback tran
				close interval_id
				deallocate interval_id
				return
			end
		fetch next from interval_id into @interval
		end
		close interval_id
		deallocate interval_id

		if (@partition is null)
		begin
			if  ((select count(*) from t_partition_interval_map map where id_partition = (select id_partition
			from t_partition_interval_map where id_interval = @intervalid)) <= 1) and 
			(select b_partitioning_enabled from t_usage_server) = ''Y''
			begin
				select @partition = partition_name from t_partition part inner join t_partition_interval_map map
				on part.id_partition = map.id_partition where map.id_interval = @intervalid
				set @intervalid = null
			end
		end

		if (@partition is not null)
		begin
			if object_id(''tempdb..##id_view'') is not null
			drop table ##id_view
			select @sql1 = '' select distinct id_view into ##id_view from '' + @partition + ''..t_acc_usage''
			exec (@sql1)
				declare  c1 cursor fast_forward for select id_view from ##id_view 
				open c1
				fetch next from c1 into @var1
				while (@@fetch_status = 0)
				begin
					select @tab1 = nm_table_name from t_prod_view where id_view=@var1 --and nm_table_name not like ''%temp%''
					--Delete from product view tables
					select @sql1 = N''truncate table '' + @partition + ''..'' + @tab1
					exec (@sql1)
					if (@@error <> 0)
					begin
						set @result = ''2000015-archive operation failed-->Error in product view Delete operation''
						rollback tran
						close c1
						deallocate c1
						return
					end
				fetch next from c1 into @var1
				end
				close c1
				deallocate c1

			--Delete from t_acc_usage table
			select @sql1 = N''truncate table '' + @partition + ''..t_acc_usage''
			exec (@sql1)
			if (@@error <> 0)
			begin
				set @result = ''2000016-archive operation failed-->Error in Delete t_acc_usage operation''
				rollback tran
				return
			end
		end

		if (@intervalid is not null)
		begin
			if object_id(''tempdb..##id_view'') is not null
			drop table ##id_view
			select @sql1 = '' select distinct id_view into ##id_view from t_acc_usage  where id_usage_interval = '' + cast(@intervalid as nvarchar(100))
			exec (@sql1)
			declare  c1 cursor fast_forward for select id_view from ##id_view 
			open c1
			fetch next from c1 into @var1
			while (@@fetch_status = 0)
			begin
				select @tab1 = nm_table_name from t_prod_view where id_view=@var1 --and nm_table_name not like ''%temp%''
				--Delete from product view tables
				select @sql1 = N''delete pv FROM '' + @tab1 + '' pv inner join t_acc_usage tmp on 
				pv.id_sess = tmp.id_sess and pv.id_usage_interval=tmp.id_usage_interval
				and tmp.id_usage_interval = '' + cast(@intervalid as nvarchar(100))
				exec (@sql1)
				if (@@error <> 0)
				begin
					set @result = ''2000017-archive operation failed-->Error in product view Delete operation''
					rollback tran
					close c1
					deallocate c1
					return
				end
			fetch next from c1 into @var1
			end
			close c1
			deallocate c1
			--Delete from t_acc_usage table
			select @sql1 = N''delete au from t_acc_usage au
			where au.id_usage_interval = '' + cast(@intervalid as nvarchar(100))
			exec (@sql1)
			if (@@error <> 0)
			begin
				set @result = ''2000018-archive operation failed-->Error in Delete t_acc_usage operation''
				rollback tran
				return
			end
		end

		if
		( 
		(
			(@partition is not null) 
			or not exists
			(
				select 1
				from t_partition_interval_map map
				left outer join t_archive inte on inte.id_interval = map.id_interval and tt_end = @maxtime 
				where map.id_partition = (select id_partition from t_partition_interval_map where id_interval = @intervalid) and (status is null or status <> ''A'')
			)
		) 
		and 
			(select b_partitioning_enabled from t_usage_server) = ''Y''
		)
		begin
			update t_archive_partition
			set tt_end = dateadd(s,-1,@vartime)
			where partition_name = isnull(@partition,@partition1)
			and tt_end= @maxtime
			and status = ''E''
			if (@@error <> 0)
			begin
				set @result = ''2000021-archive operation failed-->Error in update t_archive_partition table''
				rollback tran
				return
			end
			insert into t_archive_partition values(isnull(@partition,@partition1),''A'',@vartime,@maxtime)	
			if (@@error <> 0)
			begin
				set @result = ''2000022-archive operation failed-->Error in insert into t_archive_partition table''
				rollback tran
				return
			end
			update t_partition set b_active = ''N'' where partition_name = isnull(@partition,@partition1)
			if (@@error <> 0)
			begin
				set @result = ''2000023-archive operation failed-->Error in update t_partition table''
				rollback tran
				return
			end
		end

		if object_id(''tempdb..tmp_t_adjustment_transaction'') is not null
		drop table tempdb..tmp_t_adjustment_transaction
		if object_id(''tempdb..##id_view'') is not null
		drop table ##id_view
			
		set @result = ''0-archive_delete operation successful''
		commit tran
		
    ' 
END
GO
/****** Object:  StoredProcedure [dbo].[archive_queue]    Script Date: 06/02/2008 11:43:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[archive_queue]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
    
create  procedure [dbo].[archive_queue]
   (
   @update_stats char(1) = ''N'',  
   @sampling_ratio varchar(3) = ''30'',  
   @result nvarchar(4000) output  
   )  
  as  
  --How to run this stored procedure  
--declare @result nvarchar(2000)  
--exec archive_queue @result=@result output  
--print @result 
--OR If we want to update statistics also
--declare @result nvarchar(2000)
--exec archive_queue ''Y'',30,@result=@result output
--print @result
 
  set nocount on  
  declare @sql1 nvarchar(4000)  
  declare @tab1 nvarchar(1000)  
  declare @var1 nvarchar(1000)  
  declare @vartime datetime  
  declare @maxtime datetime  
  declare @count nvarchar(10)  
  declare @NU_varStatPercentChar varchar(255)
  declare @id char(1)
  
--create table t_archive_queue (id_svc int, status varchar(1), tt_start datetime, tt_end datetime)  
  select @vartime = getdate()  
  select @maxtime = dbo.mtmaxdate()  
  
  if object_id(''tempdb..##tmp_t_session_state'') is not null drop table ##tmp_t_session_state  
  if (@@error <> 0)   
  begin  
	   set @result = ''7000001--archive_queues operation failed-->error in dropping ##tmp_t_session_state''  
	   return  
  end  
  
  if object_id(''tempdb..#tmp2_t_session_state'') is not null drop table #tmp2_t_session_state  
  if (@@error <> 0)   
  begin  
	   set @result = ''7000001a--archive_queues operation failed-->error in dropping #tmp2_t_session_state''  
	   return  
  end    
  begin tran
--Lock all the session tables
  declare  c1 cursor fast_forward for   
  select nm_table_name from t_service_def_log
  open c1  
  fetch next from c1 into @tab1  
  while (@@fetch_status = 0)  
  begin  
	   set @sql1 = ''select 1 from '' + @tab1 + '' with(tablockx) where 0=1''
	   exec (@sql1)
  fetch next from c1 into @tab1  
  end  
  close c1  
  deallocate c1  

   set @sql1 = ''select 1 from t_message with(tablockx) where 0=1''
   exec (@sql1)
   set @sql1 = ''select 1 from t_session_set with(tablockx) where 0=1''
   exec (@sql1)
   set @sql1 = ''select 1 from t_session with(tablockx) where 0=1''
   exec (@sql1)
   set @sql1 = ''select 1 from t_session_state with(tablockx) where 0=1''
   exec (@sql1)

  create table ##tmp_t_session_state(id_sess varbinary(16))  
  create clustered index idx_tmp_t_session_state on ##tmp_t_session_state(id_sess)  
  insert into ##tmp_t_session_state   
  select sess.id_source_sess  
  from t_session sess where not exists (select 1 from t_session_state state where  
  state.id_sess = sess.id_source_sess)  
  union all  
  select id_sess from t_session_state state where tx_state in (''F'',''R'')  
  and state.dt_end = @maxtime  
  if (@@error <> 0)  
  begin
	set @result = ''7000002-archive_queues operation failed-->Error in creating ##tmp_t_session_state''
	rollback tran  
	return  
  end  

  if exists (select 1 from t_prod_view where b_can_resubmit_from = ''N''  
  and nm_table_name not like ''t_acc_usage'')  
  begin
	   if (select b_partitioning_enabled from t_usage_server) = ''N''  
	   begin  
		    insert into ##tmp_t_session_state   
		    select state.id_sess  
		    from t_acc_usage au inner join   
		    t_session_state state  
		    on au.tx_uid = state.id_sess  
		    inner join t_prod_view prod   
		    on au.id_view = prod.id_view and prod.b_can_resubmit_from=''N''  
		    where state.dt_end = @maxtime
		    and au.id_usage_interval in  
		    (select distinct id_usage_interval from t_acc_usage_interval  
		    where tx_status <> ''H''  
		    )
		    if (@@error <> 0)  
		    begin
						set @result = ''7000003-archive_queues operation failed-->Error in creating ##tmp_t_session_state''  
		        rollback tran  
						return  
		    end  
	   end  
	   else  
	   begin  
		    insert into ##tmp_t_session_state   
		    select state.id_sess  
		    from t_session_state state  
		    inner join t_uk_acc_usage_tx_uid uk_uid  
		    on state.id_sess = uk_uid.tx_uid  
		    inner join t_acc_usage au  
		    on au.id_sess = uk_uid.id_sess  
		    inner join t_prod_view prod   
		    on au.id_view = prod.id_view and prod.b_can_resubmit_from=''N''  
		    where state.dt_end = @maxtime
		    and au.id_usage_interval in  
		    (select distinct id_usage_interval from t_acc_usage_interval  
		    where tx_status <> ''H''  
		    )
		    if (@@error <> 0)  
		    begin  
			    set @result = ''7000004-archive_queues operation failed-->Error in creating ##tmp_t_session_state''  
			    rollback tran  
			    return  
		   end  
	   end  
  end  
    
  declare  c1 cursor fast_forward for   
  select nm_table_name from t_service_def_log  
  open c1  
  fetch next from c1 into @tab1  
  while (@@fetch_status = 0)  
  begin
	if object_id(''tempdb..##svc'') is not null
	drop table ##svc
	if (@@error <> 0)   
	begin  
	    set @result = ''7000005--archive_queues operation failed-->error in dropping ##svc table''  
	    rollback tran  
	    close c1  
	    deallocate c1  
	    return  
	end  
	select @sql1 = N''select * into ##svc from '' + @tab1 + '' where id_source_sess  
   	in (select id_sess from ##tmp_t_session_state)''  
   	exec (@sql1)  
   	if (@@error <> 0)  
   	begin  
    		set @result = ''7000006-archive_queues operation failed-->Error in t_svc Delete operation''  
    		rollback tran  
    		close c1  
    		deallocate c1  
    		return  
   	end  
   	exec (''truncate table '' + @tab1)  
   	if (@@error <> 0)  
   	begin  
	    set @result = ''7000007-archive_queues operation failed-->Error in t_svc Delete operation''  
	    rollback tran  
	    close c1  
	    deallocate c1  
	    return  
   	end  
	select @sql1 = N''insert into '' + @tab1 + '' select * from ##svc''  
	exec (@sql1)  
	if (@@error <> 0)  
	begin  
	    set @result = ''7000008-archive_queues operation failed-->Error in t_svc Delete operation''  
	    rollback tran  
	    close c1  
	    deallocate c1  
	    return  
	end  
   	--Delete from t_svc tables  
   	insert into t_archive_queue (id_svc,status,tt_start,tt_end)  
   	select @tab1,''A'',@vartime,@maxtime  
   	if (@@error <> 0)  
  	begin  
	    set @result = ''7000009-archive_queues operation failed-->Error in insert t_archive table''  
	    rollback tran  
	    close c1  
	    deallocate c1  
	    return  
   	end  
  fetch next from c1 into @tab1  
  end  
  close c1  
  deallocate c1  
  
  --Delete from t_session and t_session_state table  
  if object_id(''tempdb..#tmp_t_session'') is not null drop table #tmp_t_session  
  select * into #tmp_t_session from t_session where id_source_sess  
  in (select id_sess from ##tmp_t_session_state)   
  if (@@error <> 0)  
  begin  
	   set @result = ''7000010-archive_queues operation failed-->Error in insert into tmp_t_session''  
	   rollback tran  
	   return  
  end  
  truncate table t_session  
  if (@@error <> 0)  
  begin  
	   set @result = ''7000011-archive_queues operation failed-->Error in Delete from t_session''  
	   rollback tran  
	   return  
  end  
  insert into t_session select * from #tmp_t_session  
  if (@@error <> 0)  
  begin  
	   set @result = ''7000012-archive_queues operation failed-->Error in insert into t_session''  
	   rollback tran  
	   return  
  end  
  if object_id(''tempdb..#tmp_t_session_set'') is not null drop table #tmp_t_session_set  
  select * into #tmp_t_session_set from t_session_set where id_ss in  
  (select id_ss from t_session)  
  if (@@error <> 0)  
  begin  
	   set @result = ''7000013-archive_queues operation failed-->Error in insert into tmp_t_session_set''  
	   rollback tran  
	   return  
  end  
  truncate table t_session_set  
  if (@@error <> 0)  
  begin  
	   set @result = ''7000014-archive_queues operation failed-->Error in Delete from t_session_set''  
	   rollback tran  
	   return  
  end  
  insert into t_session_set select * from #tmp_t_session_set  
  if (@@error <> 0)  
  begin  
	   set @result = ''7000015-archive_queues operation failed-->Error in insert into t_session_set''  
	   rollback tran  
	   return  
  end  
  if object_id(''tempdb..#tmp_t_message'') is not null drop table #tmp_t_message  
  select * into #tmp_t_message from t_message where id_message in  
  (select id_message from t_session_set)  
  if (@@error <> 0)  
  begin  
	   set @result = ''7000016-archive_queues operation failed-->Error in insert into tmp_t_message''  
	   rollback tran  
	   return  
  end  
  truncate table t_message  
  if (@@error <> 0)  
  begin  
	   set @result = ''7000017-archive_queues operation failed-->Error in Delete from t_message''  
	   rollback tran  
	   return  
  end  
  insert into t_message select * from #tmp_t_message  
  if (@@error <> 0)  
  begin  
	   set @result = ''7000018-archive_queues operation failed-->Error in insert into t_message''  
	   rollback tran  
	   return  
  end  
  select state.* into #tmp2_t_session_state from t_session_state state  
  where state.id_sess in  
  (select id_sess from ##tmp_t_session_state)  
  if (@@error <> 0)  
  begin  
	   set @result = ''7000019-archive_queues operation failed-->Error in creating #tmp2_t_session_state''  
	   return  
  end  
  
  truncate table t_session_state  
  if (@@error <> 0)  
  begin  
	   set @result = ''7000020-archive_queues operation failed-->Error in Delete from t_session_state table''  
	   rollback tran  
	   return  
  end  
  insert into t_session_state select * from #tmp2_t_session_state  
  if (@@error <> 0)  
  begin  
	   set @result = ''7000021-archive_queues operation failed-->Error in insert into t_session_state table''  
	   rollback tran  
	   return  
  end  
  
  if object_id(''tempdb..##svc'') is not null drop table ##svc  
  if object_id(''tempdb..##tmp_t_session_state'') is not null drop table ##tmp_t_session_state  
  if object_id(''tempdb..#tmp2_t_session_state'') is not null drop table #tmp2_t_session_state  
  if object_id(''tempdb..#tmp_t_session_set'') is not null drop table #tmp_t_session_set  
  if object_id(''tempdb..#tmp_t_message'') is not null drop table #tmp_t_message  
  if object_id(''tempdb..#tmp_t_session'') is not null drop table #tmp_t_session  
  commit tran  

  if (@update_stats = ''Y'')  
  begin
	declare  c1 cursor fast_forward for select nm_table_name from t_service_def_log
	open c1  
	fetch next from c1 into @tab1  
	while (@@fetch_status = 0)  
	begin
	   IF @sampling_ratio < 5 SET @NU_varStatPercentChar = '' WITH SAMPLE 5 PERCENT ''  
	   ELSE IF @sampling_ratio >= 100 SET @NU_varStatPercentChar = '' WITH FULLSCAN ''  
	   ELSE SET @NU_varStatPercentChar = '' WITH SAMPLE '' + CAST(@sampling_ratio AS varchar(20)) + '' PERCENT ''  
	   SET @sql1 = ''UPDATE STATISTICS '' + @tab1 + @NU_varStatPercentChar   
	   EXECUTE (@sql1)  
	   if (@@error <> 0)  
	   begin  
		     set @result = ''7000022-archive_queues operation failed-->Error in update stats''  
		     rollback tran  
		     close c1  
		     deallocate c1  
		     return  
	   end  
	fetch next from c1 into @tab1  
	end  
	close c1  
	deallocate c1
	SET @sql1 = ''UPDATE STATISTICS t_session '' + @NU_varStatPercentChar   
	EXECUTE (@sql1)  
	SET @sql1 = ''UPDATE STATISTICS t_session_set '' + @NU_varStatPercentChar   
	EXECUTE (@sql1)  
	SET @sql1 = ''UPDATE STATISTICS t_session_state '' + @NU_varStatPercentChar   
	EXECUTE (@sql1)  
	SET @sql1 = ''UPDATE STATISTICS t_message'' + @NU_varStatPercentChar   
	EXECUTE (@sql1)  
  end  
  
  set @result = ''0-archive_queue operation successful''  
    
    ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreateAdjustmentTable]    Script Date: 06/02/2008 11:43:23 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateAdjustmentTable]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
		
      create  procedure [dbo].[CreateAdjustmentTable](@p_id_pi_type INTEGER,  @p_status INTEGER OUTPUT, @p_err_msg VARCHAR(512) OUTPUT)
as
	DECLARE @CursorVar CURSOR
	declare @columncursor CURSOR
	declare @count integer
	declare @i integer
	declare @pvname varchar(256)
	declare @adjname varchar(256)
	declare @ddlstr as varchar(8000)
	declare @idpi as int
	declare @innercount as int
	declare @j as int
	declare @columnname as varchar(256)
	declare @datatype as varchar(256)
	declare @pv VARCHAR(255)
  declare @newpiname VARCHAR(255)
  declare @piname VARCHAR(255)

  set @p_status = 0
  select TOP 1 @pv = pi1.nm_productview, @piname = bp.nm_name, @newpiname = bpnew.nm_name from t_pi pi1
  inner join t_pi pi2 on pi1.nm_productview = pi2.nm_productview
  inner join t_base_props bp on bp.id_prop = pi2.id_pi
  inner join t_base_props bpnew on bpnew.id_prop = pi1.id_pi
  where pi1.id_pi = @p_id_pi_type AND pi2.id_pi <> pi1.id_pi
  if LEN(@pv) > 0
  BEGIN
    SELECT @p_status = 1
    SELECT @p_err_msg = ''Product View '''''' + @pv + '''''' is shared between '''''' +  @newpiname + '''''' and '''''' + @piname + '''''''';
    SELECT @p_err_msg = @p_err_msg + ''. If '''''' + @newpiname + '''''' is adjustable, make sure that charges in these priceable item types are the same.''; 
  END

	SET @CursorVar = CURSOR FORWARD_ONLY STATIC
	FOR
	select distinct(pv.nm_table_name),
	''t_aj_'' + substring(pv.nm_table_name,6,1000),
	t_pi.id_pi
	from 
	t_pi
	-- all of the product views references by priceable items
	INNER JOIN t_prod_view pv on (pv.nm_name) = (t_pi.nm_productview)
	-- BP changed next join to ''left outer'' from ''inner''
	-- in order to support Amount adjustments for PIs that don''t
	-- have any charges
	LEFT OUTER JOIN t_charge on t_charge.id_pi = t_pi.id_pi
  WHERE t_pi.id_pi = @p_id_pi_type
	select @i = 0
	OPEN @CursorVar
	Set @count = @@cursor_rows
	while(@i < @count) begin
		select @i = @i + 1
		FETCH NEXT FROM @CursorVar into @pvname,@adjname,@idpi
	-- create the table
		set @columncursor = CURSOR FORWARD_ONLY STATIC
		for
		select prop.nm_column_name,prop.nm_data_type from t_charge 
			INNER JOIN t_prod_view_prop prop on prop.id_prod_view_prop = t_charge.id_amt_prop
			where id_pi = @idpi
		OPEN @columncursor
		set @innercount = @@cursor_rows
		select @j = 0
    select @ddlstr =  (''if NOT exists (select * from dbo.sysobjects where id = object_id('''''' + @adjname + '''''') and OBJECTPROPERTY(id, N''''IsUserTable'''') = 1) '')
    select @ddlstr = @ddlstr + ''create table '' + @adjname + '' (id_adjustment int''
		while (@j < @innercount) begin
			FETCH NEXT FROM @columncursor into @columnname,@datatype
			select @ddlstr = (@ddlstr + '', c_aj_'' + right(@columnname,len(@columnname)-2) + '' '' + @datatype)
			select @j = @j+1
		end
		select @ddlstr = (@ddlstr + '')'')
		exec (@ddlstr)
		CLOSE @columncursor
		DEALLOCATE @columncursor
	end
	CLOSE @CursorVar
	DEALLOCATE @CursorVar
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[DropAndCreateAdjustmentTable]    Script Date: 06/02/2008 11:43:39 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DropAndCreateAdjustmentTable]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
		
      create  procedure [dbo].[DropAndCreateAdjustmentTable](@p_id_pi_type INTEGER,  @p_status INTEGER OUTPUT, @p_err_msg VARCHAR(512) OUTPUT)
  as
	DECLARE @CursorVar CURSOR
	declare @columncursor CURSOR
	declare @count integer
	declare @i integer
	declare @pvname varchar(256)
	declare @adjname varchar(256)
	declare @ddlstr as varchar(8000)
	declare @idpi as int
	declare @innercount as int
	declare @j as int
  declare @columnname as varchar(256)
	declare @datatype as varchar(256)
	
	declare @pv VARCHAR(255)
  declare @newpiname VARCHAR(255)
  declare @piname VARCHAR(255)

  set @p_status = 0
  select TOP 1 @pv = pi1.nm_productview, @piname = bp.nm_name, @newpiname = bpnew.nm_name from t_pi pi1
  inner join t_pi pi2 on pi1.nm_productview = pi2.nm_productview
  inner join t_base_props bp on bp.id_prop = pi2.id_pi
  inner join t_base_props bpnew on bpnew.id_prop = pi1.id_pi
  where pi1.id_pi = @p_id_pi_type AND pi2.id_pi <> pi1.id_pi
  if LEN(@pv) > 0
  BEGIN
    SELECT @p_status = 1
    SELECT @p_err_msg = ''Product View '''''' + @pv + '''''' is shared between '''''' +  @newpiname + '''''' and '''''' + @piname + '''''''';
    SELECT @p_err_msg = @p_err_msg + ''. If '''''' + @newpiname + '''''' is adjustable, adjustment table will not be re-created.''; 
    return;
  END
	SET @CursorVar = CURSOR FORWARD_ONLY STATIC
	FOR
	select distinct(pv.nm_table_name),
	''t_aj_'' + substring(pv.nm_table_name,6,1000),
	t_pi.id_pi
	from 
	t_pi
	-- all of the product views references by priceable items
	INNER JOIN t_prod_view pv on (pv.nm_name) = (t_pi.nm_productview)
	-- BP changed next join to ''left outer'' from ''inner''
	-- in order to support Amount adjustments for PIs that don''t
	-- have any charges
	LEFT OUTER JOIN t_charge on t_charge.id_pi = t_pi.id_pi
  WHERE t_pi.id_pi = @p_id_pi_type
	select @i = 0
	OPEN @CursorVar
	Set @count = @@cursor_rows
	while(@i < @count) begin
		select @i = @i + 1
		FETCH NEXT FROM @CursorVar into @pvname,@adjname,@idpi
		-- drop the table if it exists
		select @ddlstr =  (''if exists (select * from dbo.sysobjects where id = object_id('''''' + @adjname + '''''') and OBJECTPROPERTY(id, N''''IsUserTable'''') = 1) drop table '' + @adjname)
		exec (@ddlstr)
		-- create the table
		set @columncursor = CURSOR FORWARD_ONLY STATIC
		for
		select prop.nm_column_name,prop.nm_data_type from t_charge 
		INNER JOIN t_prod_view_prop prop on prop.id_prod_view_prop = t_charge.id_amt_prop
			where id_pi = @idpi
		OPEN @columncursor
		set @innercount = @@cursor_rows
		select @j = 0,@ddlstr = ''create table '' + @adjname + '' (id_adjustment int''
		while (@j < @innercount) begin
			FETCH NEXT FROM @columncursor into @columnname,@datatype
			select @ddlstr = (@ddlstr + '', c_aj_'' + right(@columnname,len(@columnname)-2) + '' '' + @datatype)
			select @j = @j+1
		end
		select @ddlstr = (@ddlstr + '')'')
		exec (@ddlstr)
		CLOSE @columncursor
		DEALLOCATE @columncursor
	end
	CLOSE @CursorVar
	DEALLOCATE @CursorVar
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[DropAdjustmentTables]    Script Date: 06/02/2008 11:43:39 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DropAdjustmentTables]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			  
      create proc [dbo].[DropAdjustmentTables]
      as
	      DECLARE @CursorVar CURSOR
	      declare @columncursor CURSOR
	      declare @count integer
	      declare @i integer
	      declare @pvname varchar(256)
	      declare @adjname varchar(256)
	      declare @ddlstr as varchar(8000)
	      declare @idpi as int
	      declare @innercount as int
	      declare @j as int
	      declare @columnname as varchar(256)
	      declare @datatype as varchar(256)
	      SET @CursorVar = CURSOR FORWARD_ONLY STATIC
	      FOR
	      select distinct(pv.nm_table_name),
	      ''t_aj_'' + substring(pv.nm_table_name,6,1000),
	      t_pi.id_pi
	      from 
	      t_pi
	      -- all of the product views references by priceable items
	      INNER JOIN t_prod_view pv on (pv.nm_name) = (t_pi.nm_productview)
	      INNER JOIN t_charge on t_charge.id_pi = t_pi.id_pi
	      select @i = 0
	      OPEN @CursorVar
	      Set @count = @@cursor_rows
	      while(@i < @count) begin
		      select @i = @i + 1
		      FETCH NEXT FROM @CursorVar into @pvname,@adjname,@idpi
		      -- drop the table if it exists
		      select @ddlstr =  (''if exists (select * from dbo.sysobjects where id = object_id('''''' + @adjname + '''''') and OBJECTPROPERTY(id, N''''IsUserTable'''') = 1) drop table '' + @adjname)
		      exec (@ddlstr)
	      end
	      CLOSE @CursorVar
	      DEALLOCATE @CursorVar
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[GenerateAdjustmentTables]    Script Date: 06/02/2008 11:43:41 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GenerateAdjustmentTables]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
		
create procedure [dbo].[GenerateAdjustmentTables]
as
	DECLARE @CursorVar CURSOR
	declare @columncursor CURSOR
	declare @count integer
	declare @i integer
	declare @pvname varchar(256)
	declare @adjname varchar(256)
	declare @ddlstr as varchar(8000)
	declare @idpi as int
	declare @innercount as int
	declare @j as int
	declare @columnname as varchar(256)
	declare @datatype as varchar(256)
	SET @CursorVar = CURSOR FORWARD_ONLY STATIC
	FOR
	select distinct(pv.nm_table_name),
	''t_aj_'' + substring(pv.nm_table_name,6,1000),
	t_pi.id_pi
	from 
	t_pi
	-- all of the product views references by priceable items
	INNER JOIN t_prod_view pv on (pv.nm_name) = (t_pi.nm_productview)
	-- BP changed next join to ''left outer'' from ''inner''
	-- in order to support Amount adjustments for PIs that don''t
	-- have any charges
	
	LEFT OUTER JOIN t_charge on t_charge.id_pi = t_pi.id_pi
	select @i = 0
	OPEN @CursorVar
	Set @count = @@cursor_rows
	while(@i < @count) begin
		select @i = @i + 1
		FETCH NEXT FROM @CursorVar into @pvname,@adjname,@idpi
		-- drop the table if it exists
		select @ddlstr =  (''if exists (select * from dbo.sysobjects where id = object_id('''''' + @adjname + '''''') and OBJECTPROPERTY(id, N''''IsUserTable'''') = 1) drop table '' + @adjname)
		exec (@ddlstr)
		-- create the table
		set @columncursor = CURSOR FORWARD_ONLY STATIC
		for
		select prop.nm_column_name,prop.nm_data_type from t_charge 
			INNER JOIN t_prod_view_prop prop on prop.id_prod_view_prop = t_charge.id_amt_prop
			where id_pi = @idpi
		OPEN @columncursor
		set @innercount = @@cursor_rows
		select @j = 0,@ddlstr = ''create table '' + @adjname + '' (id_adjustment int''
		while (@j < @innercount) begin
			FETCH NEXT FROM @columncursor into @columnname,@datatype
			select @ddlstr = (@ddlstr + '', c_aj_'' + right(@columnname,len(@columnname)-2) + '' '' + @datatype)
			select @j = @j+1
		end
		select @ddlstr = (@ddlstr + '')'')
		exec (@ddlstr)
		CLOSE @columncursor
		DEALLOCATE @columncursor
	end
	CLOSE @CursorVar
	DEALLOCATE @CursorVar
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[AddUniqueKeyMetadata]    Script Date: 06/02/2008 11:43:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddUniqueKeyMetadata]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      /*
      	AddUniqueKeyMetadata
      
      	Adds a unique key definintion to the metadata tables.
      	An alternative to InsertProductViewUniqueKey and 
      	InsertProdcutViewUniqueKeyCol.
      	
      	@tabname - name of a product view
      	@consname - name of the unique key
      	@cols - comma sep list of column names
      
      */
      create proc [dbo].[AddUniqueKeyMetadata](
      	@tabname varchar(200),
      	@consname	varchar(200),
      	@cols varchar(4000)
      	) as
      begin
      
      declare @err int
      -- Env set up
      set nocount on
      
      declare @localtran int
      set @localtran = 0
      if (@@trancount = 0) begin
      	begin tran
      	set @localtran = 1
      end
      
      -- Get product view id
      declare @idpv int
      select @idpv = id_prod_view
      	from t_prod_view
      	where lower(nm_table_name) = lower(@tabname)
      
      if (@idpv is null) begin
      	raiserror(''Product view [%s] does not exist.'', 16, 1, @tabname)
      	if (@localtran = 1) rollback
      	return 1
      end
      
      -- Insert the unique key name
      declare @iduk int
      insert into t_unique_cons (id_prod_view, constraint_name, nm_table_name)
      	values (@idpv, @consname, ''t_uk_'' + @consname)
      
      set @err = @@error
      set @iduk = @@identity
      if (@err <> 0) begin
      	raiserror(''Can''''t add key [%s] to table [%s]'', 16, 1, 
      		@consname, @tabname)
      	if (@localtran = 1) rollback
      	return 1
      end
      
      -- Insert the columns
      declare @propid int
      declare @col varchar(200)
      declare @pos int
      set @pos = 0
      
      -- Process the csv of column names
      -- Remove spaces and tabs; append eos
      set @cols = replace(@cols, char(9), '''')
      set @cols = replace(@cols, '' '', '''') + '',''
      
      while (len(@cols) > 0) begin
      	
      	-- Pop a column off the csv
      	set @col = left(@cols, charindex('','', @cols)-1)
      	set @cols = right(@cols, len(@cols) - charindex('','', @cols))
      
      	-- Ignore empty columns
      	if (@col = '''')
      		continue
      
      	set @pos = @pos + 1
      	
      	-- Get property id of column
      	select @propid = id_prod_view_prop
      		from t_prod_view_prop
      		where id_prod_view = @idpv
      		 and lower(nm_column_name) = lower(@col)
      
      	if (@propid is null) begin
      		if (@localtran = 1) rollback
      		raiserror(''Product view [%s] has no column named [%s]'', 16, 1, 
      			@tabname, @col)
      		return 1
      	end
      
      	-- Insert new column
      	insert t_unique_cons_columns
      		values (@iduk, @propid, @pos)
      
      	set @err = @@error
      	if (@err <> 0) begin
      		raiserror(''Can''''t add column [%s] to key [%s]'', 16, 1, 
      			@col, @consname)
      		if (@localtran = 1) rollback
      		return 1
      	end
      	
      end	-- csv process loop
      
      if (@localtran = 1)
      	commit
      
      end --proc
 	' 
END
GO
/****** Object:  StoredProcedure [dbo].[InsertProductView]    Script Date: 06/02/2008 11:43:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertProductView]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			create proc [dbo].[InsertProductView]
			@a_id_view int,
			@a_nm_name nvarchar(255),
			@a_dt_modified datetime,
			@a_nm_table_name nvarchar(255),
			@a_b_can_resubmit_from char(1),
			@a_id_prod_view int OUTPUT
			as
      insert into t_prod_view
      (
			id_view,
			dt_modified,
			nm_name,
			nm_table_name,
			b_can_resubmit_from
      )
      values
      (
			@a_id_view,
			@a_dt_modified,
			@a_nm_name,
			@a_nm_table_name,
			@a_b_can_resubmit_from
      )
			select @a_id_prod_view =@@identity
	' 
END
GO
/****** Object:  StoredProcedure [dbo].[PopFirstMessage]    Script Date: 06/02/2008 11:44:06 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[PopFirstMessage]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
create  procedure [dbo].[PopFirstMessage]
  @pipelineID int,
  @systemTime datetime,
  @messageID int OUTPUT
as
begin

set nocount on
begin transaction

select top 1 @messageID = id_message from
t_message m with(readpast, updlock)
where
m.dt_assigned is null
and 
not exists (
	select * from t_session_set ss
	where
	ss.id_message=m.id_message
	and
	ss.id_svc not in (select ps.id_svc from t_pipeline_service ps 
                    inner join t_pipeline p on ps.id_pipeline=p.id_pipeline
                    where 
                    p.id_pipeline=@pipelineID 
                    and p.b_paused = ''0''
                    and tt_end=dbo.MTMaxDate())
)
order by id_message asc

if @messageID is not null
begin
	update t_message with(ROWLOCK) set dt_assigned = @systemTime, id_pipeline = @pipelineID where id_message = @messageID

        set nocount off
	 select ss.id_message, ss.id_svc,
	 ss.session_count, m.id_feedback
   from t_session_set ss
	 inner join t_message m on ss.id_message=m.id_message
	 where ss.id_message = @messageID

end
else
begin
-- next line is a hack for now: don''t know how to
-- handle conditional rowsets
select -1 as id_message	
end
commit transaction
set nocount off
end
			' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[MessageQueueLength]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MessageQueueLength]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
create function [dbo].[MessageQueueLength]()
returns int
as
begin
  declare @queueLength int
  SELECT @queueLength = count(*) from t_message with (READPAST) where dt_assigned is null
  return @queueLength
end
			' 
END
GO
/****** Object:  StoredProcedure [dbo].[resubmit]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[resubmit]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
    
Create Procedure [dbo].[resubmit] @rerun_table_name nvarchar(30), @message_size int, @metradate nvarchar(30), 
@context text, @return_code int OUTPUT 
      as
      begin
      declare @sql nvarchar (4000)
      declare @args NVARCHAR(255)
      declare @id_svc int
      declare @curr_sessions int
      declare @maxsize int
      declare @num_parent_sessions int
      declare @num_service_sessions int
      set @maxsize = @message_size
      declare @runningTotal int
      declare @id_ss_start int
      declare @id_schedule_start int
      declare @child_svc int
      declare @id_parent binary(16)
      declare @parent_id_ss_start int
      declare @parent_id_schedule_start int
      declare @svctablename nvarchar(255)
      declare @total_sess int
      declare @id_max_sess int
      declare @bucket int
      declare @child_ss_start int
      declare @diff int
      declare @numParentsInMessage int
      declare @i int
      declare @j int
      SET @return_code = 0
      create table #t_svc_relations (
			      id_svc int primary key,
			      parent_id_svc int)
      create table #aggregate_large(
	      id_sess int identity(1,1) not null PRIMARY KEY,
	      id_parent_source_sess binary(16),
	      sessions_in_compound int)
	    create table #aggregate(
	      id_sess int identity(1,1),
	      id_parent_source_sess binary(16),
	      sessions_in_compound int)           
      set @sql = N''insert into #t_svc_relations (id_svc, parent_id_svc)
		      select distinct id_svc, null from '' + @rerun_table_name +
		      N'' where id_parent_source_sess is null''
      EXEC sp_executesql @sql
      set @sql = N''insert into #t_svc_relations (id_svc, parent_id_svc)
			      select  distinct child.id_svc, parent.id_svc
			      from '' + @rerun_table_name + N'' child
			      inner join '' + @rerun_table_name + N'' parent
			      on child.id_parent_source_sess = parent.id_source_sess''
      EXEC sp_executesql @sql
      select * from #t_svc_relations
      DECLARE tablename_cursor CURSOR FOR
	      select id_svc from #t_svc_relations
	      where parent_id_svc is null
	      OPEN tablename_cursor
	      FETCH NEXT FROM tablename_cursor into @id_svc
      WHILE @@FETCH_STATUS = 0
      BEGIN
        -- Bug Fix: 13270, id_svc can be more than 9999, changing size of varchar from 4 to 6
	      PRINT ''the service considered is: '' + cast(@id_svc as varchar(6))
	      -- Bug Fix: 12614 Check to see if all sessions of this parent service exist in the
	      -- corresponding service def table. If the counts are not same, throw 
	      -- an error.
	      set @svctablename = (select nm_table_name from t_service_def_log slog
				    inner join t_enum_data ed
				    on slog.nm_service_def = ed.nm_enum_data
				    where ed.id_enum_data = @id_svc)	
	      set @sql = N''select @num_parent_sessions = count(*) from '' +
			            @rerun_table_name +
			            N'' rr where rr.id_svc = '' +
			            cast(@id_svc as nvarchar(6)) +
			            N'' and rr.id_parent_source_sess is null''
        select @args = N''@num_parent_sessions INT OUTPUT''
	      exec sp_executesql @sql, @args, @num_parent_sessions OUTPUT
       	set @sql = N''select @num_service_sessions = count(*) from '' +
			              @rerun_table_name +
			              N'' rr inner join '' +
			              @svctablename +
			              N'' svc on rr.id_source_sess = svc.id_source_sess where rr.id_svc = '' +
			             cast(@id_svc as nvarchar(6))
	      select @args = N''@num_service_sessions INT OUTPUT''
	      exec sp_executesql @sql, @args, @num_service_sessions OUTPUT
	      if (@num_service_sessions < @num_parent_sessions)
	      begin
		      set @return_code = -100 --one or more sessions that have been identified for resubmission are missing.
		      GOTO FATALERROR
	      end
	      -- insert into the aggregate table details of compounds for this svc
	      -- if this a parent of a compound 
	      declare @numChildrenSvc int
	      select @numChildrenSvc = count(*)
	      from #t_svc_relations
	      where parent_id_svc = @id_svc
	      if (@numChildrenSvc > 0)
	      BEGIN
	
			    -- you could have some parents with no children at all (CR13174) which
			    -- would be missed in the original inner join. Changing the inner join
			    -- to left outer and adding the case statement fixes that.
			    
		      set @sql = N''insert into #aggregate
			      select  rr_parent.id_source_sess, sum(case when rr_child.id_source_sess is null then 0 else 1 end) + 1
			      from '' + @rerun_table_name + N'' rr_parent
			      left join '' + @rerun_table_name + N'' rr_child
			      on rr_parent.id_source_sess = rr_child.id_parent_source_sess
			      where rr_parent.id_parent_source_sess is null
			      and rr_parent.id_svc = '' + cast(@id_svc as nvarchar(6)) + 
			      N'' and rr_parent.tx_state = ''''B''''
			      group by rr_parent.id_source_sess
			      having count(*) < 1000''
	          EXEC sp_executesql @sql
			      set @sql = N''insert into #aggregate_large
			      select  rr_parent.id_source_sess, count(*) + 1
			      from '' + @rerun_table_name + N'' rr_parent
			      inner join '' + @rerun_table_name + N'' rr_child
			      on rr_parent.id_source_sess = rr_child.id_parent_source_sess
			      where rr_parent.id_parent_source_sess is null
			      and rr_parent.id_svc = '' + cast(@id_svc as nvarchar(6)) + 
			      N'' and rr_parent.tx_state = ''''B''''
			      group by rr_parent.id_source_sess
			      having count(*) >= 1000''	
			      
			      EXEC sp_executesql @sql	      
			      
	      END
	      ELSE
	      begin
 	            
		        set @sql = N''insert into #aggregate
			                    select id_source_sess, 1
			                    from '' + @rerun_table_name + 
			                    N'' where id_svc = '' + cast(@id_svc as nvarchar(6)) +
			                    N'' and tx_state = ''''B''''''
			                    
            EXEC sp_executesql @sql			                    
	      end

	      if ((select MAX(sessions_in_compound) from #aggregate_large) > @maxsize)
	      begin
		      set @return_code = -517996536 --one compound is larger than the entire message size
	      end

	      -- update the t_svc table''s _intervalID (Bug Fix for 12173)
                     set @sql = N''select @j = max(id) from '' + @rerun_table_name 
 	     select @args = N''@j INT OUTPUT''

	     exec sp_executesql @sql, @args, @j OUTPUT
             
	     set @i=1
                     while (@i <= @j)
                     begin
                     set @sql = N''update svc
                       		set svc.c__IntervalId = rr.id_interval
                       		from '' + @rerun_table_name + N'' rr 
                       		inner join '' + @svctablename + N'' svc
                      		on rr.id_source_sess = svc.id_source_sess
                      		inner join t_usage_interval ui
                      		on ui.id_interval = rr.id_interval
                      		inner join t_acc_usage_interval aui
                      		on aui.id_acc = rr.id_payer and
                      		   aui.id_usage_interval = rr.id_interval
                       		where rr.id_interval is not null 
                       		and	aui.tx_status = ''''C''''
                       		and rr.id between '' + cast(@i as nvarchar(10)) + N'' and '' + cast(@i+999999 as nvarchar(10))
                       		
													exec sp_executesql @sql  
	                        set @i = @i + 1000000
                     end

	      if (select count(*) from #aggregate_large) > 0
	      begin

			declare @total_large int
			declare @total_child_session_sets int
			select @total_large = max(id_sess) from #aggregate_large
			select @id_ss_start = id_current from t_current_id with(updlock) where nm_current=''id_dbqueuess''
		        select @id_schedule_start = id_current from t_current_id with(updlock) where nm_current=''id_dbqueuesch''
	             
			--set @parent_id_ss_start = @id_ss_start
			--set @parent_id_schedule_start = @id_schedule_start

			insert into t_session (id_ss, id_source_sess) 
		              select id_sess + @id_ss_start, id_parent_source_sess 
			            from #aggregate_large

			insert into t_session_set (id_ss, id_message, id_svc, session_count, b_root) 
		              select id_sess + @id_ss_start, id_sess + @id_schedule_start, @id_svc, 1, 1
			            from #aggregate_large
    			         
			insert into t_message(id_message, id_route, dt_crt, dt_assigned, 
			        id_listener, id_pipeline, dt_completed, id_feedback, dt_metered, tx_sc_serialized, tx_ip_address) 
			         select  id_message, null, cast(@metradate as datetime), null, null, null, 
			         null, null, cast(@metradate as datetime), @context, ''127.0.0.1''
			         from t_session_set WITH (READCOMMITTED)
			         where id_message > @id_schedule_start 

	                -- create child session sets
			create table #child_session_sets
			(
				id_sess int identity(1, 1),
				id_parent_sess int not null,
				id_svc int not null,
				cnt int
			)
			Alter table #child_session_sets
				add constraint pk_child_session_sets
				PRIMARY KEY (id_parent_sess, id_svc)


			set @sql = N''insert into #child_session_sets (id_parent_sess, id_svc, cnt)
				select prnt.id_sess , rr.id_svc, count(*)
				from '' +	
				@rerun_table_name + N'' rr
				inner join #aggregate_large prnt on prnt.id_parent_source_sess=rr.id_parent_source_sess
				group by prnt.id_sess, rr.id_svc''

			EXEC sp_executesql @sql

			select * from #child_session_sets
			select @total_child_session_sets = max(id_sess) from #child_session_sets

			insert into t_session_set (id_ss, id_message, id_svc, session_count, b_root) 
				select id_sess + @total_large + @id_ss_start, id_parent_sess + @id_schedule_start, id_svc, cnt, 0
				from #child_session_sets

			set @sql = N''insert into t_session (id_ss, id_source_sess) 
				select css.id_sess + '' + cast(@total_large as nvarchar(15)) + N'' + '' + cast(@id_ss_start as nvarchar(15))+
				+ N'' , rr.id_source_sess
				from '' + @rerun_table_name + N'' rr
				inner join #aggregate_large prnt on prnt.id_parent_source_sess=rr.id_parent_source_sess
				inner join #child_session_sets css on css.id_parent_sess=prnt.id_sess and css.id_svc=rr.id_svc''

			EXEC sp_executesql @sql
		       
			update t_current_id 
		            set id_current = id_current + @total_large + @total_child_session_sets + 1
		            where nm_current=''id_dbqueuess''
    		        
		        update t_current_id 
		            set id_current = id_current + @total_large + 1
		            where nm_current=''id_dbqueuesch''	
				
			
	                truncate table #aggregate_large
			drop table #child_session_sets
	              
        end -- if we have compounds with more than 100 children   
        if (select count(*) from #aggregate) > 0
        begin    -- dealing with atomics or with compounds with less than 100 children
          if (@numChildrenSvc > 0)	 -- compounds with children less than 100, 
          begin
                select @total_sess = sum(sessions_in_compound), @id_max_sess = max(id_sess) from #aggregate
		
                if (@total_sess > @maxsize)
                begin
          	      select @numParentsInMessage = @maxsize/AVG(sessions_in_compound) from #aggregate
			            print '' the @numParentsInMessage is: '' + cast(@numParentsInMessage as varchar(4)) 
          	      set @bucket = @id_max_sess/@numParentsInMessage + 1
          	    end  
          	    else
          	      set @bucket = 1    
          	      
          	    select @id_ss_start = id_current from t_current_id with(updlock) 
		                              where nm_current=''id_dbqueuess''
		            select @id_schedule_start = id_current from t_current_id with(updlock) 
		                                    where nm_current=''id_dbqueuesch''
                
		            set @parent_id_ss_start = @id_ss_start
		            set @parent_id_schedule_start = @id_schedule_start
		              		                                    
	              insert into t_session (id_ss, id_source_sess) 
		            select (id_sess%@bucket)+ @id_ss_start, id_parent_source_sess 
			            from #aggregate
	
				        insert into t_session_set(id_ss, id_message, id_svc, session_count, b_root)
			          select id_ss, (id_ss%@bucket) + @id_schedule_start, @id_svc, count(*), 1
			          from t_session WITH (READCOMMITTED)
			          where id_ss >= @id_ss_start and id_ss < @id_ss_start+@bucket
			          group by id_ss
    			        
			          insert into t_message(id_message, id_route, dt_crt, dt_assigned, 
			          id_listener, id_pipeline, dt_completed, id_feedback, dt_metered, tx_sc_serialized, tx_ip_address) 
			          select  id_message, null, cast(@metradate as datetime), null, null, null, 
			          null, null, cast(@metradate as datetime), @context, ''127.0.0.1''
			          from t_session_set WITH (READCOMMITTED)
			          where id_message >= @id_schedule_start and id_message < @id_schedule_start+@bucket
   
                update t_current_id 
		            set id_current = id_current + @bucket
		            where nm_current=''id_dbqueuess''
    		        
		            update t_current_id 
		            set id_current = id_current + @bucket
		            where nm_current=''id_dbqueuesch''	

   				
                -- add sessions for each child type
                DECLARE Children_cursor CURSOR for
		            select id_svc from #t_svc_relations where parent_id_svc = @id_svc
		            OPEN Children_cursor
		            FETCH NEXT FROM Children_cursor into @child_svc
		            WHILE @@FETCH_STATUS = 0
		            BEGIN
			            --PRINT ''dealing with child service: '' + cast (@child_svc as varchar(4))
			            select @id_ss_start = id_current from t_current_id with(updlock) where nm_current=''id_dbqueuess''

			            select @diff = @id_ss_start - @parent_id_ss_start

	            select @child_ss_start = @id_ss_start
					            
			            set @sql = N''insert into t_session (id_ss, id_source_sess)
				            select id_ss + '' + cast(@diff as nvarchar(10)) +  N'' , rr.id_source_sess
				            from '' + @rerun_table_name + N'' rr
				            inner join t_session ss WITH (READCOMMITTED)
				            on ss.id_source_sess = rr.id_parent_source_sess
				            where ss.id_ss >= '' + cast(@parent_id_ss_start as nvarchar(10)) +
				            N'' and ss.id_ss < '' + cast(@id_ss_start as nvarchar(10)) +
				            N'' and rr.id_svc = '' + cast(@child_svc as nvarchar(4))
			            EXEC sp_executesql @sql

                  update t_current_id
                    set id_current = (select max(id_ss) from t_session) + 1
                    where nm_current=''id_dbqueuess''
                    
                  select @id_ss_start = id_current from t_current_id 
                    where nm_current=''id_dbqueuess''

     
			            set @sql = N''insert into t_session_set(id_ss, id_message, id_svc, session_count, b_root)
				            select ss.id_ss , parentset.id_message, '' + cast(@child_svc as nvarchar(4)) + N'', count(*), ''''0''''
				            from t_session ss WITH (READCOMMITTED)
				            inner join '' + @rerun_table_name + N'' rr
				            on ss.id_source_sess = rr.id_source_sess
				            left outer join t_session parent WITH (READCOMMITTED)
				            on parent.id_source_sess = rr.id_parent_source_sess
				            left outer join t_session_set parentset WITH (READCOMMITTED)
				            on parentset.id_ss = parent.id_ss
				            where ss.id_ss >= '' + cast(@child_ss_start as nvarchar(10))
				            + N'' and ss.id_ss < '' + cast(@id_ss_start as nvarchar(10))
					    + N'' and parentset.id_message >= '' + cast(@parent_id_schedule_start as nvarchar(10))
				            + N'' group by ss.id_ss, parentset.id_message''

                  EXEC sp_executesql @sql
	                  
			            FETCH NEXT FROM Children_cursor into @child_svc
		            END
		            CLOSE Children_cursor
		            DEALLOCATE Children_cursor
	              IF OBJECT_ID(''tempdb..#aggregate'') IS NOT NULL 
		            truncate table #aggregate		                                      
            	    
          end
          else -- finally, just the atomics!	  
          begin    
		          select @id_max_sess=max(id_sess) from #aggregate
    		      
			        if (@id_max_sess > @maxsize)
			         begin 
			           if @id_max_sess%@maxsize = 0
			            set @bucket = @id_max_sess/@maxsize
			           else 
			            set @bucket = @id_max_sess/@maxsize + 1
			         end 
			        else set @bucket=1
    			    
		          select @id_ss_start = id_current from t_current_id with(updlock) 
		                                where nm_current=''id_dbqueuess''
		          select @id_schedule_start = id_current from t_current_id with(updlock) 
		                                      where nm_current=''id_dbqueuesch''
		          insert into t_session (id_ss, id_source_sess) 
		              select (id_sess%@bucket)+ @id_ss_start, id_parent_source_sess 
			            from #aggregate
    			        
		          insert into t_session_set(id_ss, id_message, id_svc, session_count, b_root)
			            select id_ss, (id_ss%@bucket) + @id_schedule_start, @id_svc, count(*), 1
			            from t_session  WITH (READCOMMITTED)
			            where id_ss >= @id_ss_start and id_ss < @id_ss_start+@bucket
			            group by id_ss
    			         
			        insert into t_message(id_message, id_route, dt_crt, dt_assigned, 
			            id_listener, id_pipeline, dt_completed, id_feedback, dt_metered, tx_sc_serialized, tx_ip_address) 
			            select  id_message, null, cast(@metradate as datetime), null, null, null, 
			            null, null, cast(@metradate as datetime), @context, ''127.0.0.1''
			            from t_session_set  WITH (READCOMMITTED)
			            where id_message >= @id_schedule_start and id_message < @id_schedule_start+@bucket

		          update t_current_id 
		            set id_current = id_current + @bucket
		            where nm_current=''id_dbqueuess''
    		        
		          update t_current_id 
		            set id_current = id_current + @bucket
		            where nm_current=''id_dbqueuesch''	
    		        
		          IF OBJECT_ID(''tempdb..#aggregate'') IS NOT NULL 
		            truncate table #aggregate
          end
        end
        	              
	      FETCH NEXT FROM tablename_cursor into @id_svc
	      END -- end iterating over all parents services in the t_rerun_session table

	      CLOSE tablename_cursor
	      DEALLOCATE tablename_cursor

	      IF OBJECT_ID(''tempdb..#aggregate'') IS NOT NULL 
		      DROP table #aggregate
		      IF OBJECT_ID(''tempdb..#aggregate_large'') IS NOT NULL 
		      DROP table #aggregate_large
	      IF OBJECT_ID(''tempdb..#t_svc_relations'') IS NOT NULL 
		      DROP table #t_svc_relations

	      --adjust the session state
	      declare @mtmaxdate nvarchar(30) 
	      set @mtmaxdate = convert(nvarchar(30), dbo.MTMaxDate(), 100) 	
	      set @sql = N''update t_session_state
		        set dt_end =  '''''' + @metradate + N''''''
		        from '' + @rerun_table_name + N'' rr
		      inner join t_session_state ss
		      on rr.id_source_sess = ss.id_sess
		      where ss.dt_end = '''''' + @mtmaxdate +N''''''
		      and rr.tx_state = ''''B'''' ''

	      EXEC sp_executesql @sql


	      set @sql = N''INSERT INTO t_session_state (id_sess, dt_start, dt_end, tx_state) 
		        SELECT rr.id_source_sess, '''''' + @metradate + N'''''', '''''' + @mtmaxdate + N'''''', ''''R''''
		        from '' + @rerun_table_name + N'' rr
		        where rr.tx_state = ''''B'''' ''

	      EXEC sp_executesql @sql

	      --mark the records that were submitted to ''R'' in t_failed_transaction
	      set @sql = N''update ft
	                    set State = ''''R'''',
	                    dt_StateLastModifiedTime = '''''' + @metradate +
	                    N'''''' from '' + @rerun_table_name + N'' rr
	                    inner join t_failed_transaction ft
	                    on rr.id_source_sess = ft.tx_failureID
	                    where rr.tx_state = ''''B''''''
	   	 
	   	  EXEC sp_executesql @sql	              

	      return @return_code

      FATALERROR: IF OBJECT_ID(''tempdb..#t_svc_relations'') IS NOT NULL 
		      DROP table #t_svc_relations
	          IF OBJECT_ID(''tempdb..#aggregate'') IS NOT NULL 
		      DROP table #aggregate
		  IF (@return_code = 0)
			SET @return_code = -1
	          return @return_code

      end

       
    ' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdProductViewPropertyFromName]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdProductViewPropertyFromName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'	
			create proc [dbo].[UpdProductViewPropertyFromName]
			@a_id_prod_view int,
			@a_nm_name nvarchar(255),
			@a_nm_data_type nvarchar(255),
			@a_nm_column_name nvarchar(255),
			@a_b_required char(1),
			@a_b_composite_idx char(1),
			@a_b_single_idx char(1),
			@a_b_part_of_key char(1),
			@a_b_exportable char(1),
			@a_b_filterable char(1),
			@a_b_user_visible char(1),
			@a_nm_default_value nvarchar(255),
			@a_n_prop_type int,
			@a_nm_space nvarchar(255),
			@a_nm_enum nvarchar(255),
			@a_b_core char(1)
			as
			
			update t_prod_view_prop 
			set
				nm_data_type=@a_nm_data_type,
				nm_column_name=@a_nm_column_name,
				b_required=@a_b_required,
				b_composite_idx=@a_b_composite_idx,
				b_single_idx=@a_b_single_idx,
				b_part_of_key=@a_b_part_of_key,
				b_exportable=@a_b_exportable,
				b_filterable=@a_b_filterable,
				b_user_visible=@a_b_user_visible,
				nm_default_value=@a_nm_default_value,
				n_prop_type=@a_n_prop_type,
				nm_space=@a_nm_space,
				nm_enum=@a_nm_enum,
				b_core=@a_b_core
			where
				id_prod_view=@a_id_prod_view and
				nm_name=@a_nm_name
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdateProductViewProperty]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateProductViewProperty]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			create proc [dbo].[UpdateProductViewProperty] 
			@a_id_prod_view_prop int,
			@a_id_prod_view int,
			@a_nm_name nvarchar(255),
			@a_nm_data_type nvarchar(255),
			@a_nm_column_name nvarchar(255),
			@a_b_required char(1),
			@a_b_composite_idx char(1),
			@a_b_single_idx char(1),
      @a_b_part_of_key char(1),
      @a_b_exportable char(1),
      @a_b_filterable char(1),
      @a_b_user_visible char(1),
			@a_nm_default_value nvarchar(255),
			@a_n_prop_type int,
			@a_nm_space nvarchar(255),
			@a_nm_enum nvarchar(255),
      @a_b_core char(1)
			as
      update t_prod_view_prop 
			set
			id_prod_view=@a_id_prod_view,
			nm_name=@a_nm_name,
			nm_data_type=@a_nm_data_type,
			nm_column_name=@a_nm_column_name,
			b_required=@a_b_required,
			b_composite_idx=@a_b_composite_idx,
			b_single_idx=@a_b_single_idx,
      b_part_of_key=@a_b_part_of_key,
      b_exportable=@a_b_exportable,
      b_filterable=@a_b_filterable,
      b_user_visible=@a_b_user_visible,
			nm_default_value=@a_nm_default_value,
			n_prop_type=@a_n_prop_type,
			nm_space=@a_nm_space,
			nm_enum=@a_nm_enum,
      b_core=@a_b_core
			where
			id_prod_view_prop=@a_id_prod_view_prop
	' 
END
GO
/****** Object:  StoredProcedure [dbo].[InsertProductViewProperty]    Script Date: 06/02/2008 11:43:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertProductViewProperty]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			create proc [dbo].[InsertProductViewProperty] 
			@a_id_prod_view int,
			@a_nm_name nvarchar(255),
			@a_nm_data_type nvarchar(255),
			@a_nm_column_name nvarchar(255),
			@a_b_required char(1),
			@a_b_composite_idx char(1),
			@a_b_single_idx char(1),
      @a_b_part_of_key char(1),
      @a_b_exportable char(1),
      @a_b_filterable char(1),
      @a_b_user_visible char(1),
			@a_nm_default_value nvarchar(255),
			@a_n_prop_type int,
			@a_nm_space nvarchar(255),
			@a_nm_enum nvarchar(255),
      @a_b_core char(1),
			@a_id_prod_view_prop int OUTPUT
			as
      insert into t_prod_view_prop 
      (
			id_prod_view,
			nm_name,
			nm_data_type,
			nm_column_name,
			b_required,
			b_composite_idx,
			b_single_idx,
      b_part_of_key,
      b_exportable,
      b_filterable,
      b_user_visible,
			nm_default_value,
			n_prop_type,
			nm_space,
			nm_enum,
      b_core
      )
      values
      (
			@a_id_prod_view,
			@a_nm_name,
			@a_nm_data_type,
			@a_nm_column_name,
			@a_b_required,
			@a_b_composite_idx,
			@a_b_single_idx,
      @a_b_part_of_key,
      @a_b_exportable,
      @a_b_filterable,
      @a_b_user_visible,
			@a_nm_default_value,
			@a_n_prop_type,
			@a_nm_space,
			@a_nm_enum,
      @a_b_core
      )
			select @a_id_prod_view_prop =@@identity
	' 
END
GO
/****** Object:  StoredProcedure [dbo].[ReRunCreate]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ReRunCreate]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      create procedure [dbo].[ReRunCreate](@tx_filter nvarchar(255),
			  @id_acc int,
			  @tx_comment nvarchar(255),
			  @dt_system_date datetime,
			  @id_rerun int output)
      as
      insert into t_rerun (tx_filter, tx_tag) values(@tx_filter, null)
      set @id_rerun = @@identity

      insert into t_rerun_history (id_rerun, dt_action, tx_action,
		    id_acc, tx_comment)
	      values (@id_rerun, @dt_system_date, ''CREATE'', @id_acc,
		    @tx_comment)

    ' 
END
GO
/****** Object:  View [dbo].[VW_ADJUSTMENT_SUMMARY]    Script Date: 06/02/2008 11:44:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[VW_ADJUSTMENT_SUMMARY]'))
EXEC dbo.sp_executesql @statement = N'
				CREATE view [dbo].[VW_ADJUSTMENT_SUMMARY] as
        select
          ajtrx.id_acc_payer id_acc,
          ajtrx.id_usage_interval,
          ajtrx.am_currency,
          ajui.dt_start,
          ajui.dt_end,
        --add info about adjustments
        SUM (CASE WHEN ajtrx.n_adjustmenttype=0  THEN ajtrx.AdjustmentAmount ELSE 0 END)  AS PrebillAdjAmt
        ,SUM (CASE WHEN ajtrx.n_adjustmenttype=0  THEN aj_tax_federal+aj_tax_state+aj_tax_county+aj_tax_local+aj_tax_other ELSE 0 END)  AS PrebillTaxAdjAmt
         ,SUM (CASE WHEN ajtrx.n_adjustmenttype=0  THEN aj_tax_federal ELSE 0 END)  AS PrebillFederalTaxAdjustAmt
         ,SUM (CASE WHEN ajtrx.n_adjustmenttype=0  THEN aj_tax_state ELSE 0 END)  AS PrebillStateTaxAdjAmt
         ,SUM (CASE WHEN ajtrx.n_adjustmenttype=0  THEN aj_tax_county ELSE 0 END)  AS PrebillCntyTaxAdjAmt
         ,SUM (CASE WHEN ajtrx.n_adjustmenttype=0  THEN aj_tax_local ELSE 0 END)  AS PrebillLocalTaxAdjAmnt
         ,SUM (CASE WHEN ajtrx.n_adjustmenttype=0  THEN aj_tax_other ELSE 0 END)  AS PrebillOtherTaxAdjAmnt
       ,SUM (CASE WHEN ajtrx.n_adjustmenttype=1  THEN ajtrx.AdjustmentAmount ELSE 0 END)  AS PostbillAdjAmt
        ,SUM (CASE WHEN ajtrx.n_adjustmenttype=1  THEN aj_tax_federal+aj_tax_state+aj_tax_county+aj_tax_local+aj_tax_other ELSE 0 END)  AS PostbillTaxAdjAmt
         ,SUM (CASE WHEN ajtrx.n_adjustmenttype=1  THEN aj_tax_federal ELSE 0 END)  AS PostbillFedTaxAdjAmt
         ,SUM (CASE WHEN ajtrx.n_adjustmenttype=1  THEN aj_tax_state ELSE 0 END)  AS PostbillStateTaxAdjAmt
         ,SUM (CASE WHEN ajtrx.n_adjustmenttype=1  THEN aj_tax_county ELSE 0 END)  AS PostbillCntyTaxAdjAmt
         ,SUM (CASE WHEN ajtrx.n_adjustmenttype=1  THEN aj_tax_local ELSE 0 END)  AS PostbillLocalTaxAdjAmt
         ,SUM (CASE WHEN ajtrx.n_adjustmenttype=1  THEN aj_tax_other ELSE 0 END)  AS PostbillOtherTaxAdjAmt
        ,SUM (CASE WHEN ajtrx.n_adjustmenttype=1  THEN 1 ELSE 0 END)  AS NumPostbillAdjustments
        ,SUM (CASE WHEN ajtrx.n_adjustmenttype=0  THEN 1 ELSE 0 END)  AS NumPrebillAdjustments
        FROM t_adjustment_transaction ajtrx
        INNER JOIN t_usage_interval ajui on ajui.id_interval = ajtrx.id_usage_interval
        WHERE  ajtrx.c_status = ''A''
		and (id_sess is not null or archive_sess is not null)
        GROUP BY
          ajtrx.id_acc_payer,
          ajtrx.id_usage_interval,
          ajtrx.am_currency,
          ajtrx.c_status,
          ajui.dt_start,
          ajui.dt_end
				'
GO
/****** Object:  StoredProcedure [dbo].[GetIdBlock]    Script Date: 06/02/2008 11:43:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetIdBlock]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
    
		Create Procedure [dbo].[GetIdBlock] @block_size int, @sequence_name nvarchar(20), @block_start int OUTPUT 
    as
    begin
      SELECT @block_start = id_current FROM t_current_id WITH(UPDLOCK) WHERE nm_current = @sequence_name 
      UPDATE t_current_id SET id_current=id_current+@block_size where nm_current=@sequence_name
    end
    
    ' 
END
GO
/****** Object:  StoredProcedure [dbo].[GetCurrentID]    Script Date: 06/02/2008 11:43:42 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetCurrentID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			 	CREATE PROC [dbo].[GetCurrentID] @nm_current nvarchar(20), @id_current int OUTPUT
        as 
        begin tran 
        select @id_current = id_current from t_current_id 
          where nm_current = @nm_current 
        update t_current_id set id_current = id_current + 1 
          where nm_current = @nm_current 
				if ((@@error != 0) OR (@@rowCount != 1)) 
        begin 
          select @id_current = -99
				  rollback transaction 
        end 
        else 
        begin 
				  commit transaction 
        end 
			 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpsertPipeline]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpsertPipeline]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[UpsertPipeline] @tx_machine nvarchar(128), @id_pipeline int OUTPUT
AS
BEGIN
      update t_pipeline 
			set 
			  b_online = ''1'',
			  b_processing = ''0'' -- explicitly resets processing flag in case the pipeline 
			                     -- came down hard or had a shared memory leak (CR13044)
			where
			tx_machine = @tx_machine

			if (@@ROWCOUNT = 0)
			insert into t_pipeline(tx_machine, b_online, b_paused, b_processing) values (@tx_machine, ''1'', ''0'', ''0'')

			select @id_pipeline=id_pipeline from t_pipeline where tx_machine=@tx_machine
END
			' 
END
GO
/****** Object:  StoredProcedure [dbo].[InsertAcctUsageWithUID]    Script Date: 06/02/2008 11:43:49 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertAcctUsageWithUID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
		  create proc [dbo].[InsertAcctUsageWithUID] @tx_UID varbinary(16), 
			@id_acc int, @id_view int, @id_usage_interval int, @uid_parent_sess varbinary(16), 
			@id_svc int, @dt_session datetime, @amount numeric(18,6), @am_currency nvarchar(3), 
			@tax_federal numeric(18,6), @tax_state numeric(18,6), @tax_county numeric(18,6), 
			@tax_local numeric(18,6), @tax_other numeric(18,6), @tx_batch varbinary(16), 
		@id_prod int, @id_pi_instance int, @id_pi_template int,
		@id_sess bigint OUTPUT as
		  declare @id_parent_sess bigint
  
		  select @id_parent_sess = -1
			select @id_parent_sess = id_sess from t_acc_usage 
			where tx_UID = @uid_parent_sess
		  if (@id_parent_sess = -1)	begin	select @id_sess = -99	end
		  else
		  begin 
		  select @id_sess = id_current from t_current_long_id where nm_current=''id_sess'' 
		  update t_current_long_id set id_current = id_current + 1 where nm_current=''id_sess''
		  insert into t_acc_usage (id_sess, tx_UID, id_acc, id_view, id_usage_interval, 
			id_parent_sess, id_svc, dt_session, amount, am_currency, tax_federal, tax_state, 
			tax_county, tax_local, tax_other, tx_batch, id_prod, id_pi_instance, id_pi_template) 
		  values 
			(@id_sess, @tx_UID, @id_acc, @id_view, @id_usage_interval, @id_parent_sess, @id_svc, @dt_session, 
			@amount, @am_currency, @tax_federal, @tax_state, @tax_county, @tax_local, @tax_other, @tx_batch,
		@id_prod, @id_pi_instance, @id_pi_template)
		  if ((@@error != 0) OR (@@rowcount <> 1))
		  begin 
			select @id_sess = -99 
		  end 
		  end
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[GetPCViewHierarchy]    Script Date: 06/02/2008 11:43:46 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetPCViewHierarchy]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				create proc [dbo].[GetPCViewHierarchy](@id_acc as int,
					@id_interval as int,
					@id_lang_code as int)
				as
				select 
				tb_po.n_display_name id_po,-- use the display name as the product offering ID
				--au.id_prod id_po,
				pi_template.id_template_parent id_template_parent,
				--po_nm_name = case when t_description.tx_desc is NULL then template_desc.tx_desc else t_description.tx_desc end,
				po_nm_name = case when t_description.tx_desc is NULL then template_desc.tx_desc else t_description.tx_desc end,
				ed.nm_enum_data pv_child,
				ed.id_enum_data pv_childID,
				pv_parentID = case when parent_kind.nm_productview is NULL then tb_po.n_display_name else tenum_parent.id_enum_data end,
				AggRate = case when pi_props.n_kind = 15 then ''Y'' else ''N'' end,
				viewID = case when au.id_pi_instance is NULL then id_view else 
					(select viewID = case when pi_props.n_kind = 15 AND child_kind.nm_productview = ed.nm_enum_data then
					-(au.id_pi_instance + 0x40000000)
					else
					-au.id_pi_instance 
					end)
				end,
				id_view realPVID,
				--ViewName = case when tb_instance.nm_display_name is NULL then tb_template.nm_display_name else tb_instance.nm_display_name end,
				ViewName = case when tb_instance.nm_display_name is NULL then tb_template.nm_display_name else tb_instance.nm_display_name end,
				''Product'' ViewType,
				--id_view DescriptionID,
				DescriptionID = case when t_description.tx_desc is NULL then template_props.n_display_name else id_view end,
				sum(au.amount) ''Amount'',
				count(au.id_sess) ''Count'',
				au.am_currency ''Currency'', sum((isnull((au.tax_federal), 
				0.0) + isnull((au.tax_state), 0.0) + isnull((au.tax_county), 0.0) + 
				isnull((au.tax_local), 0.0) + isnull((au.tax_other), 0.0))) TaxAmount, 
				sum(au.amount + (isnull((au.tax_federal), 0.0) + isnull((au.tax_state), 0.0) + 
				isnull((au.tax_county), 0.0) + isnull((au.tax_local), 0.0) + 
				isnull((au.tax_other), 0.0))) AmountWithTax
				from t_usage_interval
				JOIN t_acc_usage au on au.id_acc = @id_acc AND au.id_usage_interval = @id_interval AND au.id_pi_template is not NULL
				JOIN t_base_props tb_template on tb_template.id_prop = au.id_pi_template
				JOIN t_pi_template pi_template on pi_template.id_template = au.id_pi_template
				JOIN t_pi child_kind on child_kind.id_pi = pi_template.id_pi
				JOIN t_base_props pi_props on pi_props.id_prop = child_kind.id_pi
				JOIN t_enum_data ed on ed.id_enum_data = au.id_view
				JOIN t_base_props template_props on pi_template.id_template = template_props.id_prop
				JOIN t_description template_desc on template_props.n_display_name = template_desc.id_desc AND template_desc.id_lang_code = @id_lang_code
				LEFT OUTER JOIN t_pi_template parent_template on parent_template.id_template = pi_template.id_template_parent
				LEFT OUTER JOIN t_pi parent_kind on parent_kind.id_pi = parent_template.id_pi
				LEFT OUTER JOIN t_enum_data tenum_parent on tenum_parent.nm_enum_data = parent_kind.nm_productview
				LEFT OUTER JOIN t_base_props tb_po on tb_po.id_prop = au.id_prod
				LEFT OUTER JOIN t_base_props tb_instance on tb_instance.id_prop = au.id_pi_instance 
				LEFT OUTER JOIN t_description on t_description.id_desc = tb_po.n_display_name AND t_description.id_lang_code = @id_lang_code
				where
				t_usage_interval.id_interval = @id_interval
				GROUP BY 
				--t_pl_map.id_po,t_pl_map.id_pi_instance_parent,
				tb_po.n_display_name,tb_instance.n_display_name,
				t_description.tx_desc,template_desc.tx_desc,
				tb_instance.nm_display_name,tb_template.nm_display_name,
				tb_instance.nm_display_name, -- this shouldn''t need to be here!!
				child_kind.nm_productview,
				parent_kind.nm_productview,tenum_parent.id_enum_data,
				pi_props.n_kind,
				id_view,ed.nm_enum_data,ed.id_enum_data,
				au.am_currency,
				tb_template.nm_name,
				pi_template.id_template_parent,
				au.id_pi_instance,
				template_props.n_display_name
				ORDER BY tb_po.n_display_name ASC, pi_template.id_template_parent ASC
		' 
END
GO
/****** Object:  View [dbo].[t_vw_base_props]    Script Date: 06/02/2008 11:44:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_base_props]'))
EXEC dbo.sp_executesql @statement = N'
create view [dbo].[t_vw_base_props]
as
select
  td_dispname.id_lang_code, bp.id_prop, bp.n_kind, bp.n_name, bp.n_desc,
  bp.nm_name as nm_name, bp.nm_desc as nm_desc, bp.b_approved, bp.b_archive,
  bp.n_display_name, td_dispname.tx_desc as nm_display_name
from t_base_props bp
  left join t_description td_dispname on td_dispname.id_desc = bp.n_display_name
  '
GO
/****** Object:  StoredProcedure [dbo].[RemoveCompositeAdjDetails]    Script Date: 06/02/2008 11:44:06 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[RemoveCompositeAdjDetails]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			create proc [dbo].[RemoveCompositeAdjDetails]
			(@p_id_prop int
			)
            AS
			BEGIN
				DELETE FROM T_COMPOSITE_ADJUSTMENT WHERE id_prop =@p_id_prop
			END
				' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpsertListener]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpsertListener]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[UpsertListener] @tx_machine NVARCHAR(128), @id_listener INT OUTPUT
AS
BEGIN
  UPDATE t_listener 
	SET b_online = ''1''
	WHERE tx_machine = @tx_machine

  IF (@@ROWCOUNT = 0)
	  INSERT INTO t_listener (tx_machine, b_online) VALUES (@tx_machine, ''1'')

  SELECT @id_listener = id_listener 
  FROM t_listener
  WHERE tx_machine = @tx_machine
END
			' 
END
GO
/****** Object:  View [dbo].[T_VW_EFFECTIVE_SUBS]    Script Date: 06/02/2008 11:44:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[T_VW_EFFECTIVE_SUBS]'))
EXEC dbo.sp_executesql @statement = N'
        
CREATE VIEW [dbo].[T_VW_EFFECTIVE_SUBS] ( ID_SUB, 
ID_ACC, ID_PO, DT_START, DT_END, 
DT_CRT, B_GROUP ) AS  
select 
sub.id_sub, 
tgs.id_acc,
sub.id_po,
tgs.vt_start,
tgs.vt_end,
tgs.tt_start as dt_crt,
''Y'' b_group
from t_sub sub
INNER JOIN t_gsubmember_historical tgs on sub.id_group = tgs.id_group 
where tgs.tt_end = dbo.MTMaxDate()
UNION ALL
select 
sub.id_sub, 
sub.id_acc,
sub.id_po,
sub.vt_start,
sub.vt_end,
sub.dt_crt,
''N'' b_group
from t_sub sub 
WHERE sub.id_group IS NULL
		'
GO
/****** Object:  StoredProcedure [dbo].[UpdateStateRecordSet]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateStateRecordSet]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				CREATE PROCEDURE [dbo].[UpdateStateRecordSet] (
					@system_date DATETIME,
					@start_date_mod DATETIME,
					@from_status CHAR(2),
					@to_status CHAR(2),
					@status INT OUTPUT)
				AS
 				BEGIN
					DECLARE @varMaxDateTime DATETIME,
						@varSystemGMTDateTime DATETIME,
						@varSystemGMTDateTimeSOD DATETIME,
						@start_date_modSOD DATETIME
					DECLARE @table_formerge TABLE (id_acc INT, status CHAR(2), vt_start DATETIME) 

					-- Set the maxdatetime into a variable
					SELECT @varMaxDateTime = dbo.MTMaxDate()
					-- Use the true current GMT time for the tt_ dates
					SELECT @varSystemGMTDateTime = @system_date
					SELECT @varSystemGMTDateTimeSOD = dbo.mtstartofday(@system_date)
					SELECT @start_date_modSOD = dbo.mtstartofday(@start_date_mod)
					SELECT @status = -1

					--CREATE TABLE #updatestate_1 (id_acc INT)

					-- Update the tt_end field of the t_account_state_history record 
					-- for the accounts
					UPDATE t_account_state_history 
					SET tt_end = DATEADD(ms, -10, @varSystemGMTDateTime)
					WHERE vt_end = @varMaxDateTime
					AND tt_end = @varMaxDateTime
					AND status = @from_status
					AND EXISTS (SELECT NULL FROM #updatestate_1 tmp 
						    WHERE tmp.id_acc = t_account_state_history.id_acc)
 					if (@@error <>0)
					begin
	  					RETURN
					end

					-- Insert the to-be-updated Current records into the History table 
					-- for the accounts, exclude the one that needs to be override
					INSERT INTO t_account_state_history
					SELECT 
						ast.id_acc,
						ast.status,
						ast.vt_start,
						dbo.subtractsecond(@start_date_modSOD),
						@varSystemGMTDateTime,
						@varMaxDateTime
					FROM t_account_state ast, #updatestate_1 tmp
					WHERE ast.id_acc = tmp.id_acc
					AND ast.vt_end = @varMaxDateTime
					AND ast.status = @from_status
					AND @start_date_mod between ast.vt_start and ast.vt_end
					-- exclude the one that needs to be override
					AND ast.vt_start <> @start_date_modSOD
 					if (@@error <>0)
					begin
	  					RETURN
					end

					-- Update the vt_end field of the Current records for the accounts
					-- when the new status is on a different day
					UPDATE t_account_state 
					SET vt_end = dbo.subtractsecond(@start_date_modSOD)
					FROM t_account_state, #updatestate_1 tmp
					WHERE tmp.id_acc = t_account_state.id_acc
					AND t_account_state.vt_end = @varMaxDateTime
					AND t_account_state.status = @from_status 
					AND @start_date_mod between t_account_state.vt_start and t_account_state.vt_end
					AND t_account_state.vt_start <> @start_date_modSOD
 					if (@@error <>0)
					begin
	  					RETURN
					end

					-- MERGE: Identify if needs to be merged with the previous record 
					INSERT INTO @table_formerge
					SELECT tmp.id_acc, status, vt_start
					FROM t_account_state ast, #updatestate_1 tmp
					WHERE ast.id_acc = tmp.id_acc
					AND ast.status = @to_status
					AND ast.vt_end = dateadd(second,-1,@start_date_modSOD)
 					if (@@error <>0)
					begin
	  					RETURN
					end

					-- MERGE: Remove the to-be-merged records
					DELETE t_account_state
					FROM t_account_state, @table_formerge mrg
					WHERE t_account_state.id_acc = mrg.id_acc
					AND t_account_state.status = mrg.status
					AND t_account_state.vt_start = mrg.vt_start
 					if (@@error <>0)
					begin
	  					RETURN
					end

					-- Remove the Current records for the accounts if the new 
					-- status is from the same day
					DELETE t_account_state
					FROM t_account_state, #updatestate_1 tmp
					WHERE t_account_state.id_acc = tmp.id_acc
					AND t_account_state.vt_end = @varMaxDateTime
					AND t_account_state.status = @from_status
					AND t_account_state.vt_start = @start_date_modSOD
 					if (@@error <>0)
					begin
	  					RETURN
					end

					DELETE t_account_state_history
					FROM t_account_state_history, @table_formerge mrg
					WHERE t_account_state_history.id_acc = mrg.id_acc
					AND t_account_state_history.status = mrg.status
					AND t_account_state_history.vt_start = mrg.vt_start
					AND t_account_state_history.tt_end = @varMaxDateTime
 					if (@@error <>0)
					begin
	  					RETURN
					end

					-- Insert new records to the Current table
					INSERT INTO t_account_state (
						id_acc,
						status,
						vt_start,
						vt_end)
					SELECT tmp.id_acc,
						@to_status,
						CASE WHEN mrg.vt_start IS NULL 
							THEN @start_date_modSOD
							ELSE mrg.vt_start END,
						@varMaxDateTime
					FROM #updatestate_1 tmp LEFT OUTER JOIN @table_formerge mrg
						ON mrg.id_acc = tmp.id_acc
 					if (@@error <>0)
					begin
	  					RETURN
					end

					-- Insert new records to the History table

					INSERT INTO t_account_state_history (
						id_acc,
						status,
						vt_start,
						vt_end,
						tt_start,
						tt_end)
					SELECT tmp.id_acc,
						@to_status,
						CASE WHEN mrg.vt_start IS NULL 
							THEN @start_date_modSOD
							ELSE mrg.vt_start END,
						@varMaxDateTime,
						@varSystemGMTDateTime,
						@varMaxDateTime
					FROM #updatestate_1 tmp LEFT OUTER JOIN @table_formerge mrg
						ON mrg.id_acc = tmp.id_acc
 					if (@@error <>0)
					begin
	  					RETURN
					end

					select @status = 1
					RETURN
				END
				' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdateAccountState]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateAccountState]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				CREATE PROCEDURE [dbo].[UpdateAccountState] (
				  @id_acc int,
					@new_status varchar(2),
					@start_date datetime,
					@system_date datetime,
					@status int OUTPUT
					)
				AS
				BEGIN
					select @status = 0

					-- Set the maxdatetime into a variable
					declare @varMaxDateTime datetime
					declare @realstartdate datetime
					declare @realenddate datetime

					select @varMaxDateTime = dbo.MTMaxDate()

					select @realstartdate = dbo.mtstartofday(@start_date)
					select @realenddate = dbo.mtstartofday(@varMaxDateTime)

					exec CreateAccountStateRecord
					  @id_acc,
					  @new_status,
						@realstartdate,
						@realenddate,
						@system_date,
						@status output
				END
				' 
END
GO
/****** Object:  StoredProcedure [dbo].[Reverse_UpdateStateRecordSet]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Reverse_UpdateStateRecordSet]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
        
				CREATE PROCEDURE [dbo].[Reverse_UpdateStateRecordSet] (
          @CurrentSystemGMTDateTime DATETIME,
					@status INT output)
				AS
				Begin
					declare @varMaxDateTime datetime

					select @status = -1

					-- Set the maxdatetime into a variable
					select @varMaxDateTime = dbo.MTMaxDate()

					-- Reverse actions for the identified id_accs

					-- Remove the existing set of states for these id_accs
					DELETE FROM t_account_state
					WHERE id_acc IN (SELECT id_acc from #updatestate_1)
 					if (@@error <>0)
					begin
	  					RETURN
					end

					-- Add the reversed set of states back for these id_accs
					INSERT INTO t_account_state (id_acc,status,vt_start,vt_end)
					SELECT tmp.id_acc, ash.status, ash.vt_start, ash.vt_end 
					FROM t_account_state_history ash
					INNER JOIN #updatestate_1 tmp
						ON ash.id_acc = tmp.id_acc
						AND tmp.tt_end BETWEEN ash.tt_start AND ash.tt_end
 					if (@@error <>0)
					begin
	  					RETURN
					end
					
					-- Update the tt_end in history
					UPDATE t_account_state_history
					SET tt_end = DATEADD(ms, -10, @CurrentSystemGMTDateTime)
					FROM t_account_state_history ash
					INNER JOIN #updatestate_1 tmp
						ON tmp.id_acc = ash.id_acc
						AND ash.tt_end = @varMaxDateTime 
 					if (@@error <>0)
					begin
	  					RETURN
					end

					-- Record these changes to the history table
					INSERT INTO t_account_state_history
					(id_acc,status,vt_start,vt_end,tt_start,tt_end)
					SELECT tmp.id_acc, ash.status, ash.vt_start, ash.vt_end, 
						@CurrentSystemGMTDateTime, @varMaxDateTime 
					FROM t_account_state_history ash
					INNER JOIN #updatestate_1 tmp
						ON tmp.id_acc = ash.id_acc
						AND tmp.tt_end BETWEEN ash.tt_start AND ash.tt_end
 					if (@@error <>0)
					begin
	  					RETURN
					end

					select @status=1
					RETURN
				END
				' 
END
GO
/****** Object:  StoredProcedure [dbo].[Backup_partitions_full]    Script Date: 06/02/2008 11:43:12 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Backup_partitions_full]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
Create PROCEDURE [dbo].[Backup_partitions_full] (@path nvarchar(4000), @database_name nvarchar(4000) =null,
@force_flag char(1) = ''N'',@litespeed char(1) = ''N'')
AS
/*
		How to run this stored procedure
		exec Backup_partitions_full @path=''c:\backup\archive'',@database_name=null,@force_flag=null,@litespeed=''N''
		or
		exec Backup_partitions_full @path=''c:\backup\archive'',@database_name=null,@force_flag=null,@litespeed=''Y''
		or
		exec Backup_partitions_full @path=''c:\backup\archive'',@database_name=''netmeter'',@force_flag=null,@litespeed=''Y''
*/
BEGIN
DECLARE @SQLStmt nvarchar(4000)
SET NOCOUNT ON
declare @intervalstart int
declare @intervalend int
declare @partname nvarchar(4000)
declare @reportdbname nvarchar(4000)
declare @getdate DATETIME
declare @getdate1 varchar(8)
declare @getdate2 varchar(8)
declare @dbname nvarchar(100)
declare @start nvarchar(255)
declare @end nvarchar(255)
declare @rowcount int 
declare @maxdate datetime
set @maxdate = dbo.mtmaxdate()
set @rowcount = 0
select @getdate = getdate()
select @getdate1 = CONVERT(VARCHAR(8), GETDATE(), 112)
select @getdate2 = REPLACE(CONVERT(VARCHAR(8), GETDATE(), 108), '':'', '''')

if (@litespeed not in (''N'',''Y'')) or (@force_flag not in (''N'',''Y''))
BEGIN
	PRINT ''Specify the correct value for litespeed  and force_flag input parameter''
	return -1
END

if (@database_name is null)
begin
	select @dbname = db_name()
	if (@litespeed = ''N'')
	begin
		SET @SQLStmt = ''backup database '' + @dbname + '' to disk='''''' + @path + ''\'' + @dbname + ''_F_'' 
			+ @getdate1 + @getdate2 + ''.BAK'''' with init,skip''
	end
	else
	begin
		SET @SQLStmt = ''EXEC master.dbo.xp_backup_database @database='''''' + @dbname + '''''' ,@filename='''''' + @path + ''\'' + @dbname + ''_F_'' 
			+ @getdate1 + @getdate2 + ''.BAK'''' ,@init= 1, @compressionlevel=3''
	end
	PRINT @SQLStmt 
	EXECUTE (@SQLStmt)
	insert into t_backup_partition(partname,type,last_backup_time,partition_status)
	values ( @dbname,''F'',@getdate,''O'')
	
	DECLARE part CURSOR FOR select partition_name from t_partition --where dbname not in (select name from t_archive_partition)
	open part
	fetch part into @partname
	WHILE @@FETCH_STATUS = 0
	BEGIN
		--print @partname
		select @intervalstart = id_interval_start, @intervalend= id_interval_end from t_partition 
		where partition_name = @partname
		if exists 
			(
			select 1 from t_usage_interval
			where tx_interval_status <> ''H''
			and id_interval between @intervalstart and @intervalend
			and not exists (select 1 from t_archive_partition where partition_name=@partname
			and status = ''A'' and tt_end = @maxdate)			
			union all
			select 1 from t_partition where partition_name = @partname and b_default = ''Y''
			union all
			select 1 from t_partition where id_partition not in
			(select id_partition from t_partition_interval_map)
			and partition_name = @partname)
		begin
				if (@litespeed = ''N'')
				begin
					SET @SQLStmt = ''backup database '' + @partname + '' to disk='''''' + @path + ''\'' + @partname + ''_F_'' 
						+ @getdate1 + @getdate2 + ''.BAK'''' with init,skip''
				end
				else
				begin
					SET @SQLStmt = ''EXEC master.dbo.xp_backup_database @database='''''' + @partname + '''''' ,@filename='''''' + @path + ''\'' + @partname + ''_F_'' 
						+ @getdate1 + @getdate2 + ''.BAK'''' ,@init= 1, @compressionlevel=3''
				end
	      PRINT @SQLStmt 
	      EXECUTE (@SQLStmt)
				insert into t_backup_partition(partname,type,last_backup_time,partition_status)
				values ( @partname,''F'',@getdate,''O'')
				set @rowcount = @@rowcount
		end
		if (@rowcount = 0)
		begin 
			if exists 
				(select 1 from t_partition part
				inner join t_archive_partition archive
				on part.partition_name = archive.partition_name
				where part.partition_name = @partname
				and not exists
					(select 1 from t_backup_partition back1
					where part.partition_name = back1.partname
					and
					back1.last_backup_time is not null and type = ''F'' and partition_status = ''A''
					and not exists (select 1 from t_query_log log1
					where log1.c_timestamp > back1.last_backup_time))
					and status = ''A'' and tt_end=@maxdate
				)
			begin
				if (@litespeed = ''N'')
				begin
					SET @SQLStmt = ''backup database '' + @partname + '' to disk='''''' + @path + ''\'' + @partname + ''_F_A_'' 
						+ @getdate1 + @getdate2 + ''.BAK'''' with init,skip''
				end
				else
				begin
					SET @SQLStmt = ''EXEC master.dbo.xp_backup_database @database='''''' + @partname + '''''' ,@filename='''''' + @path + ''\'' + @partname + ''_F_A_'' 
						+ @getdate1 + @getdate2 + ''.BAK'''' ,@init= 1, @compressionlevel=3''
				end
	      PRINT @SQLStmt 
	      EXECUTE (@SQLStmt)
				insert into t_backup_partition(partname,type,last_backup_time,partition_status)
				values ( @partname,''F'',@getdate,''A'')
				set @rowcount = @@rowcount
			end
		end
		if (@rowcount = 0)
		begin 
			if exists 
				(select 1 from t_partition part
				where partition_name = @partname
				and id_partition in
				(select id_partition from t_partition_interval_map)
				and @partname not in (select partition_name from t_partition where b_default = ''Y'')
				and not exists
					(
					select 1 from t_usage_interval usage
					where tx_interval_status <> ''H''
					and id_interval between @intervalstart and @intervalend
					)
				and not exists
				(
				select 1 from t_backup_partition back1
				where part.partition_name = back1.partname
				and
				((back1.last_backup_time is not null and type = ''F'' and partition_status = ''H'') 
				or (back1.last_backup_time is not null and type = ''F'' and partition_status = ''A''))
					and not exists (select 1 from t_query_log log1
					where log1.c_timestamp > back1.last_backup_time))
				)
			begin
					if (@litespeed = ''N'')
					begin
						SET @SQLStmt = ''backup database '' + @partname + '' to disk='''''' + @path + ''\'' + @partname + ''_F_H_'' 
							+ @getdate1 + @getdate2 + ''.BAK'''' with init,skip''
					end
					else
					begin
						SET @SQLStmt = ''EXEC master.dbo.xp_backup_database @database='''''' + @partname + '''''' ,@filename='''''' + @path + ''\'' + @partname + ''_F_H_'' 
							+ @getdate1 + @getdate2 + ''.BAK'''' ,@init= 1, @compressionlevel=3''
					end
		      PRINT @SQLStmt 
		      EXECUTE (@SQLStmt)
					insert into t_backup_partition(partname,type,last_backup_time,partition_status)
					values ( @partname,''F'',@getdate,''H'')
					set @rowcount = @@rowcount
			end
		end
	set @rowcount = 0
	fetch next from part into @partname
	end
	close part
	deallocate part
--Backup the reporting databases
	DECLARE reportingdb CURSOR FOR select NameOfReportingDB from t_ReportingDBLog where doBackup =''Y''
	open reportingdb
	fetch reportingdb into @reportdbname
	WHILE @@FETCH_STATUS = 0
	BEGIN
			if (@litespeed = ''N'')
			begin
				SET @SQLStmt = ''backup database '' + @partname + '' to disk='''''' + @path + ''\'' + @partname + ''_F_'' 
					+ @getdate1 + @getdate2 + ''.BAK'''' with init,skip''
			end
			else
			begin
				SET @SQLStmt = ''EXEC master.dbo.xp_backup_database @database='''''' + @partname + '''''' ,@filename='''''' + @path + ''\'' + @partname + ''_F_'' 
					+ @getdate1 + @getdate2 + ''.BAK'''' ,@init= 1, @compressionlevel=3''
			end
     	EXECUTE (@SQLStmt)
			insert into t_backup_partition(partname,type,last_backup_time,partition_status)
			values ( @reportdbname,''F'',@getdate,''O'')
	fetch next from reportingdb into @reportdbname
	end
	close reportingdb
	deallocate reportingdb
end
else
begin
	if not exists ((select 1 from t_partition where partition_name = @database_name)
	union all (select 1 from t_ReportingDBLog where NameOfReportingDB = @database_name))
	begin
		if (@litespeed = ''N'')
		begin
			SET @SQLStmt = ''backup database '' + @database_name + '' to disk='''''' + @path + ''\'' + @database_name + ''_F_'' 
				+ @getdate1 + @getdate2 + ''.BAK'''' with init,skip''
		end
		else
		begin
			SET @SQLStmt = ''EXEC master.dbo.xp_backup_database @database='''''' + @database_name + '''''' ,@filename='''''' + @path + ''\'' + @database_name + ''_F_'' 
				+ @getdate1 + @getdate2 + ''.BAK'''' ,@init= 1, @compressionlevel=3''
		end
		PRINT @SQLStmt 
		EXECUTE (@SQLStmt)
		insert into t_backup_partition(partname,type,last_backup_time,partition_status)
		values ( @database_name,''F'',@getdate,''O'')
	end
	if exists ((select 1 from t_ReportingDBLog where NameOfReportingDB = @database_name and doBackup = ''Y'')
	union all (select 1 from t_ReportingDBLog where NameOfReportingDB = @database_name and @force_flag = ''Y''))
	begin
		if (@litespeed = ''N'')
		begin
			SET @SQLStmt = ''backup database '' + @database_name + '' to disk='''''' + @path + ''\'' + @database_name + ''_F_'' 
				+ @getdate1 + @getdate2 + ''.BAK'''' with init,skip''
		end
		else
		begin
			SET @SQLStmt = ''EXEC master.dbo.xp_backup_database @database='''''' + @database_name + '''''' ,@filename='''''' + @path + ''\'' + @database_name + ''_F_'' 
				+ @getdate1 + @getdate2 + ''.BAK'''' ,@init= 1, @compressionlevel=3''
		end
		EXECUTE (@SQLStmt)
		insert into t_backup_partition(partname,type,last_backup_time,partition_status)
		values ( @database_name,''F'',@getdate,''O'')
	end
	if exists (select 1 from t_partition where partition_name = @database_name)
	begin
		select @intervalstart = id_interval_start, @intervalend= id_interval_end from t_partition 
		where partition_name = @database_name
		if exists (select 1 from t_usage_interval
			where tx_interval_status <> ''H''
			and id_interval between @intervalstart and @intervalend
			and not exists (select 1 from t_archive_partition where partition_name=@database_name
			and status = ''A'' and tt_end = @maxdate)
			union all
			select 1 from t_partition where partition_name = @database_name and b_default = ''Y''
			union all
			select 1 from t_partition where id_partition not in
			(select id_partition from t_partition_interval_map)
			and partition_name = @database_name)
		begin
				if (@litespeed = ''N'')
				begin
					SET @SQLStmt = ''backup database '' + @database_name + '' to disk='''''' + @path + ''\'' + @database_name + ''_F_'' 
						+ @getdate1 + @getdate2 + ''.BAK'''' with init,skip''
				end
				else
				begin
					SET @SQLStmt = ''EXEC master.dbo.xp_backup_database @database='''''' + @database_name + '''''' ,@filename='''''' + @path + ''\'' + @database_name + ''_F_'' 
						+ @getdate1 + @getdate2 + ''.BAK'''' ,@init= 1, @compressionlevel=3''
				end
	      PRINT @SQLStmt 
	      EXECUTE (@SQLStmt)
				insert into t_backup_partition(partname,type,last_backup_time,partition_status)
				values ( @database_name,''F'',@getdate,''O'')
				set @rowcount = @@rowcount
		end
		if (@rowcount = 0)
		begin 
			if exists 
				(select 1 from t_partition part
				inner join t_archive_partition archive
				on part.partition_name = archive.partition_name
				where part.partition_name = @database_name
				and (not exists
					(select 1 from t_backup_partition back1
					where part.partition_name = back1.partname
					and
					back1.last_backup_time is not null and type = ''F'' and partition_status = ''A''
					and not exists (select 1 from t_query_log log1
					where log1.c_timestamp > back1.last_backup_time))
					or
					(@force_flag = ''Y''))
				and status = ''A'' and tt_end=@maxdate
				)
			begin
					if (@litespeed = ''N'')
					begin
						SET @SQLStmt = ''backup database '' + @database_name + '' to disk='''''' + @path + ''\'' + @database_name + ''_F_A_'' 
							+ @getdate1 + @getdate2 + ''.BAK'''' with init,skip''
					end
					else
					begin
						SET @SQLStmt = ''EXEC master.dbo.xp_backup_database @database='''''' + @database_name + '''''' ,@filename='''''' + @path + ''\'' + @database_name + ''_F_A_'' 
							+ @getdate1 + @getdate2 + ''.BAK'''' ,@init= 1, @compressionlevel=3''
					end
		      PRINT @SQLStmt 
		      EXECUTE (@SQLStmt)
					insert into t_backup_partition(partname,type,last_backup_time,partition_status)
					values ( @database_name,''F'',@getdate,''A'')
					set @rowcount = @@rowcount
			end	
		end
		if (@rowcount = 0)
		begin 
			if exists 
				(select 1 from t_partition part
				where partition_name = @database_name
				and id_partition in
				(select id_partition from t_partition_interval_map)
				and not exists
					(
					select 1 from t_usage_interval usage
					where tx_interval_status <> ''H''
					and id_interval between @intervalstart and @intervalend
					)
				and (not exists
				(
				select 1 from t_backup_partition back1
				where part.partition_name = back1.partname
				and
				((back1.last_backup_time is not null  and type = ''F'' and partition_status = ''H'' ) or (back1.last_backup_time is not null and type = ''F'' and partition_status = ''A''))
					and not exists (select 1 from t_query_log log1
					where log1.c_timestamp > back1.last_backup_time))
				)
				or
				(@force_flag = ''Y''))
			begin
					if (@litespeed = ''N'')
					begin
						SET @SQLStmt = ''backup database '' + @database_name + '' to disk='''''' + @path + ''\'' + @database_name + ''_F_H_'' 
							+ @getdate1 + @getdate2 + ''.BAK'''' with init,skip''
					end
					else
					begin
						SET @SQLStmt = ''EXEC master.dbo.xp_backup_database @database='''''' + @database_name + '''''' ,@filename='''''' + @path + ''\'' + @database_name + ''_F_H_'' 
							+ @getdate1 + @getdate2 + ''.BAK'''' ,@init= 1, @compressionlevel=3''
					end
		      PRINT @SQLStmt 
		      EXECUTE (@SQLStmt)
					insert into t_backup_partition(partname,type,last_backup_time,partition_status)
					values ( @database_name,''F'',@getdate,''H'')
					set @rowcount = @@rowcount
			end
		end
	end	
end

RETURN 0 
END 
 	' 
END
GO
/****** Object:  StoredProcedure [dbo].[Backup_partitions_log]    Script Date: 06/02/2008 11:43:12 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Backup_partitions_log]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
Create PROCEDURE [dbo].[Backup_partitions_log] (@path nvarchar(4000), @database_name nvarchar(4000)=null, 
@force_flag char(1) = ''N'',@litespeed char(1) = ''N'')
AS
/*
		How to run this stored procedure
		exec Backup_partitions_log @path=''c:\backup\archive'',@database_name=null,@force_flag=null,@litespeed=''N''
		or
		exec Backup_partitions_log @path=''c:\backup\archive'',@database_name=null,@force_flag=null,@litespeed=''Y''
		or
		exec Backup_partitions_log @path=''c:\backup\archive'',@database_name=''netmeter'',@force_flag=null,@litespeed=''Y''
*/
BEGIN
DECLARE @SQLStmt nvarchar(4000)
SET NOCOUNT ON
declare @intervalstart int
declare @intervalend int
declare @partname nvarchar(4000)
declare @getdate datetime
declare @getdate1 varchar(8)
declare @getdate2 varchar(8)
declare @dbname nvarchar(100)
declare @rowcount int
declare @maxdate datetime
set @maxdate = dbo.MTMaxdate()
set @rowcount = 0
select @getdate = getdate(), @getdate1 = CONVERT(VARCHAR(8), GETDATE(), 112), @getdate2 = REPLACE(CONVERT(VARCHAR(8), GETDATE(), 108), '':'', '''')

if (@litespeed not in (''N'',''Y'')) or (@force_flag not in (''N'',''Y''))
BEGIN
	PRINT ''Specify the correct value for litespeed  and force_flag input parameter''
	return -1
END

if (@database_name is null)
begin
	select @dbname = db_name()
	if (@litespeed = ''N'')
	begin
		SET @SQLStmt = ''backup database '' + @dbname + '' to disk='''''' + @path + ''\'' + @dbname + ''_L_'' 
			+ @getdate1 + @getdate2 + ''.BAK'''' with init,skip''
	end
	else
	begin
		SET @SQLStmt = ''EXEC master.dbo.xp_backup_log @database='''''' + @dbname + '''''' ,@filename='''''' + @path + ''\'' + @dbname + ''_L_'' 
			+ @getdate1 + @getdate2 + ''.BAK'''' ,@init= 1''
	end
	PRINT @SQLStmt 
	EXECUTE (@SQLStmt)
	insert into t_backup_partition(partname,type,last_backup_time,partition_status)
	values ( @dbname,''L'',@getdate,''O'')
	
	DECLARE part CURSOR FOR select partition_name from t_partition --where dbname not in (select name from t_archive_partition)
	open part
	fetch part into @partname
	WHILE @@FETCH_STATUS = 0
	BEGIN
		select @intervalstart = id_interval_start, @intervalend= id_interval_end from t_partition 
		where partition_name = @partname
		if exists 
			(
			select 1 from t_usage_interval
			where tx_interval_status <> ''H''
			and id_interval between @intervalstart and @intervalend
			and not exists (select 1 from t_archive_partition where partition_name=@partname
			and status = ''A'' and tt_end = @maxdate)
			union all
			select 1 from t_partition where partition_name = @partname and b_default = ''Y''
			union all
			select 1 from t_partition where id_partition not in
			(select id_partition from t_partition_interval_map)
			and partition_name = @partname)
			begin
				if (@litespeed = ''N'')
				begin
					SET @SQLStmt = ''backup database '' + @partname + '' to disk='''''' + @path + ''\'' + @partname + ''_L_'' 
						+ @getdate1 + @getdate2 + ''.BAK'''' with init,skip''
				end
				else
				begin
					SET @SQLStmt = ''EXEC master.dbo.xp_backup_log @database='''''' + @partname + '''''' ,@filename='''''' + @path + ''\'' + @partname + ''_L_'' 
						+ @getdate1 + @getdate2 + ''.BAK'''' ,@init= 1''
				end
	      PRINT @SQLStmt 
	      EXECUTE (@SQLStmt)
				insert into t_backup_partition(partname,type,last_backup_time,partition_status)
				values ( @partname,''L'',@getdate,''O'')
				set @rowcount = @@rowcount
		end
		if (@rowcount = 0)
		begin
				if exists 
					(select 1 from t_partition part
					inner join t_archive_partition archive
					on part.partition_name = archive.partition_name
					where part.partition_name = @partname
					and not exists
						(select 1 from t_backup_partition back1
						where part.partition_name = back1.partname
						and
						(
						(back1.last_backup_time is not null and type = ''L'' and partition_status = ''A'')
						or
						(back1.last_backup_time is not null and type = ''D'' and partition_status = ''A'')
						or
						(back1.last_backup_time is not null and type = ''F'' and partition_status = ''A'')
						))
						and status = ''A'' and tt_end=@maxdate
					)
				begin
					if (@litespeed = ''N'')
					begin
						SET @SQLStmt = ''backup database '' + @partname + '' to disk='''''' + @path + ''\'' + @partname + ''_L_A_'' 
							+ @getdate1 + @getdate2 + ''.BAK'''' with init,skip''
					end
					else
					begin
						SET @SQLStmt = ''EXEC master.dbo.xp_backup_log @database='''''' + @partname + '''''' ,@filename='''''' + @path + ''\'' + @partname + ''_L_A_'' 
							+ @getdate1 + @getdate2 + ''.BAK'''' ,@init= 1''
					end
					PRINT @SQLStmt 
					EXECUTE (@SQLStmt)
					insert into t_backup_partition(partname,type,last_backup_time,partition_status)
					values ( @partname,''L'',@getdate,''A'')
					set @rowcount = @@rowcount
				end
		end
		if (@rowcount = 0)
		begin
				if exists 
					(select 1 from t_partition part
					where partition_name = @partname
					and id_partition in
						(select id_partition from t_partition_interval_map)
					and @partname not in (select partition_name from t_partition where b_default = ''Y'')
					and not exists
						(
						select 1 from t_usage_interval usage
						where tx_interval_status <> ''H''
						and id_interval between @intervalstart and @intervalend
						)
					and not exists
						(
						select 1 from t_backup_partition back1
						where part.partition_name = back1.partname
						and
						((back1.last_backup_time is not null and type = ''L'' and partition_status = ''A'') 
						or (back1.last_backup_time is not null and type = ''L'' and partition_status = ''H'')
						or (back1.last_backup_time is not null and type = ''D'' and partition_status = ''A'')
						or (back1.last_backup_time is not null and type = ''D'' and partition_status = ''H'')
						or (back1.last_backup_time is not null and type = ''F'' and partition_status = ''H'')
						or (back1.last_backup_time is not null and type = ''F'' and partition_status = ''A''))
						)
					)
				begin
					if (@litespeed = ''N'')
					begin
						SET @SQLStmt = ''backup database '' + @partname + '' to disk='''''' + @path + ''\'' + @partname + ''_L_H_'' 
							+ @getdate1 + @getdate2 + ''.BAK'''' with init,skip''
					end
					else
					begin
						SET @SQLStmt = ''EXEC master.dbo.xp_backup_log @database='''''' + @partname + '''''' ,@filename='''''' + @path + ''\'' + @partname + ''_L_H_'' 
							+ @getdate1 + @getdate2 + ''.BAK'''' ,@init= 1''
					end
					PRINT @SQLStmt 
					EXECUTE (@SQLStmt)
					insert into t_backup_partition(partname,type,last_backup_time,partition_status)
					values ( @partname,''L'',@getdate,''H'')
				end
		end
	set @rowcount=0	
	fetch next from part into @partname
	end
	close part
	deallocate part
end
else
begin
	if not exists (select 1 from t_partition where partition_name = @database_name)
	begin
		if (@litespeed = ''N'')
		begin
			SET @SQLStmt = ''backup database '' + @database_name + '' to disk='''''' + @path + ''\'' + @database_name + ''_L_'' 
				+ @getdate1 + @getdate2 + ''.BAK'''' with init,skip''
		end
		else
		begin
			SET @SQLStmt = ''EXEC master.dbo.xp_backup_log @database='''''' + @database_name + '''''' ,@filename='''''' + @path + ''\'' + @database_name + ''_L_'' 
				+ @getdate1 + @getdate2 + ''.BAK'''' ,@init= 1''
		end
		PRINT @SQLStmt 
		EXECUTE (@SQLStmt)
		insert into t_backup_partition(partname,type,last_backup_time,partition_status)
		values ( @database_name,''L'',@getdate,''O'')
	end
	else
	begin
		select @intervalstart = id_interval_start, @intervalend= id_interval_end from t_partition 
		where partition_name = @database_name
		if exists (select 1 from t_usage_interval
			where tx_interval_status <> ''H''
			and id_interval between @intervalstart and @intervalend
			and not exists (select 1 from t_archive_partition where partition_name=@database_name
			and status = ''A'' and tt_end = @maxdate)
			union all
			select 1 from t_partition where partition_name = @database_name and b_default = ''Y''
			union all
			select 1 from t_partition where id_partition not in
			(select id_partition from t_partition_interval_map)
			and partition_name = @database_name)
			begin
				if (@litespeed = ''N'')
				begin
					SET @SQLStmt = ''backup database '' + @database_name + '' to disk='''''' + @path + ''\'' + @database_name + ''_L_'' 
						+ @getdate1 + @getdate2 + ''.BAK'''' with init,skip''
				end
				else
				begin
					SET @SQLStmt = ''EXEC master.dbo.xp_backup_log @database='''''' + @database_name + '''''' ,@filename='''''' + @path + ''\'' + @database_name + ''_L_'' 
						+ @getdate1 + @getdate2 + ''.BAK'''' ,@init= 1''
				end
	      PRINT @SQLStmt 
	      EXECUTE (@SQLStmt)
				insert into t_backup_partition(partname,type,last_backup_time,partition_status)
				values ( @database_name,''L'',@getdate,''O'')
				set @rowcount = @@rowcount
		end
		if (@rowcount = 0)
		begin 
		if exists 
			(select 1 from t_partition part
			inner join t_archive_partition archive
			on part.partition_name = archive.partition_name
			where part.partition_name = @database_name
			and 	(not exists
					(select 1 from t_backup_partition back1
					where part.partition_name = back1.partname
					and
						(
						(back1.last_backup_time is not null and type = ''L'' and partition_status = ''A'')
						or
						(back1.last_backup_time is not null and type = ''D'' and partition_status = ''A'')
						or
						(back1.last_backup_time is not null and type = ''F'' and partition_status = ''A'')
						)
					)
				or
				(@force_flag = ''Y'')
				)
			and status = ''A'' and tt_end=@maxdate
			)
			begin
				if (@litespeed = ''N'')
				begin
					SET @SQLStmt = ''backup database '' + @database_name + '' to disk='''''' + @path + ''\'' + @database_name + ''_L_A_'' 
						+ @getdate1 + @getdate2 + ''.BAK'''' with init,skip''
				end
				else
				begin
					SET @SQLStmt = ''EXEC master.dbo.xp_backup_log @database='''''' + @database_name + '''''' ,@filename='''''' + @path + ''\'' + @database_name + ''_L_A_'' 
						+ @getdate1 + @getdate2 + ''.BAK'''' ,@init= 1''
				end
	      PRINT @SQLStmt 
	      EXECUTE (@SQLStmt)
				insert into t_backup_partition(partname,type,last_backup_time,partition_status)
				values ( @database_name,''L'',@getdate,''A'')
				set @rowcount = @@rowcount
			end	
		end
		if (@rowcount = 0)
		begin 
			if exists 
				(select 1 from t_partition part
				where partition_name = @database_name
				and id_partition in
					(select id_partition from t_partition_interval_map)
				and not exists
					(
					select 1 from t_usage_interval usage
					where tx_interval_status <> ''H''
					and id_interval between @intervalstart and @intervalend
					)
				and (not exists
				(
				select 1 from t_backup_partition back1
				where part.partition_name = back1.partname
				and
						(
							(back1.last_backup_time is not null and type = ''L'' and partition_status = ''A'') 
							or (back1.last_backup_time is not null and type = ''L'' and partition_status = ''H'')
							or (back1.last_backup_time is not null and type = ''D'' and partition_status = ''A'')
							or (back1.last_backup_time is not null and type = ''D'' and partition_status = ''H'')
							or (back1.last_backup_time is not null and type = ''F'' and partition_status = ''H'')
							or (back1.last_backup_time is not null and type = ''F'' and partition_status = ''A'')
						)
				)
				)
				or
				(@force_flag = ''Y''))
			begin
				if (@litespeed = ''N'')
				begin
					SET @SQLStmt = ''backup database '' + @database_name + '' to disk='''''' + @path + ''\'' + @database_name + ''_L_H_'' 
						+ @getdate1 + @getdate2 + ''.BAK'''' with init,skip''
				end
				else
				begin
					SET @SQLStmt = ''EXEC master.dbo.xp_backup_log @database='''''' + @database_name + '''''' ,@filename='''''' + @path + ''\'' + @database_name + ''_L_H_'' 
						+ @getdate1 + @getdate2 + ''.BAK'''' ,@init= 1''
				end
	      PRINT @SQLStmt 
	      EXECUTE (@SQLStmt)
				insert into t_backup_partition(partname,type,last_backup_time,partition_status)
				values ( @database_name,''L'',@getdate,''H'')
				set @rowcount = @@rowcount
			end
		end
	end	
end
RETURN 0 
END  
 	' 
END
GO
/****** Object:  StoredProcedure [dbo].[RemoveGroupSubMember]    Script Date: 06/02/2008 11:44:06 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[RemoveGroupSubMember]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				create procedure [dbo].[RemoveGroupSubMember](
				@id_acc int,
				@p_substartdate datetime,
				@id_group int,
				@b_overrideDateCheck varchar,
        @p_systemdate datetime,
				@status int OUTPUT
				)
				as
				begin
				declare @startdate datetime
				declare @varMaxDateTime datetime
				select @varMaxDateTime = dbo.MTMaxDate()
				select @status = 0

				if (@b_overrideDateCheck = ''N'')

					begin

					-- find the start date of the group subscription membership
					-- that exists at some point in the future.

						select @startdate  = vt_start from t_gsubmember
						where id_acc = @id_acc 
									AND id_group = @id_group 
									AND vt_start > @p_systemdate

						if (@startdate is null)
							begin
								select @status = -486604776
								return
							end
					end

				-- The logic here is the following:
				-- We have a parameter called p_substartdate. We need it to identify the proper record to delete,
				-- in case we have multiple participations for the same account on a group sub.
				-- But this parameter is optional to the object - so if it is not passed in, we will delete
				-- all participations of this account. Otherwise, we delete just the participation with the provided
				-- start date.
 				if (@p_substartdate = dbo.MTMaxDate())
					begin
					  delete from t_gsubmember where id_acc = @id_acc and id_group = @id_group
						update t_gsubmember_historical set tt_end = dbo.subtractsecond(@p_systemdate)
							where id_acc = @id_acc 
										and id_group = @id_group
										and tt_end = @varMaxDateTime
					end
				else
					begin
					  delete from t_gsubmember where id_acc = @id_acc and id_group = @id_group and @p_substartdate = vt_start
						update t_gsubmember_historical set tt_end = dbo.subtractsecond(@p_systemdate)
						where id_acc = @id_acc 
							and id_group = @id_group
							and tt_end = @varMaxDateTime
							and @p_substartdate = vt_start
					end
					
				-- If-else structure above is not very elegant, both options very similar, but I will not get fancy right now
				-- done

				select @status = 1

				end		 
		 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpsertAccountTypeServiceDefMap]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpsertAccountTypeServiceDefMap]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[UpsertAccountTypeServiceDefMap] @accounttype int, @operation nvarchar(510), 
@servicedefname nvarchar(510)
AS
BEGIN
	declare @serviceid int
	declare @opid int
	set @serviceid = (select id_enum_data from t_enum_data where nm_enum_data = @servicedefname)
	set @opid = (select id_enum_data from t_enum_data where nm_enum_data = @operation)

	update t_account_type_servicedef_map
		set id_service_def = @serviceid
		where id_type = @accounttype
		and operation = @opid
	if (@@rowcount = 0)
		insert into t_account_type_servicedef_map (id_type, operation, id_service_def) 
		values (@accounttype, @opid, @serviceid)
END
			' 
END
GO
/****** Object:  StoredProcedure [dbo].[InsertDefaultTariff]    Script Date: 06/02/2008 11:43:51 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertDefaultTariff]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
       create proc [dbo].[InsertDefaultTariff]
       as 
       declare @id int
       select @id = id_enum_data from t_enum_data where 
          nm_enum_data = ''metratech.com/tariffs/TariffID/Default''
       insert into t_tariff (id_enum_tariff, tx_currency) values (@id, N''USD'')
			 select @id = id_enum_data from t_enum_data where
					nm_enum_data = ''metratech.com/tariffs/TariffID/ConferenceExpress''
				insert into t_tariff(id_enum_tariff,tx_currency) values (@id, N''USD'')
			 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[RetrieveEnumCode]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[RetrieveEnumCode]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'	
			CREATE PROCEDURE [dbo].[RetrieveEnumCode]
			@enum_string varchar(200)
			AS

			SELECT id_enum_data FROM t_enum_data  WHERE nm_enum_data = @enum_string
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[ApprovePayments]    Script Date: 06/02/2008 11:43:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ApprovePayments]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      
      CREATE PROCEDURE [dbo].[ApprovePayments]
			@id_interval int,
			@id_acc int,
			@status int output
			AS
			BEGIN
			  SET @status = -1

				-- It is not necessary to use the temp table here.
				-- However, since there is currently no index on the 
				-- t_acc_uage.id_usage_interval column, to improve the 
				-- performance, the temp table is used so that the 
				-- id_sess be looked up only once for the two deletions.
				DECLARE @id_enum int
				SELECT
				  @id_enum = id_enum_data
				FROM
				  t_enum_data
				WHERE
				  nm_enum_data = ''metratech.com/paymentserver/PaymentStatus/Pending''
				IF ((@@ERROR != 0) OR (@@ROWCOUNT = 0)) 
				BEGIN
					GOTO FatalError
				END

				UPDATE t_pv_ps_paymentscheduler
				SET 
				  c_currentstatus = @id_enum
				where
					c_originalaccountid = @id_acc And c_originalintervalid = @id_interval
  
				IF (@@ERROR != 0)
				BEGIN
					GOTO FatalError
				END

				SET @status = 0
				RETURN 0

			FatalError:
			SET @status = -1

			END
      
      ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CheckForNotClosedDescendents]    Script Date: 06/02/2008 11:43:18 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckForNotClosedDescendents]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				CREATE PROCEDURE [dbo].[CheckForNotClosedDescendents] (
					@id_acc INT,
					@ref_date DATETIME,
					@status INT output)
				AS
					BEGIN
						select @status = 1
						begin

						-- select accounts that have status less than closed
						SELECT @status =	count(*) 
						FROM 
				  		t_account_ancestor aa
							-- join between t_account_state and t_account_ancestor
							INNER JOIN t_account_state astate ON aa.id_ancestor = astate.id_acc 
						WHERE
							aa.id_ancestor = @id_acc AND
				  		astate.status <> ''CL'' AND
				  		@ref_date between astate.vt_start and astate.vt_end AND
				  		@ref_date between aa.vt_start and aa.vt_end
				  		-- success is when no rows found
   						if (@status is null)
							   begin
         				  select @status = 1
         					return
					        end
					  end
					END
				' 
END
GO
/****** Object:  StoredProcedure [dbo].[CheckForNotArchivedDescendents]    Script Date: 06/02/2008 11:43:18 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckForNotArchivedDescendents]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				CREATE PROCEDURE [dbo].[CheckForNotArchivedDescendents] (
					@id_acc INT,
					@ref_date DATETIME,
					@status INT output)
				AS

				BEGIN
				  select @status = 1

					BEGIN

						-- select accounts that have status as closed or archived
						SELECT 
							@status = count(*)  
						FROM 
				  		t_account_ancestor aa
							-- join between t_account_state and t_account_ancestor
							INNER JOIN t_account_state astate ON aa.id_ancestor = astate.id_acc 
						WHERE
							aa.id_ancestor = @id_acc AND
				  		astate.status <> ''AR'' AND
				  		@ref_date between astate.vt_start and astate.vt_end AND
				  		@ref_date between aa.vt_start and aa.vt_end
				  		-- success is when no rows found
   					IF (@status = 0)
						BEGIN
						  SELECT @status = 1
         			RETURN
            END
					END
				END
				' 
END
GO
/****** Object:  StoredProcedure [dbo].[copytemplate]    Script Date: 06/02/2008 11:43:22 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[copytemplate]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
					CREATE procedure [dbo].[copytemplate](
					@id_folder int,
					@p_id_accounttype int,
					@id_parent int,
          @p_systemdate datetime,
          @p_enforce_same_corporation varchar,
					@status int output)
					as
				 	begin
					declare @parentID int
					declare @cdate datetime
					declare @nexttemplate int
					declare @parentTemplateID int
					 begin
						--only check same hierarchy for parent if corp business rule is
						--enforced.
						if (@p_enforce_same_corporation = ''1'' AND @id_parent is NULL)
						 begin
							select @parentID = id_ancestor 
							from t_account_ancestor where id_descendent = @id_folder
							AND @p_systemdate between vt_start AND vt_end AND
							num_generations = 1
						  if (@parentID is null)
							 begin
						     select @status = -486604771 -- MT_PARENT_NOT_IN_HIERARCHY
							   return
							 end
						 end
						else
						 begin
							select @parentID = @id_parent  
						 end 
						end	
						begin
							select @parentTemplateID = id_acc_template from t_acc_template
							where id_folder = @parentID and id_acc_type = @p_id_accounttype
							if (@parentTemplateID is null)
							 begin
								SELECT @status = -486604772
							  return
							 end
						end	
							
							exec clonesecuritypolicy @id_parent,@id_folder,''D'',''D''

							insert into t_acc_template 
							 (id_folder,dt_crt,tx_name,tx_desc,b_applydefaultpolicy, id_acc_type)
							 select @id_folder,@p_systemdate,
							 tx_name,tx_desc,b_applydefaultpolicy, id_acc_type
							 from t_acc_template where id_folder = @parentID
							 and id_acc_type = @p_id_accounttype
  					  select @nexttemplate =@@identity
         		  
							insert into t_acc_template_props (id_acc_template,nm_prop_class,
							nm_prop,nm_value)
							select @nexttemplate,existing.nm_prop_class,existing.nm_prop,
							existing.nm_value from 
							t_acc_template_props existing where 
							existing.id_acc_template = @parentTemplateID

							insert into t_acc_template_subs (id_po, id_group, id_acc_template,
							vt_start,vt_end)
						  select existing.id_po, existing.id_group, @nexttemplate,
							existing.vt_start,existing.vt_end
							from t_acc_template_subs existing
							where
							existing.id_acc_template = @parentTemplateID
							
							select @status = 1
					 end
				' 
END
GO
/****** Object:  StoredProcedure [dbo].[SetTariffs]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SetTariffs]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			 create procedure [dbo].[SetTariffs] (@id_enum_tariff varchar(255),
			 @tx_currency nvarchar (255))	 
			 as
			 if not exists (select * from t_tariff where id_enum_tariff = 
			 @id_enum_tariff and tx_currency = @tx_currency) 
			 begin 
				 insert into t_tariff (id_enum_tariff, tx_currency) values (
				 @id_enum_tariff, @tx_currency)
			end
			 ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[GetExpiredIntervals]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetExpiredIntervals]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
/* ===========================================================
   Returns the expired intervals based on the given datetime. 
   If @not_materialized is ''1'', then return only those intervals which have not been materialized.
   Otherwise, the materialization status of the interval does not matter.
=========================================================== */
CREATE FUNCTION [dbo].[GetExpiredIntervals]
(
   @dt_now DATETIME,
   @not_materialized INT
)
RETURNS @retIntervals TABLE (id_interval INT)
AS

BEGIN

INSERT @retIntervals
SELECT ui.id_interval  
FROM t_usage_interval ui
INNER JOIN t_usage_cycle uc 
   ON uc.id_usage_cycle = ui.id_usage_cycle
INNER JOIN t_usage_cycle_type uct 
   ON uct.id_cycle_type = uc.id_cycle_type
WHERE
  -- if the not_materialized flag is ''1'' 
  -- then
  --    return only those intervals which have not been materialized
  -- else 
  --    the materialization status of the interval does not matter
  CASE WHEN @not_materialized = 1
           THEN (SELECT COUNT(id_materialization) 
                      FROM t_billgroup_materialization 
                      WHERE id_usage_interval = ui.id_interval)
           ELSE 0
           END = 0 
  AND
  CASE WHEN uct.n_grace_period IS NOT NULL 
            THEN ui.dt_end + uct.n_grace_period -- take into account the cycle type''s grace period
            ELSE @dt_now -- the grace period has been disabled, so don''t close this interval
            END < @dt_now

    RETURN

END
   ' 
END
GO
/****** Object:  StoredProcedure [dbo].[SoftCloseUsageIntervals]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SoftCloseUsageIntervals]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[SoftCloseUsageIntervals]
(
  @dt_now DATETIME,     -- MetraTech system date
  @id_interval INT,     -- specific usage interval to close or null for automatic detection based on grace periods
  @pretend INT,         -- if pretend is true no intervals are closed but instead are just returned
  @n_count INT OUTPUT   -- the number of usage intervals closed (or that would have been closed)
)
AS

  BEGIN TRAN

  DECLARE @closing_intervals TABLE
  (
    id_interval INT NOT NULL,
    id_usage_cycle INT NOT NULL,
    id_cycle_type INT NOT NULL,
    dt_start DATETIME NOT NULL,
    dt_end DATETIME NOT NULL,
    tx_interval_status VARCHAR(1) NOT NULL
  )

  -- determines which intervals to close
  IF (@id_interval IS NULL)
  BEGIN
    -- looks at all the intervals in the system
    INSERT INTO @closing_intervals
    SELECT ui.id_interval, ui.id_usage_cycle, uct.id_cycle_type, ui.dt_start, ui.dt_end, ''C''
    FROM t_usage_interval ui
    INNER JOIN t_usage_cycle uc ON uc.id_usage_cycle = ui.id_usage_cycle
    INNER JOIN t_usage_cycle_type uct ON uct.id_cycle_type = uc.id_cycle_type
    WHERE
      CASE WHEN uct.n_grace_period IS NOT NULL THEN
        -- take into account the cycle type''s grace period
        ui.dt_end + uct.n_grace_period 
      ELSE
        -- the grace period has been disabled, so don''t close this interval
        @dt_now
      END < @dt_now AND
      ui.tx_interval_status = ''O''

    SET @n_count = @@ROWCOUNT
  END
  ELSE
  BEGIN
    -- only close the given interval (regardless of grace period/end date)
    INSERT INTO @closing_intervals
    SELECT ui.id_interval, ui.id_usage_cycle, uct.id_cycle_type, ui.dt_start, ui.dt_end, ui.tx_interval_status
    FROM t_usage_interval ui
    INNER JOIN t_usage_cycle uc ON uc.id_usage_cycle = ui.id_usage_cycle
    INNER JOIN t_usage_cycle_type uct ON uct.id_cycle_type = uc.id_cycle_type
    WHERE ui.tx_interval_status = ''O''
          AND ui.id_interval = @id_interval

    SET @n_count = @@ROWCOUNT
  END

  -- only closes the intervals if pretend is false
  IF @pretend = 0
  BEGIN
    UPDATE t_usage_interval
    SET tx_interval_status = ''C''
    FROM t_usage_interval ui
    INNER JOIN @closing_intervals cui ON cui.id_interval = ui.id_interval

    -- adds instance entries for each interval that closed
    INSERT INTO t_recevent_inst(id_event,id_arg_interval,dt_arg_start,dt_arg_end,b_ignore_deps,dt_effective,tx_status)
    SELECT 
      evt.id_event id_event,
      cui.id_interval id_arg_interval,
      NULL dt_arg_start,
      NULL dt_arg_end,
      ''N'' b_ignore_deps,
      NULL dt_effective,
      -- the start root event is created as Succeeded
      -- the end root event is created as ReadyToRun (for auto hard close)
      -- all others are created as  NotYetRun
      CASE WHEN evt.tx_name = ''_StartRoot'' AND evt.tx_type = ''Root'' THEN ''Succeeded'' 
           WHEN evt.tx_name = ''_EndRoot''   AND evt.tx_type = ''Root'' THEN ''ReadyToRun'' ELSE
           ''NotYetRun'' 
      END tx_status
    FROM @closing_intervals cui
    INNER JOIN t_usage_cycle uc ON uc.id_usage_cycle = cui.id_usage_cycle
    INNER JOIN t_recevent_schedule sch ON 
               -- the schedule is not constrained in any way
               ((sch.id_cycle_type IS NULL AND sch.id_cycle IS NULL) OR
               -- the schedule''s cycle type is constrained
               (sch.id_cycle_type = uc.id_cycle_type) OR
               -- the schedule''s cycle is constrained
               (sch.id_cycle = uc.id_usage_cycle))
    INNER JOIN t_recevent evt ON evt.id_event = sch.id_event
    WHERE 
      -- event must be active
      evt.dt_activated <= @dt_now and
      (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
      -- event must be of type: root, end-of-period or checkpoint
      (evt.tx_type in (''Root'', ''EndOfPeriod'', ''Checkpoint'')) AND
      evt.id_event NOT IN 
      (
        -- only adds instances if they are missing
        -- this guards against extra instances after closing -> reopening -> closing
        SELECT evt.id_event
        FROM @closing_intervals cui 
        INNER JOIN t_recevent_inst inst ON inst.id_arg_interval = cui.id_interval
        INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
        WHERE  
          -- event must be active
          evt.dt_activated <= @dt_now and
          (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated)
      )
  END

  SELECT * FROM @closing_intervals
  COMMIT
  ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreateUsageIntervalsForAccount]    Script Date: 06/02/2008 11:43:33 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateUsageIntervalsForAccount]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROC [dbo].[CreateUsageIntervalsForAccount]
(
  @dt_now   DATETIME,  -- the MetraTech system''s date
  @id_acc   INT,       -- account ID to create intervals/mappings for 
  @dt_start DATETIME,  -- account start date
  @dt_end   DATETIME,  -- account end date
  @pretend  INT,       -- if true doesn''t create new intervals but returns what would have been created
  @n_count  INT OUTPUT -- the count of intervals created (or that would have been created)
)
AS
BEGIN
  BEGIN TRAN

  -- NOTE: this procedure is closely realted to CreateUsageIntervals
  -- except that it only does work for one account (@id_acc). This sproc
  -- is used to decrease total duration of an account creation. Other
  -- accounts affected by new intervals being created are addressed later
  -- in the day when a required usm -create triggers a full CreateUsageIntervals
  -- execution.

  --
  -- PRECONDITIONS:
  --   Intervals and mappings will be created and backfilled as long as there
  --   is an entry for the account in t_acc_usage_cycle. Missing mappings will
  --   be detected and added.

  -- ensures that there is only one instance of this sproc or the CreateUsageIntervals sproc
  -- being executing right now
  DECLARE @result INT
  EXEC @result = sp_getapplock @Resource = ''CreateUsageIntervals'', @LockMode = ''Exclusive''
  IF @result < 0
  BEGIN
      ROLLBACK
      RETURN
  END

  -- represents the end date that an interval must
  -- fall into to be considered 
  DECLARE @dt_probe DATETIME
  SELECT @dt_probe = (@dt_now + n_adv_interval_creation) FROM t_usage_server

  -- if the account hasn''t started nor is about to start or
  -- the account has already ended (is this possible?)
  -- then don''t do anything
  IF (@dt_start >= @dt_probe AND @dt_end < @dt_now)
  BEGIN
    SET @n_count = @@ROWCOUNT
    COMMIT
    RETURN
  END

  -- adjusts the account end date to be no later than the probe date
  -- no intervals are created in the future after the probe date
  DECLARE @dt_adj_end DATETIME
  SELECT @dt_adj_end = CASE WHEN @dt_end > @dt_probe THEN @dt_probe ELSE @dt_end END

  DECLARE @new_mappings TABLE
  (
    id_acc INT NOT NULL,
    id_usage_interval INT NOT NULL,
    tx_status VARCHAR(1)  
  )

  -- associate the account with intervals based on its cycle mapping
  -- this will detect missing mappings and add them
  INSERT INTO @new_mappings
  SELECT 
    auc.id_acc,
    ref.id_interval,
    ISNULL(ui.tx_interval_status, ''O'')  -- TODO: this column is no longer used and should eventually be removed
  FROM t_acc_usage_cycle auc
  INNER JOIN t_pc_interval ref ON
    ref.id_cycle = auc.id_usage_cycle AND
    -- reference interval must at least partially overlap the [minstart, maxend] period
    (ref.dt_end >= @dt_start AND ref.dt_start <= @dt_adj_end)
  LEFT OUTER JOIN t_acc_usage_interval aui ON
    aui.id_usage_interval = ref.id_interval AND
    aui.id_acc = auc.id_acc  
  LEFT OUTER JOIN t_usage_interval ui
    ON ui.id_interval = ref.id_interval 
  WHERE
    auc.id_acc = @id_acc AND
    -- Only add mappings for non-blocked intervals
    (ui.tx_interval_status IS NULL OR ui.tx_interval_status != ''B'') AND
    -- only add mappings that don''t exist already
    aui.id_usage_interval IS NULL        


  DECLARE @new_intervals TABLE
  (
    id_interval INT NOT NULL,
    id_usage_cycle INT NOT NULL,
    dt_start DATETIME NOT NULL,
    dt_end DATETIME NOT NULL,
    tx_interval_status VARCHAR(1) NOT NULL,
    id_cycle_type INT NOT NULL
  )

  -- determines what usage intervals need to be added
  -- based on the new account-to-interval mappings  
  INSERT INTO @new_intervals
  SELECT 
    ref.id_interval,
    ref.id_cycle,
    ref.dt_start,
    ref.dt_end,
    ''O'',  -- Open
    uct.id_cycle_type
  FROM t_pc_interval ref
  INNER JOIN @new_mappings mappings ON mappings.id_usage_interval = ref.id_interval
  INNER JOIN t_usage_cycle uc ON uc.id_usage_cycle = ref.id_cycle
  INNER JOIN t_usage_cycle_type uct ON uct.id_cycle_type = uc.id_cycle_type
  WHERE 
    -- don''t add any intervals already in t_usage_interval
    ref.id_interval NOT IN (SELECT id_interval FROM t_usage_interval)

  -- records how many intervals would be added
  SET @n_count = @@ROWCOUNT

  -- only adds the new intervals and mappings if we aren''t pretending
  IF ISNULL(@pretend, 0) = 0
  BEGIN
    
    -- adds the new intervals
    INSERT INTO t_usage_interval(id_interval,id_usage_cycle,dt_start,dt_end,tx_interval_status)
    SELECT id_interval, id_usage_cycle, dt_start, dt_end, tx_interval_status
    FROM @new_intervals

    -- adds the new mappings
    INSERT INTO t_acc_usage_interval(id_acc,id_usage_interval,tx_status,dt_effective)
    SELECT id_acc, id_usage_interval, tx_status, NULL
    FROM @new_mappings 

  END

  -- returns the added intervals
  SELECT * FROM @new_intervals
  COMMIT
END
  ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreateUsageIntervals]    Script Date: 06/02/2008 11:43:33 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateUsageIntervals]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
	
CREATE PROC [dbo].[CreateUsageIntervals]
(
  @dt_now   DATETIME,  -- the MetraTech system''s date
  @pretend  INT,       -- if true doesn''t create new intervals but returns what would have been created
  @n_count  INT OUTPUT -- the count of intervals created (or that would have been created)
)
AS

  BEGIN TRAN

/*  
  -- debug mode --
  declare @dt_now datetime 
  select @dt_now = CAST(''2/9/2003'' AS DATETIME) --GetUTCDate()
  declare @pretend int
  select @pretend = null
  declare @n_count int
*/  

  --
  -- PRECONDITIONS:
  --   Intervals and mappings will be created and backfilled as long as there
  --   is an entry for the account in t_acc_usage_cycle. Missing mappings will
  --   be detected and added.
  --   
  --   To update a billing cycle: t_acc_usage_cycle must be updated. Also the
  --   new interval the account is updating to must be created and the initial
  --   special update mapping must be made in t_acc_usage_interval - dt_effective
  --   must be set to the end date of the previous (old) interval. 
  --

  -- ensures that there is only one instance of this sproc executing right now
  DECLARE @result INT
  EXEC @result = sp_getapplock @Resource = ''CreateUsageIntervals'', @LockMode = ''Exclusive''
  IF @result < 0
  BEGIN
      ROLLBACK
      RETURN
  END

  -- represents the end date that an interval must
  -- fall into to be considered 
  DECLARE @dt_end DATETIME
  SELECT @dt_end = (@dt_now + n_adv_interval_creation) FROM t_usage_server

  DECLARE @new_mappings TABLE
  (
    id_acc INT NOT NULL,
    id_usage_interval INT NOT NULL,
    tx_status VARCHAR(1)  
  )

if object_id(''tempdb..#minstart'') is not null
drop table #minstart

    SELECT 
      accstate.id_acc,
      -- if the usage cycle was updated, consider the time of update as the start date
      -- this prevents backfilling mappings for the previous cycle
      MIN(ISNULL(maxaui.dt_effective, accstate.vt_start)) dt_start,
      MAX(CASE WHEN vt_end > @dt_end THEN @dt_end ELSE vt_end END) dt_end
 into #minstart
    FROM t_account_state accstate
    LEFT OUTER JOIN 
    (
      SELECT 
        id_acc,
        MAX(CASE WHEN dt_effective IS NULL THEN NULL ELSE dbo.AddSecond(dt_effective) END) dt_effective
      FROM t_acc_usage_interval
      GROUP BY id_acc
    ) maxaui ON maxaui.id_acc = accstate.id_acc
    WHERE 
      -- excludes archived accounts
      accstate.status <> ''AR'' AND 
      -- the account has already started or is about to start
      accstate.vt_start < @dt_end AND
      -- the account has not yet ended
      accstate.vt_end >= @dt_now
    GROUP BY accstate.id_acc

create clustered index idx_minstart on #minstart(id_acc)

  -- associate accounts with intervals based on their cycle mapping
  -- this will detect missing mappings and add them
  INSERT INTO @new_mappings
  SELECT 
    auc.id_acc,
    ref.id_interval,
    ISNULL(ui.tx_interval_status, ''O'')
  FROM t_acc_usage_cycle auc
  INNER JOIN 
	#minstart minstart ON minstart.id_acc = auc.id_acc
  INNER JOIN t_pc_interval ref ON
    ref.id_cycle = auc.id_usage_cycle AND
    -- reference interval must at least partially overlap the [minstart, maxend] period
    (ref.dt_end >= minstart.dt_start AND ref.dt_start <= minstart.dt_end)
  LEFT OUTER JOIN t_usage_interval ui
    ON ui.id_interval = ref.id_interval 
  WHERE
  not exists (select 1 from t_acc_usage_interval aui where
    aui.id_usage_interval = ref.id_interval AND
    aui.id_acc = auc.id_acc  
) 
and
    -- Only add mappings for non-blocked intervals
    (ui.tx_interval_status IS NULL OR ui.tx_interval_status != ''B'')
--  SELECT count(*) FROM @new_mappings

if object_id(''tempdb..#minstart'') is not null
drop table #minstart


  DECLARE @new_intervals TABLE
  (
    id_interval INT NOT NULL,
    id_usage_cycle INT NOT NULL,
    dt_start DATETIME NOT NULL,
    dt_end DATETIME NOT NULL,
    tx_interval_status VARCHAR(1) NOT NULL,
    id_cycle_type INT NOT NULL
  )

  -- determines what usage intervals need to be added
  -- based on the new account-to-interval mappings  
  INSERT INTO @new_intervals
  SELECT 
    ref.id_interval,
    ref.id_cycle,
    ref.dt_start,
    ref.dt_end,
    ''O'',  -- Open
    uct.id_cycle_type
  FROM t_pc_interval ref
  INNER JOIN 
  (
    SELECT DISTINCT id_usage_interval FROM @new_mappings
  ) mappings ON mappings.id_usage_interval = ref.id_interval
  INNER JOIN t_usage_cycle uc ON uc.id_usage_cycle = ref.id_cycle
  INNER JOIN t_usage_cycle_type uct ON uct.id_cycle_type = uc.id_cycle_type
  WHERE 
    -- don''t add any intervals already in t_usage_interval
    ref.id_interval NOT IN (SELECT id_interval FROM t_usage_interval)

  -- records how many intervals would be added
  SET @n_count = @@ROWCOUNT

  -- only adds the new intervals and mappings if pretend is false
  IF ISNULL(@pretend, 0) = 0
  BEGIN
    
    -- adds the new intervals
    INSERT INTO t_usage_interval(id_interval,id_usage_cycle,dt_start,dt_end,tx_interval_status)
    SELECT id_interval, id_usage_cycle, dt_start, dt_end, tx_interval_status
    FROM @new_intervals

    -- adds the new mappings
    INSERT INTO t_acc_usage_interval(id_acc,id_usage_interval,tx_status,dt_effective)
    SELECT id_acc, id_usage_interval, tx_status, NULL
    FROM @new_mappings    

    -- updates the last interval creation time, useful for debugging
    UPDATE t_usage_server SET dt_last_interval_creation = @dt_now
  END

  -- returns the added intervals
  SELECT * FROM @new_intervals
  COMMIT
  ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[WarnOnEBCRStartDateChange]    Script Date: 06/02/2008 11:44:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[WarnOnEBCRStartDateChange]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
				
CREATE FUNCTION [dbo].[WarnOnEBCRStartDateChange]
(
  @id_sub INT -- subscription ID
)
RETURNS INT  -- 1 if a warning should be raised, 0 otherwise
AS
BEGIN

  DECLARE @isGroup INT
  SELECT @isGroup = CASE WHEN id_group IS NULL THEN 0 ELSE 1 END
  FROM t_sub 
  WHERE id_sub = @id_sub

  IF @@ROWCOUNT = 0
    RETURN -1

    -- checks to see if the subscription is associated with an EBCR RC
    -- and that the EBCR cycle type and the subscriber''s billing cycle
    -- are such that the start date would be used in derivations
  IF @isGroup = 0 AND EXISTS 
    (
      SELECT *
      FROM t_sub sub 
      INNER JOIN t_pl_map plmap ON plmap.id_po = sub.id_po
      INNER JOIN t_recur rc ON rc.id_prop = plmap.id_pi_instance
      INNER JOIN t_acc_usage_cycle auc ON auc.id_acc = sub.id_acc
      INNER JOIN t_usage_cycle payeecycle ON payeecycle.id_usage_cycle = auc.id_usage_cycle
      WHERE 
        rc.tx_cycle_mode = ''EBCR'' AND
        rc.b_charge_per_participant = ''N'' AND
        sub.id_sub = @id_sub AND
        plmap.id_paramtable IS NULL AND
        payeecycle.id_cycle_type = 1 AND -- the subscriber is Monthly
        rc.id_cycle_type IN (7, 8) -- and the EBCR cycle type is either Quarterly or Annually
    )
      RETURN 1 -- warn the user!
  -- checks to see if the group sub is associated with an EBCR RC
  -- and that the EBCR cycle type and the receiver''s payer''s billing cycle
  -- are such that the start date would be used in derivations
  ELSE IF @isGroup = 1 AND EXISTS 
    (
      SELECT NULL
      FROM t_sub sub
      INNER JOIN t_gsub_recur_map gsrm ON gsrm.id_group = sub.id_group 
      INNER JOIN t_pl_map plmap ON plmap.id_po = sub.id_po
      INNER JOIN t_recur rc ON rc.id_prop = plmap.id_pi_instance
      INNER JOIN t_payment_redirection pay ON 
        pay.id_payee = gsrm.id_acc AND
        -- checks all payer''s who overlap with the group sub
        pay.vt_end >= sub.vt_start AND
        pay.vt_start <= sub.vt_end
      INNER JOIN t_acc_usage_cycle auc ON auc.id_acc = pay.id_payer
      INNER JOIN t_usage_cycle payercycle ON payercycle.id_usage_cycle = auc.id_usage_cycle
      WHERE 
        rc.tx_cycle_mode = ''EBCR'' AND
        rc.b_charge_per_participant = ''N'' AND
        sub.id_sub = @id_sub AND
        plmap.id_paramtable IS NULL AND
        payercycle.id_cycle_type = 1 AND -- the subscriber is Monthly
        rc.id_cycle_type IN (7, 8) -- and the EBCR cycle type is either Quarterly or Annually
    )
      RETURN 1 -- warn the user!

  RETURN 0 -- don''t warn
END
				
			 ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[DeriveEBCRCycle]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeriveEBCRCycle]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
  
CREATE FUNCTION [dbo].[DeriveEBCRCycle] 
(
  @usageCycle INT,     -- billing cycle of the account (context-sensitive)
  @subStart DATETIME,  -- start date of the subscription/membership (context-sensitive)
  @ebcrCycleType INT   -- cycle type of the EBCR PI 
) 
RETURNS INT
AS
BEGIN
  DECLARE @usageCycleType INT
  DECLARE @derivedEBCRCycle INT

  DECLARE @startDay INT
  DECLARE @startMonth INT
  DECLARE @endDay INT

  -- looks up the usage cycle''s cycle type
  SELECT @usageCycleType = id_cycle_type
  FROM t_usage_cycle
  WHERE id_usage_cycle = @usageCycle

  IF (@@ROWCOUNT != 1)
    RETURN -1 -- ERROR: Exactly one usage cycle type was not found for given usage cycle ID
   
  -- if  cycle types are identical then EBCR reduces to a trivial BCR case
  IF (@ebcrCycleType = @usageCycleType)
    RETURN @usageCycle      

  -- Case map:
  --   -Weekly EBCR
  --      -Bi-weekly BC
  --   - Bi-weekly EBCR
  --      -Weekly BC
  --   -Monthly EBCR
  --      -Quarterly BC
  --      -Annual BC
  --   -Quarterly EBCR
  --      -Monthly BC
  --      -Annual BC
  --   -Annual EBCR
  --      -Monthly BC
  --      -Quarterly BC

  -- Weekly EBCR
  IF (@ebcrCycleType = 4)
  BEGIN
    -- only Bi-weekly cycle type is permitted
    IF (@usageCycleType != 5)
      RETURN -3 -- ERROR: unsupported EBCR cycle combination

    -- retrieves the Bi-weekly start day
    SELECT @startDay = start_day
    FROM t_usage_cycle uc
    WHERE uc.id_usage_cycle = @usageCycle

    -- reduces the start day [1,14] to a start day between [1,7]
    SET @startDay = @startDay % 7
    IF (@startDay = 0)
      SET @startDay = 7

    --   January 2000    
    -- Su Mo Tu We Th Fr Sa
    --                    1
    --  2  3  4  5  6  7  8
    --  9 10 11 12 13 14 15
    -- 16 17 18 19 20 21 22
    -- 23 24 25 26 27 28 29
    -- 30 31 
  
    -- Bi-weekly      Weekly
    -- start day  --> end day of week
    -- 1, 8              6
    -- 2, 9              7
    -- 3, 10             1
    -- 4, 11             2
    -- 5, 12             3
    -- 6, 13             4
    -- 7, 14             5
 
    -- translates the start day to an end day of week for use with Weekly 
    SET @endDay = @startDay - 2
    IF (@endDay < 1)  -- handles wrap around
      SET @endDay = @endDay + 7
      
    SELECT @derivedEBCRCycle = ebcr.id_usage_cycle
    FROM t_usage_cycle ebcr
    WHERE 
      ebcr.id_cycle_type = @ebcrCycleType AND 
      ebcr.day_of_week = @endDay
  END
   -- Bi-weekly EBCR
   ELSE IF (@ebcrCycleType = 5)
   BEGIN
      -- only a Weekly cycle type is permitted
      IF (@usageCycleType != 4)
         RETURN -3 -- ERROR: unsupported EBCR cycle combination

      -- retrieves the Weekly end day
      SELECT @endDay = day_of_week
      FROM t_usage_cycle uc
      WHERE uc.id_usage_cycle = @usageCycle

      -- performs the reverse translation described in the Weekly EBCR case
      -- NOTE: subscription information is ignored
      SET @startDay = @endDay + 2 
      IF (@startDay > 7)  -- handles wrap around
        SET @startDay = @startDay - 7
         
      SELECT @derivedEBCRCycle = ebcr.id_usage_cycle
      FROM t_usage_cycle ebcr
      WHERE 
         ebcr.id_cycle_type = @ebcrCycleType AND 
         ebcr.start_day = @startDay AND
         ebcr.start_month = 1 AND
         ebcr.start_year = 2000
   END

   -- Monthly EBCR
   ELSE IF (@ebcrCycleType = 1)
   BEGIN
      -- only Quarterly and Annual billing cycle types are legal for this case
      IF (@usageCycleType NOT IN (7, 8))
         RETURN -3 -- ERROR: unsupported EBCR cycle combination

      -- the usage cycle type is either Quarterly or Annual
      -- both of which use the same start_day property
      SELECT @startDay = start_day
      FROM t_usage_cycle uc
      WHERE uc.id_usage_cycle = @usageCycle

      -- translates the start day to an end day since Monthly cycle types
      -- use end days and Quarterly and Annual cycle types use start days
      IF (@startDay > 27) -- wraps around to EOM
        SET @endDay = 27
      ELSE
      BEGIN
        SET @endDay = @startDay - 1
        IF (@endDay < 1) -- wraps around to EOM
           SET @endDay = 31
      END

      
      SELECT @derivedEBCRCycle = ebcr.id_usage_cycle
      FROM t_usage_cycle ebcr
      WHERE 
         ebcr.id_cycle_type = @ebcrCycleType AND 
         ebcr.day_of_month = @endDay
   END

   -- Quarterly EBCR
   ELSE IF (@ebcrCycleType = 7)
   BEGIN
      -- Monthly billing cycle type
      IF (@usageCycleType = 1)
      BEGIN
         SELECT @endDay = day_of_month
         FROM t_usage_cycle uc
         WHERE uc.id_usage_cycle = @usageCycle

         -- infers the start month from the subscription start date   
         SELECT @startMonth = DATEPART(month, @subStart)

         -- translates the end day to a start day since Monthly cycle types
         -- use end days and Quarterly and Annual cycle types use start days
         SET @startDay = @endDay + 1

         -- wraps to beginning of month
         -- NOTE: it is important to have the start date of the EBCR cycle
         -- come after the sub start date so that certain RC charges 
         -- are generated.
         IF (@startDay > 31)
         BEGIN 
            SET @startDay = 1 
            SET @startMonth = @startMonth + 1

            IF (@startMonth > 12)
              SET @startMonth = 1
         END
  
         -- KLUDGE: it is impossible to align to a Monthly ending on 27th billing cycle
         -- because Quartery EOM does not exist. Instead the derived cycle will end on
         -- the 26th (one day off).
         IF (@startDay > 27)
           SET @startDay = 27

         -- reduces start month to a value between 1 and 3 since there are
         -- really only 3 months of quarterly cycles:
         -- Original Month: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
         --                   1   2   3   4   5   6   7   8   9  10  11  12
         -- Reduced Month:    1   2   3   1   2   3   1   2   3   1   2   3
         SET @startMonth = @startMonth % 3
         IF (@startMonth = 0)
            SET @startMonth = 3 
      END
      -- Annual billing cycle type
      ELSE IF (@usageCycleType = 8)
      BEGIN
         SELECT 
            @startDay = start_day,
            @startMonth = start_month
         FROM t_usage_cycle uc
         WHERE uc.id_usage_cycle = @usageCycle

         -- annual start days can occur in the range [1 - 31] while Quarterly start days
         -- only occur in [1 - 27, 31]. the start date will be translated to the 27th
         IF (@startDay > 27) 
            SET @startDay = 27
      END
      ELSE
         RETURN -3 -- ERROR: unsupported EBCR cycle combination

      -- translates the Annual start month [1 - 12] to a Quarterly start month [1 - 3]
      SET @startMonth = @startMonth % 3
      IF (@startMonth = 0)
        SET @startMonth = 3
 
      SELECT @derivedEBCRCycle = ebcr.id_usage_cycle
      FROM t_usage_cycle ebcr
      WHERE 
         ebcr.id_cycle_type = @ebcrCycleType AND 
         ebcr.start_day = @startDay AND
         ebcr.start_month = @startMonth
   END
   
   -- Annual EBCR
   ELSE IF (@ebcrCycleType = 8)
   BEGIN
      -- Monthly billing cycle type
      IF (@usageCycleType = 1)
      BEGIN
         SELECT @endDay = day_of_month
         FROM t_usage_cycle uc
         WHERE uc.id_usage_cycle = @usageCycle

         -- translates the end day to a start day since Monthly cycle types
         -- use end days and Quarterly and Annual cycle types use start days
         SET @startDay = @endDay + 1

         -- infers the start month from the subscription start date   
         SET @startMonth = DATEPART(month, @subStart)

         -- wraps to beginning of the next month
         -- NOTE: it is important to have the start date of the EBCR cycle
         -- come after the sub start date so that certain RC charges 
         -- are generated.
         IF (@startDay > 31)
         BEGIN 
            SET @startDay = 1 
            SET @startMonth = @startMonth + 1

            IF (@startMonth > 12)
              SET @startMonth = 1
         END

      END   

      -- Quarterly billing cycle type
      ELSE IF (@usageCycleType = 7)
      BEGIN
         SELECT 
            @startDay = start_day,
            @startMonth = start_month  
         FROM t_usage_cycle uc
         WHERE uc.id_usage_cycle = @usageCycle
      END
      ELSE
         RETURN -3 -- ERROR: unsupported usage cycle combination
      
      SELECT @derivedEBCRCycle = ebcr.id_usage_cycle
      FROM t_usage_cycle ebcr
      WHERE 
         ebcr.id_cycle_type = @ebcrCycleType AND 
         ebcr.start_day = @startDay AND
         ebcr.start_month = @startMonth
  END
  ELSE
    RETURN -4 -- unsupported EBCR cycle type

  IF (@derivedEBCRCycle IS NULL)
    RETURN -5   -- derivation failed

  RETURN @derivedEBCRCycle
END
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[InsertUsageCycleInfo]    Script Date: 06/02/2008 11:43:56 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertUsageCycleInfo]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				create proc [dbo].[InsertUsageCycleInfo] @id_cycle_type int, @dom int, 
          @period_type char(1), @id_usage_cycle int OUTPUT
				as 
        insert into t_usage_cycle (id_cycle_type, day_of_month, tx_period_type) 
          values (@id_cycle_type, @dom, @period_type) 
        if ((@@error != 0) OR (@@rowcount != 1)) 
        begin
          select @id_usage_cycle = -99 
        end 
        else 
        begin 
          select @id_usage_cycle = @@identity 
        end
			 ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[IsAccountPayingForOthers]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsAccountPayingForOthers]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
				create function [dbo].[IsAccountPayingForOthers](@id_acc int,@dt_ref datetime) 
				returns varchar
				as
        begin
				declare @returnValue char(1)
				SELECT @returnValue = CASE WHEN count(*) > 0 THEN ''Y'' ELSE ''N'' END
				FROM t_payment_redirection
				WHERE id_payer = @id_acc and
				-- this is the key difference between this and DoesAccountHavePayees
				id_payer <> id_payee and
				((@dt_ref between vt_start and vt_end) OR @dt_ref < vt_start)
				if (@returnValue is null)
					begin
					select @returnValue = ''N''
					end
				return @returnValue
				end
				' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[DoesAccountHavePayees]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DoesAccountHavePayees]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
				create function [dbo].[DoesAccountHavePayees](@id_acc int,@dt_ref datetime) 
				returns varchar
				as
        begin
				declare @returnValue char(1)
				SELECT @returnValue = CASE WHEN count(*) > 0 THEN ''Y'' ELSE ''N'' END
				FROM t_payment_redirection
				WHERE id_payer = @id_acc and
				((@dt_ref between vt_start and vt_end) OR @dt_ref < vt_start)
				if (@returnValue is null)
					begin
					select @returnValue = ''N''
					end
				return @returnValue
				end
				' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[MTComputeEffectiveEndDate]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTComputeEffectiveEndDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
  
	create function [dbo].[MTComputeEffectiveEndDate](@type as int, @offset as int, @base as datetime,  
	@sub_begin datetime, @id_usage_cycle int) returns datetime  
	as
	begin  
	if (@type = 1)  
	begin  
	return @base
	end  
	else if (@type = 2)  
	begin   
	return dbo.MTEndOfDay(@sub_begin + @offset)
	end  
	else if (@type = 3)  
	begin  
	declare @current_interval_end datetime  
	select @current_interval_end = dt_end from t_pc_interval where @base between dt_start and dt_end and id_cycle = @id_usage_cycle  
	return @current_interval_end
	end  
	return null
	end  
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[account_bucket_mapping]    Script Date: 06/02/2008 11:42:55 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[account_bucket_mapping]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
    
create procedure [dbo].[account_bucket_mapping]
(
@partition nvarchar(4000) = null,
@intervalId int = null,
@hash int,
@result nvarchar(4000) output)
as
/*How to execute the procedure
		declare @result nvarchar(4000)
		exec account_bucket_mapping @partition=''N_20040701_20040731'',@intervalId=null,@hash=3,@RESULT=@result output
		print @result
		OR
		declare @result nvarchar(4000)
		exec account_bucket_mapping @partition=null,@intervalId=827719717,@hash=3,@RESULT=@result output
		print @result
*/
declare @sql nvarchar(4000)
declare @partname nvarchar(4000)
declare @maxdate datetime
declare @currentdate datetime

set @currentdate = getdate()

set @maxdate = dbo.mtmaxdate()
--Check that either Interval or Partition is specified
if ((@partition is not null and @intervalId is not null) or (@partition is null and @intervalId is null))
begin
	set @result = ''4000001-account_bucket_mapping operation failed-->Either Partition or Interval should be specified''
	return
END
begin tran
--Run the following code if Interval is specified
if (@intervalId is not null)
begin
--Check that Interval exists
	if not exists (select 1 from t_usage_interval where id_interval=@intervalId)
	BEGIN
		set @result = ''4000002-account_bucket_mapping operation failed-->Interval Does not exists''
		rollback tran
		return
	END
--Check that Interval is hard closed
	if exists (select 1 from t_usage_interval where id_interval=@intervalId and tx_interval_status in (''O'',''B''))
	BEGIN
		set @result = ''4000002a-account_bucket_mapping operation failed-->Interval is not Hard Closed''
		rollback tran
		return
	END
--Check that mapping should not already exists
	if exists (select 1 from t_acc_bucket_map where id_usage_interval=@intervalId)
	BEGIN
		set @result = ''4000003-account_bucket_mapping operation failed-->Mapping already exists''
		rollback tran
		return
	END

--	Insert into account bucket mapping table
	select @sql = ''insert into t_acc_bucket_map(id_usage_interval,id_acc,bucket,status,tt_start,tt_end) 
			select distinct '' + cast(@intervalId as nvarchar(10)) + '',id_acc,id_acc%'' + cast(@hash as nvarchar(10)) + '',''''U'''','''''' + convert(nvarchar(23),@currentdate,121) + '''''',''''''
			+ convert(nvarchar(23),@maxdate,121) + '''''' from t_acc_usage_interval
			where id_usage_interval = '' + cast(@intervalId as nvarchar(10))
	exec (@sql)
	if (@@error <> 0) 
	begin
		set @result = ''4000004-account_bucket_mapping operation failed-->error in insert into t_acc_bucket_map''
		rollback tran
		return
	end
end
--Run the following code if Partition is specified
else
begin
--Get all the intervals in the specified Partition
	if object_id(''tempdb..#tmp'') is not null drop table #tmp
	select id_interval into #tmp from t_partition_interval_map map where id_partition 
	= (select id_partition  from t_partition where partition_name = @partition)
	create unique clustered index idx_tmp on #tmp(id_interval)
	if not exists (select 1 from t_usage_interval inte inner join #tmp map on inte.id_interval=map.id_interval and tx_interval_status = ''H'')
		BEGIN
			set @result = ''4000005-account_bucket_mapping operation failed-->Interval does not exist or is not Hard Closed''
			rollback tran
			return
		END
	--Check that mapping should not already exists
	if exists (select 1 from t_acc_bucket_map inte inner join #tmp map on inte.id_usage_interval=map.id_interval)
		BEGIN
			set @result = ''4000006-account_bucket_mapping operation failed-->Mapping already exists''
			rollback tran
			return
		END

	set @sql = ''insert into t_acc_bucket_map(id_usage_interval,id_acc,bucket,status,tt_start,tt_end) 
			select id_usage_interval,id_acc,id_acc%'' + cast(@hash as nvarchar(10)) + '',''''U'''','''''' + 
			convert(nvarchar(23),@currentdate,121) + '''''',''''''
			+ convert(nvarchar(23),@maxdate,121) + '''''' from t_acc_usage_interval
			where id_usage_interval in (select id_interval from #tmp)''
		exec (@sql)			
		if (@@error <> 0) 
		begin
			set @result = ''4000007-account_bucket_mapping operation failed-->error in insert into t_acc_bucket_map''
			rollback tran
			return
		end
	if object_id(''tempdb..#tmp'') is not null drop table #tmp
	if object_id(''tempdb..#tmp1'') is not null drop table #tmp1
end
set @result = ''0-account_bucket_mapping operation successful''
commit tran
    
    ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[GetEventExecutionDeps]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetEventExecutionDeps]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
/* ===========================================================
Return the dependencies for the given @id_instances or all ''ReadyToRun'' instances
if @id_instances is NULL
=========================================================== */
CREATE FUNCTION [dbo].[GetEventExecutionDeps](@dt_now DATETIME, @id_instances VARCHAR(4000))
RETURNS @deps TABLE
(
  id_orig_event INT NOT NULL,
  tx_orig_billgroup_support VARCHAR(15),         -- useful for debugging
  id_orig_instance INT NOT NULL,
  id_orig_billgroup INT,                               -- useful for debugging
  tx_orig_name VARCHAR(255) NOT NULL, -- useful for debugging
  tx_name nvarchar(255) NOT NULL,           -- useful for debugging
  id_event INT NOT NULL,
  tx_billgroup_support VARCHAR(15),         -- useful for debugging
  id_instance INT,
  id_billgroup INT,                                       -- useful for debugging
  id_arg_interval INT,
  dt_arg_start DATETIME,
  dt_arg_end DATETIME,
  tx_status VARCHAR(14),
  b_critical_dependency VARCHAR(1)
)
AS
BEGIN

  DECLARE @args TABLE
  ( 
    id_instance INT NOT NULL
  )
  
  -- builds up a table from the comma separated list of instance IDs
  -- if the list is null, then add all ReadyToRun instances
  IF (@id_instances IS NOT NULL)
  BEGIN
    INSERT INTO @args
    SELECT value FROM CSVToInt(@id_instances)
  END
  ELSE
  BEGIN
    INSERT INTO @args
    SELECT id_instance 
    FROM t_recevent_inst
    WHERE tx_status = ''ReadyToRun''
  END


  DECLARE @instances TABLE
  (
    id_event INT NOT NULL,
    tx_type VARCHAR(11) NOT NULL,
    tx_name nvarchar(255) NOT NULL,
    id_instance INT NOT NULL,
    id_arg_interval INT,
    id_arg_billgroup INT,
    id_arg_root_billgroup INT,
    dt_arg_start DATETIME,
    dt_arg_end DATETIME
  )

  --
  -- inserts all active ''ReadyToRun'' instances or the instance ID''s passed in
  --
  INSERT INTO @instances
  SELECT
    evt.id_event,
    evt.tx_type,
    evt.tx_name,
    inst.id_instance,
    inst.id_arg_interval,
    inst.id_arg_billgroup,
    inst.id_arg_root_billgroup,
    -- in the case of EOP then, use the interval''s start date
    CASE WHEN evt.tx_type = ''Scheduled'' THEN inst.dt_arg_start ELSE intervals.dt_start END,
    -- in the case of EOP then, use the interval''s end date
    CASE WHEN evt.tx_type = ''Scheduled'' THEN inst.dt_arg_end ELSE intervals.dt_end END
  FROM t_recevent_inst inst
  INNER JOIN @args args ON args.id_instance = inst.id_instance
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  LEFT OUTER JOIN t_pc_interval intervals ON intervals.id_interval = inst.id_arg_interval
  WHERE
    -- event is active
    evt.dt_activated <= @dt_now AND
    (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated)

  --
  -- inserts EOP to EOP dependencies for interval-only adapters
  --
  INSERT INTO @deps
  SELECT
    inst.id_event,
    origevent.tx_billgroup_support,
    inst.id_instance,
    inst.id_arg_billgroup,
    inst.tx_name,
    depevt.tx_name,
    depevt.id_event,
    depevt.tx_billgroup_support,
    depinst.id_instance,
    depinst.id_arg_billgroup,
    depinst.id_arg_interval,
    NULL,
    NULL,
    CASE WHEN inst.id_instance = depinst.id_instance THEN
      -- treats the identity dependency as successful
      ''Succeeded''
    ELSE
      depinst.tx_status
    END,
    ''Y''  -- b_critical_dependency
  FROM @instances inst
  INNER JOIN t_recevent_dep dep 
      ON dep.id_event = inst.id_event
  INNER JOIN t_recevent depevt 
      ON depevt.id_event = dep.id_dependent_on_event
  INNER JOIN t_recevent_inst depinst 
      ON depinst.id_event = depevt.id_event AND
            depinst.id_arg_interval = inst.id_arg_interval
  INNER JOIN t_recevent origevent
      ON origevent.id_event = inst.id_event
  WHERE
    -- dep event is active
    depevt.dt_activated <= @dt_now AND
    (depevt.dt_deactivated IS NULL OR @dt_now < depevt.dt_deactivated) AND
    -- the original instance''s event is root, EOP or a checkpoint event
    inst.tx_type IN (''Root'', ''EndOfPeriod'', ''Checkpoint'') AND
    -- the dependency instance''s event is an EOP or Checkpoint event
    depevt.tx_type IN (''EndOfPeriod'', ''Checkpoint'')  AND
    -- the original instance''s event is ''Interval''
    origevent.tx_billgroup_support = ''Interval''

   /* 
      Inserts EOP to EOP dependencies for billing group-only and account-only adapters. 
      For a given adapter instance, the depends-on instance could
      be and interval-only instance, a billing-group-only instance or an account-only instance.
    */
  
  INSERT INTO @deps
  SELECT
    inst.id_event,
    origevent.tx_billgroup_support,
    inst.id_instance,
    inst.id_arg_billgroup,
    inst.tx_name,
    depevt.tx_name,
    depevt.id_event,
    depevt.tx_billgroup_support,
    depinst.id_instance,
    depinst.id_arg_billgroup,
    depinst.id_arg_interval,
    NULL,
    NULL,
    CASE WHEN inst.id_instance = depinst.id_instance THEN
      -- treats the identity dependency as successful
      ''Succeeded''
    ELSE
      depinst.tx_status
    END,
    ''Y''  -- b_critical_dependency
  FROM @instances inst
   INNER JOIN t_recevent origEvt
      ON origEvt.id_event = inst.id_event
  INNER JOIN t_recevent_dep dep 
      ON dep.id_event = inst.id_event
  INNER JOIN t_recevent depevt 
      ON depevt.id_event = dep.id_dependent_on_event
  INNER JOIN t_recevent_inst depinst 
      ON depinst.id_event = depevt.id_event AND
          (
                 -- when the original event or dependent event is Interval then make sure
                 -- that the original instance and the dependent instance have the same interval
               (
                   (
                       origEvt.tx_billgroup_support = ''Interval'' OR 
                       depEvt.tx_billgroup_support = ''Interval''
                   )
                   AND 
                   (
                       depinst.id_arg_interval = inst.id_arg_interval
                   )
               )
              
               OR
               -- when the original event is BillingGroup
               (
                   (
                      origEvt.tx_billgroup_support = ''BillingGroup'' 
                   )
                   AND 
                   (
                       --and dependent event is either BillingGroup or Account then make sure
                       -- that the original instance and the dependent instance have the same root billgroup
                       -- (depevt.tx_billgroup_support IN (''BillingGroup'', ''Account'') AND
                       depinst.id_arg_root_billgroup = inst.id_arg_root_billgroup
                   )
               )
    
                -- when the original event is Account
               OR     
               (
                   (
                       origEvt.tx_billgroup_support = ''Account'' 
                   )
                   AND 
                   (
                      (
                            --and dependent event is Account then make sure
                            -- that the original instance and the dependent instance have the same billgroup 
                            depevt.tx_billgroup_support = ''Account'' AND
                            depinst.id_arg_billgroup = inst.id_arg_billgroup
                      )
                   
                      OR
                           --and dependent event is BillingGroup then make sure
                           -- that the original instance and the dependent instance have the same root billgroup 
                      (
                          depevt.tx_billgroup_support = ''BillingGroup'' AND
                          depinst.id_arg_root_billgroup = inst.id_arg_root_billgroup
                      )
                   )  -- closes that AND dangling up there
               ) -- closes that OR dangling up there - no not that OR, the other OR
          )       
         
  INNER JOIN t_recevent origevent
      ON origevent.id_event = inst.id_event
  WHERE
    -- dep event is active
    depevt.dt_activated <= @dt_now AND
    (depevt.dt_deactivated IS NULL OR @dt_now < depevt.dt_deactivated) AND
    -- the original instance''s event is root, EOP or a checkpoint event
    inst.tx_type IN (''Root'', ''EndOfPeriod'', ''Checkpoint'') AND
    -- the dependency instance''s event is an EOP or Checkpoint event
    depevt.tx_type IN (''EndOfPeriod'', ''Checkpoint'')  AND
    -- the original instance''s event is ''BillingGroup''
    origevent.tx_billgroup_support IN (''BillingGroup'', ''Account'') 
     
 /* 

It is possible for adapters instances which belong to pull lists to have dependencies 
on ''BillingGroup'' type adapters which exist at the parent billing group level and not at the pull list level.
If the parent billing group is ''Open'' then these BillingGroup adapter instances don''t even exist in t_recvent_inst.

Hence, create dummy BillingGroup type adapter instances (in a tmp table) for the parent billing groups (if necessary)
Use the tmp table to generate dependencies specifically for BillingGroup type adapters.

*/

 DECLARE @tmp_recevent_inst TABLE
  (
    id_event INT NOT NULL,
    id_arg_interval INT,
    id_arg_billgroup INT,
    id_arg_root_billgroup INT
  )

  DECLARE @tmp_billgroup TABLE
  (
     id_billgroup INT NOT NULL
  )


-- select those parent billing groups which don''t have any entries in t_recevent_inst
INSERT INTO @tmp_billgroup(id_billgroup)
SELECT id_arg_root_billgroup 
FROM t_recevent_inst ri1
WHERE NOT EXISTS (SELECT 1 
                  FROM t_recevent_inst ri2 
                  WHERE ri1.id_arg_root_billgroup = ri2.id_arg_billgroup) 
      AND id_arg_root_billgroup IS NOT NULL                                
GROUP BY id_arg_root_billgroup

-- create fake instance rows only for ''BillingGroup'' type adapters
INSERT INTO  @tmp_recevent_inst (id_event,
                                                        id_arg_interval,
                                                        id_arg_billgroup,
                                                        id_arg_root_billgroup)
SELECT evt.id_event id_event,
             bg.id_usage_interval id_arg_interval,
             tbg.id_billgroup,
             tbg.id_billgroup
FROM @tmp_billgroup tbg
  INNER JOIN t_billgroup bg ON bg.id_billgroup = tbg.id_billgroup 
  INNER JOIN t_usage_interval ui ON ui.id_interval = bg.id_usage_interval
  INNER JOIN t_usage_cycle uc ON uc.id_usage_cycle = ui.id_usage_cycle
  INNER JOIN t_recevent_schedule sch ON 
               -- the schedule is not constrained in any way
               ((sch.id_cycle_type IS NULL AND sch.id_cycle IS NULL) OR
               -- the schedule''s cycle type is constrained
               (sch.id_cycle_type = uc.id_cycle_type) OR
               -- the schedule''s cycle is constrained
               (sch.id_cycle = uc.id_usage_cycle))
    INNER JOIN t_recevent evt ON evt.id_event = sch.id_event
    
    WHERE 
      -- event must be active
      evt.dt_activated <= @dt_now AND
      (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
      -- event must be of type: end-of-period
      (evt.tx_type in (''EndOfPeriod'')) AND
      evt.tx_billgroup_support = ''BillingGroup''

 INSERT INTO @deps
  SELECT
    inst.id_event,
    origevent.tx_billgroup_support,
    inst.id_instance,
    inst.id_arg_billgroup,
    inst.tx_name,
    depevt.tx_name,
    depevt.id_event,
    depevt.tx_billgroup_support,
    -1,
    depinst.id_arg_billgroup,
    depinst.id_arg_interval,
    NULL,
    NULL,
    ''NotCreated'',
    ''Y''  -- b_critical_dependency
  FROM @instances inst
   INNER JOIN t_recevent origEvt
      ON origEvt.id_event = inst.id_event
  INNER JOIN t_recevent_dep dep 
      ON dep.id_event = inst.id_event
  INNER JOIN t_recevent depevt 
      ON depevt.id_event = dep.id_dependent_on_event
  INNER JOIN @tmp_recevent_inst depinst 
      ON depinst.id_event = depevt.id_event AND
             -- when the original event is Account
             origEvt.tx_billgroup_support = ''Account'' AND 
             --and dependent event is BillingGroup then make sure
             -- that the original instance and the dependent instance have the same root billgroup 
             depevt.tx_billgroup_support = ''BillingGroup'' AND
             depinst.id_arg_root_billgroup = inst.id_arg_root_billgroup
                       
  INNER JOIN t_recevent origevent
      ON origevent.id_event = inst.id_event
  WHERE
    -- dep event is active
    depevt.dt_activated <= @dt_now AND
    (depevt.dt_deactivated IS NULL OR @dt_now < depevt.dt_deactivated) AND
    -- the original instance''s event is EOP event
    inst.tx_type IN (''EndOfPeriod'') AND
    -- the dependency instance''s event is an EOP event
    depevt.tx_type IN (''EndOfPeriod'')  AND
    -- the original instance''s event is ''Account''
    origevent.tx_billgroup_support IN (''Account'') 

--SELECT * FROM @deps  

  --
  -- inserts EOP cross-interval dependencies
  --
  INSERT INTO @deps
  SELECT 
    inst.id_event,
    NULL, -- original tx_billgroup_support
    inst.id_instance,
    inst.id_arg_billgroup,
    inst.tx_name,
    depevt.tx_name,
    depevt.id_event,
    NULL, -- tx_billgroup_support
    depinst.id_instance,
    depinst.id_arg_billgroup,
    ui.id_interval,
    NULL,
    NULL,
    ISNULL(depinst.tx_status, ''Missing''),
    ''N''  -- b_critical_dependency
  FROM @instances inst
  INNER JOIN t_usage_interval ui ON ui.dt_end < inst.dt_arg_end 
  CROSS JOIN 
  (
    -- returns the event dependencies of the end root event
    -- this event depends on all EOP events
    SELECT
      depevt.id_event,
      depevt.tx_name
    FROM t_recevent evt
    INNER JOIN t_recevent_dep dep ON dep.id_event = evt.id_event
    INNER JOIN t_recevent depevt ON depevt.id_event = dep.id_dependent_on_event
    WHERE
      evt.tx_name = ''_EndRoot'' AND
      -- end root event is active
      evt.dt_activated <= @dt_now AND
      (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
      -- dep event is active
      depevt.dt_activated <= @dt_now AND
      (depevt.dt_deactivated IS NULL OR @dt_now < depevt.dt_deactivated) AND
      -- the dependency instance''s event is an EOP or Checkpoint event
      depevt.tx_type IN (''EndOfPeriod'', ''Checkpoint'') 
  ) depevt
  LEFT OUTER JOIN t_recevent_inst depinst ON depinst.id_event = depevt.id_event AND
                                                                          depinst.id_arg_interval = ui.id_interval
  WHERE
    -- the original instance''s event is root, EOP or a checkpoint event
    inst.tx_type IN (''Root'', ''EndOfPeriod'', ''Checkpoint'') AND
    -- don''t consider hard closed intervals
    ui.tx_interval_status <> ''H''

  --
  -- inserts scheduled dependencies (including complete missing instances)
  --
  INSERT INTO @deps
  SELECT
    inst.id_event,
    NULL, -- original tx_billgroup_support
    inst.id_instance,
    NULL, -- id_arg_billgroup
    inst.tx_name,
    depevt.tx_name,
    depevt.id_event,
    depevt.tx_billgroup_support,
    depinst.id_instance,
    NULL, -- id_arg_billgroup
    NULL, -- id_arg_interval
    ISNULL(depinst.dt_arg_start, inst.dt_arg_start),
    ISNULL(depinst.dt_arg_end, inst.dt_arg_end),
    CASE WHEN inst.id_instance = depinst.id_instance THEN
      -- treats the identity dependency as successful
      ''Succeeded''
    ELSE
      ISNULL(depinst.tx_status, ''Missing'')
    END,
     ''N''  -- b_critical_dependency
  FROM @instances inst
  INNER JOIN t_recevent_dep dep ON dep.id_event = inst.id_event
  INNER JOIN t_recevent depevt ON depevt.id_event = dep.id_dependent_on_event
  LEFT OUTER JOIN t_recevent_inst depinst ON depinst.id_event = depevt.id_event AND
    -- enforce that the instance''s dependency''s start arg and end arg
    -- at least partially overlap with the original instance''s start and end arguments
    depinst.dt_arg_start <= inst.dt_arg_end AND
    depinst.dt_arg_end >= inst.dt_arg_start
  WHERE
    -- dep event is active
    depevt.dt_activated <= @dt_now AND
    (depevt.dt_deactivated IS NULL OR @dt_now < depevt.dt_deactivated) AND
    depevt.tx_type = ''Scheduled''

--SELECT * FROM @deps ORDER BY tx_orig_name ASC

  -- inserts partially missing scheduled dependency instances (start to min)
  -- covers the original instance''s start date to the minimum start date
  -- of all scheduled instances of an event
  INSERT INTO @deps
  SELECT
    inst.id_event,
    NULL, -- original tx_billgroup_support
    inst.id_instance,
    NULL, -- id_arg_billgroup
    inst.tx_name,
    missingdeps.tx_name,
    missingdeps.id_event,
    NULL, -- tx_billgroup_support
    NULL, -- id_instance,
    NULL, -- id_arg_billgroup
    NULL, -- id_arg_interval
    inst.dt_arg_start,
    dbo.SubtractSecond(missingdeps.dt_min_arg_start),
    ''Missing'', -- tx_status,
     ''N''  -- b_critical_dependency
  FROM @instances inst
  INNER JOIN
  (
    -- gets the minimum arg start date per scheduled event
    SELECT
      deps.id_orig_instance,
      deps.id_event,
      deps.tx_name,
      MIN(deps.dt_arg_start) dt_min_arg_start
    FROM @deps deps
    INNER JOIN t_recevent evt ON evt.id_event = deps.id_event
    WHERE
      evt.tx_type = ''Scheduled'' AND
      deps.tx_status <> ''Missing''
    GROUP BY
      deps.id_orig_instance,
      deps.id_event,
      deps.tx_name
  ) missingdeps ON missingdeps.id_orig_instance = inst.id_instance
  WHERE
    -- only adds a missing instance if the minimum start date is too late
    missingdeps.dt_min_arg_start > inst.dt_arg_start 


--SELECT * FROM @deps ORDER BY tx_orig_name ASC

  -- inserts partially missing scheduled dependency instances (max to end)
  -- covers the maximum end date of all scheduled instances of an event to the
  -- original instance''s end date
  INSERT INTO @deps
  SELECT
    inst.id_event,
    NULL, -- original tx_billgroup_support
    inst.id_instance,
    NULL, -- id_arg_billgroup
    inst.tx_name,
    missingdeps.tx_name,
    missingdeps.id_event,
    NULL, -- tx_billgroup_support
    NULL, -- id_instance,
    NULL, -- id_arg_billgroup
    NULL, -- id_arg_interval
    dbo.AddSecond(missingdeps.dt_max_arg_end),
    inst.dt_arg_end,
    ''Missing'', -- tx_status,
     ''N''  -- b_critical_dependency
  FROM @instances inst
  INNER JOIN
  (
    -- gets the maximum arg end date per scheduled event
    SELECT
      deps.id_orig_instance,
      deps.id_event,
      deps.tx_name,
      MAX(deps.dt_arg_end) dt_max_arg_end
    FROM @deps deps
    INNER JOIN t_recevent evt ON evt.id_event = deps.id_event
    WHERE
      evt.tx_type = ''Scheduled'' AND
      deps.tx_status <> ''Missing''
    GROUP BY
      deps.id_orig_instance,
      deps.id_event,
      deps.tx_name
  ) missingdeps ON missingdeps.id_orig_instance = inst.id_instance
  WHERE
    -- only adds a missing instance if the maximum end date is too early
    missingdeps.dt_max_arg_end < inst.dt_arg_end 

--SELECT * FROM @deps ORDER BY tx_orig_name ASC
  RETURN
END
' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[GetEventReversalDeps]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetEventReversalDeps]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
/* ===========================================================
Return the dependencies for the given @id_instances or all ''ReadyToRun'' instances
if @id_instances is NULL
=========================================================== */
 CREATE FUNCTION [dbo].[GetEventReversalDeps](@dt_now DATETIME, @id_instances VARCHAR(4000))
RETURNS @deps TABLE
(
  id_orig_event INT NOT NULL,
  tx_orig_billgroup_support VARCHAR(15),         -- useful for debugging
  id_orig_instance INT NOT NULL,
  id_orig_billgroup INT,                               -- useful for debugging
  tx_orig_name VARCHAR(255) NOT NULL, -- useful for debugging
  tx_name nvarchar(255) NOT NULL,           -- useful for debugging
  id_event INT NOT NULL,
  tx_billgroup_support VARCHAR(15),         -- useful for debugging
  id_instance INT,
  id_billgroup INT,                                       -- useful for debugging
  id_arg_interval INT,
  dt_arg_start DATETIME,
  dt_arg_end DATETIME,
  tx_status VARCHAR(14),
  b_critical_dependency VARCHAR(1)
)
AS
BEGIN

  DECLARE @args TABLE
  ( 
    id_instance INT NOT NULL
  )
  
  -- builds up a table from the comma separated list of instance IDs
  -- if the list is null, then add all ReadyToReverse instances
  IF (@id_instances IS NOT NULL)
  BEGIN
    INSERT INTO @args
    SELECT value FROM CSVToInt(@id_instances)
  END
  ELSE
  BEGIN
    INSERT INTO @args
    SELECT id_instance 
    FROM t_recevent_inst
    WHERE tx_status = ''ReadyToReverse''
  END


  DECLARE @instances TABLE
  (
    id_event INT NOT NULL,
    tx_type VARCHAR(11) NOT NULL,
    tx_name nvarchar(255) NOT NULL,
    id_instance INT NOT NULL,
    id_arg_interval INT,
    id_arg_billgroup INT,
    id_arg_root_billgroup INT,
    dt_arg_start DATETIME,
    dt_arg_end DATETIME
  )

  --
  -- inserts all active instances found in @args
  --
  INSERT INTO @instances
  SELECT
    evt.id_event,
    evt.tx_type,
    evt.tx_name,
    inst.id_instance,
    inst.id_arg_interval,
    inst.id_arg_billgroup,
    inst.id_arg_root_billgroup,
    -- in the case of EOP then, use the interval''s start date
    CASE WHEN evt.tx_type = ''Scheduled'' THEN inst.dt_arg_start ELSE intervals.dt_start END,
    -- in the case of EOP then, use the interval''s end date
    CASE WHEN evt.tx_type = ''Scheduled'' THEN inst.dt_arg_end ELSE intervals.dt_end END
  FROM t_recevent_inst inst
  INNER JOIN @args args ON args.id_instance = inst.id_instance
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  LEFT OUTER JOIN t_pc_interval intervals ON intervals.id_interval = inst.id_arg_interval
  WHERE
    -- event is active
    evt.dt_activated <= @dt_now AND
    (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated)

  --
  -- inserts EOP to EOP dependencies for interval-only adapters
  --
  INSERT INTO @deps
  SELECT
    inst.id_event,
    origevent.tx_billgroup_support,
    inst.id_instance,
    inst.id_arg_billgroup,
    inst.tx_name,
    depevt.tx_name,
    depevt.id_event,
    depevt.tx_billgroup_support,
    depinst.id_instance,
    depinst.id_arg_billgroup,
    depinst.id_arg_interval,
    NULL,
    NULL,
    CASE WHEN inst.id_instance = depinst.id_instance THEN
      -- treats the identity dependency as NotYetRun
      ''NotYetRun''
    ELSE
      depinst.tx_status
    END,
     ''Y''  -- b_critical_dependency
  FROM @instances inst
  INNER JOIN t_recevent_dep dep ON dep.id_dependent_on_event = inst.id_event
  INNER JOIN t_recevent depevt ON depevt.id_event = dep.id_event
  INNER JOIN t_recevent_inst depinst ON depinst.id_event = depevt.id_event AND
                                        depinst.id_arg_interval = inst.id_arg_interval
  INNER JOIN t_recevent origevent
      ON origevent.id_event = inst.id_event
  WHERE
    -- dep event is active
    depevt.dt_activated <= @dt_now AND
    (depevt.dt_deactivated IS NULL OR @dt_now < depevt.dt_deactivated) AND
    -- the original instance''s event is root, EOP or a checkpoint event
    inst.tx_type IN (''Root'', ''EndOfPeriod'', ''Checkpoint'') AND
    -- the dependency instance''s event is an EOP or Checkpoint event
    depevt.tx_type IN (''EndOfPeriod'', ''Checkpoint'') AND
    -- the original instance''s event is ''Interval''
    origevent.tx_billgroup_support = ''Interval''

--SELECT * FROM @deps ORDER BY tx_orig_name ASC
   /* 
      Inserts EOP to EOP dependencies for billing group-only and account-only adapters. 
      For a given adapter instance, the depends-on instance could
      be and interval-only instance, a billing-group-only instance or an account-only instance.
    */

 INSERT INTO @deps
  SELECT
    inst.id_event,
    origevent.tx_billgroup_support,
    inst.id_instance,
    inst.id_arg_billgroup,
    inst.tx_name,
    depevt.tx_name,
    depevt.id_event,
    depevt.tx_billgroup_support,
    depinst.id_instance,
    depinst.id_arg_billgroup,
    depinst.id_arg_interval,
    NULL,
    NULL,
    CASE WHEN inst.id_instance = depinst.id_instance THEN
      -- treats the identity dependency as NotYetRun
      ''NotYetRun''
    ELSE
      depinst.tx_status
    END,
     ''Y''  -- b_critical_dependency
  FROM @instances inst
  INNER JOIN t_recevent_dep dep ON dep.id_dependent_on_event = inst.id_event
  INNER JOIN t_recevent depevt ON depevt.id_event = dep.id_event
  INNER JOIN t_recevent_inst depinst ON depinst.id_event = depevt.id_event AND
          (
               -- if the depends-on instance is an interval-only instance
               (depinst.id_arg_interval = inst.id_arg_interval AND depevt.tx_billgroup_support = ''Interval'') 
               OR
               -- if the depends-on instance is an account-only instance
              (depinst.id_arg_billgroup = inst.id_arg_billgroup AND depevt.tx_billgroup_support = ''Account'')
               OR
              -- if the depends-on instance is a billing-group-only instance
              (depinst.id_arg_root_billgroup = inst.id_arg_root_billgroup AND depevt.tx_billgroup_support = ''BillingGroup'')
           )

  INNER JOIN t_recevent origevent
      ON origevent.id_event = inst.id_event
  WHERE
    -- dep event is active
    depevt.dt_activated <= @dt_now AND
    (depevt.dt_deactivated IS NULL OR @dt_now < depevt.dt_deactivated) AND
    -- the original instance''s event is root, EOP or a checkpoint event
    inst.tx_type IN (''Root'', ''EndOfPeriod'', ''Checkpoint'') AND
    -- the dependency instance''s event is an EOP or Checkpoint event
    depevt.tx_type IN (''EndOfPeriod'', ''Checkpoint'') AND
    -- the original instance''s event is ''BillingGroup''
    origevent.tx_billgroup_support IN (''BillingGroup'', ''Account'') 

  --
  -- inserts EOP cross-interval dependencies (every instance in future intervals)
  --
  INSERT INTO @deps
  SELECT 
    inst.id_event,
    NULL, -- original tx_billgroup_support
    inst.id_instance,
    inst.id_arg_billgroup,
    inst.tx_name,
    depevt.tx_name,
    depevt.id_event,
    NULL, -- tx_billgroup_support
    depinst.id_instance,
    depinst.id_arg_billgroup,
    ui.id_interval,
    NULL,
    NULL,
    depinst.tx_status,
    ''N'' -- b_critical_dependency
  FROM @instances inst
  INNER JOIN t_usage_interval ui ON ui.dt_end > inst.dt_arg_end
  CROSS JOIN 
  (
    -- returns the event dependencies of the end root event
    -- this event depends on all EOP events
    SELECT
      depevt.id_event,
      depevt.tx_name
    FROM t_recevent evt
    INNER JOIN t_recevent_dep dep ON dep.id_event = evt.id_event
    INNER JOIN t_recevent depevt ON depevt.id_event = dep.id_dependent_on_event
    WHERE
      evt.tx_name = ''_EndRoot'' AND
      -- end root event is active
      evt.dt_activated <= @dt_now AND
      (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
      -- dep event is active
      depevt.dt_activated <= @dt_now AND
      (depevt.dt_deactivated IS NULL OR @dt_now < depevt.dt_deactivated) AND
      -- the dependency instance''s event is an EOP or Checkpoint event
      depevt.tx_type IN (''EndOfPeriod'', ''Checkpoint'') 
  ) depevt
  INNER JOIN t_recevent_inst depinst ON depinst.id_event = depevt.id_event AND
                                        depinst.id_arg_interval = ui.id_interval
  WHERE
    -- the original instance''s event is root, EOP or a checkpoint event
    inst.tx_type IN (''Root'', ''EndOfPeriod'', ''Checkpoint'')


  --
  -- inserts scheduled dependencies
  --
  INSERT INTO @deps
  SELECT
    inst.id_event,
    NULL, -- original tx_billgroup_support
    inst.id_instance,
    NULL, -- id_arg_billgroup
    inst.tx_name,
    depevt.tx_name,
    depevt.id_event,
    depevt.tx_billgroup_support,
    depinst.id_instance,
    NULL, -- id_arg_billgroup
    NULL, -- id_arg_interval
    ISNULL(depinst.dt_arg_start, inst.dt_arg_start),
    ISNULL(depinst.dt_arg_end, inst.dt_arg_end),
    CASE WHEN inst.id_instance = depinst.id_instance THEN
      -- treats the identity dependency as NotYetRun
      ''NotYetRun''
    ELSE
      depinst.tx_status
    END,
    ''N''  -- b_critical_dependency
  FROM @instances inst
  INNER JOIN t_recevent_dep dep ON dep.id_dependent_on_event = inst.id_event
  INNER JOIN t_recevent depevt ON depevt.id_event = dep.id_event
  INNER JOIN t_recevent_inst depinst ON depinst.id_event = depevt.id_event AND
    -- enforce that the instance''s dependency''s start arg and end arg
    -- at least partially overlap with the original instance''s start and end arguments
    depinst.dt_arg_start <= inst.dt_arg_end AND
    depinst.dt_arg_end >= inst.dt_arg_start
  WHERE
    -- dep event is active
    depevt.dt_activated <= @dt_now AND
    (depevt.dt_deactivated IS NULL OR @dt_now < depevt.dt_deactivated) AND
    depevt.tx_type = ''Scheduled''

--SELECT * FROM @deps ORDER BY tx_orig_name ASC
  RETURN
END
' 
END
GO
/****** Object:  View [dbo].[t_partition_interval_map]    Script Date: 06/02/2008 11:44:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_partition_interval_map]'))
EXEC dbo.sp_executesql @statement = N'
				create view [dbo].[t_partition_interval_map] as
					select 
						ui.id_interval, p.id_partition
					from t_usage_interval ui
					left join t_partition p
						on ui.dt_end between p.dt_start and p.dt_end
			'
GO
/****** Object:  StoredProcedure [dbo].[GeneratePartitionSequence]    Script Date: 06/02/2008 11:43:41 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GeneratePartitionSequence]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      /*
      	Proc: GeneratePartitionSequence
      
      	Returns a list partitions based on current partition type
      	and active intervals.
      
      */
      create proc [dbo].[GeneratePartitionSequence]
      	@partitions cursor varying output
      AS
      begin
      
      /* Get the partition cycle
      */
      declare @cycle int
      select @cycle = partition_cycle from t_usage_server
      -- Only 4 cycles supported 30, 31, 338, 430
      -- todo: Check that @cycle is in (30, 31, 338, 430)
      --			1 row expected
      --			exception handling
      
		-- Determine if this is a conversion and include 
		--	hard-closed intervals if so.
		declare @intervalstatus varchar(10)
		set @intervalstatus = ''[BO]''
		if objectproperty(object_id(''t_acc_usage''),''istable'') = 1
			set @intervalstatus = ''[HBO]''

      /* Get high and low end-dates for all active intervals
      */
      declare @dtmin datetime, @dtmax datetime
      select @dtmin = min(dt_end), @dtmax = max(dt_end)
      from t_usage_interval ui
      where ui.tx_interval_status like @intervalstatus
      
      /* Get end-date of eldest active partition.  If there aren''t
      	any partitions yet then use lowest of active interval end-dates.
      */
      declare @dtend datetime  -- new partition starts on day after last
      select @dtend = max(dt_end) from t_partition
      where b_active = ''Y''
      --	todo: exception handling
      
      /* The start of the new partition range is always the day
      	after the last partition ends.  If there is no prior
      	partition, then use the youngest of the interval end-dates.
      */
      declare @start datetime
      select @start = isnull(@dtend + 1, @dtmin)
      
      /*-- debugging...
      -- convert(varchar, @now, 102) the hack string
      declare @dtend datetime
      set @cycle = 30
      set @dtend = null 
      set @dtend = ''2005-01-15 23:59:59''
      set @dtmin = ''2005-05-31 23:59:59'' 
      set @dtmax = ''2005-09-05 23:59:59''
      */
      
      /* Round start dates down to whole day
      */
      set @dtmin = convert(varchar, @dtmin, 102)
      set @start = convert(varchar, @start, 102)
      
      /* debugging
      select @cycle as cyc, @dtend as dtend, @start as start, 
      	@dtmin as dtmin, @dtmax as dtmax
      */
      
      /* Get the partition sequence
      */
      declare partscur cursor local for
      select 
      		-- The real start of the cycle; untruncated
      		--dt_start as interval_start, 
      
      		-- dt_start might be the truncated start of the interval
      		case
      			when @dtend is not null and @start > dt_start 
      			then @start else dt_start end
      		as dt_start,
      
      		-- dt_end is the end of the interval
      		dt_end,
      
      		-- interval_start is a usage-interval key equivalent
      		-- used to constrain the partition''s lower bound.
      		datediff(d, ''1970-1-1'', case
      					when @dtend is not null and @start > dt_start
      					then @start else dt_start end
      					)
      				* power(2,16) 
      			as interval_start,
      
      		-- interval_end is a usage-interval key equivalent
      		-- used to constrain the partition''s upper bound
      		datediff(d, ''1970-1-1'', dt_end) * power(2,16)  
      				+ (power(2,16) - 1) 
      			as interval_end
      
      from t_pc_interval 
      where id_cycle = @cycle
      and dt_end > @start		
      and dt_start <= @dtmax
      order by dt_end
      
      /* Open the cursor for the caller.
      */
      open partscur
      set @partitions = partscur
      
      end -- procedure
 	' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdIntervalBlockedForNewAccts]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdIntervalBlockedForNewAccts]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
Updates the status for the specified interval to ''B'' (if the existing status is not ''H'')
meaning that no new accounts will be mapped to this interval.
===========================================================*/
CREATE PROCEDURE [dbo].[UpdIntervalBlockedForNewAccts]
(
   @id_interval INT
)
AS

BEGIN
  UPDATE t_usage_interval 
  SET tx_interval_status = ''B''
  WHERE id_interval = @id_interval AND
              tx_interval_status != ''H''
END
 
         ' 
END
GO
/****** Object:  StoredProcedure [dbo].[GetLastBalance]    Script Date: 06/02/2008 11:43:44 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetLastBalance]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
---------------------------------------------------------
-- gets last calculated balance for an account
-- or latest calculated balance based on a cut-off date
---------------------------------------------------------
CREATE PROCEDURE [dbo].[GetLastBalance]( 
@id_acc int,                    -- account
@before_date datetime,          -- last balance before this date, can be NULL
@balance numeric(18, 6) OUTPUT, -- the balance
@balance_date datetime OUTPUT,  -- the date the balance was computed
@currency nvarchar(3) OUTPUT     -- currency for account
)
AS
BEGIN

  SELECT TOP 1 @balance = inv.current_balance,
    @balance_date = ui.dt_end,
    @currency = inv.invoice_currency
  FROM t_invoice inv
  JOIN t_usage_interval ui ON ui.id_interval = inv.id_interval
  WHERE id_acc = @id_acc
    AND (@before_date IS NULL OR ui.dt_end < @before_date)
  ORDER BY ui.dt_end DESC

  IF @balance IS NULL
    BEGIN
    SET @balance = 0
    SET @currency = (select c_currency from t_av_internal where id_acc = @id_acc)
    SET @balance_date = ''1900-01-01''
    END
END
     ' 
END
GO
/****** Object:  StoredProcedure [dbo].[MTSP_RATE_AGGREGATE_CHARGE]    Script Date: 06/02/2008 11:44:04 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTSP_RATE_AGGREGATE_CHARGE]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[MTSP_RATE_AGGREGATE_CHARGE]
@input_RUN_ID int,
@input_USAGE_INTERVAL int,
@input_BILLING_GROUP_ID int,
@input_TEMPLATE_ID int,
@input_FIRST_PASS_PV_VIEWID int,
@input_FIRST_PASS_PV_TABLE varchar(50),
@input_COUNTABLE_VIEWIDS varchar(2000),
@input_COUNTABLE_OJOINS varchar(2000),
@input_FIRST_PASS_PV_PROPERTIES_ALIASED varchar(4000),  --field names with alias
@input_COUNTABLE_PROPERTIES varchar(2000),                    --field names only
@input_COUNTER_FORMULAS varchar(2000),                  --counters
@input_ACCOUNT_FILTER varchar(2000),
@input_COMPOUND_ORDERING varchar(2000),
@input_COUNTER_FORMULAS_ALIASES varchar(2000),
@output_SQLStmt_SELECT varchar(4000) OUTPUT,
@output_SQLStmt_DROPTMPTBL1 varchar(200) OUTPUT,
@output_SQLStmt_DROPTMPTBL2 varchar(200) OUTPUT,
@return_code int OUTPUT
AS
BEGIN
/********************************************************************
** Procedure Name: MTSP_RATE_AGGREGATE_CHARGE
** 
** Procedure Description: 
**
** Parameters: 
**
** Returns: 0 if successful
**          -1 if fatal error occurred
**
** Created By: Ning Zhuang
** Created On: 1/8/2002
** 
** Last Modified On: 02/19/2003
** Last Modified On: 01/21/2003
** Last Modified On: 01/08/2003** Last Modified On: 01/02/2003
** Last Modified On: 12/10/2002
** Last Modified On: 11/18/2002
** Last Modified On: 11/14/2002
** Last Modified On: 10/31/2002
** Last Modified On: 6/12/2002
** Last Modified On: 6/10/2002
**
**********************************************************************/
DECLARE
@au_id_usage_interval int,
@au_id_usage_cycle int,
@au_bc_dt_start datetime,
@ag_dt_start datetime,
@SQLStmt nvarchar(4000),
@tmp_tbl_name_base varchar(50),

@tmp_tbl_name1 varchar(50),
@tmp_tbl_name12 varchar(50),
@tmp_tbl_name2 varchar(50),
@tmp_tbl_name3 varchar(50),
@debug_flag bit,
@SQLError int,

-- the following are added on 11/11/2002
-- I tried a number of ways to implement the performance change. Based on the testing 
-- results of 3 versions of the implementations, both feature flexibility and script flexibility 
-- (like using table variables) have processing cost associated with them. Since the purpose of 
-- the coding change is to improve the performance, I thus decide to use the version 
-- SPAggRate_OK_listed20.sql which provides the best performance improvement among the three new 
-- versions. This stored procedure contains this version.
@max_loop_cnt int,
-- used to accumulate the counter values (SUM)
@countable_0 numeric(18,6),
@countable_1 numeric(18,6),
@countable_2 numeric(18,6),
@countable_3 numeric(18,6),
@countable_4 numeric(18,6),
@countable_5 numeric(18,6),
@countable_6 numeric(18,6),
@countable_7 numeric(18,6),
@countable_8 numeric(18,6),
@countable_9 numeric(18,6),
@countable_10 numeric(18,6),
@countable_11 numeric(18,6),
@countable_12 numeric(18,6),
@countable_13 numeric(18,6),
@countable_14 numeric(18,6),
@countable_15 numeric(18,6),
@countable_16 numeric(18,6),
@countable_17 numeric(18,6),
@countable_18 numeric(18,6),
@countable_19 numeric(18,6),
-- use to count the number of records (COUNT)
@rec_count_0 int,
@rec_count_1 int,
@rec_count_2 int,
@rec_count_3 int,
@rec_count_4 int,
@rec_count_5 int,@rec_count_6 int,
@rec_count_7 int,
@rec_count_8 int,
@rec_count_9 int,
@rec_count_10 int,
@rec_count_11 int,
@rec_count_12 int,
@rec_count_13 int,
@rec_count_14 int,
@rec_count_15 int,
@rec_count_16 int,
@rec_count_17 int,
@rec_count_18 int,
@rec_count_19 int,

@work_counter_formulas varchar(500),
@work_counter varchar(500),
@loop_index int,
@as_index int,
@comma_index int,
-- store the parsed counter formula
@countable_formula_0 varchar(500),
@countable_formula_1 varchar(500),
@countable_formula_2 varchar(500),
@countable_formula_3 varchar(500),
@countable_formula_4 varchar(500),
@countable_formula_5 varchar(500),
@countable_formula_6 varchar(500),
@countable_formula_7 varchar(500),
@countable_formula_8 varchar(500),
@countable_formula_9 varchar(500),
@countable_formula_10 varchar(500),
@countable_formula_11 varchar(500),
@countable_formula_12 varchar(500),
@countable_formula_13 varchar(500),
@countable_formula_14 varchar(500),
@countable_formula_15 varchar(500),
@countable_formula_16 varchar(500),
@countable_formula_17 varchar(500),
@countable_formula_18 varchar(500),
@countable_formula_19 varchar(500),
-- store the actual value of the calculated formula
@countable_formula_value_0 numeric(18,6),
@countable_formula_value_1 numeric(18,6),
@countable_formula_value_2 numeric(18,6),
@countable_formula_value_3 numeric(18,6),
@countable_formula_value_4 numeric(18,6),
@countable_formula_value_5 numeric(18,6),
@countable_formula_value_6 numeric(18,6),
@countable_formula_value_7 numeric(18,6),
@countable_formula_value_8 numeric(18,6),
@countable_formula_value_9 numeric(18,6),
@countable_formula_value_10 numeric(18,6),
@countable_formula_value_11 numeric(18,6),
@countable_formula_value_12 numeric(18,6),
@countable_formula_value_13 numeric(18,6),
@countable_formula_value_14 numeric(18,6),
@countable_formula_value_15 numeric(18,6),
@countable_formula_value_16 numeric(18,6),
@countable_formula_value_17 numeric(18,6),
@countable_formula_value_18 numeric(18,6),
@countable_formula_value_19 numeric(18,6),
-- store the parsed field names which will be used to create the "temp" table
@counter_resultfieldname_0 varchar(500),
@counter_resultfieldname_1 varchar(500),
@counter_resultfieldname_2 varchar(500),
@counter_resultfieldname_3 varchar(500),
@counter_resultfieldname_4 varchar(500),
@counter_resultfieldname_5 varchar(500),
@counter_resultfieldname_6 varchar(500),
@counter_resultfieldname_7 varchar(500),
@counter_resultfieldname_8 varchar(500),
@counter_resultfieldname_9 varchar(500),
@counter_resultfieldname_10 varchar(500),
@counter_resultfieldname_11 varchar(500),
@counter_resultfieldname_12 varchar(500),
@counter_resultfieldname_13 varchar(500),
@counter_resultfieldname_14 varchar(500),
@counter_resultfieldname_15 varchar(500),
@counter_resultfieldname_16 varchar(500),
@counter_resultfieldname_17 varchar(500),
@counter_resultfieldname_18 varchar(500),
@counter_resultfieldname_19 varchar(500),

@countable_count int,
@formula_count int, -- added on 12/10/2002
@insert_count int

-- added on 12/31/2002
DECLARE
@cur_id_pass int,
@cur_id_sess bigint,
@cur_id_acc int,
@cur_group_acc_flag tinyint,
@cur_group_acc_id int,
@cur_pci_id_interval int,
@cur_dt_session datetime,
@cur_ui_dt_start datetime,
@cur_ui_dt_end datetime,
@cur_pci_dt_start datetime,
@cur_pci_dt_end datetime,
@cur_countable_0 numeric(18,6),
@cur_countable_1 numeric(18,6),
@cur_countable_2 numeric(18,6),
@cur_countable_3 numeric(18,6),
@cur_countable_4 numeric(18,6),
@cur_countable_5 numeric(18,6),
@cur_countable_6 numeric(18,6),
@cur_countable_7 numeric(18,6),
@cur_countable_8 numeric(18,6),
@cur_countable_9 numeric(18,6),
@cur_countable_10 numeric(18,6),
@cur_countable_11 numeric(18,6),
@cur_countable_12 numeric(18,6),
@cur_countable_13 numeric(18,6),
@cur_countable_14 numeric(18,6),
@cur_countable_15 numeric(18,6),
@cur_countable_16 numeric(18,6),
@cur_countable_17 numeric(18,6),
@cur_countable_18 numeric(18,6),
@cur_countable_19 numeric(18,6),
@pre_group_acc_flag tinyint,
@pre_group_acc_id int,
@pre_pci_id_interval int,
@FetchStatusCalc int

SET NOCOUNT ON
SET @debug_flag = 1

------------------------------------------
-- Reguide transactions to subscriptions
-- that may have changed retroactively
------------------------------------------

-- CR12878 - a select into temp table approach is used here
-- because lock exhaustion issues ocurred when the same logic
-- was in the form of update joins
SELECT 
  id_sess,
  ISNULL(plm1.id_pi_instance, plm2.id_pi_instance) id_pi_instance,
  ISNULL(s1.id_po, s2.id_po) id_prod
INTO #reguide_usage
FROM t_acc_usage
LEFT OUTER JOIN 
	t_gsubmember gsm
	INNER JOIN t_sub s1 ON s1.id_group=gsm.id_group
	INNER JOIN t_pl_map plm1 ON plm1.id_po=s1.id_po AND plm1.id_paramtable IS NULL
ON gsm.id_acc=t_acc_usage.id_payee AND gsm.vt_start <= t_acc_usage.dt_session AND gsm.vt_end >= t_acc_usage.dt_session AND plm1.id_pi_template=t_acc_usage.id_pi_template 
LEFT OUTER JOIN 
	t_sub s2 
	INNER JOIN t_pl_map plm2 ON plm2.id_po=s2.id_po AND plm2.id_paramtable IS NULL
ON s2.id_acc=t_acc_usage.id_payee AND s2.vt_start <= t_acc_usage.dt_session AND s2.vt_end >= t_acc_usage.dt_session AND s2.id_group IS NULL AND plm2.id_pi_template=t_acc_usage.id_pi_template 
WHERE
t_acc_usage.id_usage_interval=@input_USAGE_INTERVAL AND
t_acc_usage.id_pi_template=@input_TEMPLATE_ID AND
t_acc_usage.id_view=@input_FIRST_PASS_PV_VIEWID
AND
(
	ISNULL(plm1.id_pi_instance, plm2.id_pi_instance) <> t_acc_usage.id_pi_instance
	OR
	ISNULL(s1.id_po, s2.id_po) <> t_acc_usage.id_prod
	OR
	(t_acc_usage.id_pi_instance IS NULL AND ISNULL(plm1.id_pi_instance, plm2.id_pi_instance) IS NOT NULL)
  OR
	(t_acc_usage.id_prod IS NULL AND ISNULL(plm1.id_po, plm2.id_po) IS NOT NULL)
)

IF @@rowcount > 0
BEGIN
  ALTER TABLE #reguide_usage ADD CONSTRAINT pk_reguide_usage PRIMARY KEY (id_sess)

  UPDATE t_acc_usage
  SET 
    t_acc_usage.id_pi_instance = #reguide_usage.id_pi_instance,
    t_acc_usage.id_prod = #reguide_usage.id_prod
  FROM #reguide_usage
  WHERE t_acc_usage.id_sess = #reguide_usage.id_sess

  DROP TABLE #reguide_usage
END

SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

------------------------------------------
-- Construct the temp. table names
------------------------------------------
SET @tmp_tbl_name_base = REPLACE(REPLACE(REPLACE(REPLACE
	(RTRIM(CAST(@@SPID AS CHAR) + ''_'' + CONVERT(CHAR, getdate(), 121)),
	 '' '', ''''), '':'', ''''), ''.'', ''''), ''-'','''')
SET @tmp_tbl_name1 = ''t'' + @tmp_tbl_name_base + ''_1''
SET @tmp_tbl_name12 = ''t'' + @tmp_tbl_name_base + ''_12''
SET @tmp_tbl_name2 = ''t'' + @tmp_tbl_name_base + ''_2''
SET @tmp_tbl_name3 = ''t'' + @tmp_tbl_name_base + ''_3''
------------------------------------------
-- Obtain the billing start and end dates:
-- One billing interval has only one pair of start and end dates
-- Retrieve and then store them in local variables
-----------------------------------------------
SELECT
	@au_id_usage_interval=ui.id_interval,
	@au_id_usage_cycle=ui.id_usage_cycle,
	@au_bc_dt_start=ui.dt_start
FROM 
	t_usage_interval ui
WHERE
	ui.id_interval = @input_USAGE_INTERVAL
SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError
IF @debug_flag = 1 AND @input_RUN_ID IS NOT NULL
BEGIN
  INSERT INTO t_recevent_run_details (id_run, tx_type, tx_detail, dt_crt)
  VALUES (@input_RUN_ID, ''Debug'', ''Finished selecting from the t_usage_interval table'', getutcdate())  
	SELECT @SQLError = @@ERROR
	IF @SQLError <> 0 GOTO FatalError
END
--PRINT @au_id_usage_interval
--PRINT @au_id_usage_cycle
--PRINT @au_bc_dt_start
--PRINT '' ''
--PRINT ''started: to obtain the earliest aggragate starting date''
--PRINT CONVERT(char, getdate(), 109)
-----------------------------------------------
-- Obtain the earliest aggragate starting date:
-- Modified on 5/31/02 to take the group sub into consideration
-----------------------------------------------
SELECT au.dt_session, 
ag.id_usage_cycle id_pc_cycle,
ISNULL(gs.id_usage_cycle,auc.id_usage_cycle) id_usage_cycle
INTO #tmp1
FROM 
	t_acc_usage au
	INNER JOIN t_acc_usage_cycle auc ON auc.id_acc = au.id_acc
	LEFT OUTER JOIN t_gsubmember gsm 
	  INNER JOIN t_group_sub gs ON gs.id_group = gsm.id_group
	  INNER JOIN t_sub s on gs.id_group = s.id_group 
  ON gsm.id_acc = au.id_payee AND s.id_po = au.id_prod AND au.dt_session BETWEEN gsm.vt_start AND gsm.vt_end,
	t_usage_interval ui,
	t_aggregate ag
WHERE
	au.id_view = @input_FIRST_PASS_PV_VIEWID AND
	au.id_usage_interval = @input_USAGE_INTERVAL AND
	au.id_pi_template = @input_TEMPLATE_ID AND
	ui.id_interval = au.id_usage_interval AND
	ui.id_interval = @input_USAGE_INTERVAL AND
	ag.id_prop = ISNULL(au.id_pi_instance, au.id_pi_template)
SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

SELECT @ag_dt_start = MIN(pci.dt_start)
FROM #tmp1 tmp1
	LEFT OUTER JOIN t_pc_interval pci ON pci.id_cycle = ISNULL(tmp1.id_pc_cycle,tmp1.id_usage_cycle)
		AND tmp1.dt_session BETWEEN pci.dt_start AND pci.dt_end 
SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

DROP TABLE #tmp1
SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError
IF @debug_flag = 1 AND @input_RUN_ID IS NOT NULL
BEGIN
  INSERT INTO t_recevent_run_details (id_run, tx_type, tx_detail, dt_crt)
  VALUES (@input_RUN_ID, ''Debug'', ''Finished selecting the minimum pci.dt_start'', getutcdate())  
	SELECT @SQLError = @@ERROR
	IF @SQLError <> 0 GOTO FatalError
END
--PRINT @ag_dt_start
--PRINT ''completed: to obtain the earliest aggragate starting date''
--PRINT CONVERT(char, getdate(), 109)
-----------------------------------------------
-- If no aggregate cycle then use billing cycle
IF @ag_dt_start IS NULL SET @ag_dt_start = @au_bc_dt_start
--PRINT @ag_dt_start

-- creates the billing group join filter which is only valid during EOP runs (not estimate jobs)
DECLARE @billingGroupJoin NVARCHAR(256)
IF @input_RUN_ID IS NOT NULL
  SET @billingGroupJoin = N''INNER JOIN t_billgroup_member bgm ON bgm.id_acc = au.id_acc AND bgm.id_billgroup = '' + CAST(@input_BILLING_GROUP_ID AS NVARCHAR)
ELSE
  SET @billingGroupJoin = N''''

----------------------------------------------------------------
-- Firstpass records
----------------------------------------------------------------
SET @SQLStmt = ''''
SET @SQLStmt =
N''SELECT
	au.id_sess,
	au.id_acc,
	au.id_payee,
	au.dt_session,
	ui.dt_start ui_dt_start,
	ui.dt_end ui_dt_end,
	-- Changed on 5/3, 5/6/2002 to take the group subscription dates into consideration
	CASE WHEN 
		gsm.id_group IS NOT NULL AND gs.b_supportgroupops = ''''Y''''
		THEN 1 ELSE 0 
	END group_acc_flag,
	CASE WHEN
		gsm.id_group IS NOT NULL AND gs.b_supportgroupops = ''''Y''''
		THEN gsm.id_group ELSE au.id_payee 
	END group_acc_id,
	ag.id_usage_cycle pci_id_cycle,
	ISNULL(gs.id_usage_cycle,auc.id_usage_cycle) ui_id_cycle
INTO '' + CAST(@tmp_tbl_name12 AS nvarchar(50)) + N'' 
FROM
	t_acc_usage au
	INNER JOIN t_acc_usage_cycle auc ON auc.id_acc = au.id_acc
  '' + @billingGroupJoin + N'' 
	-- Changed on 5/3 to take the group subscription dates into consideration
	LEFT OUTER JOIN t_gsubmember gsm 
	  INNER JOIN t_group_sub gs ON gs.id_group = gsm.id_group
	  INNER JOIN t_sub s on s.id_group = gs.id_group
  ON gsm.id_acc = au.id_payee AND s.id_po = au.id_prod AND au.dt_session BETWEEN gsm.vt_start AND gsm.vt_end,
	t_usage_interval ui,
	t_aggregate ag
WHERE
	au.id_view = @dinput_FIRST_PASS_PV_VIEWID AND
	au.id_usage_interval = @dinput_id_usage_interval AND
	au.id_pi_template = @dinput_TEMPLATE_ID AND
	ui.id_interval = au.id_usage_interval AND
	ag.id_prop = ISNULL(au.id_pi_instance, au.id_pi_template) AND
	au.dt_session >= @dag_dt_start ''
	+ CAST(@input_ACCOUNT_FILTER AS nvarchar(2000)) 

EXEC sp_executesql @SQLStmt,
N''@dinput_FIRST_PASS_PV_VIEWID int, @dinput_id_usage_interval int, @dinput_TEMPLATE_ID int, @dag_dt_start datetime'',
@input_FIRST_PASS_PV_VIEWID, @input_USAGE_INTERVAL, @input_TEMPLATE_ID, @ag_dt_start

SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

SET @SQLStmt = ''''
SET @SQLStmt =
N''SELECT
	tmp.id_sess,
	tmp.id_acc,
	tmp.id_payee,
	tmp.dt_session,
	tmp.ui_dt_start,
	tmp.ui_dt_end,
	pci.dt_start pci_dt_start,
	pci.dt_end pci_dt_end,
	pci.id_interval pci_id_interval,
	tmp.group_acc_flag,
	tmp.group_acc_id
INTO '' + CAST(@tmp_tbl_name1 AS nvarchar(50)) + N'' 
FROM '' + CAST(@tmp_tbl_name12 AS nvarchar(50)) + N'' tmp 
	LEFT OUTER JOIN t_pc_interval pci ON pci.id_cycle = ISNULL(tmp.pci_id_cycle,tmp.ui_id_cycle)
		AND tmp.dt_session BETWEEN pci.dt_start AND pci.dt_end ''
--PRINT @SQLStmt
EXEC sp_executesql @SQLStmt
SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

IF @debug_flag = 1 AND @input_RUN_ID IS NOT NULL
BEGIN
  INSERT INTO t_recevent_run_details (id_run, tx_type, tx_detail, dt_crt)
  VALUES (@input_RUN_ID, ''Debug'', ''Finished inserting into the temp1 table'', getutcdate())
	SELECT @SQLError = @@ERROR
	IF @SQLError <> 0 GOTO FatalError
END
--PRINT ''completed: to obtain the firstpass records''
--PRINT CONVERT(char, getdate(), 109)

SET @SQLStmt = ''DROP TABLE '' + @tmp_tbl_name12
EXEC sp_executesql @SQLStmt
SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

----------------------------------------------------------------
-- Counter records
----------------------------------------------------------------
SET @SQLStmt = ''''
IF RTRIM(@input_COUNTABLE_VIEWIDS) = '''' OR @input_COUNTABLE_VIEWIDS IS NULL
BEGIN
SET @SQLStmt =
N''SELECT
	au.id_sess,
	au.id_acc,
	au.id_payee,
	au.dt_session,
	au.id_pi_template,
	ui.dt_start ui_dt_start,
	ui.dt_end ui_dt_end,
	pci.id_interval pci_id_interval,
	--Changed on 5/3 to take the group subscription dates into consideration
	CASE WHEN 
		gsm.id_group IS NOT NULL AND gs.b_supportgroupops = ''''Y''''
		THEN 1 ELSE 0 
	END group_acc_flag,
	CASE WHEN
		gsm.id_group IS NOT NULL AND gs.b_supportgroupops = ''''Y''''
		THEN gsm.id_group ELSE au.id_payee 
	END group_acc_id ''
	+ CAST(@input_COUNTABLE_PROPERTIES AS nvarchar(2000)) 
	+ N'' 
INTO '' + CAST(@tmp_tbl_name2 AS nvarchar(50)) + N'' 
FROM
	t_acc_usage au 
	--Changed on 5/3 to take the group subscription dates into consideration
	LEFT OUTER JOIN t_gsubmember gsm
	  INNER JOIN t_group_sub gs ON gs.id_group = gsm.id_group 
    INNER JOIN t_sub s ON gs.id_group = s.id_group 
  ON gsm.id_acc = au.id_payee AND s.id_po = au.id_prod AND au.dt_session BETWEEN gsm.vt_start AND gsm.vt_end '' 
  + CAST(@input_COUNTABLE_OJOINS AS nvarchar(2000)) + N'',
	t_usage_interval ui,
	(SELECT DISTINCT pci_id_interval FROM '' + CAST(@tmp_tbl_name1 AS nvarchar(50)) 
	+ N'' ) agi,
	t_pc_interval pci
WHERE
	au.id_view IS NULL AND
	ui.id_interval = au.id_usage_interval AND
	pci.id_interval = agi.pci_id_interval AND 
	au.dt_session BETWEEN pci.dt_start AND pci.dt_end AND
	au.dt_session >= @dag_dt_start ''
	+ CAST(@input_ACCOUNT_FILTER AS nvarchar(2000)) 
END
ELSE
BEGIN
SET @SQLStmt =
N''SELECT
	au.id_sess,
	au.id_acc,
	au.id_payee,
	au.dt_session,
	au.id_pi_template,
	ui.dt_start ui_dt_start,
	ui.dt_end ui_dt_end,
	pci.id_interval pci_id_interval,
	--Changed on 5/3 to take the group subscription dates into consideration
	CASE WHEN 
		gsm.id_group IS NOT NULL AND gs.b_supportgroupops = ''''Y''''
		THEN 1 ELSE 0 
	END group_acc_flag,
	CASE WHEN
		gsm.id_group IS NOT NULL AND gs.b_supportgroupops = ''''Y''''
		THEN gsm.id_group ELSE au.id_payee 
	END group_acc_id ''
	+ CAST(@input_COUNTABLE_PROPERTIES AS nvarchar(2000)) 
	+ N'' 
INTO '' + CAST(@tmp_tbl_name2 AS nvarchar(50)) + N'' 
FROM
	t_acc_usage au 
	--Changed on 5/3 to take the group subscription dates into consideration
	LEFT OUTER JOIN t_gsubmember gsm 
	  INNER JOIN t_group_sub gs ON gs.id_group = gsm.id_group 
    INNER JOIN t_sub s ON s.id_group=gs.id_group 
  ON gsm.id_acc = au.id_payee AND s.id_po = au.id_prod AND au.dt_session BETWEEN gsm.vt_start AND gsm.vt_end '' 
  + CAST(@input_COUNTABLE_OJOINS AS nvarchar(2000)) + N'',
	t_usage_interval ui,
	(SELECT DISTINCT pci_id_interval FROM '' + CAST(@tmp_tbl_name1 AS nvarchar(50)) 
	+ N'' ) agi,
	t_pc_interval pci
WHERE
	(au.id_view IS NULL OR au.id_view in ('' + CAST(@input_COUNTABLE_VIEWIDS AS nvarchar(2000)) + N'')) AND
	ui.id_interval = au.id_usage_interval AND
	pci.id_interval = agi.pci_id_interval AND 
	au.dt_session BETWEEN pci.dt_start AND pci.dt_end AND
	au.dt_session >= @dag_dt_start ''
	+ CAST(@input_ACCOUNT_FILTER AS nvarchar(2000)) 
END
--PRINT @SQLStmt
EXEC sp_executesql @SQLStmt, N''@dag_dt_start datetime'', @ag_dt_start

SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError
IF @debug_flag = 1 AND @input_RUN_ID IS NOT NULL
BEGIN
  INSERT INTO t_recevent_run_details (id_run, tx_type, tx_detail, dt_crt)
  VALUES (@input_RUN_ID, ''Debug'', ''Finished inserting into the temp2 table'', getutcdate())
	SELECT @SQLError = @@ERROR
	IF @SQLError <> 0 GOTO FatalError
END
--PRINT ''completed: to obtain the counter records''
--PRINT CONVERT(char, getdate(), 109)

----------------------------------------------------------------
-- Calculate the counters
----------------------------------------------------------------
-- 11/11/2002
-- Check to see which method to use to calculate the counters
SET @max_loop_cnt = 0
SET @SQLStmt =
N''SELECT @max_loop_cnt = MAX(cnt) FROM ''
+ N''(SELECT COUNT(*) cnt FROM '' + CAST(@tmp_tbl_name2 AS nvarchar(50))
+ N'' GROUP BY group_acc_flag, group_acc_id) tmptbl''
--PRINT @SQLStmt
EXEC sp_executesql @SQLStmt,
	N''@max_loop_cnt int OUTPUT'',
	@max_loop_cnt = @max_loop_cnt OUTPUT

SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

IF @input_COUNTER_FORMULAS IS NULL 
   OR @input_COUNTER_FORMULAS = ''''
   OR @max_loop_cnt IS NULL 
-- 1/2/2003 Always use the linear approach.
-- Uncomment the following line if want to use either the selfjoin or the linear approach 
-- depending on the data volume.
--   OR @max_loop_cnt <= 1000
-- Use the selfjoin approach
BEGIN
SET @SQLStmt = ''''
SET @SQLStmt = 
N''SELECT tp1.id_sess '' + @input_COUNTER_FORMULAS + N'' 
INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) 
+ N'' FROM '' + CAST(@tmp_tbl_name1 AS nvarchar(50)) 
+ N'' tp1 LEFT OUTER JOIN '' + CAST(@tmp_tbl_name2 AS nvarchar(50)) 
+ N'' tp2 ON tp2.group_acc_flag = tp1.group_acc_flag AND tp2.group_acc_id = tp1.group_acc_id
	AND tp2.dt_session BETWEEN tp1.pci_dt_start AND tp1.pci_dt_end
	AND (tp2.ui_dt_end < tp1.ui_dt_end 
		OR (tp2.ui_dt_end = tp1.ui_dt_end 
		AND tp2.dt_session < tp1.dt_session)
		OR (tp2.ui_dt_end = tp1.ui_dt_end 
		AND tp2.dt_session = tp1.dt_session 
		AND tp2.id_sess < tp1.id_sess))
GROUP BY tp1.id_sess''

EXEC sp_executesql @SQLStmt
SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError
IF @debug_flag = 1 AND @input_RUN_ID IS NOT NULL
BEGIN
  INSERT INTO t_recevent_run_details (id_run, tx_type, tx_detail, dt_crt)
  VALUES (@input_RUN_ID, ''Debug'', ''Finished inserting into the temp3 table'', getutcdate())
	SELECT @SQLError = @@ERROR
	IF @SQLError <> 0 GOTO FatalError
END
END -- End of the selfjoin approach
ELSE
-- Use the linear approach
BEGIN
SET @countable_0 = 0
SET @countable_1 = 0
SET @countable_2 = 0
SET @countable_3 = 0
SET @countable_4 = 0
SET @countable_5 = 0
SET @countable_6 = 0
SET @countable_7 = 0
SET @countable_8 = 0
SET @countable_9 = 0
SET @countable_10 = 0
SET @countable_11 = 0
SET @countable_12 = 0
SET @countable_13 = 0
SET @countable_14 = 0
SET @countable_15 = 0
SET @countable_16 = 0
SET @countable_17 = 0
SET @countable_18 = 0
SET @countable_19 = 0

SET @rec_count_0 = 0
SET @rec_count_1 = 0
SET @rec_count_2 = 0
SET @rec_count_3 = 0
SET @rec_count_4 = 0
SET @rec_count_5 = 0
SET @rec_count_6 = 0
SET @rec_count_7 = 0
SET @rec_count_8 = 0
SET @rec_count_9 = 0
SET @rec_count_10 = 0
SET @rec_count_11 = 0
SET @rec_count_12 = 0
SET @rec_count_13 = 0
SET @rec_count_14 = 0
SET @rec_count_15 = 0
SET @rec_count_16 = 0
SET @rec_count_17 = 0
SET @rec_count_18 = 0
SET @rec_count_19 = 0

SET @countable_count = LEN(RTRIM(@input_COUNTABLE_PROPERTIES)) - LEN(RTRIM(REPLACE(@input_COUNTABLE_PROPERTIES, '','' , '''')))
--PRINT @countable_count
SET @formula_count = LEN(RTRIM(@input_COUNTER_FORMULAS_ALIASES)) - LEN(RTRIM(REPLACE(@input_COUNTER_FORMULAS_ALIASES, '','' , '''')))
--PRINT @formula_count

-- Parse the @input_COUNTER_FORMULAS string to obtain the "temp" table column names
SET @work_counter_formulas = @input_COUNTER_FORMULAS
-- remove the leading comma and add the trailing comma
SET @work_counter_formulas = SUBSTRING(@work_counter_formulas,3,LEN(@work_counter_formulas)) + '', ''
-- remove the ISNULL
SET @work_counter_formulas = REPLACE(REPLACE(@work_counter_formulas, ''ISNULL('', ''''), '', 0)'', '''')

SET @loop_index = -1
WHILE LEN(@work_counter_formulas) > 0
BEGIN
	SET @loop_index = @loop_index + 1
	SET @as_index = PATINDEX(''% AS %'', @work_counter_formulas)
	SET @comma_index = PATINDEX(''%, %'', @work_counter_formulas)
	IF @loop_index = 0
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_0 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_0 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_0 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_0 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_0 = REPLACE(@countable_formula_0, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_0, ''countable_'', ''@rec_count_'')
		END
	END
	ELSE IF @loop_index = 1
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_1 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_1 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_1 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_1 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_1 = REPLACE(@countable_formula_1, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_1, ''countable_'', ''@rec_count_'')
		END
	END
	ELSE IF @loop_index = 2
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_2 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_2 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_2 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_2 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_2 = REPLACE(@countable_formula_2, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_2, ''countable_'', ''@rec_count_'')
		END
	END
	ELSE IF @loop_index = 3
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_3 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_3 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_3 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_3 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_3 = REPLACE(@countable_formula_3, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_3, ''countable_'', ''@rec_count_'')
		END
	END
	ELSE IF @loop_index = 4
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_4 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_4 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_4 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_4 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_4 = REPLACE(@countable_formula_4, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_4, ''countable_'', ''@rec_count_'')
		END
	END
	ELSE IF @loop_index = 5
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_5 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_5 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_5 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_5 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_5 = REPLACE(@countable_formula_5, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_5, ''countable_'', ''@rec_count_'')
		END
	END
	ELSE IF @loop_index = 6
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_6 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_6 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_6 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_6 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_6 = REPLACE(@countable_formula_6, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_6, ''countable_'', ''@rec_count_'')
		END
	END
	ELSE IF @loop_index = 7
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_7 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_7 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_7 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_7 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_7 = REPLACE(@countable_formula_7, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_7, ''countable_'', ''@rec_count_'')
		END
	END
	ELSE IF @loop_index = 8
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_8 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_8 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_8 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_8 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_8 = REPLACE(@countable_formula_8, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_8, ''countable_'', ''@rec_count_'')
		END
	END
	ELSE IF @loop_index = 9
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_9 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_9 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_9 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_9 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_9 = REPLACE(@countable_formula_9, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_9, ''countable_'', ''@rec_count_'')
		END
	END
	ELSE IF @loop_index = 10
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_10 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_10 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_10 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_10 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_10 = REPLACE(@countable_formula_10, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_10, ''countable_'', ''@rec_count_'')
		END
	END
	ELSE IF @loop_index = 11
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_11 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_11 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_11 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_11 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_11 = REPLACE(@countable_formula_11, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_11, ''countable_'', ''@rec_count_'')
		END
	END
	ELSE IF @loop_index = 12
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_12 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_12 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_12 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_12 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_12 = REPLACE(@countable_formula_12, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_12, ''countable_'', ''@rec_count_'')
		END
	END
	ELSE IF @loop_index = 13
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_13 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_13 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_13 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_13 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_13 = REPLACE(@countable_formula_13, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_13, ''countable_'', ''@rec_count_'')
		END
	END
	ELSE IF @loop_index = 14
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_14 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_14 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_14 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_14 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_14 = REPLACE(@countable_formula_14, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_14, ''countable_'', ''@rec_count_'')
		END
	END
	ELSE IF @loop_index = 15
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_15 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_15 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_15 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_15 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_15 = REPLACE(@countable_formula_15, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_15, ''countable_'', ''@rec_count_'')
		END
	END
	ELSE IF @loop_index = 16
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_16 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_16 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_16 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_16 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_16 = REPLACE(@countable_formula_16, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_16, ''countable_'', ''@rec_count_'')
		END
	END
	ELSE IF @loop_index = 17
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_17 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_17 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_17 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_17 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_17 = REPLACE(@countable_formula_17, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_17, ''countable_'', ''@rec_count_'')
		END
	END
	ELSE IF @loop_index = 18
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_18 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_18 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_18 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_18 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_18 = REPLACE(@countable_formula_18, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_18, ''countable_'', ''@rec_count_'')
		END
	END
	ELSE IF @loop_index = 19
	BEGIN
		SET @work_counter = SUBSTRING(@work_counter_formulas, 1, @as_index-1)
		SET @counter_resultfieldname_19 = SUBSTRING(@work_counter_formulas, @as_index+4, @comma_index-@as_index-4)

		IF PATINDEX(''%(SUM(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_19 = REPLACE(REPLACE(@work_counter, ''SUM'', ''''), ''tp2.'', ''@'')
		END
		ELSE IF PATINDEX(''%(COUNT(%'',@work_counter) > 0
		BEGIN			SET @countable_formula_19 = REPLACE(REPLACE(@work_counter, ''(COUNT('', ''((''), ''tp2.countable_'', ''@rec_count_'')
		END
		ELSE IF PATINDEX(''%(AVG(%'',@work_counter) > 0
		BEGIN
			SET @countable_formula_19 = REPLACE(REPLACE(@work_counter, ''AVG'', ''''), ''tp2.'', '''')
			SET @countable_formula_19 = REPLACE(@countable_formula_19, ''countable_'', ''@countable_'')
				+ ''/'' + REPLACE(@countable_formula_19, ''countable_'', ''@rec_count_'')
		END
	END

	SET @work_counter_formulas = SUBSTRING(@work_counter_formulas, @comma_index+2, LEN(@work_counter_formulas))
	--PRINT @work_counter_formulas
END
-- end of the string parsing to extract counter formulas

-- Create the @tmp_tbl_name3 table
IF @formula_count = 1
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6) ) ''
ELSE IF @formula_count = 2
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_1 + N'' NUMERIC (38,6) ) ''
ELSE IF @formula_count = 3
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_1 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_2 + N'' NUMERIC (38,6) ) ''
ELSE IF @formula_count = 4
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_1 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_2 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_3 + N'' NUMERIC (38,6) ) ''
ELSE IF @formula_count = 5
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_1 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_2 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_3 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_4 + N'' NUMERIC (38,6) ) ''
ELSE IF @formula_count = 6
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_1 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_2 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_3 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_4 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_5 + N'' NUMERIC (38,6) ) ''
ELSE IF @formula_count = 7
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_1 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_2 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_3 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_4 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_5 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_6 + N'' NUMERIC (38,6) ) ''
ELSE IF @formula_count = 8
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_1 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_2 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_3 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_4 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_5 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_6 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_7 + N'' NUMERIC (38,6) ) ''
ELSE IF @formula_count = 9
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_1 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_2 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_3 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_4 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_5 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_6 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_7 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_8 + N'' NUMERIC (38,6) ) ''
ELSE IF @formula_count = 10
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_1 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_2 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_3 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_4 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_5 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_6 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_7 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_8 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_9 + N'' NUMERIC (38,6) ) ''
ELSE IF @formula_count = 11
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_1 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_2 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_3 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_4 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_5 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_6 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_7 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_8 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_9 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_10 + N'' NUMERIC (38,6) ) ''
ELSE IF @formula_count = 12
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_1 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_2 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_3 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_4 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_5 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_6 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_7 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_8 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_9 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_10 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_11 + N'' NUMERIC (38,6) ) ''
ELSE IF @formula_count = 13
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_1 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_2 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_3 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_4 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_5 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_6 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_7 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_8 + N'' NUMERIC (38,6), ''		+ @counter_resultfieldname_9 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_10 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_11 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_12 + N'' NUMERIC (38,6) ) ''
ELSE IF @formula_count = 14
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_1 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_2 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_3 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_4 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_5 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_6 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_7 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_8 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_9 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_10 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_11 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_12 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_13 + N'' NUMERIC (38,6) ) ''
ELSE IF @formula_count = 15
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_1 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_2 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_3 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_4 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_5 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_6 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_7 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_8 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_9 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_10 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_11 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_12 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_13 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_14 + N'' NUMERIC (38,6) ) ''
ELSE IF @formula_count = 16
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_1 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_2 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_3 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_4 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_5 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_6 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_7 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_8 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_9 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_10 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_11 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_12 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_13 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_14 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_15 + N'' NUMERIC (38,6) ) ''
ELSE IF @formula_count = 17
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_1 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_2 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_3 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_4 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_5 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_6 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_7 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_8 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_9 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_10 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_11 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_12 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_13 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_14 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_15 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_16 + N'' NUMERIC (38,6) ) ''
ELSE IF @formula_count = 18
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_1 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_2 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_3 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_4 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_5 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_6 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_7 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_8 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_9 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_10 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_11 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_12 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_13 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_14 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_15 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_16 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_17 + N'' NUMERIC (38,6) ) ''
ELSE IF @formula_count = 19
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_1 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_2 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_3 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_4 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_5 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_6 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_7 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_8 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_9 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_10 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_11 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_12 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_13 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_14 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_15 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_16 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_17 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_18 + N'' NUMERIC (38,6) ) ''
ELSE IF @formula_count = 20
	SET @SQLStmt = N''CREATE TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' ( id_sess bigint, ''
		+ @counter_resultfieldname_0 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_1 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_2 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_3 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_4 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_5 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_6 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_7 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_8 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_9 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_10 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_11 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_12 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_13 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_14 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_15 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_16 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_17 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_18 + N'' NUMERIC (38,6), ''
		+ @counter_resultfieldname_19 + N'' NUMERIC (38,6) ) ''
--PRINT @SQLStmt
EXEC sp_executesql @SQLStmt
-- End of creating the table

-- Linear processing, 12/31/2002
IF @countable_count = 1 
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''
	+ N'' countable_0''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
ELSE IF @countable_count = 2
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''
	+ N'' countable_0,''
	+ N'' countable_1''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
ELSE IF @countable_count = 3
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0,0,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass,''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''
	+ N'' countable_0,''
	+ N'' countable_1,''
	+ N'' countable_2''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
ELSE IF @countable_count = 4
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0,0,0,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass,''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''
	+ N'' countable_0,''
	+ N'' countable_1,''
	+ N'' countable_2,''
	+ N'' countable_3''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
ELSE IF @countable_count = 5
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0,0,0,0,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass,''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''
	+ N'' countable_0,''
	+ N'' countable_1,''
	+ N'' countable_2,''
	+ N'' countable_3,''
	+ N'' countable_4''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
ELSE IF @countable_count = 6
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0,0,0,0,0,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass,''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''
	+ N'' countable_0,''
	+ N'' countable_1,''
	+ N'' countable_2,''
	+ N'' countable_3,''
	+ N'' countable_4,''
	+ N'' countable_5''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
ELSE IF @countable_count = 7
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0,0,0,0,0,0,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass,''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''
	+ N'' countable_0,''
	+ N'' countable_1,''
	+ N'' countable_2,''
	+ N'' countable_3,''
	+ N'' countable_4,''
	+ N'' countable_5,''
	+ N'' countable_6''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
ELSE IF @countable_count = 8
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0,0,0,0,0,0,0,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass,''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''
	+ N'' countable_0,''
	+ N'' countable_1,''
	+ N'' countable_2,''
	+ N'' countable_3,''
	+ N'' countable_4,''
	+ N'' countable_5,''
	+ N'' countable_6,''
	+ N'' countable_7''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
ELSE IF @countable_count = 9
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0,0,0,0,0,0,0,0,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass,''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''
	+ N'' countable_0,''
	+ N'' countable_1,''
	+ N'' countable_2,''
	+ N'' countable_3,''
	+ N'' countable_4,''
	+ N'' countable_5,''
	+ N'' countable_6,''
	+ N'' countable_7,''
	+ N'' countable_8''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
ELSE IF @countable_count = 10
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0,0,0,0,0,0,0,0,0,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass,''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''
	+ N'' countable_0,''
	+ N'' countable_1,''
	+ N'' countable_2,''
	+ N'' countable_3,''
	+ N'' countable_4,''
	+ N'' countable_5,''
	+ N'' countable_6,''
	+ N'' countable_7,''
	+ N'' countable_8,''
	+ N'' countable_9''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
ELSE IF @countable_count = 11
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0,0,0,0,0,0,0,0,0,0,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass,''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''
	+ N'' countable_0,''
	+ N'' countable_1,''
	+ N'' countable_2,''
	+ N'' countable_3,''
	+ N'' countable_4,''
	+ N'' countable_5,''
	+ N'' countable_6,''
	+ N'' countable_7,''
	+ N'' countable_8,''
	+ N'' countable_9,''
	+ N'' countable_10''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
ELSE IF @countable_count = 12
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0,0,0,0,0,0,0,0,0,0,0,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass,''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''
	+ N'' countable_0,''
	+ N'' countable_1,''
	+ N'' countable_2,''
	+ N'' countable_3,''
	+ N'' countable_4,''
	+ N'' countable_5,''
	+ N'' countable_6,''
	+ N'' countable_7,''
	+ N'' countable_8,''
	+ N'' countable_9,''
	+ N'' countable_10,''
	+ N'' countable_11''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
ELSE IF @countable_count = 13
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0,0,0,0,0,0,0,0,0,0,0,0,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass,''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''
	+ N'' countable_0,''
	+ N'' countable_1,''
	+ N'' countable_2,''
	+ N'' countable_3,''
	+ N'' countable_4,''
	+ N'' countable_5,''
	+ N'' countable_6,''
	+ N'' countable_7,''
	+ N'' countable_8,''
	+ N'' countable_9,''
	+ N'' countable_10,''
	+ N'' countable_11,''
	+ N'' countable_12''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
ELSE IF @countable_count = 14
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0,0,0,0,0,0,0,0,0,0,0,0,0,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass,''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''
	+ N'' countable_0,''
	+ N'' countable_1,''
	+ N'' countable_2,''
	+ N'' countable_3,''
	+ N'' countable_4,''
	+ N'' countable_5,''
	+ N'' countable_6,''
	+ N'' countable_7,''
	+ N'' countable_8,''
	+ N'' countable_9,''
	+ N'' countable_10,''
	+ N'' countable_11,''
	+ N'' countable_12,''
	+ N'' countable_13''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
ELSE IF @countable_count = 15
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass,''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''
	+ N'' countable_0,''
	+ N'' countable_1,''
	+ N'' countable_2,''
	+ N'' countable_3,''
	+ N'' countable_4,''
	+ N'' countable_5,''
	+ N'' countable_6,''
	+ N'' countable_7,''
	+ N'' countable_8,''
	+ N'' countable_9,''
	+ N'' countable_10,''
	+ N'' countable_11,''
	+ N'' countable_12,''
	+ N'' countable_13,''
	+ N'' countable_14''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
ELSE IF @countable_count = 16
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass,''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''
	+ N'' countable_0,''
	+ N'' countable_1,''
	+ N'' countable_2,''
	+ N'' countable_3,''
	+ N'' countable_4,''
	+ N'' countable_5,''
	+ N'' countable_6,''
	+ N'' countable_7,''
	+ N'' countable_8,''
	+ N'' countable_9,''
	+ N'' countable_10,''
	+ N'' countable_11,''
	+ N'' countable_12,''
	+ N'' countable_13,''
	+ N'' countable_14,''
	+ N'' countable_15''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
ELSE IF @countable_count = 17
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass,''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''
	+ N'' countable_0,''
	+ N'' countable_1,''
	+ N'' countable_2,''
	+ N'' countable_3,''
	+ N'' countable_4,''
	+ N'' countable_5,''
	+ N'' countable_6,''
	+ N'' countable_7,''
	+ N'' countable_8,''
	+ N'' countable_9,''
	+ N'' countable_10,''
	+ N'' countable_11,''
	+ N'' countable_12,''
	+ N'' countable_13,''
	+ N'' countable_14,''
	+ N'' countable_15,''
	+ N'' countable_16''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
ELSE IF @countable_count = 18
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass,''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''
	+ N'' countable_0,''
	+ N'' countable_1,''
	+ N'' countable_2,''
	+ N'' countable_3,''
	+ N'' countable_4,''
	+ N'' countable_5,''
	+ N'' countable_6,''
	+ N'' countable_7,''
	+ N'' countable_8,''
	+ N'' countable_9,''
	+ N'' countable_10,''
	+ N'' countable_11,''
	+ N'' countable_12,''
	+ N'' countable_13,''
	+ N'' countable_14,''
	+ N'' countable_15,''
	+ N'' countable_16,''
	+ N'' countable_17''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
ELSE IF @countable_count = 19
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass,''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''	+ N'' countable_0,''
	+ N'' countable_1,''
	+ N'' countable_2,''
	+ N'' countable_3,''
	+ N'' countable_4,''
	+ N'' countable_5,''
	+ N'' countable_6,''
	+ N'' countable_7,''
	+ N'' countable_8,''
	+ N'' countable_9,''
	+ N'' countable_10,''
	+ N'' countable_11,''
	+ N'' countable_12,''
	+ N'' countable_13,''
	+ N'' countable_14,''
	+ N'' countable_15,''
	+ N'' countable_16,''
	+ N'' countable_17,''
	+ N'' countable_18''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
ELSE IF @countable_count = 20
BEGIN
	SET @SQLStmt = 
	N''DECLARE calc_cursor CURSOR GLOBAL FOR ''
	+ N'' SELECT 1 id_pass, ''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' pci_dt_start,pci_dt_end,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 FROM '' 
	+ CAST(@tmp_tbl_name1 AS nvarchar(50))
	+ N'' UNION ALL ''
	+ N'' SELECT 2 id_pass,''
	+ N'' id_sess,id_acc,group_acc_flag,group_acc_id,pci_id_interval,dt_session,ui_dt_start,ui_dt_end,''
	+ N'' NULL,NULL,''
	+ N'' countable_0,''
	+ N'' countable_1,''
	+ N'' countable_2,''
	+ N'' countable_3,''
	+ N'' countable_4,''
	+ N'' countable_5,''
	+ N'' countable_6,''
	+ N'' countable_7,''
	+ N'' countable_8,''
	+ N'' countable_9,''
	+ N'' countable_10,''
	+ N'' countable_11,''
	+ N'' countable_12,''
	+ N'' countable_13,''
	+ N'' countable_14,''
	+ N'' countable_15,''
	+ N'' countable_16,''
	+ N'' countable_17,''
	+ N'' countable_18,''
	+ N'' countable_19''
	+ N'' FROM ''
	+ CAST(@tmp_tbl_name2 AS nvarchar(50))
	+ N'' ORDER BY group_acc_flag,group_acc_id,pci_id_interval,ui_dt_end,dt_session,id_sess, id_pass''
END
-- PRINT @SQLStmt

EXEC sp_executesql @SQLStmt
SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

OPEN calc_cursor 
SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

IF @countable_count = 1
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0
END
ELSE IF @countable_count = 2
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1
END
ELSE IF @countable_count = 3
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2
END
ELSE IF @countable_count = 4
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3
END
ELSE IF @countable_count = 5
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4
END
ELSE IF @countable_count = 6
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5
END
ELSE IF @countable_count = 7
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6
END
ELSE IF @countable_count = 8
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7
END
ELSE IF @countable_count = 9
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8
END
ELSE IF @countable_count = 10
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9
END
ELSE IF @countable_count = 11
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10
END
ELSE IF @countable_count = 12
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10,@cur_countable_11
END
ELSE IF @countable_count = 13
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10,@cur_countable_11,
	@cur_countable_12
END
ELSE IF @countable_count = 14
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10,@cur_countable_11,
	@cur_countable_12,@cur_countable_13
END
ELSE IF @countable_count = 15
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10,@cur_countable_11,
	@cur_countable_12,@cur_countable_13,@cur_countable_14
END
ELSE IF @countable_count = 16
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10,@cur_countable_11,
	@cur_countable_12,@cur_countable_13,@cur_countable_14,@cur_countable_15
END
ELSE IF @countable_count = 17
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10,@cur_countable_11,
	@cur_countable_12,@cur_countable_13,@cur_countable_14,@cur_countable_15,@cur_countable_16
END
ELSE IF @countable_count = 18
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10,@cur_countable_11,
	@cur_countable_12,@cur_countable_13,@cur_countable_14,@cur_countable_15,@cur_countable_16,@cur_countable_17
END
ELSE IF @countable_count = 19
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10,@cur_countable_11,
	@cur_countable_12,@cur_countable_13,@cur_countable_14,@cur_countable_15,@cur_countable_16,@cur_countable_17,
	@cur_countable_18
END
ELSE IF @countable_count = 20
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10,@cur_countable_11,
	@cur_countable_12,@cur_countable_13,@cur_countable_14,@cur_countable_15,@cur_countable_16,@cur_countable_17,
	@cur_countable_18,@cur_countable_19
END

SET @FetchStatusCalc = @@FETCH_STATUS
SET @pre_group_acc_flag = 0
SET @pre_group_acc_id = 0
SET @pre_pci_id_interval = 0

WHILE @FetchStatusCalc <> -1
BEGIN
	-- Reset the counters when necessary
	IF @FetchStatusCalc = 0
		AND (@cur_group_acc_flag <> @pre_group_acc_flag 
		     OR @cur_group_acc_id <> @pre_group_acc_id
		     OR @cur_pci_id_interval <> @pre_pci_id_interval
		    )
	BEGIN
		SET @pre_pci_id_interval = @cur_pci_id_interval
		SET @pre_group_acc_flag = @cur_group_acc_flag
		SET @pre_group_acc_id = @cur_group_acc_id

		IF @countable_count = 1
		BEGIN
			SET @countable_0 = 0

			SET @rec_count_0 = 0
		END
		ELSE IF @countable_count = 2
		BEGIN
			SET @countable_0 = 0
			SET @countable_1 = 0

			SET @rec_count_0 = 0
			SET @rec_count_1 = 0
		END
		ELSE IF @countable_count = 3
		BEGIN
			SET @countable_0 = 0
			SET @countable_1 = 0
			SET @countable_2 = 0

			SET @rec_count_0 = 0
			SET @rec_count_1 = 0
			SET @rec_count_2 = 0
		END
		ELSE IF @countable_count = 4
		BEGIN
			SET @countable_0 = 0
			SET @countable_1 = 0
			SET @countable_2 = 0
			SET @countable_3 = 0

			SET @rec_count_0 = 0
			SET @rec_count_1 = 0
			SET @rec_count_2 = 0
			SET @rec_count_3 = 0
		END
		ELSE IF @countable_count = 5
		BEGIN
			SET @countable_0 = 0
			SET @countable_1 = 0
			SET @countable_2 = 0
			SET @countable_3 = 0
			SET @countable_4 = 0

			SET @rec_count_0 = 0
			SET @rec_count_1 = 0
			SET @rec_count_2 = 0
			SET @rec_count_3 = 0
			SET @rec_count_4 = 0
		END
		ELSE IF @countable_count = 6
		BEGIN
			SET @countable_0 = 0
			SET @countable_1 = 0
			SET @countable_2 = 0
			SET @countable_3 = 0
			SET @countable_4 = 0
			SET @countable_5 = 0

			SET @rec_count_0 = 0
			SET @rec_count_1 = 0
			SET @rec_count_2 = 0
			SET @rec_count_3 = 0
			SET @rec_count_4 = 0
			SET @rec_count_5 = 0
		END
		ELSE IF @countable_count = 7
		BEGIN
			SET @countable_0 = 0
			SET @countable_1 = 0
			SET @countable_2 = 0
			SET @countable_3 = 0
			SET @countable_4 = 0
			SET @countable_5 = 0
			SET @countable_6 = 0

			SET @rec_count_0 = 0
			SET @rec_count_1 = 0
			SET @rec_count_2 = 0
			SET @rec_count_3 = 0
			SET @rec_count_4 = 0
			SET @rec_count_5 = 0
			SET @rec_count_6 = 0
		END
		ELSE IF @countable_count = 8
		BEGIN
			SET @countable_0 = 0
			SET @countable_1 = 0
			SET @countable_2 = 0
			SET @countable_3 = 0
			SET @countable_4 = 0
			SET @countable_5 = 0
			SET @countable_6 = 0
			SET @countable_7 = 0

			SET @rec_count_0 = 0
			SET @rec_count_1 = 0
			SET @rec_count_2 = 0
			SET @rec_count_3 = 0
			SET @rec_count_4 = 0
			SET @rec_count_5 = 0
			SET @rec_count_6 = 0
			SET @rec_count_7 = 0
		END
		ELSE IF @countable_count = 9
		BEGIN
			SET @countable_0 = 0
			SET @countable_1 = 0
			SET @countable_2 = 0
			SET @countable_3 = 0
			SET @countable_4 = 0
			SET @countable_5 = 0
			SET @countable_6 = 0
			SET @countable_7 = 0
			SET @countable_8 = 0

			SET @rec_count_0 = 0
			SET @rec_count_1 = 0
			SET @rec_count_2 = 0
			SET @rec_count_3 = 0
			SET @rec_count_4 = 0
			SET @rec_count_5 = 0
			SET @rec_count_6 = 0
			SET @rec_count_7 = 0
			SET @rec_count_8 = 0
		END
		ELSE IF @countable_count = 10
		BEGIN
			SET @countable_0 = 0
			SET @countable_1 = 0
			SET @countable_2 = 0
			SET @countable_3 = 0
			SET @countable_4 = 0
			SET @countable_5 = 0
			SET @countable_6 = 0			SET @countable_7 = 0
			SET @countable_8 = 0
			SET @countable_9 = 0

			SET @rec_count_0 = 0
			SET @rec_count_1 = 0
			SET @rec_count_2 = 0
			SET @rec_count_3 = 0
			SET @rec_count_4 = 0
			SET @rec_count_5 = 0
			SET @rec_count_6 = 0
			SET @rec_count_7 = 0
			SET @rec_count_8 = 0
			SET @rec_count_9 = 0
		END
		ELSE IF @countable_count = 11
		BEGIN
			SET @countable_0 = 0
			SET @countable_1 = 0
			SET @countable_2 = 0
			SET @countable_3 = 0
			SET @countable_4 = 0
			SET @countable_5 = 0
			SET @countable_6 = 0
			SET @countable_7 = 0
			SET @countable_8 = 0
			SET @countable_9 = 0
			SET @countable_10 = 0

			SET @rec_count_0 = 0
			SET @rec_count_1 = 0
			SET @rec_count_2 = 0
			SET @rec_count_3 = 0
			SET @rec_count_4 = 0
			SET @rec_count_5 = 0
			SET @rec_count_6 = 0
			SET @rec_count_7 = 0
			SET @rec_count_8 = 0
			SET @rec_count_9 = 0
			SET @rec_count_10 = 0
		END
		ELSE IF @countable_count = 12
		BEGIN
			SET @countable_0 = 0
			SET @countable_1 = 0
			SET @countable_2 = 0
			SET @countable_3 = 0
			SET @countable_4 = 0
			SET @countable_5 = 0
			SET @countable_6 = 0
			SET @countable_7 = 0
			SET @countable_8 = 0
			SET @countable_9 = 0
			SET @countable_10 = 0
			SET @countable_11 = 0

			SET @rec_count_0 = 0
			SET @rec_count_1 = 0
			SET @rec_count_2 = 0
			SET @rec_count_3 = 0
			SET @rec_count_4 = 0
			SET @rec_count_5 = 0
			SET @rec_count_6 = 0
			SET @rec_count_7 = 0
			SET @rec_count_8 = 0
			SET @rec_count_9 = 0
			SET @rec_count_10 = 0
			SET @rec_count_11 = 0
		END
		ELSE IF @countable_count = 13
		BEGIN
			SET @countable_0 = 0
			SET @countable_1 = 0
			SET @countable_2 = 0
			SET @countable_3 = 0
			SET @countable_4 = 0
			SET @countable_5 = 0
			SET @countable_6 = 0
			SET @countable_7 = 0
			SET @countable_8 = 0
			SET @countable_9 = 0
			SET @countable_10 = 0
			SET @countable_11 = 0
			SET @countable_12 = 0

			SET @rec_count_0 = 0
			SET @rec_count_1 = 0
			SET @rec_count_2 = 0
			SET @rec_count_3 = 0
			SET @rec_count_4 = 0
			SET @rec_count_5 = 0
			SET @rec_count_6 = 0
			SET @rec_count_7 = 0
			SET @rec_count_8 = 0
			SET @rec_count_9 = 0
			SET @rec_count_10 = 0
			SET @rec_count_11 = 0
			SET @rec_count_12 = 0
		END
		ELSE IF @countable_count = 14
		BEGIN
			SET @countable_0 = 0
			SET @countable_1 = 0
			SET @countable_2 = 0
			SET @countable_3 = 0
			SET @countable_4 = 0
			SET @countable_5 = 0
			SET @countable_6 = 0
			SET @countable_7 = 0
			SET @countable_8 = 0
			SET @countable_9 = 0
			SET @countable_10 = 0
			SET @countable_11 = 0
			SET @countable_12 = 0
			SET @countable_13 = 0

			SET @rec_count_0 = 0
			SET @rec_count_1 = 0
			SET @rec_count_2 = 0
			SET @rec_count_3 = 0
			SET @rec_count_4 = 0
			SET @rec_count_5 = 0
			SET @rec_count_6 = 0
			SET @rec_count_7 = 0
			SET @rec_count_8 = 0
			SET @rec_count_9 = 0
			SET @rec_count_10 = 0
			SET @rec_count_11 = 0
			SET @rec_count_12 = 0
			SET @rec_count_13 = 0
		END
		ELSE IF @countable_count = 15
		BEGIN
			SET @countable_0 = 0
			SET @countable_1 = 0
			SET @countable_2 = 0
			SET @countable_3 = 0
			SET @countable_4 = 0
			SET @countable_5 = 0
			SET @countable_6 = 0
			SET @countable_7 = 0
			SET @countable_8 = 0
			SET @countable_9 = 0
			SET @countable_10 = 0
			SET @countable_11 = 0
			SET @countable_12 = 0
			SET @countable_13 = 0
			SET @countable_14 = 0

			SET @rec_count_0 = 0
			SET @rec_count_1 = 0
			SET @rec_count_2 = 0
			SET @rec_count_3 = 0
			SET @rec_count_4 = 0
			SET @rec_count_5 = 0
			SET @rec_count_6 = 0
			SET @rec_count_7 = 0
			SET @rec_count_8 = 0
			SET @rec_count_9 = 0
			SET @rec_count_10 = 0
			SET @rec_count_11 = 0
			SET @rec_count_12 = 0
			SET @rec_count_13 = 0
			SET @rec_count_14 = 0
		END
		ELSE IF @countable_count = 16
		BEGIN
			SET @countable_0 = 0
			SET @countable_1 = 0
			SET @countable_2 = 0
			SET @countable_3 = 0
			SET @countable_4 = 0
			SET @countable_5 = 0
			SET @countable_6 = 0
			SET @countable_7 = 0
			SET @countable_8 = 0
			SET @countable_9 = 0
			SET @countable_10 = 0
			SET @countable_11 = 0
			SET @countable_12 = 0
			SET @countable_13 = 0
			SET @countable_14 = 0
			SET @countable_15 = 0

			SET @rec_count_0 = 0
			SET @rec_count_1 = 0
			SET @rec_count_2 = 0
			SET @rec_count_3 = 0
			SET @rec_count_4 = 0
			SET @rec_count_5 = 0
			SET @rec_count_6 = 0
			SET @rec_count_7 = 0
			SET @rec_count_8 = 0
			SET @rec_count_9 = 0
			SET @rec_count_10 = 0
			SET @rec_count_11 = 0
			SET @rec_count_12 = 0
			SET @rec_count_13 = 0
			SET @rec_count_14 = 0
			SET @rec_count_15 = 0
		END
		ELSE IF @countable_count = 17
		BEGIN
			SET @countable_0 = 0
			SET @countable_1 = 0
			SET @countable_2 = 0
			SET @countable_3 = 0
			SET @countable_4 = 0
			SET @countable_5 = 0
			SET @countable_6 = 0
			SET @countable_7 = 0
			SET @countable_8 = 0
			SET @countable_9 = 0
			SET @countable_10 = 0
			SET @countable_11 = 0
			SET @countable_12 = 0
			SET @countable_13 = 0
			SET @countable_14 = 0
			SET @countable_15 = 0
			SET @countable_16 = 0

			SET @rec_count_0 = 0
			SET @rec_count_1 = 0
			SET @rec_count_2 = 0
			SET @rec_count_3 = 0
			SET @rec_count_4 = 0
			SET @rec_count_5 = 0
			SET @rec_count_6 = 0
			SET @rec_count_7 = 0
			SET @rec_count_8 = 0
			SET @rec_count_9 = 0
			SET @rec_count_10 = 0
			SET @rec_count_11 = 0
			SET @rec_count_12 = 0
			SET @rec_count_13 = 0
			SET @rec_count_14 = 0
			SET @rec_count_15 = 0
			SET @rec_count_16 = 0
		END
		ELSE IF @countable_count = 18
		BEGIN
			SET @countable_0 = 0
			SET @countable_1 = 0
			SET @countable_2 = 0
			SET @countable_3 = 0
			SET @countable_4 = 0
			SET @countable_5 = 0
			SET @countable_6 = 0
			SET @countable_7 = 0
			SET @countable_8 = 0
			SET @countable_9 = 0
			SET @countable_10 = 0
			SET @countable_11 = 0
			SET @countable_12 = 0
			SET @countable_13 = 0
			SET @countable_14 = 0
			SET @countable_15 = 0
			SET @countable_16 = 0
			SET @countable_17 = 0
			SET @rec_count_0 = 0
			SET @rec_count_1 = 0
			SET @rec_count_2 = 0
			SET @rec_count_3 = 0
			SET @rec_count_4 = 0
			SET @rec_count_5 = 0
			SET @rec_count_6 = 0
			SET @rec_count_7 = 0
			SET @rec_count_8 = 0
			SET @rec_count_9 = 0
			SET @rec_count_10 = 0
			SET @rec_count_11 = 0
			SET @rec_count_12 = 0
			SET @rec_count_13 = 0
			SET @rec_count_14 = 0
			SET @rec_count_15 = 0
			SET @rec_count_16 = 0
			SET @rec_count_17 = 0
		END
		ELSE IF @countable_count = 19
		BEGIN
			SET @countable_0 = 0
			SET @countable_1 = 0
			SET @countable_2 = 0
			SET @countable_3 = 0
			SET @countable_4 = 0
			SET @countable_5 = 0
			SET @countable_6 = 0
			SET @countable_7 = 0
			SET @countable_8 = 0
			SET @countable_9 = 0
			SET @countable_10 = 0
			SET @countable_11 = 0
			SET @countable_12 = 0
			SET @countable_13 = 0
			SET @countable_14 = 0
			SET @countable_15 = 0
			SET @countable_16 = 0			SET @countable_17 = 0
			SET @countable_18 = 0

			SET @rec_count_0 = 0
			SET @rec_count_1 = 0
			SET @rec_count_2 = 0
			SET @rec_count_3 = 0
			SET @rec_count_4 = 0
			SET @rec_count_5 = 0
			SET @rec_count_6 = 0
			SET @rec_count_7 = 0
			SET @rec_count_8 = 0
			SET @rec_count_9 = 0
			SET @rec_count_10 = 0
			SET @rec_count_11 = 0
			SET @rec_count_12 = 0
			SET @rec_count_13 = 0
			SET @rec_count_14 = 0
			SET @rec_count_15 = 0
			SET @rec_count_16 = 0
			SET @rec_count_17 = 0
			SET @rec_count_18 = 0
		END
		ELSE IF @countable_count = 20
		BEGIN
			SET @countable_0 = 0
			SET @countable_1 = 0
			SET @countable_2 = 0
			SET @countable_3 = 0
			SET @countable_4 = 0
			SET @countable_5 = 0
			SET @countable_6 = 0
			SET @countable_7 = 0
			SET @countable_8 = 0
			SET @countable_9 = 0
			SET @countable_10 = 0
			SET @countable_11 = 0
			SET @countable_12 = 0
			SET @countable_13 = 0
			SET @countable_14 = 0
			SET @countable_15 = 0
			SET @countable_16 = 0
			SET @countable_17 = 0
			SET @countable_18 = 0
			SET @countable_19 = 0

			SET @rec_count_0 = 0
			SET @rec_count_1 = 0
			SET @rec_count_2 = 0
			SET @rec_count_3 = 0
			SET @rec_count_4 = 0
			SET @rec_count_5 = 0
			SET @rec_count_6 = 0
			SET @rec_count_7 = 0
			SET @rec_count_8 = 0
			SET @rec_count_9 = 0
			SET @rec_count_10 = 0
			SET @rec_count_11 = 0
			SET @rec_count_12 = 0
			SET @rec_count_13 = 0
			SET @rec_count_14 = 0
			SET @rec_count_15 = 0
			SET @rec_count_16 = 0
			SET @rec_count_17 = 0
			SET @rec_count_18 = 0
			SET @rec_count_19 = 0
		END
	END -- reset the counters

	-- Processing the record
	IF @FetchStatusCalc = 0
	BEGIN
		IF @cur_id_pass = 1
		BEGIN
			-- Insert into the temp table

			-- obtain the actual value before the insertion
			SET @SQLStmt = N''DECLARE get_value_cursor CURSOR GLOBAL FOR SELECT ''
			+ ISNULL(@countable_formula_0,0) + N'','' + ISNULL(@countable_formula_1 ,0) + N'','' + ISNULL(@countable_formula_2 ,0) + N'',''
			+ ISNULL(@countable_formula_3 ,0) + N'','' + ISNULL(@countable_formula_4 ,0) + N'','' + ISNULL(@countable_formula_5 ,0) + N'',''
			+ ISNULL(@countable_formula_6 ,0) + N'','' + ISNULL(@countable_formula_7 ,0) + N'','' + ISNULL(@countable_formula_8 ,0) + N'',''
			+ ISNULL(@countable_formula_9 ,0) + N'','' + ISNULL(@countable_formula_10 ,0) + N'','' + ISNULL(@countable_formula_11 ,0) + N'',''
			+ ISNULL(@countable_formula_12 ,0) + N'','' + ISNULL(@countable_formula_13 ,0) + N'','' + ISNULL(@countable_formula_14 ,0) + N'',''
			+ ISNULL(@countable_formula_15 ,0) + N'','' + ISNULL(@countable_formula_16 ,0) + N'','' + ISNULL(@countable_formula_17 ,0) + N'',''
			+ ISNULL(@countable_formula_18 ,0) + N'','' + ISNULL(@countable_formula_19 ,0) 
			--PRINT @SQLStmt

			EXEC sp_executesql @SQLStmt,
			N''@countable_0 numeric(18,6), @countable_1 numeric(18,6), @countable_2 numeric(18,6),
			@countable_3 numeric(18,6), @countable_4 numeric(18,6), @countable_5 numeric(18,6),
			@countable_6 numeric(18,6), @countable_7 numeric(18,6), @countable_8 numeric(18,6),
			@countable_9 numeric(18,6), @countable_10 numeric(18,6), @countable_11 numeric(18,6),
			@countable_12 numeric(18,6), @countable_13 numeric(18,6), @countable_14 numeric(18,6),
			@countable_15 numeric(18,6), @countable_16 numeric(18,6), @countable_17 numeric(18,6),
			@countable_18 numeric(18,6), @countable_19 numeric(18,6),
			@rec_count_0 int, @rec_count_1 int, @rec_count_2 int, 
			@rec_count_3 int, @rec_count_4 int, @rec_count_5 int, 
			@rec_count_6 int, @rec_count_7 int, @rec_count_8 int, 
			@rec_count_9 int, @rec_count_10 int, @rec_count_11 int, 
			@rec_count_12 int, @rec_count_13 int, @rec_count_14 int, 
			@rec_count_15 int, @rec_count_16 int, @rec_count_17 int, 
			@rec_count_18 int, @rec_count_19 int'',
			@countable_0, @countable_1, @countable_2,
			@countable_3, @countable_4, @countable_5,
			@countable_6, @countable_7, @countable_8,
			@countable_9, @countable_10, @countable_11,
			@countable_12, @countable_13, @countable_14,
			@countable_15, @countable_16, @countable_17,
			@countable_18, @countable_19,
			@rec_count_0, @rec_count_1, @rec_count_2, 
			@rec_count_3, @rec_count_4, @rec_count_5, 
			@rec_count_6, @rec_count_7, @rec_count_8, 
			@rec_count_9, @rec_count_10, @rec_count_11, 
			@rec_count_12, @rec_count_13, @rec_count_14, 
			@rec_count_15, @rec_count_16, @rec_count_17, 
			@rec_count_18, @rec_count_19

			SELECT @SQLError = @@ERROR
			IF @SQLError <> 0 GOTO FatalErrorCursor_Calc

			OPEN get_value_cursor
			SELECT @SQLError = @@ERROR
			IF @SQLError <> 0 GOTO FatalErrorCursor_Calc

			FETCH NEXT FROM get_value_cursor INTO 
			@countable_formula_value_0, @countable_formula_value_1, @countable_formula_value_2,
			@countable_formula_value_3, @countable_formula_value_4, @countable_formula_value_5,
			@countable_formula_value_6, @countable_formula_value_7, @countable_formula_value_8,
			@countable_formula_value_9, @countable_formula_value_10, @countable_formula_value_11,
			@countable_formula_value_12, @countable_formula_value_13, @countable_formula_value_14,
			@countable_formula_value_15, @countable_formula_value_16, @countable_formula_value_17,
			@countable_formula_value_18, @countable_formula_value_19

			CLOSE get_value_cursor
			DEALLOCATE get_value_cursor

			-- start insertions
			IF @formula_count = 1
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) + N'')''
			ELSE IF @formula_count = 2
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_1 AS nvarchar(50)) 
				+ N'')''
			ELSE IF @formula_count = 3
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_1 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_2 AS nvarchar(50)) 
				+ N'')''
			ELSE IF @formula_count = 4
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_1 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_2 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_3 AS nvarchar(50)) 
				+ N'')''
			ELSE IF @formula_count = 5
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_1 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_2 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_3 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_4 AS nvarchar(50)) 
				+ N'')''
			ELSE IF @formula_count = 6
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_1 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_2 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_3 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_4 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_5 AS nvarchar(50)) 
				+ N'')''
			ELSE IF @formula_count = 7
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_1 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_2 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_3 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_4 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_5 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_6 AS nvarchar(50)) 
				+ N'')''
			ELSE IF @formula_count = 8
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_1 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_2 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_3 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_4 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_5 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_6 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_7 AS nvarchar(50)) 
				+ N'')''
			ELSE IF @formula_count = 9
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_1 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_2 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_3 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_4 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_5 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_6 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_7 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_8 AS nvarchar(50)) 
				+ N'')''
			ELSE IF @formula_count = 10
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_1 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_2 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_3 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_4 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_5 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_6 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_7 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_8 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_9 AS nvarchar(50)) 
				+ N'')''
			ELSE IF @formula_count = 11
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_1 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_2 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_3 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_4 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_5 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_6 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_7 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_8 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_9 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_10 AS nvarchar(50)) 
				+ N'')''
			ELSE IF @formula_count = 12
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_1 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_2 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_3 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_4 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_5 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_6 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_7 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_8 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_9 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_10 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_11 AS nvarchar(50)) 
				+ N'')''
			ELSE IF @formula_count = 13
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_1 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_2 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_3 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_4 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_5 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_6 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_7 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_8 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_9 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_10 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_11 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_12 AS nvarchar(50)) 
				+ N'')''
			ELSE IF @formula_count = 14
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_1 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_2 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_3 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_4 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_5 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_6 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_7 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_8 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_9 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_10 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_11 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_12 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_13 AS nvarchar(50)) 
				+ N'')''
			ELSE IF @formula_count = 15
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_1 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_2 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_3 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_4 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_5 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_6 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_7 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_8 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_9 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_10 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_11 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_12 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_13 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_14 AS nvarchar(50)) 
				+ N'')''
			ELSE IF @formula_count = 16
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_1 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_2 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_3 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_4 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_5 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_6 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_7 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_8 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_9 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_10 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_11 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_12 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_13 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_14 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_15 AS nvarchar(50)) 
				+ N'')''
			ELSE IF @formula_count = 17
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_1 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_2 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_3 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_4 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_5 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_6 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_7 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_8 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_9 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_10 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_11 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_12 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_13 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_14 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_15 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_16 AS nvarchar(50)) 
				+ N'')''
			ELSE IF @formula_count = 18
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_1 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_2 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_3 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_4 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_5 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_6 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_7 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_8 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_9 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_10 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_11 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_12 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_13 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_14 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_15 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_16 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_17 AS nvarchar(50)) 
				+ N'')''
			ELSE IF @formula_count = 19
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_1 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_2 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_3 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_4 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_5 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_6 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_7 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_8 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_9 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_10 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_11 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_12 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_13 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_14 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_15 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_16 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_17 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_18 AS nvarchar(50)) 
				+ N'')''
			ELSE IF @formula_count = 20
				SET @SQLStmt = N''INSERT INTO '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
				+ N'' VALUES ('' + CAST(@cur_id_sess AS nvarchar(50)) + N'','' 
				+ CAST(@countable_formula_value_0 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_1 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_2 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_3 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_4 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_5 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_6 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_7 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_8 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_9 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_10 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_11 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_12 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_13 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_14 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_15 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_16 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_17 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_18 AS nvarchar(50)) 
				+ N'','' + CAST(@countable_formula_value_19 AS nvarchar(50)) 
				+ N'')''

			EXEC sp_executesql @SQLStmt
			SELECT @SQLError = @@ERROR
			IF @SQLError <> 0 GOTO FatalErrorCursor_Calc
		END
		ELSE
		BEGIN
			-- Counter records to accumulate the counters
			IF @countable_count = 1
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
			END
			ELSE IF @countable_count = 2
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)
				SET @countable_1 = @countable_1 + ISNULL(@cur_countable_1,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_1 = @rec_count_1 + CASE WHEN @cur_countable_1 IS NULL THEN 0 ELSE 1 END
			END
			ELSE IF @countable_count = 3
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)
				SET @countable_1 = @countable_1 + ISNULL(@cur_countable_1,0)
				SET @countable_2 = @countable_2 + ISNULL(@cur_countable_2,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_1 = @rec_count_1 + CASE WHEN @cur_countable_1 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_2 = @rec_count_2 + CASE WHEN @cur_countable_2 IS NULL THEN 0 ELSE 1 END
			END
			ELSE IF @countable_count = 4
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)
				SET @countable_1 = @countable_1 + ISNULL(@cur_countable_1,0)
				SET @countable_2 = @countable_2 + ISNULL(@cur_countable_2,0)
				SET @countable_3 = @countable_3 + ISNULL(@cur_countable_3,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_1 = @rec_count_1 + CASE WHEN @cur_countable_1 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_2 = @rec_count_2 + CASE WHEN @cur_countable_2 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_3 = @rec_count_3 + CASE WHEN @cur_countable_3 IS NULL THEN 0 ELSE 1 END
			END
			ELSE IF @countable_count = 5
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)
				SET @countable_1 = @countable_1 + ISNULL(@cur_countable_1,0)
				SET @countable_2 = @countable_2 + ISNULL(@cur_countable_2,0)
				SET @countable_3 = @countable_3 + ISNULL(@cur_countable_3,0)
				SET @countable_4 = @countable_4 + ISNULL(@cur_countable_4,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_1 = @rec_count_1 + CASE WHEN @cur_countable_1 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_2 = @rec_count_2 + CASE WHEN @cur_countable_2 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_3 = @rec_count_3 + CASE WHEN @cur_countable_3 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_4 = @rec_count_4 + CASE WHEN @cur_countable_4 IS NULL THEN 0 ELSE 1 END
			END
			ELSE IF @countable_count = 6
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)
				SET @countable_1 = @countable_1 + ISNULL(@cur_countable_1,0)
				SET @countable_2 = @countable_2 + ISNULL(@cur_countable_2,0)
				SET @countable_3 = @countable_3 + ISNULL(@cur_countable_3,0)
				SET @countable_4 = @countable_4 + ISNULL(@cur_countable_4,0)
				SET @countable_5 = @countable_5 + ISNULL(@cur_countable_5,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_1 = @rec_count_1 + CASE WHEN @cur_countable_1 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_2 = @rec_count_2 + CASE WHEN @cur_countable_2 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_3 = @rec_count_3 + CASE WHEN @cur_countable_3 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_4 = @rec_count_4 + CASE WHEN @cur_countable_4 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_5 = @rec_count_5 + CASE WHEN @cur_countable_5 IS NULL THEN 0 ELSE 1 END
			END
			ELSE IF @countable_count = 7
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)
				SET @countable_1 = @countable_1 + ISNULL(@cur_countable_1,0)
				SET @countable_2 = @countable_2 + ISNULL(@cur_countable_2,0)
				SET @countable_3 = @countable_3 + ISNULL(@cur_countable_3,0)
				SET @countable_4 = @countable_4 + ISNULL(@cur_countable_4,0)
				SET @countable_5 = @countable_5 + ISNULL(@cur_countable_5,0)
				SET @countable_6 = @countable_6 + ISNULL(@cur_countable_6,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_1 = @rec_count_1 + CASE WHEN @cur_countable_1 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_2 = @rec_count_2 + CASE WHEN @cur_countable_2 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_3 = @rec_count_3 + CASE WHEN @cur_countable_3 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_4 = @rec_count_4 + CASE WHEN @cur_countable_4 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_5 = @rec_count_5 + CASE WHEN @cur_countable_5 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_6 = @rec_count_6 + CASE WHEN @cur_countable_6 IS NULL THEN 0 ELSE 1 END
			END
			ELSE IF @countable_count = 8
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)
				SET @countable_1 = @countable_1 + ISNULL(@cur_countable_1,0)
				SET @countable_2 = @countable_2 + ISNULL(@cur_countable_2,0)
				SET @countable_3 = @countable_3 + ISNULL(@cur_countable_3,0)
				SET @countable_4 = @countable_4 + ISNULL(@cur_countable_4,0)
				SET @countable_5 = @countable_5 + ISNULL(@cur_countable_5,0)
				SET @countable_6 = @countable_6 + ISNULL(@cur_countable_6,0)
				SET @countable_7 = @countable_7 + ISNULL(@cur_countable_7,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_1 = @rec_count_1 + CASE WHEN @cur_countable_1 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_2 = @rec_count_2 + CASE WHEN @cur_countable_2 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_3 = @rec_count_3 + CASE WHEN @cur_countable_3 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_4 = @rec_count_4 + CASE WHEN @cur_countable_4 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_5 = @rec_count_5 + CASE WHEN @cur_countable_5 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_6 = @rec_count_6 + CASE WHEN @cur_countable_6 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_7 = @rec_count_7 + CASE WHEN @cur_countable_7 IS NULL THEN 0 ELSE 1 END
			END
			ELSE IF @countable_count = 9
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)
				SET @countable_1 = @countable_1 + ISNULL(@cur_countable_1,0)
				SET @countable_2 = @countable_2 + ISNULL(@cur_countable_2,0)
				SET @countable_3 = @countable_3 + ISNULL(@cur_countable_3,0)
				SET @countable_4 = @countable_4 + ISNULL(@cur_countable_4,0)
				SET @countable_5 = @countable_5 + ISNULL(@cur_countable_5,0)
				SET @countable_6 = @countable_6 + ISNULL(@cur_countable_6,0)
				SET @countable_7 = @countable_7 + ISNULL(@cur_countable_7,0)
				SET @countable_8 = @countable_8 + ISNULL(@cur_countable_8,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_1 = @rec_count_1 + CASE WHEN @cur_countable_1 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_2 = @rec_count_2 + CASE WHEN @cur_countable_2 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_3 = @rec_count_3 + CASE WHEN @cur_countable_3 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_4 = @rec_count_4 + CASE WHEN @cur_countable_4 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_5 = @rec_count_5 + CASE WHEN @cur_countable_5 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_6 = @rec_count_6 + CASE WHEN @cur_countable_6 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_7 = @rec_count_7 + CASE WHEN @cur_countable_7 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_8 = @rec_count_8 + CASE WHEN @cur_countable_8 IS NULL THEN 0 ELSE 1 END
			END
			ELSE IF @countable_count = 10
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)
				SET @countable_1 = @countable_1 + ISNULL(@cur_countable_1,0)
				SET @countable_2 = @countable_2 + ISNULL(@cur_countable_2,0)
				SET @countable_3 = @countable_3 + ISNULL(@cur_countable_3,0)
				SET @countable_4 = @countable_4 + ISNULL(@cur_countable_4,0)
				SET @countable_5 = @countable_5 + ISNULL(@cur_countable_5,0)
				SET @countable_6 = @countable_6 + ISNULL(@cur_countable_6,0)
				SET @countable_7 = @countable_7 + ISNULL(@cur_countable_7,0)
				SET @countable_8 = @countable_8 + ISNULL(@cur_countable_8,0)
				SET @countable_9 = @countable_9 + ISNULL(@cur_countable_9,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_1 = @rec_count_1 + CASE WHEN @cur_countable_1 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_2 = @rec_count_2 + CASE WHEN @cur_countable_2 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_3 = @rec_count_3 + CASE WHEN @cur_countable_3 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_4 = @rec_count_4 + CASE WHEN @cur_countable_4 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_5 = @rec_count_5 + CASE WHEN @cur_countable_5 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_6 = @rec_count_6 + CASE WHEN @cur_countable_6 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_7 = @rec_count_7 + CASE WHEN @cur_countable_7 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_8 = @rec_count_8 + CASE WHEN @cur_countable_8 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_9 = @rec_count_9 + CASE WHEN @cur_countable_9 IS NULL THEN 0 ELSE 1 END
			END
			ELSE IF @countable_count = 11
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)
				SET @countable_1 = @countable_1 + ISNULL(@cur_countable_1,0)
				SET @countable_2 = @countable_2 + ISNULL(@cur_countable_2,0)
				SET @countable_3 = @countable_3 + ISNULL(@cur_countable_3,0)
				SET @countable_4 = @countable_4 + ISNULL(@cur_countable_4,0)
				SET @countable_5 = @countable_5 + ISNULL(@cur_countable_5,0)
				SET @countable_6 = @countable_6 + ISNULL(@cur_countable_6,0)
				SET @countable_7 = @countable_7 + ISNULL(@cur_countable_7,0)
				SET @countable_8 = @countable_8 + ISNULL(@cur_countable_8,0)
				SET @countable_9 = @countable_9 + ISNULL(@cur_countable_9,0)
				SET @countable_10 = @countable_10 + ISNULL(@cur_countable_10,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_1 = @rec_count_1 + CASE WHEN @cur_countable_1 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_2 = @rec_count_2 + CASE WHEN @cur_countable_2 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_3 = @rec_count_3 + CASE WHEN @cur_countable_3 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_4 = @rec_count_4 + CASE WHEN @cur_countable_4 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_5 = @rec_count_5 + CASE WHEN @cur_countable_5 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_6 = @rec_count_6 + CASE WHEN @cur_countable_6 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_7 = @rec_count_7 + CASE WHEN @cur_countable_7 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_8 = @rec_count_8 + CASE WHEN @cur_countable_8 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_9 = @rec_count_9 + CASE WHEN @cur_countable_9 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_10 = @rec_count_10 + CASE WHEN @cur_countable_10 IS NULL THEN 0 ELSE 1 END
			END
			ELSE IF @countable_count = 12
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)
				SET @countable_1 = @countable_1 + ISNULL(@cur_countable_1,0)
				SET @countable_2 = @countable_2 + ISNULL(@cur_countable_2,0)
				SET @countable_3 = @countable_3 + ISNULL(@cur_countable_3,0)
				SET @countable_4 = @countable_4 + ISNULL(@cur_countable_4,0)
				SET @countable_5 = @countable_5 + ISNULL(@cur_countable_5,0)
				SET @countable_6 = @countable_6 + ISNULL(@cur_countable_6,0)
				SET @countable_7 = @countable_7 + ISNULL(@cur_countable_7,0)
				SET @countable_8 = @countable_8 + ISNULL(@cur_countable_8,0)
				SET @countable_9 = @countable_9 + ISNULL(@cur_countable_9,0)
				SET @countable_10 = @countable_10 + ISNULL(@cur_countable_10,0)
				SET @countable_11 = @countable_11 + ISNULL(@cur_countable_11,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_1 = @rec_count_1 + CASE WHEN @cur_countable_1 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_2 = @rec_count_2 + CASE WHEN @cur_countable_2 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_3 = @rec_count_3 + CASE WHEN @cur_countable_3 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_4 = @rec_count_4 + CASE WHEN @cur_countable_4 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_5 = @rec_count_5 + CASE WHEN @cur_countable_5 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_6 = @rec_count_6 + CASE WHEN @cur_countable_6 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_7 = @rec_count_7 + CASE WHEN @cur_countable_7 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_8 = @rec_count_8 + CASE WHEN @cur_countable_8 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_9 = @rec_count_9 + CASE WHEN @cur_countable_9 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_10 = @rec_count_10 + CASE WHEN @cur_countable_10 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_11 = @rec_count_11 + CASE WHEN @cur_countable_11 IS NULL THEN 0 ELSE 1 END
			END
			ELSE IF @countable_count = 13
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)
				SET @countable_1 = @countable_1 + ISNULL(@cur_countable_1,0)
				SET @countable_2 = @countable_2 + ISNULL(@cur_countable_2,0)
				SET @countable_3 = @countable_3 + ISNULL(@cur_countable_3,0)
				SET @countable_4 = @countable_4 + ISNULL(@cur_countable_4,0)
				SET @countable_5 = @countable_5 + ISNULL(@cur_countable_5,0)
				SET @countable_6 = @countable_6 + ISNULL(@cur_countable_6,0)
				SET @countable_7 = @countable_7 + ISNULL(@cur_countable_7,0)
				SET @countable_8 = @countable_8 + ISNULL(@cur_countable_8,0)
				SET @countable_9 = @countable_9 + ISNULL(@cur_countable_9,0)
				SET @countable_10 = @countable_10 + ISNULL(@cur_countable_10,0)
				SET @countable_11 = @countable_11 + ISNULL(@cur_countable_11,0)
				SET @countable_12 = @countable_12 + ISNULL(@cur_countable_12,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_1 = @rec_count_1 + CASE WHEN @cur_countable_1 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_2 = @rec_count_2 + CASE WHEN @cur_countable_2 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_3 = @rec_count_3 + CASE WHEN @cur_countable_3 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_4 = @rec_count_4 + CASE WHEN @cur_countable_4 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_5 = @rec_count_5 + CASE WHEN @cur_countable_5 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_6 = @rec_count_6 + CASE WHEN @cur_countable_6 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_7 = @rec_count_7 + CASE WHEN @cur_countable_7 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_8 = @rec_count_8 + CASE WHEN @cur_countable_8 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_9 = @rec_count_9 + CASE WHEN @cur_countable_9 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_10 = @rec_count_10 + CASE WHEN @cur_countable_10 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_11 = @rec_count_11 + CASE WHEN @cur_countable_11 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_12 = @rec_count_12 + CASE WHEN @cur_countable_12 IS NULL THEN 0 ELSE 1 END
			END
			ELSE IF @countable_count = 14
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)
				SET @countable_1 = @countable_1 + ISNULL(@cur_countable_1,0)
				SET @countable_2 = @countable_2 + ISNULL(@cur_countable_2,0)
				SET @countable_3 = @countable_3 + ISNULL(@cur_countable_3,0)
				SET @countable_4 = @countable_4 + ISNULL(@cur_countable_4,0)
				SET @countable_5 = @countable_5 + ISNULL(@cur_countable_5,0)
				SET @countable_6 = @countable_6 + ISNULL(@cur_countable_6,0)
				SET @countable_7 = @countable_7 + ISNULL(@cur_countable_7,0)
				SET @countable_8 = @countable_8 + ISNULL(@cur_countable_8,0)
				SET @countable_9 = @countable_9 + ISNULL(@cur_countable_9,0)
				SET @countable_10 = @countable_10 + ISNULL(@cur_countable_10,0)
				SET @countable_11 = @countable_11 + ISNULL(@cur_countable_11,0)
				SET @countable_12 = @countable_12 + ISNULL(@cur_countable_12,0)
				SET @countable_13 = @countable_13 + ISNULL(@cur_countable_13,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_1 = @rec_count_1 + CASE WHEN @cur_countable_1 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_2 = @rec_count_2 + CASE WHEN @cur_countable_2 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_3 = @rec_count_3 + CASE WHEN @cur_countable_3 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_4 = @rec_count_4 + CASE WHEN @cur_countable_4 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_5 = @rec_count_5 + CASE WHEN @cur_countable_5 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_6 = @rec_count_6 + CASE WHEN @cur_countable_6 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_7 = @rec_count_7 + CASE WHEN @cur_countable_7 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_8 = @rec_count_8 + CASE WHEN @cur_countable_8 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_9 = @rec_count_9 + CASE WHEN @cur_countable_9 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_10 = @rec_count_10 + CASE WHEN @cur_countable_10 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_11 = @rec_count_11 + CASE WHEN @cur_countable_11 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_12 = @rec_count_12 + CASE WHEN @cur_countable_12 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_13 = @rec_count_13 + CASE WHEN @cur_countable_13 IS NULL THEN 0 ELSE 1 END
			END
			ELSE IF @countable_count = 15
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)
				SET @countable_1 = @countable_1 + ISNULL(@cur_countable_1,0)
				SET @countable_2 = @countable_2 + ISNULL(@cur_countable_2,0)
				SET @countable_3 = @countable_3 + ISNULL(@cur_countable_3,0)
				SET @countable_4 = @countable_4 + ISNULL(@cur_countable_4,0)
				SET @countable_5 = @countable_5 + ISNULL(@cur_countable_5,0)
				SET @countable_6 = @countable_6 + ISNULL(@cur_countable_6,0)
				SET @countable_7 = @countable_7 + ISNULL(@cur_countable_7,0)
				SET @countable_8 = @countable_8 + ISNULL(@cur_countable_8,0)
				SET @countable_9 = @countable_9 + ISNULL(@cur_countable_9,0)
				SET @countable_10 = @countable_10 + ISNULL(@cur_countable_10,0)
				SET @countable_11 = @countable_11 + ISNULL(@cur_countable_11,0)
				SET @countable_12 = @countable_12 + ISNULL(@cur_countable_12,0)
				SET @countable_13 = @countable_13 + ISNULL(@cur_countable_13,0)
				SET @countable_14 = @countable_14 + ISNULL(@cur_countable_14,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_1 = @rec_count_1 + CASE WHEN @cur_countable_1 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_2 = @rec_count_2 + CASE WHEN @cur_countable_2 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_3 = @rec_count_3 + CASE WHEN @cur_countable_3 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_4 = @rec_count_4 + CASE WHEN @cur_countable_4 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_5 = @rec_count_5 + CASE WHEN @cur_countable_5 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_6 = @rec_count_6 + CASE WHEN @cur_countable_6 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_7 = @rec_count_7 + CASE WHEN @cur_countable_7 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_8 = @rec_count_8 + CASE WHEN @cur_countable_8 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_9 = @rec_count_9 + CASE WHEN @cur_countable_9 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_10 = @rec_count_10 + CASE WHEN @cur_countable_10 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_11 = @rec_count_11 + CASE WHEN @cur_countable_11 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_12 = @rec_count_12 + CASE WHEN @cur_countable_12 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_13 = @rec_count_13 + CASE WHEN @cur_countable_13 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_14 = @rec_count_14 + CASE WHEN @cur_countable_14 IS NULL THEN 0 ELSE 1 END
			END
			ELSE IF @countable_count = 16
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)
				SET @countable_1 = @countable_1 + ISNULL(@cur_countable_1,0)
				SET @countable_2 = @countable_2 + ISNULL(@cur_countable_2,0)
				SET @countable_3 = @countable_3 + ISNULL(@cur_countable_3,0)
				SET @countable_4 = @countable_4 + ISNULL(@cur_countable_4,0)
				SET @countable_5 = @countable_5 + ISNULL(@cur_countable_5,0)
				SET @countable_6 = @countable_6 + ISNULL(@cur_countable_6,0)
				SET @countable_7 = @countable_7 + ISNULL(@cur_countable_7,0)
				SET @countable_8 = @countable_8 + ISNULL(@cur_countable_8,0)
				SET @countable_9 = @countable_9 + ISNULL(@cur_countable_9,0)
				SET @countable_10 = @countable_10 + ISNULL(@cur_countable_10,0)
				SET @countable_11 = @countable_11 + ISNULL(@cur_countable_11,0)
				SET @countable_12 = @countable_12 + ISNULL(@cur_countable_12,0)
				SET @countable_13 = @countable_13 + ISNULL(@cur_countable_13,0)
				SET @countable_14 = @countable_14 + ISNULL(@cur_countable_14,0)
				SET @countable_15 = @countable_15 + ISNULL(@cur_countable_15,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_1 = @rec_count_1 + CASE WHEN @cur_countable_1 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_2 = @rec_count_2 + CASE WHEN @cur_countable_2 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_3 = @rec_count_3 + CASE WHEN @cur_countable_3 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_4 = @rec_count_4 + CASE WHEN @cur_countable_4 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_5 = @rec_count_5 + CASE WHEN @cur_countable_5 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_6 = @rec_count_6 + CASE WHEN @cur_countable_6 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_7 = @rec_count_7 + CASE WHEN @cur_countable_7 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_8 = @rec_count_8 + CASE WHEN @cur_countable_8 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_9 = @rec_count_9 + CASE WHEN @cur_countable_9 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_10 = @rec_count_10 + CASE WHEN @cur_countable_10 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_11 = @rec_count_11 + CASE WHEN @cur_countable_11 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_12 = @rec_count_12 + CASE WHEN @cur_countable_12 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_13 = @rec_count_13 + CASE WHEN @cur_countable_13 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_14 = @rec_count_14 + CASE WHEN @cur_countable_14 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_15 = @rec_count_15 + CASE WHEN @cur_countable_15 IS NULL THEN 0 ELSE 1 END
			END
			ELSE IF @countable_count = 17
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)
				SET @countable_1 = @countable_1 + ISNULL(@cur_countable_1,0)
				SET @countable_2 = @countable_2 + ISNULL(@cur_countable_2,0)
				SET @countable_3 = @countable_3 + ISNULL(@cur_countable_3,0)
				SET @countable_4 = @countable_4 + ISNULL(@cur_countable_4,0)
				SET @countable_5 = @countable_5 + ISNULL(@cur_countable_5,0)
				SET @countable_6 = @countable_6 + ISNULL(@cur_countable_6,0)
				SET @countable_7 = @countable_7 + ISNULL(@cur_countable_7,0)
				SET @countable_8 = @countable_8 + ISNULL(@cur_countable_8,0)
				SET @countable_9 = @countable_9 + ISNULL(@cur_countable_9,0)
				SET @countable_10 = @countable_10 + ISNULL(@cur_countable_10,0)
				SET @countable_11 = @countable_11 + ISNULL(@cur_countable_11,0)
				SET @countable_12 = @countable_12 + ISNULL(@cur_countable_12,0)
				SET @countable_13 = @countable_13 + ISNULL(@cur_countable_13,0)
				SET @countable_14 = @countable_14 + ISNULL(@cur_countable_14,0)
				SET @countable_15 = @countable_15 + ISNULL(@cur_countable_15,0)
				SET @countable_16 = @countable_16 + ISNULL(@cur_countable_16,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_1 = @rec_count_1 + CASE WHEN @cur_countable_1 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_2 = @rec_count_2 + CASE WHEN @cur_countable_2 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_3 = @rec_count_3 + CASE WHEN @cur_countable_3 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_4 = @rec_count_4 + CASE WHEN @cur_countable_4 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_5 = @rec_count_5 + CASE WHEN @cur_countable_5 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_6 = @rec_count_6 + CASE WHEN @cur_countable_6 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_7 = @rec_count_7 + CASE WHEN @cur_countable_7 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_8 = @rec_count_8 + CASE WHEN @cur_countable_8 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_9 = @rec_count_9 + CASE WHEN @cur_countable_9 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_10 = @rec_count_10 + CASE WHEN @cur_countable_10 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_11 = @rec_count_11 + CASE WHEN @cur_countable_11 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_12 = @rec_count_12 + CASE WHEN @cur_countable_12 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_13 = @rec_count_13 + CASE WHEN @cur_countable_13 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_14 = @rec_count_14 + CASE WHEN @cur_countable_14 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_15 = @rec_count_15 + CASE WHEN @cur_countable_15 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_16 = @rec_count_16 + CASE WHEN @cur_countable_16 IS NULL THEN 0 ELSE 1 END
			END
			ELSE IF @countable_count = 18
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)
				SET @countable_1 = @countable_1 + ISNULL(@cur_countable_1,0)
				SET @countable_2 = @countable_2 + ISNULL(@cur_countable_2,0)
				SET @countable_3 = @countable_3 + ISNULL(@cur_countable_3,0)
				SET @countable_4 = @countable_4 + ISNULL(@cur_countable_4,0)
				SET @countable_5 = @countable_5 + ISNULL(@cur_countable_5,0)
				SET @countable_6 = @countable_6 + ISNULL(@cur_countable_6,0)
				SET @countable_7 = @countable_7 + ISNULL(@cur_countable_7,0)
				SET @countable_8 = @countable_8 + ISNULL(@cur_countable_8,0)
				SET @countable_9 = @countable_9 + ISNULL(@cur_countable_9,0)
				SET @countable_10 = @countable_10 + ISNULL(@cur_countable_10,0)
				SET @countable_11 = @countable_11 + ISNULL(@cur_countable_11,0)
				SET @countable_12 = @countable_12 + ISNULL(@cur_countable_12,0)
				SET @countable_13 = @countable_13 + ISNULL(@cur_countable_13,0)
				SET @countable_14 = @countable_14 + ISNULL(@cur_countable_14,0)
				SET @countable_15 = @countable_15 + ISNULL(@cur_countable_15,0)
				SET @countable_16 = @countable_16 + ISNULL(@cur_countable_16,0)
				SET @countable_17 = @countable_17 + ISNULL(@cur_countable_17,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_1 = @rec_count_1 + CASE WHEN @cur_countable_1 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_2 = @rec_count_2 + CASE WHEN @cur_countable_2 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_3 = @rec_count_3 + CASE WHEN @cur_countable_3 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_4 = @rec_count_4 + CASE WHEN @cur_countable_4 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_5 = @rec_count_5 + CASE WHEN @cur_countable_5 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_6 = @rec_count_6 + CASE WHEN @cur_countable_6 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_7 = @rec_count_7 + CASE WHEN @cur_countable_7 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_8 = @rec_count_8 + CASE WHEN @cur_countable_8 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_9 = @rec_count_9 + CASE WHEN @cur_countable_9 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_10 = @rec_count_10 + CASE WHEN @cur_countable_10 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_11 = @rec_count_11 + CASE WHEN @cur_countable_11 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_12 = @rec_count_12 + CASE WHEN @cur_countable_12 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_13 = @rec_count_13 + CASE WHEN @cur_countable_13 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_14 = @rec_count_14 + CASE WHEN @cur_countable_14 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_15 = @rec_count_15 + CASE WHEN @cur_countable_15 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_16 = @rec_count_16 + CASE WHEN @cur_countable_16 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_17 = @rec_count_17 + CASE WHEN @cur_countable_17 IS NULL THEN 0 ELSE 1 END
			END
			ELSE IF @countable_count = 19
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)
				SET @countable_1 = @countable_1 + ISNULL(@cur_countable_1,0)
				SET @countable_2 = @countable_2 + ISNULL(@cur_countable_2,0)
				SET @countable_3 = @countable_3 + ISNULL(@cur_countable_3,0)
				SET @countable_4 = @countable_4 + ISNULL(@cur_countable_4,0)
				SET @countable_5 = @countable_5 + ISNULL(@cur_countable_5,0)
				SET @countable_6 = @countable_6 + ISNULL(@cur_countable_6,0)
				SET @countable_7 = @countable_7 + ISNULL(@cur_countable_7,0)
				SET @countable_8 = @countable_8 + ISNULL(@cur_countable_8,0)
				SET @countable_9 = @countable_9 + ISNULL(@cur_countable_9,0)
				SET @countable_10 = @countable_10 + ISNULL(@cur_countable_10,0)
				SET @countable_11 = @countable_11 + ISNULL(@cur_countable_11,0)
				SET @countable_12 = @countable_12 + ISNULL(@cur_countable_12,0)
				SET @countable_13 = @countable_13 + ISNULL(@cur_countable_13,0)
				SET @countable_14 = @countable_14 + ISNULL(@cur_countable_14,0)
				SET @countable_15 = @countable_15 + ISNULL(@cur_countable_15,0)
				SET @countable_16 = @countable_16 + ISNULL(@cur_countable_16,0)
				SET @countable_17 = @countable_17 + ISNULL(@cur_countable_17,0)
				SET @countable_18 = @countable_18 + ISNULL(@cur_countable_18,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_1 = @rec_count_1 + CASE WHEN @cur_countable_1 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_2 = @rec_count_2 + CASE WHEN @cur_countable_2 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_3 = @rec_count_3 + CASE WHEN @cur_countable_3 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_4 = @rec_count_4 + CASE WHEN @cur_countable_4 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_5 = @rec_count_5 + CASE WHEN @cur_countable_5 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_6 = @rec_count_6 + CASE WHEN @cur_countable_6 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_7 = @rec_count_7 + CASE WHEN @cur_countable_7 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_8 = @rec_count_8 + CASE WHEN @cur_countable_8 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_9 = @rec_count_9 + CASE WHEN @cur_countable_9 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_10 = @rec_count_10 + CASE WHEN @cur_countable_10 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_11 = @rec_count_11 + CASE WHEN @cur_countable_11 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_12 = @rec_count_12 + CASE WHEN @cur_countable_12 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_13 = @rec_count_13 + CASE WHEN @cur_countable_13 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_14 = @rec_count_14 + CASE WHEN @cur_countable_14 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_15 = @rec_count_15 + CASE WHEN @cur_countable_15 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_16 = @rec_count_16 + CASE WHEN @cur_countable_16 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_17 = @rec_count_17 + CASE WHEN @cur_countable_17 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_18 = @rec_count_18 + CASE WHEN @cur_countable_18 IS NULL THEN 0 ELSE 1 END
			END
			ELSE IF @countable_count = 20
			BEGIN
				SET @countable_0 = @countable_0 + ISNULL(@cur_countable_0,0)
				SET @countable_1 = @countable_1 + ISNULL(@cur_countable_1,0)
				SET @countable_2 = @countable_2 + ISNULL(@cur_countable_2,0)
				SET @countable_3 = @countable_3 + ISNULL(@cur_countable_3,0)
				SET @countable_4 = @countable_4 + ISNULL(@cur_countable_4,0)
				SET @countable_5 = @countable_5 + ISNULL(@cur_countable_5,0)
				SET @countable_6 = @countable_6 + ISNULL(@cur_countable_6,0)
				SET @countable_7 = @countable_7 + ISNULL(@cur_countable_7,0)
				SET @countable_8 = @countable_8 + ISNULL(@cur_countable_8,0)
				SET @countable_9 = @countable_9 + ISNULL(@cur_countable_9,0)
				SET @countable_10 = @countable_10 + ISNULL(@cur_countable_10,0)
				SET @countable_11 = @countable_11 + ISNULL(@cur_countable_11,0)
				SET @countable_12 = @countable_12 + ISNULL(@cur_countable_12,0)
				SET @countable_13 = @countable_13 + ISNULL(@cur_countable_13,0)
				SET @countable_14 = @countable_14 + ISNULL(@cur_countable_14,0)
				SET @countable_15 = @countable_15 + ISNULL(@cur_countable_15,0)
				SET @countable_16 = @countable_16 + ISNULL(@cur_countable_16,0)
				SET @countable_17 = @countable_17 + ISNULL(@cur_countable_17,0)
				SET @countable_18 = @countable_18 + ISNULL(@cur_countable_18,0)
				SET @countable_19 = @countable_19 + ISNULL(@cur_countable_19,0)

				SET @rec_count_0 = @rec_count_0 + CASE WHEN @cur_countable_0 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_1 = @rec_count_1 + CASE WHEN @cur_countable_1 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_2 = @rec_count_2 + CASE WHEN @cur_countable_2 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_3 = @rec_count_3 + CASE WHEN @cur_countable_3 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_4 = @rec_count_4 + CASE WHEN @cur_countable_4 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_5 = @rec_count_5 + CASE WHEN @cur_countable_5 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_6 = @rec_count_6 + CASE WHEN @cur_countable_6 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_7 = @rec_count_7 + CASE WHEN @cur_countable_7 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_8 = @rec_count_8 + CASE WHEN @cur_countable_8 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_9 = @rec_count_9 + CASE WHEN @cur_countable_9 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_10 = @rec_count_10 + CASE WHEN @cur_countable_10 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_11 = @rec_count_11 + CASE WHEN @cur_countable_11 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_12 = @rec_count_12 + CASE WHEN @cur_countable_12 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_13 = @rec_count_13 + CASE WHEN @cur_countable_13 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_14 = @rec_count_14 + CASE WHEN @cur_countable_14 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_15 = @rec_count_15 + CASE WHEN @cur_countable_15 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_16 = @rec_count_16 + CASE WHEN @cur_countable_16 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_17 = @rec_count_17 + CASE WHEN @cur_countable_17 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_18 = @rec_count_18 + CASE WHEN @cur_countable_18 IS NULL THEN 0 ELSE 1 END
				SET @rec_count_19 = @rec_count_19 + CASE WHEN @cur_countable_19 IS NULL THEN 0 ELSE 1 END
			END -- up to 20 countables
		END -- pass 1 (count for) or 2 (contributing to the counters)
	END -- @FetchStatusCalc = 0

-- Process the next record
IF @countable_count = 1
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0
END
ELSE IF @countable_count = 2
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1
END
ELSE IF @countable_count = 3
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2
END
ELSE IF @countable_count = 4
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3
END
ELSE IF @countable_count = 5
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4
END
ELSE IF @countable_count = 6
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5
END
ELSE IF @countable_count = 7
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6
END
ELSE IF @countable_count = 8
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7
END
ELSE IF @countable_count = 9
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8
END
ELSE IF @countable_count = 10
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9
END
ELSE IF @countable_count = 11
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10
END
ELSE IF @countable_count = 12
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10,@cur_countable_11
END
ELSE IF @countable_count = 13
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10,@cur_countable_11,
	@cur_countable_12
END
ELSE IF @countable_count = 14
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10,@cur_countable_11,
	@cur_countable_12,@cur_countable_13
END
ELSE IF @countable_count = 15
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10,@cur_countable_11,
	@cur_countable_12,@cur_countable_13,@cur_countable_14
END
ELSE IF @countable_count = 16
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10,@cur_countable_11,
	@cur_countable_12,@cur_countable_13,@cur_countable_14,@cur_countable_15
END
ELSE IF @countable_count = 17
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10,@cur_countable_11,
	@cur_countable_12,@cur_countable_13,@cur_countable_14,@cur_countable_15,@cur_countable_16
END
ELSE IF @countable_count = 18
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10,@cur_countable_11,
	@cur_countable_12,@cur_countable_13,@cur_countable_14,@cur_countable_15,@cur_countable_16,@cur_countable_17
END
ELSE IF @countable_count = 19
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10,@cur_countable_11,
	@cur_countable_12,@cur_countable_13,@cur_countable_14,@cur_countable_15,@cur_countable_16,@cur_countable_17,
	@cur_countable_18
END
ELSE IF @countable_count = 20
BEGIN
	FETCH NEXT FROM calc_cursor INTO 
	@cur_id_pass,@cur_id_sess,@cur_id_acc,@cur_group_acc_flag,@cur_group_acc_id,@cur_pci_id_interval,@cur_dt_session,
	@cur_ui_dt_start,@cur_ui_dt_end,@cur_pci_dt_start,@cur_pci_dt_end,
	@cur_countable_0,@cur_countable_1,@cur_countable_2,@cur_countable_3,@cur_countable_4,@cur_countable_5,
	@cur_countable_6,@cur_countable_7,@cur_countable_8,@cur_countable_9,@cur_countable_10,@cur_countable_11,
	@cur_countable_12,@cur_countable_13,@cur_countable_14,@cur_countable_15,@cur_countable_16,@cur_countable_17,
	@cur_countable_18,@cur_countable_19
END -- fetch next

SET @FetchStatusCalc = @@FETCH_STATUS
END -- loop

CLOSE calc_cursor
DEALLOCATE calc_cursor

END -- of the linear approach 12/31/2002

----------------------------------------------------------------
-- Retrieve the result set
----------------------------------------------------------------
SET @SQLStmt = ''''SET @SQLStmt = 
N''SELECT tp1.id_sess, au.id_parent_sess, 
   au.id_view AS c_ViewId, 
   tp1.id_acc AS c__PayingAccount,
   tp1.id_payee AS c__AccountID, 
   au.dt_crt AS c_CreationDate, 
   tp1.dt_session AS c_SessionDate ''
	+ CAST(@input_FIRST_PASS_PV_PROPERTIES_ALIASED AS nvarchar(4000)) 
	+ CAST(@input_COUNTER_FORMULAS_ALIASES AS nvarchar(2000)) + N'',
   au.id_pi_template AS c__PriceableItemTemplateID, 
   au.id_pi_instance AS c__PriceableItemInstanceID, 
   au.id_prod AS c__ProductOfferingID, 
   tp1.ui_dt_start AS c_BillingIntervalStart, 
   tp1.ui_dt_end AS c_BillingIntervalEnd, 
   tp1.pci_dt_start AS c_AggregateIntervalStart, 
   tp1.pci_dt_end AS c_AggregateIntervalEnd
FROM '' + CAST(@tmp_tbl_name1 AS nvarchar(50)) + N'' tp1, '' 
	+ CAST(@tmp_tbl_name3 AS nvarchar(50)) + N'' tp2, t_acc_usage au INNER JOIN '' 
	+ CAST(@input_FIRST_PASS_PV_TABLE AS nvarchar(2000))
	+ N'' firstpasspv on firstpasspv.id_sess = au.id_sess and au.id_usage_interval=firstpasspv.id_usage_interval
WHERE tp2.id_sess = tp1.id_sess
AND au.id_sess = tp1.id_sess
ORDER BY '' + CAST(@input_COMPOUND_ORDERING AS nvarchar(2000)) + N'' tp1.id_acc, tp1.dt_session''
SET @output_SQLStmt_SELECT = @SQLStmt
SET @SQLStmt = ''DROP TABLE '' + @tmp_tbl_name2
EXEC sp_executesql @SQLStmt
SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError
SET @output_SQLStmt_DROPTMPTBL1 = ''DROP TABLE '' + @tmp_tbl_name1
SET @output_SQLStmt_DROPTMPTBL2 = ''DROP TABLE '' + @tmp_tbl_name3

--PRINT ''completed: all''
--PRINT CONVERT(char, getdate(), 109)

SET @return_code = 0
RETURN 0

FatalErrorCursor_calc:
	CLOSE calc_cursor
	DEALLOCATE calc_cursor

FatalError:
	SET @return_code = -1

	-- Added on 2/19/2003
	SET @SQLStmt = N''IF EXISTS (SELECT 1 FROM dbo.sysobjects WHERE id = object_id(N''''''
			+ CAST(@tmp_tbl_name1 AS nvarchar(50)) 
			+ N'''''') and OBJECTPROPERTY(id, N''''IsUserTable'''') = 1)''
			+ N'' DROP TABLE '' + CAST(@tmp_tbl_name1 AS nvarchar(50))
	-- PRINT @SQLStmt 
	EXEC sp_executesql @SQLStmt

	SET @SQLStmt = N''IF EXISTS (SELECT 1 FROM dbo.sysobjects WHERE id = object_id(N''''''			+ CAST(@tmp_tbl_name12 AS nvarchar(50)) 
			+ N'''''') and OBJECTPROPERTY(id, N''''IsUserTable'''') = 1)''
			+ N'' DROP TABLE '' + CAST(@tmp_tbl_name12 AS nvarchar(50))
	-- PRINT @SQLStmt 
	EXEC sp_executesql @SQLStmt

	SET @SQLStmt = N''IF EXISTS (SELECT 1 FROM dbo.sysobjects WHERE id = object_id(N''''''
			+ CAST(@tmp_tbl_name2 AS nvarchar(50)) 
			+ N'''''') and OBJECTPROPERTY(id, N''''IsUserTable'''') = 1)''
			+ N'' DROP TABLE '' + CAST(@tmp_tbl_name2 AS nvarchar(50))
	-- PRINT @SQLStmt 
	EXEC sp_executesql @SQLStmt

	SET @SQLStmt = N''IF EXISTS (SELECT 1 FROM dbo.sysobjects WHERE id = object_id(N''''''
			+ CAST(@tmp_tbl_name3 AS nvarchar(50)) 
			+ N'''''') and OBJECTPROPERTY(id, N''''IsUserTable'''') = 1)''
			+ N'' DROP TABLE '' + CAST(@tmp_tbl_name3 AS nvarchar(50))
	-- PRINT @SQLStmt 
	EXEC sp_executesql @SQLStmt

	RETURN -1
END
' 
END
GO
/****** Object:  StoredProcedure [dbo].[CanReverseEvents]    Script Date: 06/02/2008 11:43:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CanReverseEvents]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROC [dbo].[CanReverseEvents](@dt_now DATETIME, @id_instances VARCHAR(4000))
AS

BEGIN
  BEGIN TRAN

  DECLARE @results TABLE
  (  
    id_instance INT NOT NULL,
    tx_display_name nvarchar(255),
    tx_reason VARCHAR(80)
  )

  --
  -- initially all instances are considered okay
  -- a succession of queries attempt to find a reason
  -- why an instance can not be reversed

  -- builds up a table from the comma separated list of instance IDs
  INSERT INTO @results
  SELECT
    args.value,
    evt.tx_display_name,
    ''OK''
  FROM CSVToInt(@id_instances) args
  INNER JOIN t_recevent_inst inst ON inst.id_instance = args.value
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event

  -- is the event not active?
  UPDATE @results SET tx_reason = ''EventNotActive''
  FROM @results results
  INNER JOIN t_recevent_inst inst ON inst.id_instance = results.id_instance
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  WHERE 
    -- event is NOT active
    evt.dt_activated > @dt_now AND
    (evt.dt_deactivated IS NOT NULL OR @dt_now >= evt.dt_deactivated) 

  -- is the event not reversible?
  UPDATE @results SET tx_reason = evt.tx_reverse_mode
  FROM @results results
  INNER JOIN t_recevent_inst inst ON inst.id_instance = results.id_instance
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  WHERE 
    -- event is NOT reversible
    evt.tx_reverse_mode = ''NotImplemented''

  -- is the instance in an invalid state?
  UPDATE @results SET tx_reason = inst.tx_status
  FROM @results results
  INNER JOIN t_recevent_inst inst ON inst.id_instance = results.id_instance
  WHERE 
    inst.tx_status NOT IN (''ReadyToReverse'', ''Succeeded'', ''Failed'')

  -- is the interval hard closed?
  UPDATE @results SET tx_reason = ''HardClosed''
  FROM @results results
  INNER JOIN t_recevent_inst inst ON inst.id_instance = results.id_instance
  INNER JOIN t_usage_interval ui ON ui.id_interval = inst.id_arg_interval
  WHERE 
    ui.tx_interval_status = ''H''

  SELECT 
    id_instance InstanceID,
    tx_display_name EventDisplayName,
    tx_reason Reason  
  FROM @results

  COMMIT
END
' 
END
GO
/****** Object:  StoredProcedure [dbo].[CanExecuteEvents]    Script Date: 06/02/2008 11:43:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CanExecuteEvents]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROC [dbo].[CanExecuteEvents](@dt_now DATETIME, @id_instances VARCHAR(4000))
AS

BEGIN
  BEGIN TRAN

  DECLARE @results TABLE
  (  
    id_instance INT NOT NULL,
    tx_display_name nvarchar(255),
    tx_reason VARCHAR(80)
  )

  --
  -- initially all instances are considered okay
  -- a succession of queries attempt to find a problem with executing them
  --

  -- builds up a table from the comma separated list of instance IDs
  INSERT INTO @results
  SELECT
    args.value,
    evt.tx_display_name,
    ''OK''
  FROM CSVToInt(@id_instances) args
  INNER JOIN t_recevent_inst inst ON inst.id_instance = args.value
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event

  -- is the event not active?
  UPDATE @results SET tx_reason = ''EventNotActive''
  FROM @results results
  INNER JOIN t_recevent_inst inst ON inst.id_instance = results.id_instance
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  WHERE 
    -- event is NOT active
    evt.dt_activated > @dt_now AND
    (evt.dt_deactivated IS NOT NULL OR @dt_now >= evt.dt_deactivated) 

  -- is the instance in an invalid state?
  UPDATE @results SET tx_reason = inst.tx_status
  FROM @results results
  INNER JOIN t_recevent_inst inst ON inst.id_instance = results.id_instance
  WHERE 
    inst.tx_status NOT IN (''NotYetRun'', ''ReadyToRun'')

  -- is the interval hard closed?
  UPDATE @results SET tx_reason = ''HardClosed''
  FROM @results results
  INNER JOIN t_recevent_inst inst ON inst.id_instance = results.id_instance
  INNER JOIN t_usage_interval ui ON ui.id_interval = inst.id_arg_interval
  WHERE 
    ui.tx_interval_status = ''H''

  SELECT 
    id_instance InstanceID,
    tx_display_name EventDisplayName,
    tx_reason Reason  
  FROM @results

  COMMIT
END
  ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[GetCurrentIntervalID]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetCurrentIntervalID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
  
		create function [dbo].[GetCurrentIntervalID] (@aDTNow datetime, @aDTSession datetime, @aAccountID int) returns int
		as
		begin
      declare @retVal as int
      SELECT  @retVal =  id_usage_interval FROM  t_acc_usage_interval aui  
         INNER JOIN t_usage_interval ui ON ui.id_interval = aui.id_usage_interval
         WHERE ui.tx_interval_status <> ''H'' AND
 		     @aDTSession BETWEEN ui.dt_start AND ui.dt_end AND
	      ((aui.dt_effective IS NULL) OR (aui.dt_effective <= @aDTNow))
        AND aui.id_acc = @aAccountID
      return @retVal
    end
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[InsertUsageIntervalInfo]    Script Date: 06/02/2008 11:43:57 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertUsageIntervalInfo]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			 create proc [dbo].[InsertUsageIntervalInfo] @dt_start datetime, @dt_end datetime,@id_usage_cycle int, @id_usage_interval int OUTPUT
			 as 
			 select @id_usage_interval = id_interval from t_pc_interval where id_cycle = @id_usage_cycle
			 and dt_start=@dt_start and dt_end=@dt_end

			 insert into t_usage_interval (id_interval, dt_start, dt_end, 
			 id_usage_cycle, tx_interval_status) 
			   values (@id_usage_interval, @dt_start, @dt_end,@id_usage_cycle, ''O'') 
			 if ((@@error != 0) OR (@@rowcount != 1)) 
			 begin 
			   select @id_usage_interval = -99 
			 end 
			 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[InsertAcctToIntervalMapping]    Script Date: 06/02/2008 11:43:48 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertAcctToIntervalMapping]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				 CREATE PROC [dbo].[InsertAcctToIntervalMapping] @id_acc int, @id_interval int
         as 
				 SET NOCOUNT ON
				 if not exists (select * from t_acc_usage_interval where id_acc = @id_acc 
          and id_usage_interval = @id_interval) 
				 begin 
          insert into t_acc_usage_interval (id_acc, id_usage_interval, tx_status) 
          select @id_acc, @id_interval, ISNULL(tx_interval_status, ''O'')
          from t_usage_interval 
          where id_interval = @id_interval and
                tx_interval_status != ''B''
         end
			 ' 
END
GO
/****** Object:  View [dbo].[t_vw_rc_arrears_relative]    Script Date: 06/02/2008 11:44:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_rc_arrears_relative]'))
EXEC dbo.sp_executesql @statement = N'
CREATE VIEW [dbo].[t_vw_rc_arrears_relative]
AS
-- Obtain the associated subscription period, recurring cycle
-- and account usage cycle for each of the subscription recurring items
SELECT 
	t_sub.id_po,
	t_pl_map.id_pi_instance,
	t_pl_map.id_pi_template,
	t_pl_map.id_paramtable,
	t_pl_map.id_pi_type,
	t_sub.id_acc,
	t_sub.vt_start sub_dt_start,
	t_sub.vt_end sub_dt_end,
	t_recur.id_usage_cycle recur_usage_cycle_id,
	t_recur.b_advance,
	t_recur.b_prorate_on_activate,
	t_recur.b_prorate_on_deactivate,
	t_recur.b_fixed_proration_length,
	t_acc_usage_cycle.id_usage_cycle acc_usage_cycle_id
FROM 
	t_pl_map,
	t_recur,
	t_sub, 
	t_acc_usage_cycle
WHERE 
	t_pl_map.id_pi_instance = t_recur.id_prop AND
	t_pl_map.id_po = t_sub.id_po AND
	t_acc_usage_cycle.id_acc = t_sub.id_acc
'
GO
/****** Object:  StoredProcedure [dbo].[AdjustGsubMemberDates]    Script Date: 06/02/2008 11:43:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AdjustGsubMemberDates]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
create procedure [dbo].[AdjustGsubMemberDates](
@p_id_sub integer,
@p_startdate datetime,
@p_enddate datetime,
@p_adjustedstart datetime OUTPUT,
@p_adjustedend datetime OUTPUT,
@p_datemodified char(1) OUTPUT,
@p_status INT OUTPUT
)
as
begin
	select @p_datemodified = ''N''	

	select @p_adjustedstart = dbo.mtmaxoftwodates(@p_startdate,vt_start),
	@p_adjustedend = dbo.mtminoftwodates(@p_enddate,vt_end) 
	from 
	t_sub where id_sub = @p_id_sub

	if (@p_adjustedstart <> @p_startdate OR @p_adjustedend <> @p_enddate) begin
		select @p_datemodified = ''Y''
	end
	if @p_adjustedend < @p_adjustedstart begin
		-- hmm.... looks like we are outside the effective date of the group subscription
		-- MT_GSUB_DATERANGE_NOT_IN_SUB_RANGE
		select @p_status = -486604789
		return
	end
	select @p_status = 1
	return
end
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdateBillingGroupStatus]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateBillingGroupStatus]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
Updates the status for the accounts associated with the specified billing group 
to the specified status. The updates are recorded in t_acc_usage_interval.
===========================================================*/
CREATE PROCEDURE [dbo].[UpdateBillingGroupStatus]
(
   @id_billing_group INT,
   @status VARCHAR(1) 
)
AS

UPDATE aui SET aui.tx_status = @status
FROM t_acc_usage_interval aui 
INNER JOIN t_billgroup_member bgm 
   ON bgm.id_acc = aui.id_acc 
INNER JOIN t_billgroup bg 
   ON bg.id_billgroup = bgm.id_billgroup AND
         bg.id_usage_interval = aui.id_usage_interval
WHERE
    bg.id_billgroup = @id_billing_group
         
         ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[IsIntervalOpen]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsIntervalOpen]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
  
		CREATE  function [dbo].[IsIntervalOpen] (@id_acc int, @aIntervalID int) returns int
		as
		begin
		declare @retVal as int
		SET @retval = 0
		SELECT  @retVal = 
		CASE WHEN  
		( 
			SELECT  ui.tx_status 
			FROM  t_acc_usage_interval ui 
			WHERE ui.id_acc = @id_acc AND ui.id_usage_interval = @aIntervalID
		)
			IN (''B'', ''O'') THEN 1 ELSE 0 END
			return @retVal
		end
		
' 
END
GO
/****** Object:  View [dbo].[vw_all_billing_groups_status]    Script Date: 06/02/2008 11:44:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[vw_all_billing_groups_status]'))
EXEC dbo.sp_executesql @statement = N'
-- ===========================================================
-- Create a VIEW [on t_acc_usage_interval, t_billgroup_member and t_billgroup] which specifies
-- the following for each interval which has billing groups :

-- id_billgroup
-- id_usage_interval
-- status of the billing group (''O'', ''C'', or ''H'')
-- ===========================================================
CREATE VIEW [dbo].[vw_all_billing_groups_status] AS 
SELECT bgm.id_billgroup, aui.id_usage_interval, aui.tx_status status
FROM t_billgroup_member bgm
INNER JOIN t_billgroup bg ON bg.id_billgroup = bgm.id_billgroup
INNER JOIN t_acc_usage_interval aui ON aui.id_acc = bgm.id_acc 
WHERE bg.id_usage_interval = aui.id_usage_interval 
GROUP BY aui.id_usage_interval, bgm.id_billgroup, aui.tx_status
	'
GO
/****** Object:  StoredProcedure [dbo].[CreateDefaultPartition]    Script Date: 06/02/2008 11:43:26 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateDefaultPartition]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      /*
      	Proc: CreateDefaultPartition
      
      	Creates the default parition (if needed) and realigns the 
      	t_partition table to match.
      
      */
      create proc [dbo].[CreateDefaultPartition]
      as
      begin
      
      /* Vars holding default parititon properties
      */
      declare @partition_id int
      declare @partition_name varchar(300)
      declare @dt_start datetime
      declare @dt_end datetime
      declare @interval_start int
      declare @interval_end int
      declare @dt_point datetime
      
      /* Misc. vars
      */
      declare @rc int  -- row count
      declare @err int	-- sql statement errors
      declare @ret int	-- called proc return codes
      
      /* Create or update the default partition
      */
      
      /*-- debugging...
      select 
      	min(dt_start) as dt_start,
      	max(dt_end) as dt_end,
      	min(id_interval_start) as interval_start,
      	max(id_interval_end) as interval_end
      from t_partition
      where b_active = ''Y''
      */
      
      /* Get properties of new default partition based on existing active 
      	partitions.  The default covers the unbounded date ranges above 
      	and below the set of active continuous partitions.
      */
      select 
      	-- end + 1 sec is start of default
      	@dt_start = dateadd(s, 1, max(dt_end)),
      	-- start - 1 sec is end of default
      	@dt_end = dateadd(s, -1, min(dt_start)),
      	-- interval start is end + 1 sec
      	@interval_start = datediff(d, ''1970-1-1'', dateadd(s, 1, max(dt_end))) 
      		* power(2,16),
      	-- interval end is start - 1 sec
      	@interval_end = datediff(d, ''1970-1-1'', dateadd(s, -1, min(dt_start))) 
      			* power(2,16) + (power(2,16) - 1) 
      from t_partition	
      where b_active = ''Y''
      select @rc = @@rowcount, @err = @@error
      
      /* If there are no active partitions, then the default 
      	covers all intervals.
      */
      if (@dt_start is null) begin
      	-- if no other partitions the default boundry is arbitrary
      	set @dt_point = convert(varchar, getdate(), 102)
      	set @dt_start = @dt_point
      	set @dt_end = dateadd(s, -1, @dt_point)
      	set @interval_start = datediff(d, ''1970-1-1'', @dt_start) * power(2,16)
      	set @interval_end = datediff(d, ''1970-1-1'', @dt_end) * power(2,16) 
      							+ (power(2,16) - 1)
      end
      
      /* Get partition database params
      */
      declare @datasize int
      declare @logsize int
      select @datasize = partition_data_size,
      	@logsize = partition_log_size
      from t_usage_server
      
      declare @path varchar(500)
      exec GetNextStoragePath @path out
      
      /* Create the partition database.
      */
      set @partition_name = ''N_default''
      exec @ret = CreatePartitionDatabase @partition_name, @path, @datasize, @logsize
      
      if (@ret <> 0) begin
      	raiserror(''Could not create Default partition [%s]'', 16, 1, @partition_name)
      	return 1
      end
      
      /* Get id of default partition if it exists
      */
      select @partition_id = id_partition
      from t_partition
      where b_default = ''Y''
      
      select @rc = @@rowcount
      if (@rc > 1) begin
      	raiserror(''Consistency failure: Found %i default partitions. There can be only one.'', 
      		16, 1, @rc)
      	return 1
      end
      
      begin tran
      
      	/* Insert partition metadata if new, else update
      	*/
      	if (@rc = 0) begin
      		insert into t_partition (
      			partition_name, b_default, dt_start, dt_end, id_interval_start,
      			id_interval_end, b_active)
      			values (
      			rtrim(@partition_name), ''Y'', @dt_start, @dt_end, @interval_start,
      			@interval_end, ''Y'')
      		set @err = @@error
      		if (@err <> 0) begin
      			raiserror(''Cannot insert into t_partition for default database [%s]'', 
      				16, 1, @partition_name)
      			rollback
      			return 1
      		end
      	end 
      	else begin
      		update t_partition set
      			dt_start = @dt_start,
      			dt_end = @dt_end,
      			id_interval_start = @interval_start,
      			id_interval_end = @interval_end
      		where id_partition = @partition_id
      		set @err = @@error
      		if (@err <> 0) begin
      			raiserror(''Cannot update t_partition for default database [%s]'', 
      				16, 1, @partition_name)
      			rollback
      			return 1
      		end
      	end
      
      commit tran
      
      end
 	' 
END
GO
/****** Object:  StoredProcedure [dbo].[Analyze]    Script Date: 06/02/2008 11:43:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Analyze]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
    
  Create PROCEDURE [dbo].[Analyze] (@table_name nvarchar(30))
    as
    begin
	  declare @rows_changed int
	  declare @query nvarchar(4000)
	  declare @svctablename nvarchar(255)
	  declare @id_svc nvarchar(10) 
	  
	  -- mark the successful rows as analyzed.
		if exists (select 1 from t_usage_server where b_partitioning_enabled = ''N'')
		begin
				set @query = N''update '' + @table_name +
					N'' set tx_state = ''''A''''
					from '' + @table_name + N'' rr
					inner join t_acc_usage acc
					on rr.id_sess = acc.id_sess
					and acc.id_usage_interval = rr.id_interval
					where tx_state = ''''I''''''
		end
		else
		begin
				set @query = N''update '' + @table_name +
					N'' set tx_state = ''''A''''
					from '' + @table_name + N'' rr
					inner join t_uk_acc_usage_tx_uid acc
					on rr.id_source_sess = acc.tx_uid
					where tx_state = ''''I''''''
		end
	  EXEC sp_executesql @query
	  
	  -- set the id_parent_source_sess correctly for the children already 
	  -- identified by now (successful only)
	 
	  set @query = N''update '' + @table_name +
		  N'' set id_parent_source_sess = acc.tx_uid
		  from '' + @table_name + N'' rr
		  inner join t_acc_usage acc
		  on rr.id_parent_sess = acc.id_sess
		  and acc.id_usage_interval = rr.id_interval
		  where acc.id_parent_sess is null
		  and rr.id_parent_source_sess is null
		  and rr.tx_state = ''''A''''''
    EXEC sp_executesql @query
    
	  -- just so the loop will run the first time
	  set @rows_changed = 1

		-- find parents for successful sessions
		set @query = N''
		insert into '' + @table_name + N'' (id_source_sess, tx_batch, id_sess, id_parent_sess, root, id_interval, id_view, tx_state, id_svc, id_parent_source_sess, id_payer, amount, currency)
		  select distinct 
			auparents.tx_UID,	-- id_source_sess
			auparents.tx_batch,	-- tx_batch
			auparents.id_sess,	-- id_sess
			auparents.id_parent_sess,	-- id_parent
			null,				-- TODO: root
			auparents.id_usage_interval,	-- id_interval
			auparents.id_view,		-- id_view
			case aui.tx_status when ''''H'''' then ''''C'''' else ''''A'''' end, -- c_state
			auparents.id_svc,		-- id_svc
			NULL, -- id_parent_source_sess
			auparents.id_acc,
			auparents.amount,
			auparents.am_currency
		  from t_acc_usage auchild
		  inner join '' + @table_name + N'' rr on auchild.id_sess = rr.id_sess
  		  and auchild.id_usage_interval =rr.id_interval
		  inner join t_acc_usage auparents on auparents.id_sess = auchild.id_parent_sess
		  and auparents.id_usage_interval =auchild.id_usage_interval
		  inner join t_acc_usage_interval aui on auparents.id_usage_interval = aui.id_usage_interval
        and auparents.id_acc = aui.id_acc
		  where not exists (select * from '' + @table_name + N'' rr1 where rr1.id_sess = auparents.id_sess and auparents.id_usage_interval =rr1.id_interval)''
		EXEC sp_executesql @query

		-- find children for successful sessions
		set @query = N''insert into '' + @table_name + N'' (id_source_sess, tx_batch, id_sess, id_parent_sess, 
				root, id_interval, id_view, tx_state, id_svc, id_parent_source_sess, id_payer, amount, currency)
		  select
			au.tx_UID,	-- id_source_sess
			au.tx_batch,	-- tx_batch
			au.id_sess,	-- id_sess
			au.id_parent_sess,	-- id_parent
			null,			-- TODO: root
			au.id_usage_interval,	-- id_interval
			au.id_view,		-- id_view
			case aui.tx_status when ''''H'''' then ''''C'''' else ''''A'''' end,			-- tx_state
			au.id_svc,	-- id_svc
			rr.id_source_sess, -- id_parent_source_sess
			au.id_acc,
			au.amount,
			au.am_currency
			from t_acc_usage au
			inner join '' + @table_name + N'' rr on au.id_parent_sess = rr.id_sess
			and au.id_usage_interval = rr.id_interval
			inner join t_acc_usage_interval aui on au.id_usage_interval = aui.id_usage_interval
         and au.id_acc = aui.id_acc
			where not exists (select 1 from '' + @table_name + N'' rr1 where rr1.id_sess = au.id_sess
			and rr1.id_interval = au.id_usage_interval)''
		EXEC sp_executesql @query

	 set @rows_changed = 1
	 -- complete the compound for failure cases.  In t_failed_transaction, you will have only the failed
	 -- portion of the failed transaction.
	 while (@rows_changed > 0)
	 begin
		set @rows_changed = 0
		-- find children for failed parent sessions
		-- find tables where children may live.
	  create table #tmpcursor1 (nm_table_name nvarchar(255), id_enum_data int)
	  set @query = N''insert into #tmpcursor1 (nm_table_name, id_enum_data)
			select distinct slog.nm_table_name, ed.id_enum_data
			from '' + @table_name + N''  rr
			inner join t_failed_transaction ft WITH (READCOMMITTED)
			on (rr.id_source_sess = ft.tx_failureCompoundID)
			inner join t_session_set ss WITH (READCOMMITTED)
			on ss.id_ss = ft.id_sch_ss
			inner join t_session_set childss WITH (READCOMMITTED)
			on ss.id_message = childss.id_message
			inner join t_enum_data ed
			on ed.id_enum_data = childss.id_svc
			inner join t_service_def_log slog
			on ed.nm_enum_data = slog.nm_service_def
			where id_parent_source_sess is null and tx_state = ''''E''''
			and childss.b_root = ''''0''''''
	  EXEC sp_executesql @query
		DECLARE tablename_cursor CURSOR FOR select nm_table_name, id_enum_data from #tmpcursor1
		OPEN tablename_cursor
		FETCH NEXT FROM tablename_cursor into @svctablename, @id_svc
		WHILE @@FETCH_STATUS = 0
		BEGIN
			PRINT @svctablename
			set @query = ''insert into '' + @table_name + N'' (id_source_sess, tx_batch, id_sess, id_parent_sess, root, id_interval, id_view, tx_state, id_svc, id_parent_source_sess, id_payer, amount, currency)
			select 
			conn.id_source_sess,	-- id_source_sess
			conn.c__CollectionID,	-- tx_batch
			NULL,	-- id_sess
			NULL,	-- id_parent_sess
			NULL,			-- TODO: root
			NULL,	-- id_interval
			NULL,		-- id_view
			''''E'''',			-- tx_state
			''+ @id_svc + N'' , 	-- id_svc
			conn.id_parent_source_sess,
			null, -- id_payer
			null, -- amount
			null -- currency
			from '' + @table_name + N'' rr
			inner join '' + @svctablename + N'' conn WITH (READCOMMITTED)
			on rr.id_source_sess = conn.id_parent_source_sess
			where rr.id_parent_source_sess is null and tx_state = ''''E''''
			and not exists (select * from '' + @table_name + N'' where '' +  @table_name + ''.id_source_sess = conn.id_source_sess)''
			EXEC sp_executesql @query
			set @rows_changed = @rows_changed + @@ROWCOUNT
			FETCH NEXT FROM tablename_cursor into @svctablename, @id_svc
		END
		CLOSE tablename_cursor
		DEALLOCATE tablename_cursor
    drop table #tmpcursor1
    		-- find parents for failed children sessions
		-- this query gives us all the svc tables in which the parents may live
	  create table #tmpcursor2 (nm_table_name nvarchar(255), id_enum_data int)
	  set @query =  N''insert into #tmpcursor2(nm_table_name, id_enum_data)
			select distinct slog.nm_table_name, cast(ed.id_enum_data as nvarchar(10))
			from '' + @table_name + N'' rr
			inner join t_failed_transaction ft WITH (READCOMMITTED)
			on rr.id_source_sess = ft.tx_failureID
			inner join t_session_set ss WITH (READCOMMITTED)
			on ss.id_ss = ft.id_sch_ss
			inner join t_session_set parentss WITH (READCOMMITTED)
			on ss.id_message = parentss.id_message
			inner join t_enum_data ed
			on ed.id_enum_data = parentss.id_svc
			inner join t_service_def_log slog
			on ed.nm_enum_data = slog.nm_service_def
			where id_parent_source_sess is not null
			and tx_state = ''''E''''
			and ss.id_svc <> parentss.id_svc
			and parentss.b_root = ''''1''''''
	  EXEC sp_executesql @query
 		DECLARE tablename_cursor CURSOR FOR select nm_table_name, id_enum_data from #tmpcursor2
		OPEN tablename_cursor
		FETCH NEXT FROM tablename_cursor into @svctablename, @id_svc
		WHILE @@FETCH_STATUS = 0
		BEGIN
			PRINT @svctablename
			set @query = ''insert into '' + @table_name + N'' (id_source_sess, tx_batch, id_sess, id_parent_sess, root, id_interval, id_view, tx_state, id_svc, id_parent_source_sess, id_payer, amount, currency)
			select 
			call.id_source_sess,	-- id_source_sess
			call.c__CollectionID,	-- tx_batch
			NULL,	-- id_sess
			NULL,	-- id_parent_sess
			NULL,			-- TODO: root
			NULL,	-- id_interval
			NULL,		-- id_view
			''''E'''',			-- tx_state 
			''+ @id_svc + N'' , 	-- id_svc
			call.id_parent_source_sess,
			null, -- id_payer
		  null, -- amount
		  null  -- currency
			from '' + @table_name + N'' rr
			inner join '' + @svctablename + N'' call WITH (READCOMMITTED)
			on rr.id_parent_source_sess = call.id_source_sess
			where rr.id_parent_source_sess is not null and tx_state = ''''E''''
			and not exists (select * from '' + @table_name + N'' where '' +  @table_name + ''.id_source_sess = call.id_source_sess)''
			EXEC sp_executesql @query
			set @rows_changed = @rows_changed + @@ROWCOUNT
			FETCH NEXT FROM tablename_cursor into @svctablename, @id_svc
		END
		CLOSE tablename_cursor
		DEALLOCATE tablename_cursor
    DROP TABLE #tmpcursor2
	 end
	-- handle suspended and pending transactions.  We know we will have identified
	-- all suspended and pending parents.  Only children need to be looked at.
	-- following query tells us which tables to look for the children
	-- changing the cursor query.. for whatever reason,it takes too long, even when there are 
	-- no suspended transactions (CR: 13059)
	create table #tmpcursor3 (nm_table_name nvarchar(255), id_enum_data int)
	set @query =  N''insert into #tmpcursor3(nm_table_name, id_enum_data)
			select distinct slog.nm_table_name , cast(ss2.id_svc as nvarchar(10))
			from t_session_set ss2 WITH (READCOMMITTED)
			inner join t_enum_data ed
			on ss2.id_svc = ed.id_enum_data
			inner join t_service_def_log slog
			on ed.nm_enum_data = slog.nm_service_def
			where id_message in (
			select ss.id_message from ''+ @table_name + N'' rr
			inner join t_session sess WITH (READCOMMITTED)
			on sess.id_source_sess = rr.id_source_sess
			inner join t_session_set ss WITH (READCOMMITTED)
			on sess.id_ss = ss.id_ss
			inner join t_message msg WITH (READCOMMITTED)
			on msg.id_message = ss.id_message
			where rr.tx_state = ''''NC'''')
			and ss2.b_root = ''''0''''''
		EXEC sp_executesql @query
		DECLARE tablename_cursor CURSOR FOR select nm_table_name, id_enum_data from #tmpcursor3
		OPEN tablename_cursor
		FETCH NEXT FROM tablename_cursor into @svctablename, @id_svc
		WHILE @@FETCH_STATUS = 0
		BEGIN
			set @query = N''insert into '' + @table_name + N'' (id_source_sess, tx_batch, id_sess, id_parent_sess, root, id_interval, id_view, tx_state, id_svc, id_parent_source_sess, id_payer, amount, currency)
				select svc.id_source_sess, null, 
				null, null, null, null, null, ''''NA'''', ''
				+ cast(@id_svc as nvarchar(10)) + N'' , rr.id_source_sess, null, null, null
				from '' + @table_name + N'' rr
				inner join '' + @svctablename + N'' svc WITH (READCOMMITTED)
				on rr.id_source_sess = svc.id_parent_source_sess
				where rr.tx_state = ''''NC''''
				and svc.id_source_sess not in (select id_source_sess from '' + @table_name +'')''
			EXEC sp_executesql @query
			FETCH NEXT FROM tablename_cursor into @svctablename, @id_svc
		END
		CLOSE tablename_cursor
		DEALLOCATE tablename_cursor
		set @query = N''update '' + @table_name + N''
			set tx_state = ''''NA'''' where
			tx_state = ''''NC''''''
		EXEC sp_executesql @query
		DROP TABLE #tmpcursor3
  end
  
  ' 
END
GO
/****** Object:  StoredProcedure [dbo].[MoveDataToPartitions]    Script Date: 06/02/2008 11:44:01 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MoveDataToPartitions]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      /*
      	Proc: MoveDataToPartitions
      
			**** DEPRECATED 08/30/05 ***** 
			
      	Moves data from a source table into it''s appropriate partitions.
      
      	@srctab  -- name of source data table
      	@destab  -- destination partition view
      	@mode		-- ''copy'' or ''move'' (move deletes src rows)
      
      */
      create proc [dbo].[MoveDataToPartitions]
      	@srctab nvarchar(300),
      	@destab nvarchar(300),
      	@mode varchar(4) = ''copy''
      AS
      begin
      
      -- Check mode arg
      if @mode not in (''move'', ''copy'')
      begin
      	raiserror(''Invalid mode: %s.'', 16, 1, @mode)
      	return 1
      end
      
      
      -- Abort if system isn''t enabled for partitioning
      if not exists (select b_partitioning_enabled from t_usage_server 
      			where b_partitioning_enabled = ''Y'')
      begin
      	raiserror(''System not enabled for partitioning.'',0,1)
      	return 1
      end
      
      -- Error handling and row counts
      declare @err int   -- last error
      declare @rc int	-- row count
      
      -- Local table stores a list of partitions for deployment
      declare @partns table (
      	id_partition int,
      	partition_name varchar(100),
      	b_default char(1),
      	dt_start datetime,
      	dt_end datetime,
      	interval_start int,
      	interval_end int
      	)
      
      -- Get list of partition databases.  The destination table
      -- must exist in each of these.
      insert into @partns
      	select p.id_partition, partition_name, b_default,
      		dt_start, dt_end, id_interval_start, id_interval_end
      	from t_partition p
      /*	left join t_partition_pv_map pmap
      		on pmap.id_partition = p.id_partition
      	left join t_prod_view pv
      		on pv.id_prod_view = pmap.id_prod_view
      */	where b_active = ''Y''
      	order by p.dt_end
      set @rc = @@rowcount
      set @err = @@error
      --select @err as err, @rc as rowcnt
      
      -- Copy source data to each target partition
      declare @destdb varchar(200)
      declare @interval_start int
      declare @interval_end int
      
      declare partcur cursor for 
      	select partition_name, interval_start, interval_end
      	from @partns
      
      open partcur
      
      declare @fs int
      set @fs = 0
      while (@fs = 0) begin
      	fetch partcur into @destdb, @interval_start, @interval_end
      	set @fs = @@fetch_status
      
      	-- Quit loop when list exhausted
      	if (@fs <> 0)
      		break
      
      	-- Move data to new partitions
      	declare @srcdata varchar(200)
      	declare @destdata varchar(200)
      	set @srcdata = @srctab
      	set @destdata = @destdb + ''.dbo.'' + @destab
      	
      	-- Skip if the src and dest are the same.  This can happen
      	-- if the source table is the default partition.
      	if (lower(@srcdata) = lower(@destdata))
      		continue
      
      	declare @inscmd varchar(1000)
      	declare @delcmd varchar(1000)
      	declare @oper varchar(3)
      	declare @range varchar(200)
      
      	set @range = dbo.GetPartitionPredicate(@interval_start, @interval_end)
      	set @inscmd = ''insert into '' + @destdata + ''
      					select * from '' + @srcdata + ''
      					where '' + @range
      	
      	set @delcmd = ''delete from '' + @srcdata + '' where '' + @range
      
      	begin tran
      		-- todo: make sure this transaction really works
				raiserror(''Data %s from [%s] to [%s]'', 0, 1, @mode, @srcdata, @destdata)
      		--print @inscmd
      		exec(@inscmd)
      		if (@mode = ''move'') begin
      			--print @delcmd
      			exec(@delcmd)
      		end
      	commit
      
      end
      deallocate partcur
      
      end	-- proc
 	' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[IsSystemPartitioned]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsSystemPartitioned]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
      /*
      	Returns 1 if the system is enabled for partitioning.
      */
      
      create function [dbo].[IsSystemPartitioned] ()
      returns int
      as
      begin
      
      	if exists (select b_partitioning_enabled from t_usage_server 
      						where b_partitioning_enabled = ''Y'')
      		return 1
      
      	return 0
      end
      
 	' 
END
GO
/****** Object:  StoredProcedure [dbo].[AddNewSub]    Script Date: 06/02/2008 11:43:06 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddNewSub]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
create procedure [dbo].[AddNewSub](
 @p_id_acc int, 
 @p_dt_start datetime,
 @p_dt_end datetime,
 @p_NextCycleAfterStartDate varchar,
 @p_NextCycleAfterEndDate varchar,
 @p_id_po int,
 @p_GUID varbinary(16),
 @p_systemdate datetime,
 @p_id_sub int,
 @p_status int output,
 @p_datemodified varchar(1) output)
as
begin
declare @real_begin_date as datetime
declare @real_end_date as datetime
declare @po_effstartdate as datetime
declare @varMaxDateTime datetime
declare @datemodified varchar(1)
select @varMaxDateTime = dbo.MTMaxDate()
	select @p_status =0
-- compute usage cycle dates if necessary
if (upper(@p_NextCycleAfterStartDate) = ''Y'')
 begin
 select @real_begin_date = dbo.NextDateAfterBillingCycle(@p_id_acc,@p_dt_start)
 end
else
 begin
   select @real_begin_date = @p_dt_start
 end 
if (upper(@p_NextCycleAfterEndDate) = ''Y'' AND @p_dt_end is not NULL)
 begin
 select @real_end_date = dbo.NextDateAfterBillingCycle(@p_id_acc,@p_dt_end)
   end
else
 begin
 select @real_end_date = @p_dt_end
 end
if (@p_dt_end is NULL)
 begin
 select @real_end_date = @varMaxDateTime
 end
exec AddSubscriptionBase @p_id_acc,NULL,@p_id_po,@real_begin_date,@real_end_date,@p_GUID,@p_systemdate,@p_id_sub,
@p_status output,@datemodified output
select @p_datemodified = @datemodified
end
		' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[checksubscriptionconflicts]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[checksubscriptionconflicts]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
	
create function [dbo].[checksubscriptionconflicts] (
@id_acc            INT,
@id_po             INT,
@real_begin_date   DATETIME,
@real_end_date     DATETIME,
@id_sub            INT
)
RETURNS INT
AS
begin
declare @status int
declare @cycle_type int
declare @po_cycle int

SELECT @status = COUNT (t_sub.id_sub)
FROM t_sub
WHERE t_sub.id_acc = @id_acc
 AND t_sub.id_po = @id_po
 AND t_sub.id_sub <> @id_sub
 AND dbo.overlappingdaterange (t_sub.vt_start,t_sub.vt_end,@real_begin_date,@real_end_date)= 1
IF (@status > 0)
	begin
 -- MTPCUSER_CONFLICTING_PO_SUBSCRIPTION
  RETURN (-289472485)
	END
select @status = dbo.overlappingdaterange(@real_begin_date,@real_end_date,te.dt_start,te.dt_end)
from t_po
INNER JOIN t_effectivedate te on te.id_eff_date = t_po.id_eff_date
where id_po = @id_po
if (@status <> 1)
	begin
	-- MTPCUSER_PRODUCTOFFERING_NOT_EFFECTIVE
	return (-289472472)
	end

SELECT @status = COUNT (id_pi_template)
FROM t_pl_map
WHERE 
  t_pl_map.id_po = @id_po AND
  t_pl_map.id_paramtable IS NULL AND
  t_pl_map.id_pi_template IN
           (SELECT id_pi_template
            FROM t_pl_map
            WHERE 
              id_paramtable IS NULL AND
              id_po IN
                         (SELECT id_po
                            FROM t_vw_effective_subs subs
                            WHERE subs.id_sub <> @id_sub
                            AND subs.id_acc = @id_acc
                             AND dbo.overlappingdaterange (
                                    subs.dt_start,
                                    subs.dt_end,
                                    @real_begin_date,
                                    @real_end_date
                                 ) = 1))
IF (@status > 0)
	begin
	return (-289472484)
	END

-- CR 10872: make sure account and po have the same currency

-- BP - actually we need to check if a payer has different currency
-- In Kona we allow non billable accounts to be created with no currency
--if (dbo.IsAccountAndPOSameCurrency(@id_acc, @id_po) = ''0'')

if EXISTS
(
SELECT 1 FROM t_payment_redirection pr
INNER JOIN t_av_internal avi on avi.id_acc = pr.id_payer
INNER JOIN t_po po on  po.id_po = @id_po
INNER JOIN t_pricelist pl ON po.id_nonshared_pl = pl.id_pricelist
WHERE pr.id_payee = @id_acc
AND avi.c_currency <>  pl.nm_currency_code
AND (pr.vt_start <= @real_end_date AND pr.vt_end >= @real_begin_date)
)
begin
	-- MT_ACCOUNT_PO_CURRENCY_MISMATCH
	return (-486604729)
end

-- Check for MTPCUSER_ACCOUNT_TYPE_NOT_SUBSCRIBABLE 0xEEBF004EL -289472434
-- BR violation
if
  exists (
    SELECT 1
    FROM  t_account tacc 
    INNER JOIN t_account_type tacctype on tacc.id_type = tacctype.id_type
    WHERE tacc.id_acc = @id_acc AND tacctype.b_CanSubscribe = ''0''
  )
begin
  return(-289472434) -- MTPCUSER_ACCOUNT_TYPE_NOT_SUBSCRIBABLE 
end

-- check that account type of the account is compatible with the product offering
-- since the absense of ANY mappings for the product offering means that PO is "wide open"
-- we need to do 2 EXISTS queries
if
exists (
SELECT 1
FROM t_po_account_type_map atmap 
WHERE atmap.id_po = @id_po
)
--PO is not wide open - see if subscription is permitted for the account type
AND
not exists (
SELECT 1
FROM  t_account tacc 
INNER JOIN t_po_account_type_map atmap on atmap.id_po = @id_po AND atmap.id_account_type = tacc.id_type
 WHERE  tacc.id_acc = @id_acc
)
begin
 return (-289472435) -- MTPCUSER_CONFLICTING_PO_ACCOUNT_TYPE
end


RETURN (1)
END
	' 
END
GO
/****** Object:  StoredProcedure [dbo].[InstantiateScheduledEvent]    Script Date: 06/02/2008 11:43:57 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InstantiateScheduledEvent]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[InstantiateScheduledEvent] 
  (
    @dt_now DATETIME,
    @id_event INT,
    @dt_end DATETIME,
    @id_instance INT OUTPUT,
    @status INT OUTPUT
  )
AS

BEGIN

  BEGIN TRAN

  SELECT @status      = -99
  SELECT @id_instance = -99

  --
  -- attempts to update an pre-existing NotYetRun instance of this event
  --
  SELECT @id_instance = inst.id_instance
  FROM t_recevent_inst inst
  INNER JOIN 
  (
    -- finds the last instance
    SELECT MAX(inst.dt_arg_end) dt_arg_end
    FROM t_recevent evt
    INNER JOIN t_recevent_inst inst ON inst.id_event = evt.id_event
    WHERE
      -- event is active
      evt.dt_activated <= @dt_now AND
      (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
      evt.id_event = @id_event AND
      -- event is of type scheduled
      evt.tx_type = ''Scheduled''
  ) maxinst ON maxinst.dt_arg_end = inst.dt_arg_end
  WHERE
    inst.id_event = @id_event AND
    -- run has not yet been run
    inst.tx_status = ''NotYetRun'' AND
    -- existing end date of the latest instance must be 
    -- before the newly requested end date
    inst.dt_arg_end < @dt_end

  IF (@@ROWCOUNT = 1)
  BEGIN
    UPDATE t_recevent_inst SET dt_arg_end = @dt_end WHERE id_instance = @id_instance

    COMMIT
    SELECT @status = 0 -- success (update)
    RETURN
  END


  --
  -- otherwise, an existing instance did not exist so create a new one
  --
  INSERT INTO t_recevent_inst(id_event,id_arg_interval,dt_arg_start,dt_arg_end,b_ignore_deps,dt_effective,tx_status)
  SELECT
    evt.id_event,
    NULL,             -- id_arg_interval
    MAX(dbo.AddSecond(ISNULL(inst.dt_arg_end, dbo.SubtractSecond(evt.dt_activated)))),
    @dt_end,          -- dt_arg_end
    ''N'',              -- b_ignore_deps
    NULL,             -- dt_effective
    ''NotYetRun''       -- tx_status
  FROM t_recevent evt
  LEFT OUTER JOIN t_recevent_inst inst ON inst.id_event = evt.id_event
  WHERE
    -- event is active
    evt.dt_activated <= @dt_now AND
    (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
    evt.id_event = @id_event AND
    -- event is of type scheduled
    evt.tx_type = ''Scheduled''
  GROUP BY
    evt.id_event
  HAVING 
    -- start date must come before the requested end date
    MAX(dbo.AddSecond(ISNULL(inst.dt_arg_end, evt.dt_activated))) < @dt_end

  -- success!
  IF (@@ROWCOUNT = 1)
  BEGIN
    SELECT @status = 0    -- success (insert)
    SELECT @id_instance = @@IDENTITY
    COMMIT
    RETURN
  END


  -- 
  -- no instance was updated or created - figure out exactly what went wrong
  --

  -- does the event exist?
  SELECT 
    evt.id_event
  FROM t_recevent evt
  WHERE
    evt.dt_activated <= @dt_now AND
    (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
    evt.id_event = @id_event

  IF (@@ROWCOUNT = 0)
  BEGIN
    SELECT @status = -1 -- event not found
    ROLLBACK
    RETURN
  END

  -- is the event of type scheduled?
  SELECT 
    evt.id_event
  FROM t_recevent evt
  WHERE
    evt.tx_type = ''Scheduled'' AND
    evt.id_event = @id_event

  IF (@@ROWCOUNT = 0)
  BEGIN
    SELECT @status = -2 -- event is not active
    ROLLBACK
    RETURN
  END

  -- is the last instances end date greater than the proposed start date?
  SELECT
    evt.id_event,
    MAX(dbo.AddSecond(ISNULL(inst.dt_arg_end, dbo.SubtractSecond(evt.dt_activated))))
  FROM t_recevent evt
  LEFT OUTER JOIN t_recevent_inst inst ON inst.id_event = evt.id_event
  WHERE 
    evt.id_event = @id_event 
  GROUP BY
    evt.id_event
  HAVING 
    -- start date must come before the requested end date
    MAX(dbo.AddSecond(ISNULL(inst.dt_arg_end, evt.dt_activated))) < @dt_end

  IF (@@ROWCOUNT = 0)
  BEGIN
    SELECT @status = -3 -- last end date is greater than the proposed start date
    ROLLBACK
    RETURN
  END

  -- unknown failure
  ROLLBACK
  SELECT @status = -99  
END
  ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CancelSubmittedEvent]    Script Date: 06/02/2008 11:43:15 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CancelSubmittedEvent]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[CancelSubmittedEvent]
(
  @dt_now DATETIME,
  @id_instance INT,
  @id_acc INT,
  @tx_detail nvarchar(2048),
  @status INT OUTPUT
)
AS

BEGIN
  DECLARE @current_status VARCHAR(14)
  DECLARE @previous_status VARCHAR(14)

  SELECT @status = -99

  BEGIN TRAN
  -- gets the instances current status
  SELECT 
    @current_status = inst.tx_status
  FROM t_recevent_inst inst
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  WHERE 
    -- event is active
    evt.dt_activated <= @dt_now AND
    (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
    inst.id_instance = @id_instance
  
  IF @@ROWCOUNT = 0
  BEGIN
    SELECT @status = -1  -- instance was not found
    ROLLBACK
    RETURN
  END

  IF @current_status = ''ReadyToRun''
  BEGIN
    -- the only way to get to ReadyToRun is from NotYetRun
    SELECT @previous_status = ''NotYetRun''
  END
  ELSE IF @current_status = ''ReadyToReverse''
  BEGIN
    -- the only way to get to ReadyToReverse is from Succeeded or Failed
    -- determines which of these two statuses by looking at the last run''s status
    SELECT TOP 1 @previous_status = run.tx_status
    FROM t_recevent_run run
    WHERE run.id_instance = @id_instance
    ORDER BY run.dt_end desc
  END
  ELSE
  BEGIN
    SELECT @status = -2  -- instance cannot be cancelled because it is not in a legal state
    ROLLBACK
    RETURN
  END
  -- reverts the instance''s state to what it was previously
  UPDATE t_recevent_inst
  SET tx_status = @previous_status, b_ignore_deps = ''N'', dt_effective = NULL
  WHERE id_instance = @id_instance

  -- records the action
    INSERT INTO t_recevent_inst_audit(id_instance,id_acc,tx_action,b_ignore_deps,dt_effective,tx_detail,dt_crt)
  VALUES(@id_instance, @id_acc, ''Cancel'', NULL, NULL, @tx_detail, @dt_now) 

  SELECT @status = 0  -- success

  COMMIT
END
' 
END
GO
/****** Object:  StoredProcedure [dbo].[DeleteTemplate]    Script Date: 06/02/2008 11:43:37 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteTemplate]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			CREATE procedure [dbo].[DeleteTemplate](
				@p_id_template int, 
				@p_status int output)
 			as
	 		begin
				select @p_status = 1 --success

				-- delete the subscriptions in this template
		 		delete from t_acc_template_subs 
					where id_acc_template = @p_id_template
				-- delete properties for this template
		 		delete from t_acc_template_props
					where id_acc_template = @p_id_template
				-- delete the template itself
		 		delete from t_acc_template
					where id_acc_template = @p_id_template
		 		if (@@rowcount <> 1)
		   		begin
					select @p_status = -486604725 -- create an error MT_NO_TEMPLATE_FOUND
		   		end
			 end
				' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreateAndPopulateTempAccts]    Script Date: 06/02/2008 11:43:23 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateAndPopulateTempAccts]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
Populate the temporary table using @accountArray.
===========================================================*/
CREATE PROCEDURE [dbo].[CreateAndPopulateTempAccts]
(
   @accountArray VARCHAR(4000),
   @status INT OUTPUT
)
AS

BEGIN     
   SET @status = -1

   delete tmp_billing_rerun_accounts;

  /* Insert the accounts in @accountArray into @tx_tableName */
  INSERT INTO tmp_billing_rerun_accounts with (tablockx)
	SELECT value FROM CSVToInt(@accountArray);

  SET @status = 0
END
         ' 
END
GO
/****** Object:  StoredProcedure [dbo].[StartChildGroupCreation]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[StartChildGroupCreation]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
1) Parses the comma separated account identifiers (@accountArray) using the user defined function ''CSVToInt''
2) Validates that there are no duplicate accounts in @accountArray
3) Validates that the accounts are from the parent billing group (id_parent_billgroup)
4) Inserts name and description into t_billgroup_tmp
5) Inserts user specified account ids into  t_billgroup_member_tmp

Returns the following error codes:
   -1 : Unknown error occurred
   -2 : No accounts in @accountArray
   -3 : Duplicate accounts in @accountArray 
   -4 : Account(s) in @accountArray not a member of id_parent_billgroup 
   -5 : Accounts in @accounts are all the member accounts of id_parent_billgroup

=========================================================== */
CREATE PROCEDURE [dbo].[StartChildGroupCreation]
(
   @id_materialization INT,
   @tx_name NVARCHAR(50),
   @tx_description NVARCHAR(200),
   @id_parent_billgroup INT,
   @accountArray VARCHAR(4000),
   @status INT OUTPUT
)
AS
   BEGIN TRAN
   
   SET @status = -1
 
   /* Hold the user specified account id''s in @accountArray */
   DECLARE @accounts TABLE
   ( 
      id_acc INT NOT NULL
   )

  /* Insert the accounts in @accountArray into @accounts */
  INSERT INTO @accounts
  SELECT value FROM CSVToInt(@accountArray)
   
  /* Error if there are no accounts */
  IF (@@ROWCOUNT =  0)
    BEGIN
      SET @status = -2
      ROLLBACK
      RETURN 
    END

   /* Error if there are duplicate accounts in @accounts */
    IF (EXISTS (SELECT id_acc 
                     FROM @accounts
	         GROUP BY id_acc
	         HAVING COUNT(id_acc) > 1))
      BEGIN
         SET @status = -3
         ROLLBACK
         RETURN 
      END

   /* Error if the accounts in @accounts are not a member of id_parent_billgroup */
    IF (EXISTS (SELECT id_acc 
                    FROM @accounts 
                    WHERE id_acc NOT IN (SELECT id_acc
                                         FROM t_billgroup_member
                                         WHERE id_billgroup = @id_parent_billgroup)))
      BEGIN
         SET @status = -4
         ROLLBACK
         RETURN 
      END
   
   /* Error if the accounts in @accounts are all the member accounts of id_parent_billgroup */
   IF ( (SELECT COUNT(id_acc) 
         FROM t_billgroup_member
         WHERE id_billgroup = @id_parent_billgroup) 
         =
         (SELECT COUNT(bgm.id_acc) 
          FROM t_billgroup_member bgm
          INNER JOIN @accounts acc ON acc.id_acc = bgm.id_acc
          WHERE bgm.id_billgroup = @id_parent_billgroup) )
      BEGIN
         SET @status = -5
         ROLLBACK
         RETURN 
      END
   
   /* Insert row into t_billgroup_tmp */
   INSERT t_billgroup_tmp  (id_materialization, tx_name, tx_description) 
     VALUES (@id_materialization, @tx_name, @tx_description)

   /* Insert rows into t_billgroup_member_tmp */
   INSERT INTO t_billgroup_member_tmp (id_materialization, tx_name, id_acc)
   SELECT @id_materialization, @tx_name, acc.id_acc
   FROM @accounts acc 

   SET @status = 0
   COMMIT
   
         ' 
END
GO
/****** Object:  StoredProcedure [dbo].[InsertIntoQueryLog]    Script Date: 06/02/2008 11:43:53 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertIntoQueryLog]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'	
			CREATE PROCEDURE [dbo].[InsertIntoQueryLog] 
			@groupid varchar(50),
			@viewid int,
			@old_schema varchar(8000),
			@query nvarchar(4000)
			AS

			INSERT INTO t_query_log (c_groupid, c_id_view, c_old_schema, c_query) values(@groupid, @viewid, @old_schema, @query)
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[PropagateProperties]    Script Date: 06/02/2008 11:44:06 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[PropagateProperties]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
			create proc [dbo].[PropagateProperties](@table_name as varchar(100),
											@update_list as varchar(8000),
											@insert_list as varchar(8000),
											@clist as varchar(8000),
											@id_pi_template as int)

			as
			declare @CursorVar CURSOR
			declare @count as int
			declare @i as int
			declare @idInst as int
			declare @status as int
			set @status = 0
			set @i = 0
			set @CursorVar = CURSOR STATIC
				FOR select id_pi_instance from t_pl_map
						where id_pi_template = @id_pi_template and id_paramtable is null
			OPEN @CursorVar
			select @count = @@cursor_rows
			while @i < @count begin
				FETCH NEXT FROM @CursorVar into @idInst
				set @i = (select @i + 1)
				exec ExtendedUpsert @table_name, @update_list, @insert_list, @clist, @idInst, @status OUTPUT
				if (@status <> 0) begin
      				raiserror(''Cannot insert data into [%s], error %d.'', 16, 1, @table_name, @status)
				end
			end
			CLOSE @CursorVar
			DEALLOCATE @CursorVar
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreateTestRecurEventInst]    Script Date: 06/02/2008 11:43:32 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateTestRecurEventInst]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[CreateTestRecurEventInst] 
  (
    @id_event INT,
    @id_arg_interval INT,
    @id_arg_billgroup INT,
    @dt_arg_start DATETIME,
    @dt_arg_end DATETIME,
    @id_instance INT OUTPUT
  )
AS

BEGIN
  BEGIN TRAN

  INSERT INTO t_recevent_inst
    (id_event, id_arg_interval, id_arg_billgroup, dt_arg_start, dt_arg_end,
     b_ignore_deps, dt_effective, tx_status)
  VALUES 
    (@id_event, @id_arg_interval, @id_arg_billgroup, @dt_arg_start,
     @dt_arg_end, ''Y'', NULL, ''NotYetRun'')

  SELECT @id_instance = @@IDENTITY

  COMMIT
END
  ' 
END
GO
/****** Object:  StoredProcedure [dbo].[FailZombieRecurringEvents]    Script Date: 06/02/2008 11:43:41 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[FailZombieRecurringEvents]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[FailZombieRecurringEvents]
(
  @dt_now DATETIME,          -- system''s time
  @tx_machine VARCHAR(128),  -- macine to check for zombies on
  @count INT OUTPUT          -- number of zombies found and failed
)
AS

BEGIN

  BEGIN TRAN

  SELECT @count = 0

  DECLARE @zombies TABLE
  (
    id_instance INT NOT NULL,
    id_run INT NOT NULL
  )

  -- finds any zombie recurring events for the given machine
  INSERT INTO @zombies
  SELECT 
    inst.id_instance,
    run.id_run
  FROM t_recevent_inst inst
  LEFT OUTER JOIN
  (
    -- finds the last run''s ID
    SELECT 
      id_instance,
    MAX(dt_start) dt_start
    FROM t_recevent_run run
    GROUP BY
      id_instance
  ) lastrun ON lastrun.id_instance = inst.id_instance
  LEFT OUTER JOIN t_recevent_run run ON run.dt_start = lastrun.dt_start
  WHERE 
    (inst.tx_status IN (''Running'', ''Reversing'') OR run.tx_status = ''InProgress'') AND
    -- only look at runs which are being processed by the given machine
    -- in a multi-machine case, we don''t want to fail valid runs
    -- being processed on a different machine
    run.tx_machine = @tx_machine

  SELECT @count = @@ROWCOUNT  

  -- fails the zombie instances
  UPDATE t_recevent_inst
  SET tx_status = ''Failed''
  FROM t_recevent_inst inst
  INNER JOIN @zombies zombies ON zombies.id_instance = inst.id_instance

  -- fails the zombie runs 
  UPDATE t_recevent_run
  SET tx_status = ''Failed'', dt_end = @dt_now, tx_detail = ''Run was identified as a zombie''
  FROM t_recevent_run run
  INNER JOIN @zombies zombies ON zombies.id_run = run.id_run

  SELECT 
    id_instance InstanceID,
    id_run RunID
  FROM @zombies
  COMMIT
END
  ' 
END
GO
/****** Object:  StoredProcedure [dbo].[AddPartitionStoragePath]    Script Date: 06/02/2008 11:43:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddPartitionStoragePath]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      /*
      	AddPartitionStoragePath
      	
      	Adds a path (1 row) to the t_partition_storage table
      
      	@path char(500)  -- fully qualified filesystem pathname
      
      */
      create proc [dbo].[AddPartitionStoragePath]
      	@path char(500)  -- fully qualified filesystem pathname
      AS
      begin
      
      set nocount on
      
      -- Error reporting and row counts
      declare @err int
      declare @rc int
      
      -- get next path id
      declare @nextid int
      select @nextid = coalesce(max(id_path), 0) + 1
      from t_partition_storage
      
      insert into t_partition_storage (id_path, b_next, path)
      values (@nextid, ''N'', @path)
      
      end
      
 	' 
END
GO
/****** Object:  StoredProcedure [dbo].[GetNextStoragePath]    Script Date: 06/02/2008 11:43:45 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetNextStoragePath]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      /*
      	GetNextStoragePath
      	
      	Returns the next storage path for a partitioned database.
      
      	@path char(500)  -- output is a fully qualified filesystem pathname
      
      */
      create proc [dbo].[GetNextStoragePath]
      	@path varchar(500) output  -- fully qualified filesystem pathname
      AS
      begin
      
      set nocount on
      
      -- Error reporting and row counts
      declare @err int
      declare @rc int
      
      -- get count of paths
      declare @pathcnt int
      select @pathcnt = count(*) from t_partition_storage
      if (@pathcnt < 1) begin
      	raiserror(''There are no storage paths defined.'', 16, 1)
      	return
      end
      
      -- start a transacton
      begin tran
      
      	-- get next path
      	declare @ord int
      	select @path = path, @ord = id_path
      	from t_partition_storage
      	where lower(b_next) = ''y''
      	
      	-- if next flag isn''t found or too many found, use first
      	if (@path is null) begin
      		select @path = path, @ord = id_path
      		from t_partition_storage
      		where id_path = 1
      	end
      	
      	-- calculate the new next-path
      	declare @nextord int
      	set @nextord = (@ord%@pathcnt)+1
      
      	-- advance the b_next flag
      	update t_partition_storage set b_next = ''N''
      	update t_partition_storage set b_next = ''Y'' where id_path = @nextord
      
      commit
      
      end
      
 	' 
END
GO
/****** Object:  StoredProcedure [dbo].[AddCalendarHoliday]    Script Date: 06/02/2008 11:42:58 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddCalendarHoliday]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
		 create proc [dbo].[AddCalendarHoliday]
			@id_calendar int,
			@n_code int,
			@nm_name NVARCHAR(255),
			@n_day int,
			@n_weekday int,
			@n_weekofmonth int,
			@n_month int,
			@n_year int,
			@id_day int OUTPUT
			as
			begin tran
				insert into t_calendar_day (id_calendar, n_weekday, n_code)
					values (@id_calendar, @n_weekday, @n_code)
				select @id_day = @@IDENTITY
				insert into t_calendar_holiday (id_day, nm_name, n_day, n_weekofmonth, n_month, n_year)
					values (@id_day, @nm_name, @n_day, @n_weekofmonth, @n_month, @n_year)
			commit tran
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[AddCalendarWeekday]    Script Date: 06/02/2008 11:42:59 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddCalendarWeekday]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
		 create proc [dbo].[AddCalendarWeekday]
			@id_calendar int,
			@n_weekday int,
			@n_code int,
			@id_day int OUTPUT
			as
				begin tran
					insert into t_calendar_day (id_calendar, n_weekday, n_code)
						values (@id_calendar, @n_weekday, @n_code)
					select @id_day = @@IDENTITY
				commit tran
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[AddCalendarPeriod]    Script Date: 06/02/2008 11:42:58 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddCalendarPeriod]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
		 create proc [dbo].[AddCalendarPeriod]
			@id_day int,
			@n_begin int,
			@n_end int,
			@n_code int,
			@id_period int OUTPUT
			as
			begin tran
				insert into t_calendar_periods (id_day, n_begin, n_end, n_code)
					values (@id_day, @n_begin, @n_end, @n_code)
				select @id_period = @@IDENTITY
			commit tran
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[mtsp_BackoutInvoices]    Script Date: 06/02/2008 11:44:01 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[mtsp_BackoutInvoices]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'	
			create procedure [dbo].[mtsp_BackoutInvoices] (

			@id_billgroup int,
			@id_run int,
			@num_invoices int OUTPUT,
			@info_string nvarchar(500) OUTPUT,
			@return_code int OUTPUT
			)

                  		as
			begin

				DECLARE @debug_flag bit
				DECLARE @msg nvarchar(256)
				DECLARE @usage_cycle_type int

          				SET @msg = ''Invoice-Backout: Invoice adapter reversed''
				SET @debug_flag = 1
				--SET @debug_flag = 0
				SET @info_string = '''' 

				set @usage_cycle_type = (select id_usage_cycle from t_usage_interval 
							 where id_interval  IN (SELECT id_usage_interval 
						                                               FROM t_billgroup 
						                                               WHERE id_billgroup = @id_billgroup))/*= @id_interval*/

				select top 1 t_invoice.id_invoice from t_invoice left outer join t_usage_interval
 					on t_invoice.id_interval = t_usage_interval.id_interval
 					where id_usage_cycle = @usage_cycle_type
 					and t_invoice.id_interval > (SELECT id_usage_interval 
						                                FROM t_billgroup 
						                                WHERE id_billgroup = @id_billgroup)/*@id_interval*/
				if (@@rowcount > 0) 
 					SET @info_string = ''Reversing the invoice adapter for this interval has caused the invoices for subsequent intervals to be invalid''

				--truncate the table so that all rows corresponding to this interval are removed

				DELETE FROM t_invoice 
				WHERE
                                                            id_acc IN (SELECT bgm.id_acc 
						    FROM t_billgroup_member bgm 
						    WHERE bgm.id_billgroup = @id_billgroup) AND
                        
	            	id_interval IN (SELECT id_usage_interval 
			                                FROM t_billgroup 
			                                WHERE id_billgroup = @id_billgroup)

				SET @num_invoices = @@ROWCOUNT

				--update the t_invoice_range table''s id_run field

					UPDATE t_invoice_range
					SET id_run = @id_run 
                                                            WHERE id_billgroup = @id_billgroup

					IF @debug_flag = 1 

					INSERT INTO t_recevent_run_details (id_run, tx_type, tx_detail, dt_crt)
					  VALUES (@id_run, ''Debug'', @msg, getutcdate()) 

    					SET @return_code = 0

			end
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[MTSP_INSERTINVOICE_BALANCES]    Script Date: 06/02/2008 11:44:02 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTSP_INSERTINVOICE_BALANCES]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
   
-- populates #tmp_acc_amounts, #tmp_prev_balance, #tmp_adjustments for a given @id_interval
-- used by MTSP_INSERTINVOICE and __GET_NON_BILLABLE_ACCOUNTS_WITH_BALANCE__
CREATE   PROCEDURE [dbo].[MTSP_INSERTINVOICE_BALANCES]
@id_billgroup int,
@exclude_billable char, -- ''1'' to only return non-billable accounts, ''0'' to return all accounts
@id_run int,
@return_code int OUTPUT
AS
BEGIN
DECLARE 
@debug_flag bit,
@SQLError int,
@ErrMsg varchar(200)
SET NOCOUNT ON
SET @debug_flag = 1 -- yes
--SET @debug_flag = 0 -- no

-- populate the driver table with account ids 
INSERT INTO #tmp_all_accounts
(id_acc, namespace)
SELECT /*DISTINCT*/
bgm.id_acc,
map.nm_space
	FROM t_billgroup_member bgm
	INNER JOIN t_acc_usage au ON au.id_acc = bgm.id_acc
	INNER JOIN t_account_mapper map
	ON map.id_acc = au.id_acc
	INNER JOIN t_namespace ns
	ON ns.nm_space = map.nm_space
	WHERE ns.tx_typ_space = ''system_mps'' AND
	bgm.id_billgroup = @id_billgroup AND
    au.id_usage_interval IN (SELECT id_usage_interval FROM t_billgroup 
		                     WHERE id_billgroup = @id_billgroup)
UNION

SELECT /*DISTINCT*/
ads.id_acc,
map.nm_space
	FROM vw_adjustment_summary ads
	INNER JOIN t_billgroup_member bgm ON bgm.id_acc = ads.id_acc
	INNER JOIN t_account_mapper map
	ON map.id_acc = ads.id_acc
	INNER JOIN t_namespace ns
	ON ns.nm_space = map.nm_space
	WHERE ns.tx_typ_space = ''system_mps'' AND
	bgm.id_billgroup = @id_billgroup AND
    ads.id_usage_interval IN (SELECT id_usage_interval FROM t_billgroup 
		                     WHERE id_billgroup = @id_billgroup)
UNION

--The convoluted logic below is to find the latest current balance for the account.  This may
--not be the previous interval, as the invoice adapter may not have been run
--for certain intervals.  Won''t happen in production, but I encountered this
--a lot while testing.
SELECT DISTINCT
id_acc,
namespace
FROM
	(SELECT inv.id_acc, inv.namespace,
	ISNULL(MAX(CONVERT(CHAR(8),ui.dt_end,112)+
	REPLICATE(''0'',20-LEN(inv.current_balance)) + 
	CONVERT(CHAR,inv.current_balance)),''00000000000'') comp
	FROM t_invoice inv
			INNER JOIN t_billgroup_member bgm 
			ON bgm.id_acc = inv.id_acc                   
			INNER JOIN t_billgroup bg 
			ON bg.id_billgroup = bgm.id_billgroup
			INNER JOIN t_usage_interval ui 
			ON ui.id_interval = bg.id_usage_interval
			INNER JOIN t_namespace ns
			ON ns.nm_space = inv.namespace
			WHERE ns.tx_typ_space = ''system_mps'' AND
			bgm.id_billgroup = @id_billgroup
	GROUP BY inv.id_acc, inv.namespace) latestinv
WHERE 
CONVERT(DECIMAL(18,6), SUBSTRING(comp,CASE WHEN PATINDEX(''%-%'',comp) = 0 THEN 10 ELSE PATINDEX(''%-%'',comp) END,28)) <> 0

-- Populate with accounts that are non-billable but have payers that are billable.
-- in specified billing group
if @exclude_billable = ''1''
BEGIN
	INSERT INTO #tmp_all_accounts
	(id_acc, namespace)
	
	-- Get all payee accounts (for the payers in the given billing group) with usage
	SELECT /*DISTINCT*/
	pr.id_payee,
	map.nm_space
		FROM t_billgroup_member bgm
		INNER JOIN t_payment_redirection pr	ON pr.id_payer = bgm.id_acc
		INNER JOIN t_acc_usage au ON au.id_acc = pr.id_payee
		INNER JOIN t_account_mapper map	ON map.id_acc = au.id_acc
		INNER JOIN t_namespace ns ON ns.nm_space = map.nm_space
		WHERE ns.tx_typ_space = ''system_mps'' AND
		bgm.id_billgroup = @id_billgroup AND
		pr.id_payee NOT IN (SELECT id_acc FROM #tmp_all_accounts) AND
		au.id_usage_interval IN (SELECT id_usage_interval FROM t_billgroup 
								WHERE id_billgroup = @id_billgroup)
	UNION

	-- Get all payee accounts (for the payers in the given billing group) with adjustments
	SELECT /*DISTINCT*/
	ads.id_acc,
	map.nm_space
		FROM vw_adjustment_summary ads
		INNER JOIN t_payment_redirection pr	ON pr.id_payee = ads.id_acc
		INNER JOIN t_billgroup_member bgm ON bgm.id_acc = pr.id_payer
		INNER JOIN t_account_mapper map	ON map.id_acc = ads.id_acc
		INNER JOIN t_namespace ns ON ns.nm_space = map.nm_space
		WHERE ns.tx_typ_space = ''system_mps'' AND
		bgm.id_billgroup = @id_billgroup AND
		pr.id_payee NOT IN (SELECT id_acc FROM #tmp_all_accounts) AND
		ads.id_usage_interval IN (SELECT id_usage_interval FROM t_billgroup 
								WHERE id_billgroup = @id_billgroup)
	UNION

	-- Get all payee accounts (for the payers in the given billing group) with a balance
	-- The convoluted logic below is to find the latest current balance for the account.  This may
	-- not be the previous interval, as the invoice adapter may not have been run
	-- for certain intervals.  Won''t happen in production, but I encountered this
	-- a lot while testing.
	SELECT DISTINCT
	id_acc,
	namespace
	FROM
		(SELECT inv.id_acc, inv.namespace,
		ISNULL(MAX(CONVERT(CHAR(8),ui.dt_end,112)+
		REPLICATE(''0'',20-LEN(inv.current_balance)) + 
		CONVERT(CHAR,inv.current_balance)),''00000000000'') comp
		FROM t_invoice inv
				INNER JOIN t_payment_redirection pr	ON pr.id_payee = inv.id_acc
				INNER JOIN t_billgroup_member bgm ON bgm.id_acc = pr.id_payer
				INNER JOIN t_billgroup bg 
				ON bg.id_billgroup = bgm.id_billgroup
				INNER JOIN t_usage_interval ui 
				ON ui.id_interval = bg.id_usage_interval
				INNER JOIN t_namespace ns
				ON ns.nm_space = inv.namespace
				WHERE ns.tx_typ_space = ''system_mps'' AND
				pr.id_payee NOT IN (SELECT id_acc FROM #tmp_all_accounts) AND
				bgm.id_billgroup = @id_billgroup
		GROUP BY inv.id_acc, inv.namespace) latestinv
	WHERE 
	CONVERT(DECIMAL(18,6), SUBSTRING(comp,CASE WHEN PATINDEX(''%-%'',comp) = 0 THEN 10 ELSE PATINDEX(''%-%'',comp) END,28)) <> 0
END

SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

-- populate #tmp_acc_amounts with accounts and their invoice amounts
IF (@debug_flag = 1 and @id_run IS NOT NULL)
  INSERT INTO t_recevent_run_details (id_run, tx_type, tx_detail, dt_crt)
    VALUES (@id_run, ''Debug'', ''Invoice-Bal: Begin inserting to the #tmp_acc_amounts table'', getutcdate()) 

-- check if datamarts are being used
-- if no datamarts 
-- then...

IF ((SELECT value FROM t_db_values WHERE parameter = N''DATAMART'') = ''false'')

BEGIN
INSERT INTO #tmp_acc_amounts
  (namespace,
  id_interval,
  id_acc,
  invoice_currency,
  payment_ttl_amt,
  postbill_adj_ttl_amt,
  ar_adj_ttl_amt,
  previous_balance,
  tax_ttl_amt,
  current_charges,
  id_payer,
  id_payer_interval
)
SELECT
  RTRIM(ammps.nm_space) namespace,
  au.id_usage_interval id_interval, 
  ammps.id_acc, 
  avi.c_currency invoice_currency, 
  SUM(CASE WHEN pvpay.id_sess IS NULL THEN 0 ELSE ISNULL(au.amount,0) END) payment_ttl_amt,
  0, --postbill_adj_ttl_amt
  SUM(CASE WHEN pvar.id_sess IS NULL THEN 0 ELSE ISNULL(au.amount,0) END) ar_adj_ttl_amt,
  0, --previous_balance
  SUM(CASE WHEN (pvpay.id_sess IS NULL AND pvar.id_sess IS NULL) THEN 
	(ISNULL(au.Tax_Federal,0.0)) ELSE 0 END) + 
  SUM(CASE WHEN (pvpay.id_sess IS NULL AND pvar.id_sess IS NULL) THEN
	(ISNULL(au.Tax_State,0.0))ELSE 0 END) +
  SUM(CASE WHEN (pvpay.id_sess IS NULL AND pvar.id_sess IS NULL) THEN 
	(ISNULL(au.Tax_County,0.0))ELSE 0 END) +
  SUM(CASE WHEN (pvpay.id_sess IS NULL AND pvar.id_sess IS NULL) THEN 
	(ISNULL(au.Tax_Local,0.0))ELSE 0 END) +
  SUM(CASE WHEN (pvpay.id_sess IS NULL AND pvar.id_sess IS NULL) THEN
	(ISNULL(au.Tax_Other,0.0))ELSE 0 END) tax_ttl_amt,
  SUM(CASE WHEN (pvpay.id_sess IS NULL AND pvar.id_sess IS NULL AND NOT vh.id_view IS NULL) THEN (ISNULL(au.Amount, 0.0)) ELSE 0 END) current_charges, 
  CASE WHEN avi.c_billable = ''0'' THEN pr.id_payer ELSE ammps.id_acc END id_payer,
  CASE WHEN avi.c_billable = ''0'' THEN auipay.id_usage_interval ELSE au.id_usage_interval END id_payer_interval
FROM  #tmp_all_accounts tmpall
INNER JOIN t_av_internal avi ON avi.id_acc = tmpall.id_acc
INNER JOIN t_account_mapper ammps ON ammps.id_acc = tmpall.id_acc
INNER JOIN t_namespace ns ON ns.nm_space = ammps.nm_space
	AND ns.tx_typ_space = ''system_mps''
INNER join t_acc_usage_interval aui ON aui.id_acc = tmpall.id_acc
INNER join t_usage_interval ui ON aui.id_usage_interval = ui.id_interval
	AND ui.id_interval IN (SELECT id_usage_interval 
                                               FROM t_billgroup 
                                               WHERE id_billgroup = @id_billgroup)/*= @id_interval*/
INNER join t_payment_redirection pr ON tmpall.id_acc = pr.id_payee
	AND ui.dt_end BETWEEN pr.vt_start AND pr.vt_end
INNER join t_acc_usage_interval auipay ON auipay.id_acc = pr.id_payer
INNER join t_usage_interval uipay ON auipay.id_usage_interval = uipay.id_interval
        AND ui.dt_end BETWEEN CASE WHEN auipay.dt_effective IS NULL THEN uipay.dt_start ELSE dateadd(s, 1, auipay.dt_effective) END AND uipay.dt_end

LEFT OUTER JOIN 
(SELECT au1.id_usage_interval, au1.amount, au1.Tax_Federal, au1.Tax_State, au1.Tax_County, au1.Tax_Local, au1.Tax_Other, au1.id_sess, au1.id_acc, au1.id_view
FROM t_acc_usage au1
LEFT OUTER JOIN t_pi_template piTemplated2 
ON piTemplated2.id_template=au1.id_pi_template
LEFT OUTER JOIN t_base_props pi_type_props ON pi_type_props.id_prop=piTemplated2.id_pi
LEFT OUTER JOIN t_enum_data enumd2 ON au1.id_view=enumd2.id_enum_data
AND (pi_type_props.n_kind IS NULL or pi_type_props.n_kind <> 15 or (enumd2.nm_enum_data) NOT LIKE ''%_TEMP'')

WHERE au1.id_parent_sess is NULL
AND au1.id_usage_interval IN (SELECT id_usage_interval 
                                                 FROM t_billgroup 
                                                 WHERE id_billgroup = @id_billgroup) /*= @id_interval*/
AND ((au1.id_pi_template is null and au1.id_parent_sess is null) or (au1.id_pi_template is not null and piTemplated2.id_template_parent is null))
) au ON

	au.id_acc = tmpall.id_acc
-- join with the tables used for calculating the sums
LEFT OUTER JOIN t_view_hierarchy vh 
	ON au.id_view = vh.id_view
	AND vh.id_view = vh.id_view_parent
LEFT OUTER JOIN t_pv_aradjustment pvar ON pvar.id_sess = au.id_sess and au.id_usage_interval=pvar.id_usage_interval
LEFT OUTER JOIN t_pv_payment pvpay ON pvpay.id_sess = au.id_sess and au.id_usage_interval=pvpay.id_usage_interval
-- non-join conditions
WHERE 
(@exclude_billable = ''0'' OR avi.c_billable = ''0'')
GROUP BY ammps.nm_space, ammps.id_acc, au.id_usage_interval, avi.c_currency, pr.id_payer, auipay.id_usage_interval, avi.c_billable


SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError
---------------------------------------------------------------

-- populate #tmp_adjustments with postbill and prebill adjustments
INSERT INTO #tmp_adjustments
 ( id_acc,
   PrebillAdjAmt,
   PrebillTaxAdjAmt,
   PostbillAdjAmt,
   PostbillTaxAdjAmt
 )
select ISNULL(adjtrx.id_acc, #tmp_all_accounts.id_acc) id_acc,
       ISNULL(PrebillAdjAmt, 0) PrebillAdjAmt,
       ISNULL(PrebillTaxAdjAmt, 0) PrebillTaxAdjAmt,
       ISNULL(PostbillAdjAmt, 0) PostbillAdjAmt, 
       ISNULL(PostbillTaxAdjAmt, 0) PostbillTaxAdjAmt
  from vw_adjustment_summary adjtrx 
   INNER JOIN t_billgroup_member bgm ON bgm.id_acc = adjtrx.id_acc
   FULL OUTER JOIN #tmp_all_accounts ON adjtrx.id_acc = #tmp_all_accounts.id_acc
   WHERE bgm.id_billgroup = @id_billgroup AND 
   adjtrx.id_usage_interval IN (SELECT id_usage_interval FROM t_billgroup 
		                            WHERE id_billgroup = @id_billgroup)
  /* where adjtrx.id_usage_interval = @id_interval*/

SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

END

ELSE

-- else datamarts are being used.
-- join against t_mv_payer_interval
BEGIN
 
INSERT INTO #tmp_acc_amounts
  (namespace,
  id_interval,
  id_acc,
  invoice_currency,
  payment_ttl_amt,
  postbill_adj_ttl_amt,
  ar_adj_ttl_amt,
  previous_balance,
  tax_ttl_amt,
  current_charges,
  id_payer,
  id_payer_interval
)

SELECT

  RTRIM(ammps.nm_space) namespace,
  dm.id_usage_interval id_interval, 
  tmpall.id_acc, -- changed
  avi.c_currency invoice_currency, 
  SUM(CASE WHEN ed.nm_enum_data = ''metratech.com/Payment'' THEN ISNULL(dm.TotalAmount, 0) ELSE 0 END) payment_ttl_amt,
  0, --postbill_adj_ttl_amt
  SUM(CASE WHEN ed.nm_enum_data = ''metratech.com/ARAdjustment'' THEN ISNULL(dm.TotalAmount, 0) ELSE 0 END) ar_adj_ttl_amt,
  0, --previous_balance
  SUM(CASE WHEN (ed.nm_enum_data <> ''metratech.com/Payment'' 
                 AND ed.nm_enum_data <> ''metratech.com/ARAdjustment'') 
           THEN 
           (ISNULL(dm.TotalTax,0.0)) 
           ELSE 0 
           END),  --tax_ttl_amt 
  SUM(CASE WHEN (ed.nm_enum_data <> ''metratech.com/Payment'' 
		AND ed.nm_enum_data <> ''metratech.com/ARAdjustment'')
           THEN (ISNULL(dm.TotalAmount, 0.0)) 
           ELSE 0 
           END) current_charges, 
  CASE WHEN avi.c_billable = ''0'' 
       THEN pr.id_payer 
       ELSE tmpall.id_acc 
       END id_payer,
  CASE WHEN avi.c_billable = ''0'' 
       THEN auipay.id_usage_interval 
       ELSE dm.id_usage_interval 
       END id_payer_interval
 
FROM  #tmp_all_accounts tmpall

-- added
INNER JOIN t_av_internal avi 
ON avi.id_acc = tmpall.id_acc

-- Select accounts which are of type ''system_mps''
INNER JOIN t_account_mapper ammps 
ON ammps.id_acc = tmpall.id_acc

INNER JOIN t_namespace ns 
ON ns.nm_space = ammps.nm_space
   AND ns.tx_typ_space = ''system_mps''

-- Select accounts which belong
-- to the given usage interval
INNER join t_acc_usage_interval aui 
ON aui.id_acc = tmpall.id_acc

INNER join t_usage_interval ui
ON aui.id_usage_interval = ui.id_interval
	AND ui.id_interval IN (SELECT id_usage_interval 
                           FROM t_billgroup 
                           WHERE id_billgroup = @id_billgroup)/*= @id_interval*/

-- 
INNER join t_payment_redirection pr 
ON tmpall.id_acc = pr.id_payee
   AND ui.dt_end BETWEEN pr.vt_start AND pr.vt_end

INNER join t_acc_usage_interval auipay 
ON auipay.id_acc = pr.id_payer

INNER join t_usage_interval uipay 
ON auipay.id_usage_interval = uipay.id_interval
   AND ui.dt_end BETWEEN 
     CASE WHEN auipay.dt_effective IS NULL 
          THEN uipay.dt_start 
          ELSE dateadd(s, 1, auipay.dt_effective) 
          END 
     AND uipay.dt_end

LEFT OUTER JOIN t_mv_payer_interval dm 
ON dm.id_acc = tmpall.id_acc AND dm.id_usage_interval IN (SELECT id_usage_interval 
														  FROM t_billgroup 
							                              WHERE id_billgroup = @id_billgroup) /*= @id_interval*/
LEFT OUTER JOIN t_enum_data ed
ON dm.id_view = ed.id_enum_data

-- non-join conditions
WHERE 
(@exclude_billable = ''0'' OR avi.c_billable = ''0'')
GROUP BY  ammps.nm_space, tmpall.id_acc, dm.id_usage_interval, avi.c_currency, pr.id_payer, auipay.id_usage_interval, avi.c_billable

SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError
END

-- populate #tmp_adjustments with postbill and prebill adjustments
INSERT INTO #tmp_adjustments
 ( id_acc,
   PrebillAdjAmt,
   PrebillTaxAdjAmt,
   PostbillAdjAmt,
   PostbillTaxAdjAmt
 )
select ISNULL(adjtrx.id_acc, #tmp_all_accounts.id_acc) id_acc,
       ISNULL(PrebillAdjAmt, 0) PrebillAdjAmt,
       ISNULL(PrebillTaxAdjAmt, 0) PrebillTaxAdjAmt,
       ISNULL(PostbillAdjAmt, 0) PostbillAdjAmt, 
       ISNULL(PostbillTaxAdjAmt, 0) PostbillTaxAdjAmt
  from vw_adjustment_summary adjtrx
  INNER JOIN t_billgroup_member bgm ON bgm.id_acc = adjtrx.id_acc
  FULL OUTER JOIN #tmp_all_accounts ON adjtrx.id_acc = #tmp_all_accounts.id_acc
  WHERE bgm.id_billgroup = @id_billgroup AND 
   adjtrx.id_usage_interval IN (SELECT id_usage_interval FROM t_billgroup 
		                            WHERE id_billgroup = @id_billgroup)

SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

-- populate #tmp_prev_balance with the previous balance
INSERT INTO #tmp_prev_balance
  (id_acc,
  previous_balance)
SELECT id_acc, CONVERT(DECIMAL(18,6), SUBSTRING(comp,CASE WHEN PATINDEX(''%-%'',comp) = 0 THEN 10 ELSE PATINDEX(''%-%'',comp) END,28)) previous_balance
FROM 	(SELECT inv.id_acc, 
ISNULL(MAX(CONVERT(CHAR(8),ui.dt_end,112)+
			REPLICATE(''0'',20-LEN(inv.current_balance)) + 
			CONVERT(CHAR,inv.current_balance)),''00000000000'') comp
	FROM t_invoice inv
	INNER JOIN t_usage_interval ui ON ui.id_interval = inv.id_interval
	INNER JOIN #tmp_all_accounts ON inv.id_acc = #tmp_all_accounts.id_acc
	GROUP BY inv.id_acc) maxdtend

SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

IF (@debug_flag = 1  and @id_run IS NOT NULL)
  INSERT INTO t_recevent_run_details (id_run, tx_type, tx_detail, dt_crt)
    VALUES (@id_run, ''Debug'', ''Invoice-Bal: Completed successfully'', getutcdate()) 

SET @return_code = 0

RETURN 0

FatalError:
  IF @ErrMsg IS NULL 
    SET @ErrMsg = ''Invoice-Bal: Stored procedure failed''
  IF (@debug_flag = 1  and @id_run IS NOT NULL)
    INSERT INTO t_recevent_run_details (id_run, tx_type, tx_detail, dt_crt)
      VALUES (@id_run, ''Debug'', @ErrMsg, getutcdate()) 

  SET @return_code = -1

  RETURN -1

END
' 
END
GO
/****** Object:  StoredProcedure [dbo].[MTSP_INSERTINVOICE]    Script Date: 06/02/2008 11:44:02 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTSP_INSERTINVOICE]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
	  
CREATE PROCEDURE [dbo].[MTSP_INSERTINVOICE]
@id_billgroup int,
@invoicenumber_storedproc nvarchar(256), --this is the name of the stored procedure used to generate invoice numbers
@is_sample varchar(1),
@dt_now DATETIME,  -- the MetraTech system''s date
@id_run int,
@num_invoices int OUTPUT,
@return_code int OUTPUT
AS
SET NOCOUNT ON
BEGIN
DECLARE 
@invoice_date datetime, 
@cnt int,
@curr_max_id int,
@id_interval_exist int,
@id_billgroup_exist int,
@debug_flag bit,
@SQLError int,
@ErrMsg varchar(200)
-- Initialization
SET @num_invoices = 0
SET @invoice_date = CAST(SUBSTRING(CAST(@dt_now AS CHAR),1,11) AS DATETIME) --datepart
SET @debug_flag = 1 -- yes
--SET @debug_flag = 0 -- no
-- Validate input parameter values
IF @id_billgroup IS NULL 
BEGIN
  SET @ErrMsg = ''InsertInvoice: Completed abnormally, id_billgroup is null''
  GOTO FatalError
END
if @invoicenumber_storedproc IS NULL OR RTRIM(@invoicenumber_storedproc) = ''''
BEGIN
  SET @ErrMsg = ''InsertInvoice: Completed abnormally, invoicenumber_storedproc is null''
  GOTO FatalError
END
IF @debug_flag = 1 
  INSERT INTO t_recevent_run_details (id_run, tx_type, tx_detail, dt_crt)
    VALUES (@id_run, ''Debug'', ''InsertInvoice: Started'', getutcdate()) 
-- If already exists, do not process again
SELECT TOP 1 @id_billgroup_exist = id_billgroup
FROM t_invoice_range
WHERE id_billgroup = @id_billgroup and id_run is NULL
SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError
IF @id_billgroup_exist IS NOT NULL
BEGIN
  SET @ErrMsg = ''InsertInvoice: Invoice number already exists in the t_invoice_range table, ''
    + ''process skipped, process completed successfully at '' 
    + CONVERT(char, getutcdate(), 109)
  GOTO SkipReturn
END
/*  Does an invoice exist for the accounts in the given @id_billgroup */ 
SELECT TOP 1 @id_interval_exist = id_interval
FROM t_invoice inv
INNER JOIN t_billgroup_member bgm 
  ON bgm.id_acc = inv.id_acc 
INNER JOIN t_billgroup bg 
  ON bg.id_usage_interval = inv.id_interval AND
     bg.id_billgroup = bgm.id_billgroup   
WHERE bgm.id_billgroup = @id_billgroup and 
            inv.sample_flag = ''N''
SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError
IF @id_interval_exist IS NOT NULL
BEGIN
  SET @ErrMsg = ''InsertInvoice: Invoice number already exists in the t_invoice table, ''
    + ''process skipped, process completed successfully at '' 
    + CONVERT(char, getdate(), 109)
  GOTO SkipReturn
END

-- call MTSP_INSERTINVOICE_BALANCES to populate #tmp_acc_amounts, #tmp_prev_balance, #tmp_adjustments

CREATE TABLE #tmp_acc_amounts
  (tmp_seq int IDENTITY,
  namespace nvarchar(40),
  id_interval int,
  id_acc int,
  invoice_currency nvarchar(10),
  payment_ttl_amt numeric(18, 6),
  postbill_adj_ttl_amt numeric(18, 6),
  ar_adj_ttl_amt numeric(18, 6),
  previous_balance numeric(18, 6),
  tax_ttl_amt numeric(18, 6),
  current_charges numeric(18, 6),
  id_payer int,
  id_payer_interval int
  )

SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

CREATE TABLE #tmp_prev_balance
 ( id_acc int,
   previous_balance numeric(18, 6)
 )

SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

CREATE TABLE #tmp_adjustments
 ( id_acc int,
   PrebillAdjAmt numeric(18, 6),
   PrebillTaxAdjAmt numeric(18, 6),
   PostbillAdjAmt numeric(18, 6),
   PostbillTaxAdjAmt numeric(18, 6)
 )

SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

-- Create the driver table with all id_accs
CREATE TABLE #tmp_all_accounts
(tmp_seq int IDENTITY,
 id_acc int NOT NULL,
 namespace nvarchar(80) NOT NULL)

SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

EXEC MTSP_INSERTINVOICE_BALANCES @id_billgroup, 0, @id_run, @return_code OUTPUT

if @return_code <> 0 GOTO FatalError

-- Obtain the configured invoice strings and store them in a temp table
CREATE TABLE #tmp_invoicenumber
(id_acc int NOT NULL,
 namespace nvarchar(40) NOT NULL,
 invoice_string nvarchar(50) NOT NULL,
 invoice_due_date datetime NOT NULL,
 id_invoice_num int NOT NULL)

SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

INSERT INTO #tmp_invoicenumber EXEC @invoicenumber_storedproc @invoice_date
SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError
-- End of 11/20/2002 add

SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

IF @debug_flag = 1 
  INSERT INTO t_recevent_run_details (id_run, tx_type, tx_detail, dt_crt)
  VALUES (@id_run, ''Debug'', ''InsertInvoice: Begin Insert into t_invoice'', getutcdate()) 

-- Save all the invoice data to the t_invoice table
INSERT INTO t_invoice
  (namespace,
  invoice_string, 
  id_interval,
  id_acc, 
  invoice_amount, 
  invoice_date, 
  invoice_due_date, 
  id_invoice_num,
  invoice_currency,
  payment_ttl_amt,
  postbill_adj_ttl_amt,
  ar_adj_ttl_amt,
  tax_ttl_amt,
  current_balance,
  id_payer,
  id_payer_interval,
  sample_flag,
  balance_forward_date)
SELECT
  #tmp_acc_amounts.namespace,
  tmpin.invoice_string, -- from the stored proc as below
  ui.id_interval, /*@id_interval,*/
  #tmp_acc_amounts.id_acc,
  current_charges
    + ISNULL(#tmp_adjustments.PrebillAdjAmt,0)
    + tax_ttl_amt
    + ISNULL(#tmp_adjustments.PrebillTaxAdjAmt,0.0),  -- invoice_amount = current_charges + prebill adjustments + taxes + prebill tax adjustments, 
  @invoice_date invoice_date, 
  tmpin.invoice_due_date, -- from the stored proc as @invoice_date+@invoice_due_date_offset   invoice_due_date,
  tmpin.id_invoice_num, -- from the stored proc as tmp_seq + @invoice_number - 1,
  invoice_currency,
  payment_ttl_amt, -- payment_ttl_amt
 ISNULL(#tmp_adjustments.PostbillAdjAmt, 0.0) + ISNULL(#tmp_adjustments.PostbillTaxAdjAmt, 0.0), -- postbill_adj_ttl_amt
  ar_adj_ttl_amt, -- ar_adj_ttl_amt
  tax_ttl_amt + ISNULL(#tmp_adjustments.PrebillTaxAdjAmt,0.0), -- tax_ttl_amt 
  current_charges + tax_ttl_amt + ar_adj_ttl_amt 
	  + ISNULL(#tmp_adjustments.PostbillAdjAmt, 0.0)
    + ISNULL(#tmp_adjustments.PostbillTaxAdjAmt,0.0)
    + payment_ttl_amt
	  + ISNULL(#tmp_prev_balance.previous_balance, 0.0)
    + ISNULL(#tmp_adjustments.PrebillAdjAmt, 0.0) 
    + ISNULL(#tmp_adjustments.PrebillTaxAdjAmt,0.0), -- current_balance 
  id_payer, -- id_payer
  CASE WHEN #tmp_acc_amounts.id_payer_interval IS NULL 
           THEN (SELECT id_usage_interval
                     FROM t_billgroup 
	         WHERE id_billgroup = @id_billgroup)/*@id_interval*/
           ELSE #tmp_acc_amounts.id_payer_interval 
  END, -- id_payer_interval
  @is_sample sample_flag,
  ui.dt_end -- balance_forward_date
FROM #tmp_acc_amounts
INNER JOIN #tmp_invoicenumber tmpin ON tmpin.id_acc = #tmp_acc_amounts.id_acc
LEFT OUTER JOIN #tmp_prev_balance ON #tmp_prev_balance.id_acc = #tmp_acc_amounts.id_acc
LEFT OUTER JOIN #tmp_adjustments ON #tmp_adjustments.id_acc = #tmp_acc_amounts.id_acc
INNER JOIN t_usage_interval ui ON ui.id_interval IN (SELECT id_usage_interval 
			                                               FROM t_billgroup 
			                                               WHERE id_billgroup = @id_billgroup)/*= @id_interval*/
INNER JOIN t_av_internal avi ON avi.id_acc = #tmp_acc_amounts.id_acc

SET @num_invoices = @@ROWCOUNT

SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

-- Store the invoice range data to the t_invoice_range table
SELECT @cnt = MAX(tmp_seq)
FROM #tmp_acc_amounts
SELECT @SQLError = @@ERROR
IF @SQLError <> 0 GOTO FatalError

IF @cnt IS NOT NULL
BEGIN
  --insert info about the current run into the t_invoice_range table
  INSERT INTO t_invoice_range (id_interval, id_billgroup, namespace, id_invoice_num_first, id_invoice_num_last)
  SELECT id_interval, @id_billgroup, namespace, ISNULL(min(id_invoice_num),0), ISNULL(max(id_invoice_num),0)
  FROM t_invoice
  WHERE id_interval IN (SELECT id_usage_interval 
			 FROM t_billgroup 
			 WHERE id_billgroup = @id_billgroup)
  GROUP BY id_interval, namespace
  --update the id_invoice_num_last in the t_invoice_namespace table
  UPDATE t_invoice_namespace
  SET t_invoice_namespace.id_invoice_num_last = 
	(SELECT ISNULL(max(t_invoice.id_invoice_num),t_invoice_namespace.id_invoice_num_last)
	FROM t_invoice
  	WHERE t_invoice_namespace.namespace = t_invoice.namespace AND
	t_invoice.id_interval IN (SELECT id_usage_interval 
			              FROM t_billgroup 
			              WHERE id_billgroup = @id_billgroup))
  SELECT @SQLError = @@ERROR
  IF @SQLError <> 0 GOTO FatalError
END
ELSE  SET @cnt = 0

DROP TABLE #tmp_acc_amounts
DROP TABLE #tmp_prev_balance
DROP TABLE #tmp_invoicenumber
DROP TABLE #tmp_adjustments
DROP TABLE #tmp_all_accounts


IF @debug_flag = 1 
  INSERT INTO t_recevent_run_details (id_run, tx_type, tx_detail, dt_crt)
   VALUES (@id_run, ''Debug'', ''InsertInvoice: Completed successfully'', getutcdate())
   
SET @return_code = 0
RETURN 0

SkipReturn:
  IF @ErrMsg IS NULL 
    SET @ErrMsg = ''InsertInvoice: Process skipped''
  IF @debug_flag = 1 
    INSERT INTO t_recevent_run_details (id_run, tx_type, tx_detail, dt_crt)
      VALUES (@id_run, ''Debug'', @ErrMsg, getutcdate()) 
  SET @return_code = 0
  RETURN 0

FatalError:
  IF @ErrMsg IS NULL 
    SET @ErrMsg = ''InsertInvoice: Adapter stored procedure failed''
  IF @debug_flag = 1 
    INSERT INTO t_recevent_run_details (id_run, tx_type, tx_detail, dt_crt)
      VALUES (@id_run, ''Debug'', @ErrMsg, getutcdate()) 
  SET @return_code = -1
  RETURN -1

END

' 
END
GO
/****** Object:  StoredProcedure [dbo].[ExecSpProcOnKind]    Script Date: 06/02/2008 11:43:40 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ExecSpProcOnKind]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			create proc [dbo].[ExecSpProcOnKind] @kind as int,@id as int
				as
				declare @sprocname varchar(256)
				select @sprocname = nm_sprocname from t_principals where id_principal = @kind
				exec (@sprocname + '' '' + @id)
	 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[InsertIntoCatalogTable]    Script Date: 06/02/2008 11:43:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertIntoCatalogTable]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			create procedure [dbo].[InsertIntoCatalogTable](@name nvarchar(200), @table_name nvarchar(200), @description nvarchar(4000),
					@UpdateMode varchar(1), @QueryPath nvarchar(4000),
					@CreateQueryTag nvarchar(200), @DropQueryTag nvarchar(200), @InitQueryTag nvarchar(200),
					@FullQueryTag nvarchar(200), @ProgId nvarchar(200),
					@IdRevision int, @Checksum varchar(100),
					@id_mv int output)
			as
			insert into t_mview_catalog(
			  name, table_name, description, update_mode, query_path, 
			  create_query_tag, drop_query_tag, init_query_tag, full_query_tag, 
			  progid, id_revision, tx_checksum)
		  values(
				@name, @table_name, @description, @UpdateMode, @QueryPath, 
				@CreateQueryTag, @DropQueryTag, @InitQueryTag, @FullQueryTag, 
				@ProgId, @IdRevision, @Checksum)
			set @id_mv = @@identity
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[InsertIntoEventTable]    Script Date: 06/02/2008 11:43:52 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertIntoEventTable]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
        	create procedure [dbo].[InsertIntoEventTable](@id_mv int,
				 	@description nvarchar(4000),
			 		@id_event int output)
			as
			insert into t_mview_event(id_mv, description) values(@id_mv, @description)
			set @id_event = @@identity

		' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[GetBillingGroupAncestor]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetBillingGroupAncestor]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
/* ===========================================================
   Returns the ancestor (root parent) for a given id_billing_group
=========================================================== */
CREATE FUNCTION [dbo].[GetBillingGroupAncestor]
(
   @id_current_billgroup INT
)
RETURNS INT
AS

BEGIN

   DECLARE @id_parent_billgroup INT
   DECLARE @loopCounter INT
   SET @loopCounter = 0

   WHILE (@loopCounter = 0)
      BEGIN
          SET @id_parent_billgroup = (SELECT id_parent_billgroup /*parent*/
	                                           FROM t_billgroup
	                                           WHERE id_billgroup = @id_current_billgroup) 
          IF (@id_parent_billgroup IS NULL)
             BEGIN
                 BREAK 
             END
         ELSE
             BEGIN
                 SET @id_current_billgroup = @id_parent_billgroup
             END
      END -- WHILE

   RETURN @id_current_billgroup

END
   ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[GetBillingGroupDescendants]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetBillingGroupDescendants]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
/* ===========================================================
   Returns the descendants for a given id_billing_group
=========================================================== */
CREATE FUNCTION [dbo].[GetBillingGroupDescendants]
(
   @id_billgroup_current INT
)
RETURNS @retDescendants TABLE (id_billgroup INT)
AS

BEGIN

   DECLARE @level INT, @id_billgroup_descendant INT
   DECLARE @results TABLE (id_billgroup INT)
   DECLARE @stack TABLE (id_billgroup INT, level INT)
   INSERT INTO @stack VALUES (@id_billgroup_current, 1)
   SELECT @level = 1

   WHILE @level > 0
      BEGIN
         IF EXISTS (SELECT * FROM @stack WHERE level = @level)
            BEGIN
	    SELECT @id_billgroup_current = id_billgroup
	    FROM @stack
	    WHERE level = @level
                    
                IF @level > 1
                   BEGIN
                      INSERT @results VALUES (@id_billgroup_current)
                   END
   	    
                DELETE FROM @stack
	    WHERE level = @level AND id_billgroup = @id_billgroup_current
	         
                INSERT @stack
	    SELECT id_billgroup /*child*/, @level + 1
	    FROM t_billgroup
	    WHERE id_parent_billgroup = @id_billgroup_current
	        
                IF @@ROWCOUNT > 0
	    SELECT @level = @level + 1
	END
        ELSE
	SELECT @level = @level - 1
    END -- WHILE

    INSERT @retDescendants
    SELECT id_billgroup 
    FROM @results
    RETURN

END
   ' 
END
GO
/****** Object:  StoredProcedure [dbo].[sp_InsertBaseProps]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_InsertBaseProps]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			create proc [dbo].[sp_InsertBaseProps] @a_kind int,
						@a_nameID int,
						@a_descID int,
						@a_approved char(1),
						@a_archive char(1),
						@a_nm_name NVARCHAR(255),
						@a_nm_desc NVARCHAR(255),
						@a_id_prop int OUTPUT
			as
			insert into t_base_props (n_kind,n_name,n_desc,nm_name,nm_desc,b_approved,b_archive) values
				(@a_kind,@a_nameID,@a_descID,@a_nm_name,@a_nm_desc,@a_approved,@a_archive)
			select @a_id_prop =@@identity
	 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[InsertBaseProps]    Script Date: 06/02/2008 11:43:50 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertBaseProps]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
		create proc [dbo].[InsertBaseProps] 
			@id_lang_code int,
			@a_kind int,
			@a_approved char(1),
			@a_archive char(1),
			@a_nm_name NVARCHAR(255),
			@a_nm_desc NVARCHAR(255),
			@a_nm_display_name NVARCHAR(255),
			@a_id_prop int OUTPUT 
		AS
		begin
		  declare @id_desc_display_name int
      declare @id_desc_name int
      declare @id_desc_desc int
			exec UpsertDescription @id_lang_code, @a_nm_display_name, NULL, @id_desc_display_name output
			exec UpsertDescription @id_lang_code, @a_nm_name, NULL, @id_desc_name output
			exec UpsertDescription @id_lang_code, @a_nm_desc, NULL, @id_desc_desc output
			insert into t_base_props (n_kind, n_name, n_desc,nm_name,nm_desc,b_approved,b_archive,
			n_display_name, nm_display_name) values
			(@a_kind, @id_desc_name, @id_desc_desc, @a_nm_name,@a_nm_desc,@a_approved,@a_archive,
			 @id_desc_display_name,@a_nm_display_name)
			select @a_id_prop =@@identity
	   end
   ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[POContainsDiscount]    Script Date: 06/02/2008 11:44:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[POContainsDiscount]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
				create function [dbo].[POContainsDiscount]
				(@id_po int) returns int
				as
				begin
				declare @retval int
					select @retval = case when count(id_pi_template) > 0 then 1 else 0 end 
					from t_pl_map 
					INNER JOIN t_base_props tb on tb.id_prop = t_pl_map.id_pi_template
					where t_pl_map.id_po = @id_po AND tb.n_kind = 40
					return @retval
				end
			 ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[POContainsBillingCycleRelative]    Script Date: 06/02/2008 11:44:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[POContainsBillingCycleRelative]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
CREATE FUNCTION [dbo].[POContainsBillingCycleRelative]
(
  @id_po INT  -- product offering ID
)
RETURNS INT  -- 1 if the PO contains BCR PIs, otherwise 0
AS
BEGIN
  DECLARE @found INT

  -- checks for billing cycle relative discounts
	SELECT @found = CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END 
	FROM t_pl_map plm 
	INNER JOIN t_base_props bp ON bp.id_prop = plm.id_pi_template
  INNER JOIN t_discount disc ON disc.id_prop = bp.id_prop
	WHERE 
    plm.id_po = @id_po AND
    disc.id_usage_cycle IS NULL

  IF @found = 1
	  RETURN @found

  -- checks for billing cycle relative recurring charges
	SELECT @found = CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END 
	FROM t_pl_map plm 
	INNER JOIN t_base_props bp ON bp.id_prop = plm.id_pi_template
  INNER JOIN t_recur rc ON rc.id_prop = bp.id_prop
	WHERE 
    plm.id_po = @id_po AND
    (rc.tx_cycle_mode = ''BCR'' OR rc.tx_cycle_mode = ''BCR Constrained'')

  IF @found = 1
	  RETURN @found

  -- checks for billing cycle relative aggregate charges
	SELECT @found = CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END 
	FROM t_pl_map plm 
	INNER JOIN t_base_props bp ON bp.id_prop = plm.id_pi_template
  INNER JOIN t_aggregate agg ON agg.id_prop = bp.id_prop
	WHERE 
    plm.id_po = @id_po AND
    agg.id_usage_cycle IS NULL

  RETURN @found
END
	' 
END
GO
/****** Object:  StoredProcedure [dbo].[PIResolutionByName]    Script Date: 06/02/2008 11:44:05 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[PIResolutionByName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  create proc [dbo].[PIResolutionByName](
  @dt_session DATETIME, @nm_name nvarchar(255), @id_acc INTEGER)

  as
  select
  typemap.id_po,
  typemap.id_pi_instance,
  sub.id_sub
  from
  -- select out the instances from the pl map (either need to follow
  -- up with a group by or assume one param table or add a unique entry
  -- with a null param table/price list; I am assuming the null entry exists)
  t_pl_map typemap
  -- Now that we have the correct list of instances we match them up with the
  -- accounts on the billing interval being processed.  For each account grab the
  -- information about the billing interval dates so that we can select the
  -- correct intervals to process.
  -- Go get all subscriptions product offerings containing the proper discount
  -- instances
  , t_sub sub
  -- Go get the effective date of the subscription to the discount
  , t_base_props base
  where
  -- Join criteria for t_sub
  typemap.id_po = sub.id_po
  -- join criteria for t_sub to t_effective_date
  -- Find the subscription which contains the dt_session; there should be
  -- at most one of these.
  and (sub.vt_start <= @dt_session)
  and (sub.vt_end >= @dt_session)
  -- Join template to base props
  and base.id_prop=typemap.id_pi_template
  -- Select the unique instance record that includes an instance in a template
  and typemap.id_paramtable is null
  and base.nm_name = @nm_name
  and sub.id_acc = @id_acc
' 
END
GO
/****** Object:  StoredProcedure [dbo].[AddICBMapping]    Script Date: 06/02/2008 11:43:02 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddICBMapping]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			create proc [dbo].[AddICBMapping](@id_paramtable as int,
					@id_pi_instance as int,
					@id_sub as int,
					@id_acc as int,
					@id_po as int,
          @p_systemdate as datetime)
				as
					declare @id_pi_type as int
					declare @id_pricelist as int
					declare @id_pi_template as int
					declare @id_pi_instance_parent as int
					declare @currency as nvarchar(10)
					select @id_pi_type = id_pi_type,@id_pi_template = id_pi_template,
					@id_pi_instance_parent = id_pi_instance_parent
					from
					t_pl_map where id_pi_instance = @id_pi_instance AND id_paramtable is NULL

					--CR 10884 fix: get the price list currency from product catalog, not
					--corporation. This will take care of the case when gsubs are generated "globally".
					--Also, this seems to be correct for all other cases as well
					
					set @currency = (select pl.nm_currency_code from t_po po
					inner join t_pricelist pl on po.id_nonshared_pl = pl.id_pricelist
					where po.id_po = @id_po)

					insert into t_base_props (n_kind,n_name,n_display_name,n_desc) values (150,0,0,0)
					set @id_pricelist = @@identity
					insert into t_pricelist(id_pricelist,n_type,nm_currency_code) values (@id_pricelist, 0, @currency)
					insert into t_pl_map(
              id_paramtable,
              id_pi_type,
              id_pi_instance,
              id_pi_template,
              id_pi_instance_parent,
              id_sub,
              id_po,
              id_pricelist,
              b_canICB,
              dt_modified
              )
					values(
              @id_paramtable,
              @id_pi_type,              
              @id_pi_instance,
              @id_pi_template,
              @id_pi_instance_parent,
              @id_sub,
              @id_po,
              @id_pricelist,
              ''N'',
              @p_systemdate
              )
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[SequencedDeleteGsubRecur]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SequencedDeleteGsubRecur]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
create procedure [dbo].[SequencedDeleteGsubRecur] 
			@p_id_group_sub int,
			@p_id_prop int,
			@p_vt_start datetime,
			@p_vt_end datetime,
			@p_tt_current datetime,
			@p_tt_max datetime,
			@p_status int OUTPUT
		as
		begin
		  SET @p_status = 0
      INSERT INTO t_gsub_recur_map(id_prop, id_group, id_acc, vt_start, vt_end, tt_start, tt_end) 
        SELECT id_prop, id_group, id_acc, dateadd(s,1,@p_vt_end) AS vt_start, vt_end, @p_tt_current as tt_start, @p_tt_max as tt_end
        FROM t_gsub_recur_map 
        WHERE id_prop = @p_id_prop AND id_group = @p_id_group_sub AND vt_start < @p_vt_start AND vt_end > @p_vt_end and tt_end = @p_tt_max;
      IF @@error <> 0
      BEGIN
        SET @p_status = @@error
        return
      END
      if (@p_vt_start <> dbo.mtmindate())
      begin
				-- Valid time update becomes bi-temporal insert and update
				INSERT INTO t_gsub_recur_map(id_prop, id_group, id_acc, vt_start, vt_end, tt_start, tt_end) 
				SELECT id_prop, id_group, id_acc, vt_start, dateadd(s,-1,@p_vt_start) AS vt_end, @p_tt_current AS tt_start, @p_tt_max AS tt_end 
				FROM t_gsub_recur_map WHERE id_prop = @p_id_prop AND id_group = @p_id_group_sub AND vt_start < @p_vt_start AND vt_end >= @p_vt_start AND tt_end = @p_tt_max;
					UPDATE t_gsub_recur_map SET tt_end = dateadd(s, -1, @p_tt_current) WHERE id_prop = @p_id_prop AND id_group = @p_id_group_sub AND vt_start < @p_vt_start AND vt_end >= @p_vt_start AND tt_end = @p_tt_max;
				IF @@error <> 0
				BEGIN
					SET @p_status = @@error
					return
				END
      end
			-- Valid time update becomes bi-temporal insert (of the modified existing history into the past history) and update (of the modified existing history)
      INSERT INTO t_gsub_recur_map(id_prop, id_group, id_acc, vt_start, vt_end, tt_start, tt_end) 
      SELECT id_prop, id_group, id_acc, dateadd(s,1,@p_vt_end) AS vt_start, vt_end, @p_tt_current AS tt_start, @p_tt_max AS tt_end 
      FROM t_gsub_recur_map WHERE id_prop = @p_id_prop AND id_group = @p_id_group_sub AND vt_start <= @p_vt_end AND vt_end > @p_vt_end AND tt_end = @p_tt_max;
      UPDATE t_gsub_recur_map SET tt_end = dateadd(s, -1, @p_tt_current) WHERE id_prop = @p_id_prop AND id_group = @p_id_group_sub AND vt_start <= @p_vt_end AND vt_end > @p_vt_end AND tt_end = @p_tt_max;
      IF @@error <> 0
      BEGIN
        SET @p_status = @@error
        return
      END
      -- Now we delete any interval contained entirely in the interval we are deleting.
      -- Transaction table delete is really an update of the tt_end
      --   [----------------]                 (interval that is being modified)
      -- [------------------------]           (interval we are deleting)
      UPDATE t_gsub_recur_map SET tt_end = dateadd(s, -1, @p_tt_current)
      WHERE id_prop = @p_id_prop AND id_group = @p_id_group_sub AND vt_start >= @p_vt_start AND vt_end <= @p_vt_end AND tt_end = @p_tt_max;
      IF @@error <> 0
      BEGIN
        SET @p_status = @@error
        return
      END
		end
		
' 
END
GO
/****** Object:  View [dbo].[t_vw_rc_arrears_fixed]    Script Date: 06/02/2008 11:44:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_rc_arrears_fixed]'))
EXEC dbo.sp_executesql @statement = N'
CREATE VIEW [dbo].[t_vw_rc_arrears_fixed]
AS
-- Obtain the associated subscription period and recurring cycle
-- for each of the subscription recurring items 
SELECT 
	t_sub.id_po,
	t_pl_map.id_pi_instance,
	t_pl_map.id_pi_template,
	t_pl_map.id_paramtable,
	t_pl_map.id_pi_type,
	t_sub.id_acc,
	t_sub.vt_start sub_dt_start,
	t_sub.vt_end sub_dt_end,
	t_recur.id_usage_cycle recur_usage_cycle_id,
	t_recur.b_advance,
	t_recur.b_prorate_on_activate,
	t_recur.b_prorate_on_deactivate,
	t_recur.b_fixed_proration_length
FROM 
	t_pl_map,
	t_recur,
	t_sub
WHERE 
	t_pl_map.id_pi_instance = t_recur.id_prop and
	t_pl_map.id_po = t_sub.id_po
'
GO
/****** Object:  StoredProcedure [dbo].[GetMaterializedViewQueryTags]    Script Date: 06/02/2008 11:43:45 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetMaterializedViewQueryTags]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			create procedure [dbo].[GetMaterializedViewQueryTags](@mv_name nvarchar(1000),
													      @operation_type varchar(1),
													      @base_table_name nvarchar(4000),
														  @UpdateTag nvarchar(200) output)
			as
			if object_id( ''tempdb..#foo'' ) is not null DROP TABLE #foo
			create table #foo(name varchar(128))
			WHILE CHARINDEX('','', @base_table_name) > 0
			BEGIN
				INSERT INTO #foo (name)
                SELECT SUBSTRING(@base_table_name,1,(CHARINDEX('','', @base_table_name)-1))
                SET @base_table_name = SUBSTRING (@base_table_name, (CHARINDEX('','', @base_table_name)+1),
                                                  (LEN(@base_table_name) - (CHARINDEX('','', @base_table_name))))
            END
            
            declare @id_event int
            INSERT INTO #foo (name) SELECT @base_table_name
			SELECT DISTINCT @id_event = mbt1.id_event from t_mview_base_tables mbt1
				inner join t_mview_event c on mbt1.id_event = c.id_event
				inner join t_mview_catalog d on c.id_mv = d.id_mv
				where not exists 
				(select 1 
				 from t_mview_base_tables mbt2
                 where mbt1.id_event = mbt2.id_event
				 and not exists (select 1 from #foo where
							     mbt2.base_table_name = #foo.name
                                )                       
				)
				and not exists 
				(select 1 from #foo where not exists (select 1 from t_mview_base_tables mbt2
													  where mbt1.id_event = mbt2.id_event
													  and mbt2.base_table_name = #foo.name
												     )
			    )
				and d.name = @mv_name
				
				SELECT @UpdateTag = update_query_tag
				FROM t_mview_queries where id_event=@id_event and operation_type = @operation_type
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[CleanupMaterialization]    Script Date: 06/02/2008 11:43:19 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CleanupMaterialization]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
1) Delete data from t_billgroup_tmp
2) Delete data from t_billgroup_member_tmp
3) Delete data from t_billgroup_source_acc
4) Delete data from t_billgroup_constraint_tmp
5) Update t_billgroup_materialization
=========================================================== */
CREATE PROCEDURE [dbo].[CleanupMaterialization]
(
  @id_materialization INT,
  @dt_end DATETIME,
  @tx_status VARCHAR(10),
  @tx_failure_reason VARCHAR(4096),
  @status INT OUTPUT
)
AS

BEGIN
   -- initialize @status to failure (-1)
   SET @status = -1 

   BEGIN TRAN

  -- delete data from t_billgroup_tmp
  IF @id_materialization IS NOT NULL
     BEGIN
        DELETE t_billgroup_tmp WHERE id_materialization = @id_materialization
        DELETE t_billgroup_member_tmp WHERE id_materialization = @id_materialization
        DELETE t_billgroup_source_acc WHERE id_materialization = @id_materialization
        DELETE t_billgroup_constraint_tmp WHERE id_usage_interval = (SELECT id_usage_interval 
                                                                     FROM t_billgroup_materialization
                                                                     WHERE id_materialization = @id_materialization) 

         UPDATE t_billgroup_materialization 
         SET dt_end = @dt_end, 
                tx_status = @tx_status,
                tx_failure_reason = @tx_failure_reason
         WHERE id_materialization = @id_materialization

     END
  ELSE
     BEGIN
        DELETE t_billgroup_tmp
        DELETE t_billgroup_member_tmp 
        DELETE t_billgroup_source_acc 
        DELETE t_billgroup_constraint_tmp 
     END

   -- set @status to success
   SET @status = 0 

   COMMIT TRAN

END
' 
END
GO
/****** Object:  StoredProcedure [dbo].[SatisfyConstraintsForPullList]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SatisfyConstraintsForPullList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
This query adds extra accounts to the t_billgroup_member_tmp table
in order to satisfy grouping constraints specified in the t_billgroup_constraint table.

For the given id_materialization, the t_billgroup_member_tmp table
contains the mapping of the pull list name to the accounts specified by the user.

For each of the user specified accounts 
  - get the group which it belongs to 
  - get those accounts in the group which do not belong to the set of user specified accounts
  - if any of the accounts obtained above do not belong to the parent billing group 
       then return error
     else 
        add those accounts into t_billgroup_member_tmp if they don''t exist.
        (new accounts are added with the b_extra flag set to 1)
             

Returns:
-1 if an unknown error has occurred
-2 one or more accounts needed to satisfy the constraints do not belong to the parent billing group
-3 the parent billing group becomes empty due to constraints
============================================================== */
CREATE PROCEDURE [dbo].[SatisfyConstraintsForPullList]
(
   @id_materialization INT,
   @id_parent_billgroup INT,
   @status INT OUTPUT
)
AS

BEGIN 
   -- initialize @status to failure (-1)
   SET @status = -1 

   BEGIN TRAN
  
   /* Store the id_usage_interval */
   DECLARE @id_usage_interval INT
   DECLARE @pullListName NVARCHAR(50)

   SELECT @id_usage_interval = id_usage_interval
   FROM t_billgroup_materialization
   WHERE id_materialization = @id_materialization

   SET @pullListName = (SELECT TOP 1 tx_name
                                      FROM t_billgroup_member_tmp
                                      WHERE id_materialization = @id_materialization)

   DECLARE @groups TABLE (id_group INT NOT NULL)
   DECLARE @accounts TABLE (id_acc INT NOT NULL)

   /* Select the candidate groups based on the user specified accounts
       in t_billgroup_member_tmp for this materialization */
   INSERT @groups
   SELECT bc.id_group
   FROM t_billgroup_member_tmp bgmt
   INNER JOIN t_billgroup_constraint bc
      ON bc.id_acc = bgmt.id_acc
   WHERE bc.id_usage_interval = @id_usage_interval AND
               bgmt.id_materialization = @id_materialization
   
   /* Select the extra accounts */
   INSERT INTO @accounts
   SELECT id_acc
   FROM t_billgroup_constraint
   WHERE id_group IN (SELECT id_group 
                                   FROM @groups) AND
               id_usage_interval = @id_usage_interval AND
               -- do not add accounts that have been specified by the user
               id_acc NOT IN (SELECT id_acc 
                                       FROM t_billgroup_member_tmp
                                       WHERE id_materialization = @id_materialization)      

   /* Error if the accounts in @accounts are not a member of id_parent_billgroup */
    IF (SELECT COUNT(id_acc) FROM @accounts) > 0 AND
        (EXISTS (SELECT id_acc 
                     FROM @accounts 
                     WHERE id_acc NOT IN (SELECT id_acc
                                                         FROM t_billgroup_member
                                                         WHERE id_billgroup = @id_parent_billgroup)))
     
      BEGIN
         SET @status = -2
         ROLLBACK
         RETURN 
      END

   /* Check that not all the accounts of the parent billing group are being pulled out */
   IF ( 
         (SELECT COUNT(id_acc) 
          FROM t_billgroup_member
          WHERE id_billgroup = @id_parent_billgroup) 
          =
          (
             (SELECT COUNT(id_acc) 
              FROM t_billgroup_member_tmp 
              WHERE id_materialization = @id_materialization) 
              +
             (SELECT COUNT(id_acc) 
              FROM @accounts)
          )
       )
      BEGIN
         SET @status = -3
         ROLLBACK
         RETURN 
      END

   /* Add the extra accounts into t_billgroup_member_tmp */
   INSERT INTO t_billgroup_member_tmp(id_materialization, tx_name, id_acc, b_extra)
   SELECT @id_materialization, @pullListName, id_acc, 1
   FROM @accounts
   
   SET @status = 0
   COMMIT
END
 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpsertAccountType]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpsertAccountType]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[UpsertAccountType] @name nvarchar(400), @b_cansubscribe varchar(1), 
              @b_canbepayer varchar(1), @b_canhavesyntheticroot varchar(1), 
              @b_CanParticipateInGSub varchar(1), @bIsVisibleInHierarchy varchar(1),
              @b_CanHaveTemplates varchar(1), @b_IsCorporate varchar(1),
              @nm_desc nvarchar(1024), @id_accounttype int OUTPUT
AS
BEGIN
      update t_account_type 
			set 
			  b_cansubscribe = @b_cansubscribe,
			  b_canbepayer = @b_canbepayer,
			  b_canhavesyntheticroot = @b_canhavesyntheticroot,
			  b_CanParticipateInGSub = @b_CanParticipateInGSub,
			  b_IsVisibleInHierarchy = @bIsVisibleInHierarchy,
			  b_CanHaveTemplates = @b_CanHaveTemplates,
			  b_IsCorporate = @b_IsCorporate,
			  nm_description = @nm_desc
			where
			name = @name

			if (@@ROWCOUNT = 0)
		  insert into t_account_type 
			(name, b_CanSubscribe, b_CanBePayer, b_CanHaveSyntheticRoot, b_CanParticipateInGSub, b_IsVisibleInHierarchy,
			b_CanHaveTemplates, b_IsCorporate, nm_description)
			values 
			(@name, @b_cansubscribe, @b_canbepayer, @b_canhavesyntheticroot, @b_CanParticipateInGSub,
			 @bIsVisibleInHierarchy, @b_CanHaveTemplates, @b_IsCorporate, @nm_desc)

			select @id_accounttype=id_type from t_account_type where name=@name
END
			' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[GetAllDescendentAccountTypes]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetAllDescendentAccountTypes]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
        Create Function [dbo].[GetAllDescendentAccountTypes]
        (
          @parent varchar(200)
        )
        RETURNS @retDescendents TABLE (DescendentTypeName varchar(200))
        AS
        Begin
          declare @parentid int
          select @parentid = id_type from t_account_type where name = @parent

          DECLARE @directdesc TABLE (id_desc int not null)

          --create table #directdesc (id_desc int not null)
          insert into @directdesc
          select id_descendent_type from t_acctype_descendenttype_map amap
            where amap.id_type = @parentid


          declare @numrows integer
          set @numrows = 1 -- to get started
          while (@numrows <> 0)
          begin
            insert into @directdesc
     	        select id_descendent_type from t_acctype_descendenttype_map amap
     	        inner join @directdesc tempt on tempt.id_desc = amap.id_type
       		        where id_descendent_type not in (select id_desc from @directdesc)
            set @numrows = @@ROWCOUNT
          end

          insert @retDescendents
            SELECT t_account_type.name from @directdesc tempt
            inner join t_account_type on tempt.id_desc = t_account_type.id_type 
            RETURN
        	
        End
			' 
END
GO
/****** Object:  StoredProcedure [dbo].[ValidateBillGroupAssignments]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ValidateBillGroupAssignments]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
 Validate the following for the given materialization:
   1) The accounts in t_billgroup_source_acc are not repeated
   2) The accounts in t_billgroup_member_tmp are 
        not repeated i.e. each account is matched to exactly 
        one billing group name. 
   3) All accounts in t_billgroup_source_acc are present in t_billgroup_member_tmp
   4) Each billing group has atleast one account.


Returns the following error codes - for the given materialization:
   -1 : Unknown error occurred
   -2 : If there are duplicate accounts in t_billgroup_source_acc 
   -3 : If there are duplicate accounts in t_billgroup_member_tmp 
   -4 : If all accounts in t_billgroup_source_acc are not present in t_billgroup_member_tmp
   -5 : Each billing group in t_billgroup_tmp has atleast one account
   -6 : If there are duplicate billing group names in t_billgroup_tmp
=========================================================== */
CREATE PROCEDURE [dbo].[ValidateBillGroupAssignments]
(
   @id_materialization INT,
   @billingGroupsCount INT OUTPUT,
   @status INT OUTPUT
)
AS
   -- initialize @status to unknown error
   SET @status = -1
   SET @billingGroupsCount = 0
   
   -- check for duplicate id_acc in t_billgroup_source_acc
   IF EXISTS (SELECT id_acc 
                   FROM t_billgroup_source_acc
	       WHERE id_materialization = @id_materialization 
	       GROUP BY id_acc
	       HAVING COUNT(id_acc) > 1)
   BEGIN
     SET @status = -2
     RETURN 
   END

   -- check for duplicate id_acc in t_billgroup_member_tmp
   IF EXISTS (SELECT id_acc 
                   FROM t_billgroup_member_tmp
	       WHERE id_materialization = @id_materialization 
	       GROUP BY id_acc
	       HAVING COUNT(id_acc) > 1)
   BEGIN
     SET @status = -3
     RETURN 
   END
   
   -- check that all accounts in t_billgroup_source_acc are present in
   -- t_billgroup_member_tmp
   DECLARE @numJoinAccounts INT
   DECLARE @numOriginalAccounts INT
   
   SET @numJoinAccounts = (SELECT COUNT(bgsa.id_acc) 
			         FROM t_billgroup_source_acc bgsa
			         INNER JOIN t_billgroup_member_tmp bgt 
                                                ON bgt.id_acc = bgsa.id_acc AND
                                                      bgt.id_materialization = bgsa.id_materialization
			         WHERE bgsa.id_materialization = @id_materialization) 

   SET @numOriginalAccounts = (SELECT COUNT(id_acc) 
                                                    FROM t_billgroup_source_acc 
                                                    WHERE id_materialization = @id_materialization) 

    IF (@numJoinAccounts <> @numOriginalAccounts)
    BEGIN
      SET @status = -4
      RETURN 
    END
  
   -- Check that each billing group in t_billgroup_tmp has atleast one account   
    IF EXISTS (SELECT tx_name
	             FROM t_billgroup_tmp 
               WHERE tx_name NOT IN (SELECT tx_name
                                     FROM t_billgroup_member_tmp
                                     WHERE id_materialization = @id_materialization) AND
                     id_materialization = @id_materialization )
   BEGIN
      SET @status = -5
      RETURN 
   END

   -- Check that there are no duplicate billing group names in t_billgroup_member
   IF EXISTS (SELECT tx_name 
                   FROM t_billgroup_tmp
	       WHERE id_materialization = @id_materialization 
	       GROUP BY tx_name
	       HAVING COUNT(tx_name) > 1)
   BEGIN
      SET @status = -6
      RETURN 
   END

   SELECT @billingGroupsCount = COUNT(id_billgroup)
   FROM t_billgroup_tmp
   WHERE id_materialization = @id_materialization

   SET @status = 0
         
         ' 
END
GO
/****** Object:  StoredProcedure [dbo].[InsertAuditEvent]    Script Date: 06/02/2008 11:43:50 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertAuditEvent]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  create proc [dbo].[InsertAuditEvent] @id_userid int, @id_event int, @id_entity_type int, @id_entity int, @dt_timestamp datetime, @id_audit int, @tx_details nvarchar(4000) as
  begin
  insert into t_audit values(@id_audit, @id_event, @id_userid, @id_entity_type, @id_entity, @dt_timestamp)
  if (@tx_details is not null) and (@tx_details != '''')
  begin
  insert into t_audit_details values(@id_audit,@tx_details)
  end
  end
' 
END
GO
/****** Object:  StoredProcedure [dbo].[PurgeAuditTable]    Script Date: 06/02/2008 11:44:06 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[PurgeAuditTable]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
		    CREATE PROCEDURE [dbo].[PurgeAuditTable] @dt_start varchar(255), 
		                                     @ret_code int OUTPUT
		    AS
		    BEGIN
			    DELETE FROM t_audit 
			    WHERE dt_crt <= @dt_start 
			    IF (@@error != 0)
			    BEGIN
				    SELECT @ret_code = -99
			    END
			    ELSE
			    BEGIN
				    SELECT @ret_code = 0
			    END
			END
            ' 
END
GO
/****** Object:  StoredProcedure [dbo].[SequencedDeleteAccOwnership]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SequencedDeleteAccOwnership]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				
				CREATE  procedure [dbo].[SequencedDeleteAccOwnership]
			@p_id_owner int,
			@p_id_owned int,
			@p_vt_start datetime,
			@p_vt_end datetime,
			@p_tt_current datetime,
			@p_tt_max datetime,
			@p_status int OUTPUT
		as
		begin
    SET @p_status = 0
      INSERT INTO t_acc_ownership(id_owner, id_owned, id_relation_type, n_percent,  vt_start, vt_end, tt_start, tt_end) 
        SELECT id_owner, id_owned, id_relation_type, n_percent, dateadd(s,1,@p_vt_end) AS vt_start, vt_end, @p_tt_current as tt_start, @p_tt_max as tt_end
        FROM t_acc_ownership 
        WHERE id_owner = @p_id_owner AND id_owned = @p_id_owned
	  AND vt_start < @p_vt_start AND vt_end > @p_vt_end and tt_end = @p_tt_max;
      IF @@error <> 0
      BEGIN
        SET @p_status = @@error
        return
      END
	    -- Valid time update becomes bi-temporal insert and update
      INSERT INTO t_acc_ownership(id_owner, id_owned, id_relation_type, n_percent,  vt_start, vt_end, tt_start, tt_end) 
      SELECT id_owner, id_owned, id_relation_type, n_percent, vt_start, dateadd(s,-1,@p_vt_start) AS vt_end, @p_tt_current AS tt_start, @p_tt_max AS tt_end 
      FROM t_acc_ownership 
	    WHERE id_owner = @p_id_owner AND id_owned = @p_id_owned
	    AND vt_start < @p_vt_start AND vt_end >= @p_vt_start AND tt_end = @p_tt_max;
      
      UPDATE t_acc_ownership SET tt_end = dateadd(s, -1, @p_tt_current) 
	    WHERE id_owner = @p_id_owner AND id_owned = @p_id_owned
	    AND vt_start < @p_vt_start AND vt_end >= @p_vt_start AND tt_end = @p_tt_max;
      IF @@error <> 0
      BEGIN
        SET @p_status = @@error
        return
      END
	    -- Valid time update becomes bi-temporal insert (of the modified existing history into the past history) and update (of the modified existing history)
      INSERT INTO t_acc_ownership(id_owner, id_owned, id_relation_type, n_percent,  vt_start, vt_end, tt_start, tt_end)
      SELECT  id_owner, id_owned, id_relation_type, n_percent, dateadd(s,1,@p_vt_end) AS vt_start, vt_end, @p_tt_current AS tt_start, @p_tt_max AS tt_end 
      FROM t_acc_ownership 
	    WHERE id_owner = @p_id_owner AND id_owned = @p_id_owned
	    AND vt_start <= @p_vt_end AND vt_end > @p_vt_end AND tt_end = @p_tt_max;

      UPDATE t_acc_ownership SET tt_end = dateadd(s, -1, @p_tt_current) 
      WHERE id_owner = @p_id_owner AND id_owned = @p_id_owned
      AND vt_start <= @p_vt_end AND vt_end > @p_vt_end AND tt_end = @p_tt_max;
      IF @@error <> 0
      BEGIN
        SET @p_status = @@error
        return
      END
      -- Now we delete any interval contained entirely in the interval we are deleting.
      -- Transaction table delete is really an update of the tt_end
      --   [----------------]                 (interval that is being modified)
      -- [------------------------]           (interval we are deleting)
      UPDATE t_acc_ownership SET tt_end = dateadd(s, -1, @p_tt_current)
      WHERE id_owner = @p_id_owner AND id_owned = @p_id_owned
	    AND vt_start >= @p_vt_start AND vt_end <= @p_vt_end AND tt_end = @p_tt_max;
      IF @@error <> 0
      BEGIN
        SET @p_status = @@error
        return
      END
      end
				
			 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[ResetBillingGroupConstraints]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[ResetBillingGroupConstraints]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
Delete the existing constraints for the given interval from t_billgroup_constraint
Copy the constraints from t_billgroup_constraint_tmp to t_billgroup_constraint

Returns:
-1 if an unknown error has occurred
============================================================== */
CREATE PROCEDURE [dbo].[ResetBillingGroupConstraints]
(
   @id_usage_interval INT,
   @status INT OUTPUT
)
AS

BEGIN 
   -- initialize @status to failure (-1)
   SET @status = -1 

   
  
   -- delete previous constraint data for this interval
  DELETE 
  FROM t_billgroup_constraint
  WHERE id_usage_interval = @id_usage_interval

  -- copy data from t_billgroup_constraint_tmp to t_billgroup_constraint
  INSERT INTO t_billgroup_constraint (id_usage_interval, id_group, id_acc)
  SELECT @id_usage_interval, 
              id_group,
              id_acc
  FROM t_billgroup_constraint_tmp 
  WHERE id_usage_interval =  @id_usage_interval 

  SET @status = 0
  
END

 ' 
END
GO
/****** Object:  View [dbo].[t_vw_expanded_sub]    Script Date: 06/02/2008 11:44:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_expanded_sub]'))
EXEC dbo.sp_executesql @statement = N'
        
CREATE VIEW [dbo].[t_vw_expanded_sub]
(
id_sub,
id_acc,
id_po,
vt_start,
vt_end,
dt_crt,
id_group,
id_group_cycle,
b_supportgroupops
)
AS 
SELECT
   sub.id_sub,
   CASE WHEN sub.id_group IS NULL THEN sub.id_acc ELSE mem.id_acc END id_acc,
   sub.id_po,
   CASE WHEN sub.id_group IS NULL THEN sub.vt_start ELSE mem.vt_start END vt_start,
   CASE WHEN sub.id_group IS NULL THEN sub.vt_end ELSE mem.vt_end END vt_end,
   sub.dt_crt,
   sub.id_group,
   gsub.id_usage_cycle,
   CASE WHEN sub.id_group IS NULL THEN ''N'' ELSE gsub.b_supportgroupops END b_supportgroupops
FROM  
   t_sub sub
   LEFT OUTER JOIN t_group_sub gsub ON gsub.id_group = sub.id_group
   LEFT OUTER JOIN t_gsubmember mem ON mem.id_group = gsub.id_group
'
GO
/****** Object:  StoredProcedure [dbo].[RemoveGroupSubscription]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[RemoveGroupSubscription]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
create procedure [dbo].[RemoveGroupSubscription](
  @p_id_sub int,
  @p_systemdate datetime,
  @p_status int OUTPUT)

  as
  begin
    
    declare @groupID int
    declare @maxdate datetime   
    declare @nmembers int
    declare @icbID int

    set @p_status = 0

    select @groupID = id_group,@maxdate = dbo.mtmaxdate()
    from t_sub where id_sub = @p_id_sub

    select distinct @icbID = id_pricelist from t_pl_map where id_sub=@p_id_sub

    select @nmembers = count(*) from t_gsubmember_historical where id_group = @groupID
    if @nmembers > 0
      begin
        -- We don''t support deleting group subs if this group sub ever had a member
        select @p_status = 1
        return
      end   
    
    delete from t_gsub_recur_map where id_group = @groupID
    delete from t_recur_value where id_sub = @p_id_sub

    -- In the t_acc_template_subs, either id_po or id_group have to be null.
    -- If a subscription is added to a template, then id_po points to the subscription
    -- If a group subscription is added to a template, then id_group points to the group subscription.
    delete from t_acc_template_subs where id_group = @groupID and id_po is null

    -- Eventually we would need to make sure that the rules for each icb rate schedule are removed from the proper parameter tables
    delete from t_pl_map where id_sub = @p_id_sub

    update t_recur_value set tt_end = @p_systemdate 
      where id_sub = @p_id_sub and tt_end = @maxdate
    update t_sub_history set tt_end = @p_systemdate
      where tt_end = @maxdate and id_sub = @p_id_sub

    delete from t_sub where id_sub = @p_id_sub
    
      if (@icbID is not NULL)
      begin
        exec sp_DeletePricelist @icbID, @p_status output
        if @p_status <> 0 return
      end
  
    update t_group_sub set tx_name = CAST(''[DELETED '' + CAST(GetDate() as nvarchar) + '']'' + tx_name as nvarchar(255)) where id_group = @groupID

  end
    
' 
END
GO
/****** Object:  StoredProcedure [dbo].[sp_InsertCompositeCapType]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_InsertCompositeCapType]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
        
						create procedure [dbo].[sp_InsertCompositeCapType] 
						(@aGuid VARBINARY(16), @aName NVARCHAR(255), @aDesc NVARCHAR(255), @aProgid NVARCHAR(255), 
             @aEditor NVARCHAR(255),@aCSRAssignable VARCHAR, @aSubAssignable VARCHAR,
             @aMultipleInstances VARCHAR, @aUmbrellaSensitive VARCHAR , @ap_id_prop int OUTPUT)
						as
						
						begin
            	INSERT INTO t_composite_capability_type(tx_guid,tx_name,tx_desc,tx_progid,tx_editor,
              csr_assignable,subscriber_assignable,multiple_instances,umbrella_sensitive) VALUES (
							@aGuid, @aName, @aDesc, @aProgid, @aEditor, @aCSRAssignable,
						  @aSubAssignable, @aMultipleinstances,@aUmbrellaSensitive)
							if (@@error <> 0) 
                  begin
                  select @ap_id_prop = -99
                  end
                  else
                  begin
                  select @ap_id_prop = @@identity
                  end
        		END
				 
        ' 
END
GO
/****** Object:  StoredProcedure [dbo].[DeleteAccounts]    Script Date: 06/02/2008 11:43:35 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteAccounts]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      
			Create Procedure [dbo].[DeleteAccounts]
				@accountIDList nvarchar(4000), --accounts to be deleted
				@tablename nvarchar(4000), --table containing id_acc to be deleted
				@linkedservername nvarchar(255), --linked server name for payment server 
				@PaymentServerdbname nvarchar(255) --payment server database name
			AS
			set nocount on
			set xact_abort on
			declare @sql nvarchar(4000)
	/*
			How to run this stored procedure
			exec DeleteAccounts @accountIDList=''123,124'',@tablename=null,@linkedservername=null,@PaymentServerdbname=null
			or
			exec DeleteAccounts @accountIDList=null,@tablename=''tmp_t_account'',@linkedservername=null,@PaymentServerdbname=null
	*/
				-- Break down into simple account IDs
				-- This block of SQL can be used as an example to get 
				-- the account IDs from the list of account IDs that are
				-- passed in
				CREATE TABLE #AccountIDsTable (
				  ID int NOT NULL,
					status int NULL,
					message varchar(255) NULL)

				PRINT ''------------------------------------------------''
				PRINT ''-- Start of Account Deletion Stored Procedure --''
				PRINT ''------------------------------------------------''

				if ((@accountIDList is not null and @tablename is not null) or 
				(@accountIDList is null and @tablename is null))
				begin
					print ''ERROR--Delete account operation failed-->Either accountIDList or tablename should be specified''
					return -1
				END
				
				if (@accountIDList is not null)
				begin
					PRINT ''-- Parsing Account IDs passed in and inserting in tmp table --''
					WHILE CHARINDEX('','', @accountIDList) > 0
					BEGIN
						INSERT INTO #AccountIDsTable (ID, status, message)
	 					SELECT SUBSTRING(@accountIDList,1,(CHARINDEX('','', @accountIDList)-1)), 1, ''Okay to delete''
	 					SET @accountIDList = 
	 						SUBSTRING (@accountIDList, (CHARINDEX('','', @accountIDList)+1),
	  										(LEN(@accountIDList) - (CHARINDEX('','', @accountIDList))))
					END
	 						INSERT INTO #AccountIDsTable (ID, status, message) 
							SELECT @accountIDList, 1, ''Okay to delete''
					-- SELECT ID as one FROM #AccountIDsTable
	
					-- Transitive Closure (check for folder/corporation)
					PRINT ''-- Inserting children (if any) into the tmp table --''
					INSERT INTO #AccountIDsTable (ID, status, message)
					SELECT DISTINCT 
					  aa.id_descendent,
						1,
						''Okay to delete''
					FROM 
					  t_account_ancestor aa INNER JOIN #AccountIDsTable tmp ON 
						tmp.ID = aa.id_ancestor AND
						aa.num_generations > 0 AND
					NOT EXISTS (
					  SELECT 
						  ID 
						FROM 
						  #AccountIDsTable tmp1 
						WHERE 
						  tmp1.ID = aa.id_descendent)
	
					--fix bug 11599
					INSERT INTO #AccountIDsTable (ID, status, message)
					SELECT DISTINCT 
					  aa.id_descendent,
						1,
						''Okay to delete''
					FROM 
					  t_account_ancestor aa where id_ancestor in (select id from  #AccountIDsTable)
						AND
						aa.num_generations > 0 AND
					NOT EXISTS (
					  SELECT 
						  ID 
						FROM 
						  #AccountIDsTable tmp1 
						WHERE 
						  tmp1.ID = aa.id_descendent)
				end
				else
				begin
					set @sql = ''INSERT INTO #AccountIDsTable (ID, status, message) SELECT id_acc, 
							1, ''''Okay to delete'''' from '' + @tablename
					exec (@sql)
					INSERT INTO #AccountIDsTable (ID, status, message)
					SELECT DISTINCT 
					  aa.id_descendent,
						1,
						''Okay to delete''
					FROM 
					  t_account_ancestor aa INNER JOIN #AccountIDsTable tmp ON 
						tmp.ID = aa.id_ancestor AND
						aa.num_generations > 0 AND
					NOT EXISTS (
					  SELECT 
						  ID 
						FROM 
						  #AccountIDsTable tmp1 
						WHERE 
						  tmp1.ID = aa.id_descendent)
				end
				-- SELECT * from #AccountIDsTable			
					
				/*
				-- print out the accounts with their login names
				SELECT 
					ID as two, 
					nm_login as two 
				FROM 
					#AccountIDsTable a,
					t_account_mapper b
				WHERE
					a.ID = b.id_acc
				*/

				/*
				 * Check for all the business rules.  We want to make sure 
				 * that we are checking the more restrictive rules first
				 * 1. Check for usage in hard closed interval
				 * 2. Check for invoices in hard closed interval
				 * 3. Check if the account is a payer ever
				 * 4. Check if the account is a receiver of per subscription Recurring
				 *    Charge
				 * 5. Check for usage in soft/open closed interval
				 * 6. Check for invoices in soft/open closed interval
				 * 7. Check if the account contributes to group discount
				 */
				PRINT ''-- Account does not exists check --''
				UPDATE 
					tmp
				SET
					status = 0, -- failure
					message = ''Account does not exists!''
				FROM
					#AccountIDsTable tmp
				WHERE
					status <> 0 AND
					not EXISTS (
						SELECT 
							1
						FROM 
							t_account acc 
						WHERE
							acc.id_acc = tmp.ID )
											
				-- 1. Check for ''hard close'' usage in any of these accounts
				PRINT ''-- Usage in Hard closed interval check --''
				UPDATE 
					tmp
				SET
					status = 0, -- failure
					message = ''Account contains usage in hard interval!''
				FROM
					#AccountIDsTable tmp
				WHERE
					status <> 0 AND
					EXISTS (
						SELECT 
							au.id_acc
						FROM 
							t_acc_usage au INNER JOIN t_acc_usage_interval ui
						ON	
							ui.id_usage_interval = au.id_usage_interval AND
							ui.tx_status in (''H'')
						WHERE
							au.id_acc = tmp.ID )

				-- 2. Check for invoices in hard closed interval usage in any of these 
				-- accounts
				PRINT ''-- Invoices in Hard closed interval check --''
				UPDATE 
					tmp
				SET
					status = 0, -- failure
					message = ''Account contains invoices for hard closed interval!''
				FROM
					#AccountIDsTable tmp
				WHERE
					status <> 0 AND
					EXISTS (
						SELECT 
							i.id_acc
						FROM 
							t_invoice i INNER JOIN t_acc_usage_interval ui
						ON	
							ui.id_usage_interval = i.id_interval AND
							ui.tx_status in (''H'')
						WHERE
							i.id_acc = tmp.ID )

				-- 3. Check if this account has ever been a payer
				PRINT ''-- Payer check --''
				UPDATE 
					tmp
				SET
					status = 0, -- failure
					message = ''Account is a payer!''
				FROM
					#AccountIDsTable tmp
				WHERE
					status <> 0 AND
					EXISTS (
						SELECT 
							p.id_payer
						FROM 
							t_payment_redir_history p
						WHERE
							p.id_payer = tmp.ID AND
							p.id_payee not in (select id from #AccountIDsTable))

				-- 4. Check if this account is receiver of per subscription RC
				PRINT ''-- Receiver of per subscription Recurring Charge check --''
				UPDATE 
					tmp
				SET
					status = 0, -- failure
					message = ''Account is receiver of per subscription RC!''
				FROM
					#AccountIDsTable tmp
				WHERE
					status <> 0 AND
					EXISTS (
						SELECT 
							gsrm.id_acc
						FROM 
							t_gsub_recur_map gsrm
						WHERE
							gsrm.id_acc = tmp.ID )

				-- 5. Check for invoices in soft closed or open usage in any of these 
				-- accounts
				PRINT ''-- Invoice in Soft closed/Open interval check --''
				UPDATE 
					tmp
				SET
					status = 0, -- failure
					message = ''Account contains invoices for soft closed interval.  Please backout invoice adapter first!''
				FROM
					#AccountIDsTable tmp
				WHERE
					status <> 0 AND
					EXISTS (
						SELECT 
							i.id_acc
						FROM 
							t_invoice i INNER JOIN t_acc_usage_interval ui
						ON	
							ui.id_usage_interval = i.id_interval AND
							ui.tx_status in (''C'', ''O'')
						WHERE
							i.id_acc = tmp.ID )

				-- 6. Check for ''soft close/open'' usage in any of these accounts
				PRINT ''-- Usage in Soft closed/Open interval check --''
				UPDATE 
					tmp
				SET					status = 0, -- failure
					message = ''Account contains usage in soft closed or open interval.  Please backout first!''
				FROM
					#AccountIDsTable tmp
				WHERE
					status <> 0 AND
					EXISTS (
						SELECT 
							au.id_acc
						FROM 
							t_acc_usage au INNER JOIN t_acc_usage_interval ui
						ON	
							ui.id_usage_interval = au.id_usage_interval AND
							ui.tx_status in (''C'', ''O'')
						WHERE
							au.id_acc = tmp.ID )

				-- 7. Check if this account contributes to group discount 
				PRINT ''-- Contribution to Discount Distribution check --''
				UPDATE 
					tmp
				SET
					status = 0, -- failure
					message = ''Account is contributing to a discount!''
				FROM
					#AccountIDsTable tmp
				WHERE
					status <> 0 AND
					EXISTS (
						SELECT 
							gs.id_discountAccount
						FROM 
							t_group_sub gs
						WHERE
							gs.id_discountAccount = tmp.ID )

				IF EXISTS (
					SELECT 
						*
					FROM
						#AccountIDsTable
					WHERE
						status = 0)
				BEGIN					PRINT ''Deletion of accounts cannot proceed. Fix the errors!''
					PRINT ''-- Exiting --!''
					SELECT 
						*
					FROM
						#AccountIDsTable

					RETURN
				END
						
				-- Start the deletes here
				PRINT ''-- Beginning the transaction here --''
				BEGIN TRANSACTION

				-- Script to find ICB rates and delete from t_pt, t_rsched, 
				-- t_pricelist tables
				PRINT ''-- Finding ICB rate and deleting for PC tables --''
				create table #id_sub (id_sub int)
				INSERT into #id_sub select id_sub from t_sub where id_acc
				IN (SELECT ID FROM #AccountIDsTable) 
				DECLARE @id_pt table (id_pt int,id_pricelist int)
				INSERT 
					@id_pt 
				SELECT 
					id_paramtable,
					id_pricelist 
				FROM 
					t_pl_map 
				WHERE 
					id_sub IN (SELECT * FROM #id_sub)
				DECLARE c1 cursor forward_only for select id_pt,id_pricelist from @id_pt
				DECLARE @name varchar(200)
				DECLARE @pt_name varchar(200)
				DECLARE @pl_name varchar(200)
				DECLARE @str varchar(4000)
				OPEN c1
				FETCH c1 INTO @pt_name,@pl_name
				SELECT 
					@name =
				REVERSE(substring(REVERSE(nm_name),1,charindex(''/'',REVERSE(nm_name))-1))
				FROM 
					t_base_props 
				WHERE 
					id_prop = @pt_name
				SELECT 
					@str = ''DELETE t_pt_'' + @name + '' from t_pt_'' + @name + '' INNER JOIN t_rsched rsc on t_pt_'' 
						+ @name + ''.id_sched = rsc.id_sched 
						INNER JOIN t_pl_map map ON 
						map.id_paramtable = rsc.id_pt AND 
						map.id_pi_template = rsc.id_pi_template AND 
						map.id_pricelist = rsc.id_pricelist 
						WHERE map.id_sub IN (SELECT id_sub FROM #id_sub)''
				EXECUTE (@str)
				SELECT @str = ''DELETE FROM t_rsched WHERE id_pricelist ='' + @pl_name
				EXECUTE (@str)
				SELECT @str = ''DELETE FROM t_pl_map WHERE id_pricelist ='' + @pl_name
				EXECUTE (@str)
				SELECT @str = ''DELETE FROM t_pricelist WHERE id_pricelist ='' + @pl_name
				EXECUTE (@str)
				
				CLOSE c1
				DEALLOCATE c1

				-- t_billgroup_member
				PRINT ''-- Deleting from t_billgroup_member --''
				DELETE FROM t_billgroup_member
				WHERE id_acc IN (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_billgroup_member table''
					GOTO SetError
				END

				-- t_billgroup_member_history
				PRINT ''-- Deleting from t_billgroup_member_history --''
				DELETE FROM t_billgroup_member_history
				WHERE id_acc IN (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_billgroup_member_history table''
					GOTO SetError
				END

				-- t_billgroup_member_history
				PRINT ''-- Deleting from t_billgroup_source_acc --''
				DELETE FROM t_billgroup_source_acc
				WHERE id_acc IN (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_billgroup_source_acc table''
					GOTO SetError
				END

				-- t_billgroup_constraint 
				PRINT ''-- Deleting from t_billgroup_constraint  --''
				DELETE FROM t_billgroup_constraint 
				WHERE id_acc IN (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_billgroup_constraint table''
					GOTO SetError
				END

				-- t_billgroup_constraint_tmp
				PRINT ''-- Deleting from t_billgroup_constraint_tmp --''
				DELETE FROM t_billgroup_constraint_tmp
				WHERE id_acc IN (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_billgroup_constraint_tmp table''
					GOTO SetError
				END

				-- t_av_* tables
				DECLARE @table_name nvarchar(1000)
				DECLARE c2 CURSOR FOR SELECT table_name FROM information_schema.tables 
				WHERE table_name LIKE ''t_av_%'' AND table_type = ''BASE TABLE''
				-- Delete from t_av_* tables
				OPEN c2
				FETCH NEXT FROM c2 into @table_name
				WHILE (@@FETCH_STATUS = 0)
				BEGIN
					PRINT ''-- Deleting from '' + @table_name + '' --''					
					EXEC (''DELETE FROM '' + @table_name + '' WHERE id_acc IN (SELECT ID FROM #AccountIDsTable)'')
					IF (@@Error <> 0)				
					BEGIN
						PRINT ''Cannot delete from '' + @table_name + '' table''
  						CLOSE c2
   						DEALLOCATE c2
						GOTO SetError
					END
   					FETCH NEXT FROM c2 INTO @table_name
				END
  				CLOSE c2
   				DEALLOCATE c2
 		
				-- t_account_state_history
				PRINT ''-- Deleting from t_account_state_history --''
				DELETE FROM t_account_state_history
				WHERE id_acc IN (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_account_state_history table''
					GOTO SetError
				END

				-- t_account_state
				PRINT ''-- Deleting from t_account_state --''
				DELETE FROM t_account_state
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_account_state table''
					GOTO SetError
				END

				-- t_acc_usage_interval 
				PRINT ''-- Deleting from t_acc_usage_interval --''
				DELETE FROM t_acc_usage_interval
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_acc_usage_interval table''
					GOTO SetError
				END

				-- t_acc_usage_cycle
				PRINT ''-- Deleting from t_acc_usage_cycle --''
				DELETE FROM t_acc_usage_cycle
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_acc_usage_cycle table''
					GOTO SetError
				END

				-- t_acc_template_props
				PRINT ''-- Deleting from t_acc_template_props --''
				DELETE FROM t_acc_template_props
				WHERE id_acc_template IN 
				(SELECT id_acc_template 
				FROM t_acc_template
				WHERE id_folder in (SELECT ID FROM #AccountIDsTable))
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_acc_template_props table''
					GOTO SetError
				END

				-- t_acc_template_subs
				PRINT ''-- Deleting from t_acc_template_subs --''
				DELETE FROM t_acc_template_subs
				WHERE id_acc_template IN 
				(SELECT id_acc_template 
				FROM t_acc_template
				WHERE id_folder in (SELECT ID FROM #AccountIDsTable))
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_acc_template_subs table''
					GOTO SetError
				END

				-- t_acc_template
				PRINT ''-- Deleting from t_acc_template --''
				DELETE FROM t_acc_template
				WHERE id_folder in (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_acc_template table''
					GOTO SetError
				END
				
				-- t_user_credentials
				PRINT ''-- Deleting from t_user_credentials --''
				DELETE FROM t_user_credentials
				WHERE nm_login IN 
				(SELECT nm_login
				FROM t_account_mapper
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable))
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_user_credentials table''
					GOTO SetError
				END

				-- t_profile
				PRINT ''-- Deleting from t_profile --''
				DELETE FROM t_profile
				WHERE id_profile IN
				(SELECT id_profile
				FROM t_site_user
				WHERE nm_login IN
				(SELECT nm_login
				FROM t_account_mapper
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable)))
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_profile table''
					GOTO SetError
				END

				-- t_site_user
				PRINT ''-- Deleting from t_site_user --''
				DELETE FROM t_site_user
				WHERE nm_login IN 
				(SELECT nm_login
				FROM t_account_mapper
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable))
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_site_user table''
					GOTO SetError
				END
				
				-- t_payment_redirection
				PRINT ''-- Deleting from t_payment_redirection --''
				DELETE FROM t_payment_redirection
				WHERE id_payee IN (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_payment_redirection table''
					GOTO SetError
				END
				
				-- t_payment_redir_history
				PRINT ''-- Deleting from t_payment_redir_history --''
				DELETE FROM t_payment_redir_history
				WHERE id_payee IN (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_payment_redir_history table''
					GOTO SetError
				END
				
				-- t_sub
				PRINT ''-- Deleting from t_sub --''
				DELETE FROM t_sub
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_sub table''
					GOTO SetError
				END
				
				-- t_sub_history
				PRINT ''-- Deleting from t_sub_history --''
				DELETE FROM t_sub_history
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_sub_history table''
					GOTO SetError
				END
				
				-- t_group_sub
				PRINT ''-- Deleting from t_group_sub --''
				DELETE FROM t_group_sub
				WHERE id_discountAccount in (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_group_sub table''
					GOTO SetError
				END

				-- t_gsubmember
				PRINT ''-- Deleting from t_gsubmember --''
				DELETE FROM t_gsubmember
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_gsubmember table''
					GOTO SetError
				END
				
				-- t_gsubmember_historical
				PRINT ''-- Deleting from t_gsubmember_historical --''
				DELETE FROM t_gsubmember_historical
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_gsubmember_historical table''
					GOTO SetError
				END

				-- t_gsub_recur_map
				PRINT ''-- Deleting from t_gsub_recur_map --''
				DELETE FROM t_gsub_recur_map 
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)                                             
				BEGIN
				  PRINT ''Cannot delete from t_gsub_recur_map table''
					GOTO SetError
				END
				
				-- t_pl_map
				PRINT ''-- Deleting from t_pl_map --''
				DELETE FROM t_pl_map
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_pl_map table''
					GOTO SetError
				END
				
				-- t_path_capability
				PRINT ''-- Deleting from t_path_capability --''
				DELETE FROM t_path_capability
				WHERE id_cap_instance IN (
				SELECT id_cap_instance FROM t_capability_instance ci
				WHERE ci.id_policy IN (
				SELECT id_policy FROM t_principal_policy 
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable)))
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_path_capability table''
					GOTO SetError
				END

				-- t_enum_capability
				PRINT ''-- Deleting from t_enum_capability --''
				DELETE FROM t_enum_capability
				WHERE id_cap_instance IN (
				SELECT id_cap_instance FROM t_capability_instance ci
				WHERE ci.id_policy IN (
				SELECT id_policy FROM t_principal_policy 
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable)))
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_enum_capability table''
					GOTO SetError
				END

				-- t_decimal_capability
				PRINT ''-- Deleting from t_decimal_capability --''
				DELETE FROM t_decimal_capability
				WHERE id_cap_instance IN (
				SELECT id_cap_instance FROM t_capability_instance ci
				WHERE ci.id_policy IN (
				SELECT id_policy FROM t_principal_policy 
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable)))
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_decimal_capability table''
					GOTO SetError
				END

				-- t_capability_instance
				PRINT ''-- Deleting from t_capability_instance --''
				DELETE FROM t_capability_instance
				WHERE id_policy IN (
				SELECT id_policy FROM t_principal_policy 
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable))
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_capability_instance table''
					GOTO SetError
				END
				
				-- t_policy_role
				PRINT ''-- Deleting from t_policy_role --''
				DELETE FROM t_policy_role
				WHERE id_policy IN (
				SELECT id_policy FROM t_principal_policy 
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable))
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_policy_role table''
					GOTO SetError
				END
				
				-- t_principal_policy
				PRINT ''-- Deleting from t_principal_policy --''
				DELETE FROM t_principal_policy
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_principal_policy table''
					GOTO SetError
				END
				
				-- t_impersonate
				PRINT ''-- Deleting from t_impersonate --''
				DELETE FROM t_impersonate
				WHERE (id_acc in (SELECT ID FROM #AccountIDsTable)
				or id_owner in (SELECT ID FROM #AccountIDsTable))
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_impersonate table''
					GOTO SetError
				END
				
				-- t_account_mapper
				PRINT ''-- Deleting from t_account_mapper --''
				DELETE FROM t_account_mapper
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable) 
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_account_mapper table''
					GOTO SetError
				END

				DECLARE @hierarchyrule nvarchar(10)
				SELECT @hierarchyrule = value 
				FROM t_db_values 
				WHERE parameter = ''Hierarchy_RestrictedOperations''
				IF (@hierarchyrule = ''True'')
				BEGIN
				  DELETE FROM t_group_sub 
					WHERE id_corporate_account IN (SELECT ID FROM #AccountIDsTable)
					IF (@@Error <> 0)                                             
					BEGIN
					  PRINT ''Cannot delete from t_group_sub table''
						GOTO SetError
					END
				END
								
				-- t_account_ancestor
				PRINT ''-- Deleting from t_account_ancestor --''
				DELETE FROM t_account_ancestor
				WHERE id_descendent in (SELECT ID FROM #AccountIDsTable) 
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_account_ancestor table''
					GOTO SetError
				END

				UPDATE	
					t_account_ancestor 
				SET 
					b_Children = ''N'' 
				FROM 
					t_account_ancestor aa1
				WHERE
					id_descendent IN (SELECT ID FROM #AccountIDsTable) and
					NOT EXISTS (SELECT 1 FROM t_account_ancestor aa2
											WHERE aa2.id_ancestor = aa1.id_descendent
											AND num_generations <> 0)

				-- t_account
				PRINT ''-- Deleting from t_account --''
				DELETE FROM t_account
				WHERE id_acc in (SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_account table''
					GOTO SetError
				END

				PRINT ''-- Deleting from t_dm_account_ancestor --''
				DELETE FROM t_dm_account_ancestor
				WHERE id_dm_descendent in 
				(
				select id_dm_acc from t_dm_account where id_acc in
				(SELECT ID FROM #AccountIDsTable)
				)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_dm_account_ancestor table''
					GOTO SetError
				END

				PRINT ''-- Deleting from t_dm_account --''
				DELETE FROM t_dm_account
				WHERE id_acc in 
				(SELECT ID FROM #AccountIDsTable)
				IF (@@Error <> 0)				
				BEGIN
					PRINT ''Cannot delete from t_dm_account table''
					GOTO SetError
				END
				
				-- IF (@linkedservername <> NULL)
				-- BEGIN
				  -- Do payment server stuff here
				-- END

				-- If we are here, then all accounts should have been deleted	
				
				if (@linkedservername is not NULL and @PaymentServerdbname is not null)
				begin
					select @sql = ''delete from '' + @linkedservername + ''.'' + @PaymentServerdbname + ''.dbo.t_ps_creditcard WHERE id_acc in
							(SELECT ID FROM #AccountIDsTable)''
					print (@sql)
					execute (@sql)
					IF (@@Error <> 0)				
					BEGIN
						PRINT ''Cannot delete from t_ps_creditcard table''
						GOTO SetError
					end
					select @sql = ''delete from '' + @linkedservername + ''.'' + @PaymentServerdbname + ''.dbo.t_ps_ach WHERE id_acc in
							(SELECT ID FROM #AccountIDsTable)''
					execute (@sql)
					IF (@@Error <> 0)				
					BEGIN
						PRINT ''Cannot delete from t_ps_ach table''
						GOTO SetError
					END
					select @sql = ''delete from '' + @linkedservername + ''.'' + @PaymentServerdbname + ''.dbo.t_ps_account WHERE id_acc in
							(SELECT ID FROM #AccountIDsTable)''
					execute (@sql)
					IF (@@Error <> 0)				
					BEGIN
						PRINT ''Cannot delete from t_ps_account table''
						GOTO SetError
					END
				end
				if (@linkedservername is NULL and @PaymentServerdbname is not null)
				begin
					select @sql = ''delete from '' + @PaymentServerdbname + ''.dbo.t_ps_creditcard WHERE id_acc in
							(SELECT ID FROM #AccountIDsTable)''
					execute (@sql)
					IF (@@Error <> 0)				
					BEGIN
						PRINT ''Cannot delete from t_ps_creditcard table''
						GOTO SetError
					end
					select @sql = ''delete from '' + @PaymentServerdbname + ''.dbo.t_ps_ach WHERE id_acc in
							(SELECT ID FROM #AccountIDsTable)''
					execute (@sql)
					IF (@@Error <> 0)				
					BEGIN
						PRINT ''Cannot delete from t_ps_ach table''
						GOTO SetError
					END
					select @sql = ''delete from '' + @PaymentServerdbname + ''.dbo.t_ps_account WHERE id_acc in
							(SELECT ID FROM #AccountIDsTable)''
					execute (@sql)
					IF (@@Error <> 0)				
					BEGIN
						PRINT ''Cannot delete from t_ps_account table''
						GOTO SetError
					END
				end

				if (@linkedservername is not NULL and @PaymentServerdbname is null)
					BEGIN
						PRINT ''Please specify the database name of payment server''
						GOTO SetError
					END				

				UPDATE
				  #AccountIDsTable
				SET
				  message = ''This account no longer exists!''	

				SELECT 
					*
				FROM
					#AccountIDsTable
				--WHERE
				--	status <> 0

				COMMIT TRANSACTION
				RETURN 0

				SetError:
					ROLLBACK TRANSACTION
					RETURN -1
			
			' 
END
GO
/****** Object:  StoredProcedure [dbo].[AddDatabaseProperty]    Script Date: 06/02/2008 11:43:02 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddDatabaseProperty]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
    
		CREATE procedure [dbo].[AddDatabaseProperty](@property nvarchar(128), @value nvarchar(5))
		as
			delete from t_db_values where parameter=@property
			insert into t_db_values(parameter,value) values(@property,@value)
		
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[GetDatabaseProperty]    Script Date: 06/02/2008 11:43:43 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetDatabaseProperty]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
    
		CREATE procedure [dbo].[GetDatabaseProperty](@property nvarchar(128), @value nvarchar(200) output, @status int output)
		as
		select @value=value from t_db_values where parameter = @property
		if (@value Is NULL)
		begin
			set @status = -99
			return
		end
		set @status = 0
    
    ' 
END
GO
/****** Object:  StoredProcedure [dbo].[MT_sys_analyze_all_tables]    Script Date: 06/02/2008 11:44:01 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MT_sys_analyze_all_tables]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      
create PROCEDURE [dbo].[MT_sys_analyze_all_tables] (@NU_varStatPercent int =30,@U_varStatPercent int =30, @H_varStatPercent int =30, @database_name nvarchar(4000) =null , @only_indexes nvarchar(10) = ''ALL'')
AS
BEGIN
/********************************************************************
** Procedure Name:  MT_sys_analyze_all_tables
** exec MT_sys_analyze_all_tables 100,30,100,null,''ALL''
** Procedure Description: Analyze all the user defined tables in all the partitions
**
** Parameters: varStatPercent int
**
** Returns: 0 if successful
**          1 if fatal error occurred
**
*********************************************************************************/
DECLARE @varTblName varchar(128), @SQLStmt nvarchar(4000), @SQLStmtError int,
	@PrintStmt varchar(1000), @NU_varStatPercentChar varchar(255),@U_varStatPercentChar varchar(255),
	@H_varStatPercentChar varchar(255),@getdate datetime, @starttime datetime
SET NOCOUNT ON
declare @intervalstart int
declare @intervalend int
DECLARE @rowcount int
declare @maxdate datetime

set @maxdate = dbo.MTMaxdate()
set @rowcount=0
select @getdate = getdate()
IF @NU_varStatPercent < 5 
   SET @NU_varStatPercentChar = '' WITH SAMPLE 5 PERCENT, '' + @only_indexes
ELSE IF @NU_varStatPercent >= 100 
   SET @NU_varStatPercentChar = '' WITH FULLSCAN, '' + @only_indexes
ELSE SET @NU_varStatPercentChar = '' WITH SAMPLE '' 
   + CAST(@NU_varStatPercent AS varchar(20)) 
   + '' PERCENT, '' + @only_indexes

IF @U_varStatPercent < 5 
   SET @U_varStatPercentChar = '' WITH SAMPLE 5 PERCENT, '' + @only_indexes
ELSE IF @U_varStatPercent >= 100 
   SET @U_varStatPercentChar = '' WITH FULLSCAN, '' + @only_indexes
ELSE SET @U_varStatPercentChar = '' WITH SAMPLE '' 
   + CAST(@U_varStatPercent AS varchar(20)) 
   + '' PERCENT, '' + @only_indexes

IF @H_varStatPercent < 5 
   SET @H_varStatPercentChar = '' WITH SAMPLE 5 PERCENT, '' + @only_indexes
ELSE IF @H_varStatPercent >= 100 
   SET @H_varStatPercentChar = '' WITH FULLSCAN, '' + @only_indexes
ELSE SET @H_varStatPercentChar = '' WITH SAMPLE '' 
   + CAST(@H_varStatPercent AS varchar(20)) 
   + '' PERCENT, '' + @only_indexes


if (@database_name is null)
begin
	declare @dbname nvarchar(100)
	select @dbname = db_name()
	--Indexed Views
	DECLARE curUserObjs CURSOR FOR 
	select distinct obj.name from sysindexkeys keys inner join sysobjects obj 
	on keys.id=obj.id 
	where XTYPE=''v''
	SELECT @SQLStmtError = @@ERROR
	IF @SQLStmtError <> 0
		RETURN 1
	OPEN curUserObjs 
	FETCH curUserObjs INTO @varTblName 
	WHILE @@FETCH_STATUS = 0
	BEGIN
		set @starttime = getdate()
		SET @SQLStmt = ''UPDATE STATISTICS '' + @varTblName + @NU_varStatPercentChar 
		EXECUTE (@SQLStmt)
		Insert into t_updatestatsinfo values (@varTblName, @NU_varStatPercentChar, datediff(ss,@starttime,getdate()))
		FETCH curUserObjs INTO @varTblName 
	END 
	CLOSE curUserObjs 
	DEALLOCATE curUserObjs 
	PRINT ''Statistics have been updated for all Indexed Views.'' 
	
	--Non-Usage tables in NetMeter Database
	DECLARE curUserObjs CURSOR FOR 
	select table_name from information_schema.tables
	where table_type = ''BASE TABLE''
	and (table_name not like ''t_acc_usage%'' or table_name not like ''t_pv%''
	or table_name not like ''t_svc%'' or table_name not in (''t_session'',''t_session_state'',''t_session_set'',''t_message''))
	and table_name not in (select nm_table_name from t_unique_cons)
	SELECT @SQLStmtError = @@ERROR
	IF @SQLStmtError <> 0
		RETURN 1
	OPEN curUserObjs 
	FETCH curUserObjs INTO @varTblName 
	WHILE @@FETCH_STATUS = 0
	BEGIN 
		set @starttime = getdate()
		SET @SQLStmt = ''UPDATE STATISTICS '' + @varTblName + @NU_varStatPercentChar 
		EXECUTE (@SQLStmt) 
		Insert into t_updatestatsinfo values (@varTblName, @NU_varStatPercentChar, datediff(ss,@starttime,getdate()))
		FETCH curUserObjs INTO @varTblName 
	END 
	CLOSE curUserObjs 
	DEALLOCATE curUserObjs 
	insert into t_updatestats_partition(partname,partition_status,last_stats_time,Non_Usage_Sampling_Ratio)
	values ( @dbname,''O'',@getdate,@NU_varStatPercent)
	PRINT ''Statistics have been updated for all Non-Partitioned Non-Usage tables'' 
	
	if (select b_partitioning_enabled from t_usage_server) = ''N''
	begin
		--Usage tables in NetMeter Database
		DECLARE curUserObjs CURSOR FOR 
		select table_name from information_schema.tables
		where table_type = ''BASE TABLE''
		and (table_name like ''t_acc_usage%'' or table_name like ''t_pv%''
		or table_name like ''t_svc%'' or table_name in (''t_session'',''t_session_state'',''t_session_set'',''t_message''))
		and table_name in (select nm_table_name from t_unique_cons)
		SELECT @SQLStmtError = @@ERROR
		IF @SQLStmtError <> 0
			RETURN 1
		OPEN curUserObjs 
		FETCH curUserObjs INTO @varTblName 
		WHILE @@FETCH_STATUS = 0
		BEGIN 
			set @starttime = getdate()
			SET @SQLStmt = ''UPDATE STATISTICS '' + @varTblName + @U_varStatPercentChar 
			EXECUTE (@SQLStmt) 
			Insert into t_updatestatsinfo values (@varTblName, @U_varStatPercentChar, datediff(ss,@starttime,getdate()))
			FETCH curUserObjs INTO @varTblName 
		END 
		CLOSE curUserObjs 
		DEALLOCATE curUserObjs 
		update t_updatestats_partition set Usage_Sampling_Ratio = @U_varStatPercent
		where partname = @dbname and partition_status=''O'' and last_stats_time = @getdate
		PRINT ''Statistics have been updated for all Non-Partitioned Usage tables'' 
	end
	else
	begin
		--Loop over all the partitions and update stats with Usage sampling ratio
		declare @partname nvarchar(4000)
		--create table #partition(partname nvarchar(4000))
		DECLARE part CURSOR FOR select distinct partition_name from t_partition --where dbname not in (select name from t_archive_partition)
		open part
		fetch part into @partname
		WHILE @@FETCH_STATUS = 0
		BEGIN
		--Check for open Intervals
			select @intervalstart = id_interval_start, @intervalend= id_interval_end from t_partition 
			where partition_name = @partname
		if exists 
			(
			select 1 from t_usage_interval
			where tx_interval_status <> ''H''
			and id_interval between @intervalstart and @intervalend
			and not exists (select 1 from t_archive_partition where partition_name=@partname
			and status = ''A'' and tt_end = @maxdate)			
			union all
			select 1 from t_partition where partition_name = @partname and b_default = ''Y''
			union all
			select 1 from t_partition where id_partition not in
			(select id_partition from t_partition_interval_map)
			and partition_name = @partname)
			begin
				select @sqlstmt = ''DECLARE curUserObjs CURSOR FOR 
				SELECT table_name FROM '' + @partname + ''.information_schema.tables 
				WHERE table_type = ''''BASE TABLE''''
				ORDER BY table_name''
				exec (@sqlstmt) 
				SELECT @SQLStmtError = @@ERROR
				IF @SQLStmtError <> 0
					RETURN 1
				OPEN curUserObjs 
				FETCH curUserObjs INTO @varTblName 
				WHILE @@FETCH_STATUS = 0
				   BEGIN 
					   SET @starttime = getdate()
					   SET @SQLStmt = ''UPDATE STATISTICS '' + @partname + ''..'' + @varTblName + @U_varStatPercentChar 
					   EXECUTE (@SQLStmt)
			   		   Insert into t_updatestatsinfo values (@varTblName, @U_varStatPercentChar, datediff(ss,@starttime,getdate()))
				   FETCH curUserObjs INTO @varTblName 
				   END 
				CLOSE curUserObjs 
				DEALLOCATE curUserObjs 
				insert into t_updatestats_partition(partname,partition_status,last_stats_time,Usage_Sampling_Ratio)
				values ( @partname,''O'',@getdate,@U_varStatPercent)
				set @rowcount = @@rowcount
				PRINT ''Statistics have been updated for all tables of Open Interval Partitions.'' 
			end
			if (@rowcount = 0)
			begin
			--Check for Archived Intervals
				if exists 
					(select 1 from t_partition part
					inner join t_archive_partition archive
					on part.partition_name = archive.partition_name
					where part.partition_name = @partname
					and status =''A''
					and tt_end = @maxdate
					and not exists
						(select 1 from t_updatestats_partition back1
						where part.partition_name = back1.partname
						and
						back1.last_stats_time is not null and partition_status = ''A'')
					)
					begin
						select @sqlstmt = ''DECLARE curUserObjs CURSOR FOR 
						SELECT table_name FROM '' + @partname + ''.information_schema.tables 
						WHERE table_type = ''''BASE TABLE''''
						ORDER BY table_name''
						exec (@sqlstmt) 
						SELECT @SQLStmtError = @@ERROR
						IF @SQLStmtError <> 0
							RETURN 1
						OPEN curUserObjs 
						FETCH curUserObjs INTO @varTblName 
						WHILE @@FETCH_STATUS = 0
						   BEGIN 
						      set @starttime = getdate()
						      SET @SQLStmt = ''UPDATE STATISTICS '' + @partname + ''..'' + @varTblName + @H_varStatPercentChar 
						      EXECUTE (@SQLStmt)
		         	   		      Insert into t_updatestatsinfo values (@varTblName, @H_varStatPercentChar, datediff(ss,@starttime,getdate()))
						   FETCH curUserObjs INTO @varTblName 
						   END 
						CLOSE curUserObjs 
						DEALLOCATE curUserObjs 
						insert into t_updatestats_partition(partname,partition_status,last_stats_time,H_Sampling_Ratio)
						values ( @partname,''A'',@getdate,@H_varStatPercent)
						set @rowcount = @@rowcount
						PRINT ''Statistics have been updated for all tables of Archived Interval Partitions'' 
					end
			end
			if (@rowcount = 0)
			begin
			--Check for Hard-Closed Intervals
			if exists 
				(select 1 from t_partition part
				where partition_name = @partname
				and id_partition in
				(select id_partition from t_partition_interval_map)
				and @partname not in (select partition_name from t_partition where b_default = ''Y'')
				and not exists
					(
					select 1 from t_usage_interval usage
					where tx_interval_status <> ''H''
					and id_interval between @intervalstart and @intervalend
					)
				and not exists
					(
					select 1 from t_updatestats_partition back1
					where part.partition_name = back1.partname
					and
					((back1.last_stats_time is not null and partition_status = ''H'') 
					or (back1.last_stats_time is not null and partition_status = ''A'')))
					)
				begin
					select @sqlstmt = ''DECLARE curUserObjs CURSOR FOR 
					SELECT table_name FROM '' + @partname + ''.information_schema.tables 
					WHERE table_type = ''''BASE TABLE''''
					ORDER BY table_name''
					exec (@sqlstmt) 
					SELECT @SQLStmtError = @@ERROR
					IF @SQLStmtError <> 0
						RETURN 1
					OPEN curUserObjs 
					FETCH curUserObjs INTO @varTblName 
					WHILE @@FETCH_STATUS = 0
					   BEGIN 
					      set @starttime = getdate()
					      SET @SQLStmt = ''UPDATE STATISTICS '' + @partname + ''..'' + @varTblName + @H_varStatPercentChar 
					      EXECUTE (@SQLStmt)
	         	   		      Insert into t_updatestatsinfo values (@varTblName, @H_varStatPercentChar, datediff(ss,@starttime,getdate()))
					   FETCH curUserObjs INTO @varTblName 
					   END 
					CLOSE curUserObjs 
					DEALLOCATE curUserObjs 
					insert into t_updatestats_partition(partname,partition_status,last_stats_time,H_Sampling_Ratio)
					values ( @partname,''H'',@getdate,@H_varStatPercent)
					PRINT ''Statistics have been updated for all tables of Hard closed Interval Partitions'' 
				end
			end
		set @rowcount=0
		fetch next from part into @partname
		end
		close part
		deallocate part
	end
end
else
begin
	if not exists (select 1 from t_partition where partition_name = @database_name)
	begin
	--Indexed Views
		DECLARE curUserObjs CURSOR FOR 
		select distinct obj.name from sysindexkeys keys inner join sysobjects obj 
		on keys.id=obj.id 
		where XTYPE=''v''
		SELECT @SQLStmtError = @@ERROR
		IF @SQLStmtError <> 0
			RETURN 1
		OPEN curUserObjs 
		FETCH curUserObjs INTO @varTblName 
		WHILE @@FETCH_STATUS = 0
		BEGIN 
		      set @starttime = getdate()
		      SET @SQLStmt = ''UPDATE STATISTICS '' + @varTblName + @NU_varStatPercentChar 
		      EXECUTE (@SQLStmt)
   		      Insert into t_updatestatsinfo values (@varTblName, @NU_varStatPercentChar, datediff(ss,@starttime,getdate()))
		   FETCH curUserObjs INTO @varTblName 
		END 
		CLOSE curUserObjs 
		DEALLOCATE curUserObjs 
		PRINT ''Statistics have been updated for all Indexed Views.'' 
	
		--Non-Usage tables in NetMeter Database
		DECLARE curUserObjs CURSOR FOR 
		select table_name from information_schema.tables
		where table_type = ''BASE TABLE''
		and (table_name not like ''t_acc_usage%'' or table_name not like ''t_pv%''
		or table_name not like ''t_svc%'' or table_name not in (''t_session'',''t_session_state'',''t_session_set'',''t_message''))
		and table_name not in (select nm_table_name from t_unique_cons)
		SELECT @SQLStmtError = @@ERROR
		IF @SQLStmtError <> 0
			RETURN 1
		OPEN curUserObjs 
		FETCH curUserObjs INTO @varTblName 
		WHILE @@FETCH_STATUS = 0
		BEGIN 
		      set @starttime = getdate()
		      SET @SQLStmt = ''UPDATE STATISTICS '' + @varTblName + @NU_varStatPercentChar 
		      EXECUTE (@SQLStmt)
   		      Insert into t_updatestatsinfo values (@varTblName, @NU_varStatPercentChar, datediff(ss,@starttime,getdate()))
		   FETCH curUserObjs INTO @varTblName 
		END 
		CLOSE curUserObjs 
		DEALLOCATE curUserObjs 
		insert into t_updatestats_partition(partname,partition_status,last_stats_time,Non_Usage_Sampling_Ratio)
		values ( @database_name,''O'',@getdate,@NU_varStatPercent)
		PRINT ''Statistics have been updated for all Non-Partitioned Non-Usage tables'' 
	
		--Usage tables in NetMeter Database
		DECLARE curUserObjs CURSOR FOR 
		select table_name from information_schema.tables
		where table_type = ''BASE TABLE''
		and (table_name like ''t_acc_usage%'' or table_name like ''t_pv%''
		or table_name like ''t_svc%'' or table_name in (''t_session'',''t_session_state'',''t_session_set'',''t_message''))
		and table_name in (select nm_table_name from t_unique_cons)
		SELECT @SQLStmtError = @@ERROR
		IF @SQLStmtError <> 0
			RETURN 1
		OPEN curUserObjs 
		FETCH curUserObjs INTO @varTblName 
		WHILE @@FETCH_STATUS = 0
		BEGIN 
		      set @starttime = getdate()
		      SET @SQLStmt = ''UPDATE STATISTICS '' + @varTblName + @U_varStatPercentChar 
		      EXECUTE (@SQLStmt)
   		      Insert into t_updatestatsinfo values (@varTblName, @U_varStatPercentChar, datediff(ss,@starttime,getdate()))
		   FETCH curUserObjs INTO @varTblName 
		END 
		CLOSE curUserObjs 
		DEALLOCATE curUserObjs 
		insert into t_updatestats_partition(partname,partition_status,last_stats_time,Usage_Sampling_Ratio)
		values ( @database_name,''O'',@getdate,@U_varStatPercent)
		PRINT ''Statistics have been updated for all Non-Partitioned Usage tables'' 
	end
	else
	begin
		--Check for open Intervals
		select @intervalstart = id_interval_start, @intervalend= id_interval_end from t_partition 
		where partition_name = @database_name
		if exists (select 1 from t_usage_interval
			where tx_interval_status <> ''H''
			and id_interval between @intervalstart and @intervalend
			and not exists (select 1 from t_archive_partition where partition_name=@database_name
			and status = ''A'' and tt_end = @maxdate)
			union all
			select 1 from t_partition where partition_name = @database_name and b_default = ''Y''
			union all
			select 1 from t_partition where id_partition not in
			(select id_partition from t_partition_interval_map)
			and partition_name = @database_name)
			begin
				select @sqlstmt = ''DECLARE curUserObjs CURSOR FOR 
				SELECT table_name FROM '' + @database_name + ''.information_schema.tables 
				WHERE table_type = ''''BASE TABLE''''
				ORDER BY table_name''
				exec (@sqlstmt) 
				SELECT @SQLStmtError = @@ERROR
				IF @SQLStmtError <> 0
					RETURN 1
				OPEN curUserObjs 
				FETCH curUserObjs INTO @varTblName 
				WHILE @@FETCH_STATUS = 0
				   BEGIN 
				      set @starttime = getdate()
				      SET @SQLStmt = ''UPDATE STATISTICS '' + @database_name + ''..'' + @varTblName + @U_varStatPercentChar 
				      EXECUTE (@SQLStmt)
		   		      Insert into t_updatestatsinfo values (@varTblName, @U_varStatPercentChar, datediff(ss,@starttime,getdate()))
				   FETCH curUserObjs INTO @varTblName 
				   END 
				CLOSE curUserObjs 
				DEALLOCATE curUserObjs 
				insert into t_updatestats_partition(partname,partition_status,last_stats_time,Usage_Sampling_Ratio)
				values ( @database_name,''O'',@getdate,@U_varStatPercent)
				set @rowcount = @@rowcount
				PRINT ''Statistics have been updated for all tables of Open Interval Partitions.'' 
			end
			if (@rowcount = 0)
			begin
			--Check for Archived Intervals
				if exists 
					(select 1 from t_partition part
					inner join t_archive_partition archive
					on part.partition_name = archive.partition_name
					where part.partition_name = @database_name
						and status = ''A'' and tt_end=@maxdate
					)
				begin
					select @sqlstmt = ''DECLARE curUserObjs CURSOR FOR 
					SELECT table_name FROM '' + @database_name + ''.information_schema.tables 
					WHERE table_type = ''''BASE TABLE''''
					ORDER BY table_name''
					exec (@sqlstmt) 
					SELECT @SQLStmtError = @@ERROR
					IF @SQLStmtError <> 0
						RETURN 1
					OPEN curUserObjs 
					FETCH curUserObjs INTO @varTblName 
					WHILE @@FETCH_STATUS = 0
					   BEGIN 
					      set @starttime = getdate()
					      SET @SQLStmt = ''UPDATE STATISTICS '' + @database_name + ''..'' + @varTblName + @H_varStatPercentChar 
					      EXECUTE (@SQLStmt)
			   		      Insert into t_updatestatsinfo values (@varTblName, @H_varStatPercentChar, datediff(ss,@starttime,getdate()))
					   FETCH curUserObjs INTO @varTblName 
					   END 
					CLOSE curUserObjs 
					DEALLOCATE curUserObjs 
					insert into t_updatestats_partition(partname,partition_status,last_stats_time,H_Sampling_Ratio)
					values ( @database_name,''A'',@getdate,@H_varStatPercent)
					set @rowcount = @@rowcount
					PRINT ''Statistics have been updated for all tables of Archived Interval Partitions''
				end
			end
			if (@rowcount = 0)
			begin
			--Check for Hard-Closed Intervals
				if exists 
					(select 1 from t_partition part
					where partition_name = @database_name
					and id_partition in (select id_partition from t_partition_interval_map)
					and @database_name not in (select partition_name from t_partition where b_default = ''Y'')
					and not exists
						(
						select 1 from t_usage_interval usage
						where tx_interval_status <> ''H''
						and id_interval between @intervalstart and @intervalend
						)
					)
				begin
					select @sqlstmt = ''DECLARE curUserObjs CURSOR FOR 
					SELECT table_name FROM '' + @database_name + ''.information_schema.tables 
					WHERE table_type = ''''BASE TABLE''''
					ORDER BY table_name''
					exec (@sqlstmt) 
					SELECT @SQLStmtError = @@ERROR
					IF @SQLStmtError <> 0
						RETURN 1
					OPEN curUserObjs 
					FETCH curUserObjs INTO @varTblName 
					WHILE @@FETCH_STATUS = 0
					   BEGIN 
					      set @starttime = getdate()
					      SET @SQLStmt = ''UPDATE STATISTICS '' + @database_name + ''..'' + @varTblName + @H_varStatPercentChar 
					      EXECUTE (@SQLStmt)
			   		      Insert into t_updatestatsinfo values (@varTblName, @H_varStatPercentChar, datediff(ss,@starttime,getdate()))
					   FETCH curUserObjs INTO @varTblName 
					   END 
					CLOSE curUserObjs 
					DEALLOCATE curUserObjs 
					insert into t_updatestats_partition(partname,partition_status,last_stats_time,H_Sampling_Ratio)
					values ( @database_name,''H'',@getdate,@H_varStatPercent)
					PRINT ''Statistics have been updated for all tables of Hard closed Interval Partitions'' 
				end
			end
 	end
 end
RETURN 0 
END 
	' 
END
GO
/****** Object:  StoredProcedure [dbo].[sp_InsertAtomicCapType]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_InsertAtomicCapType]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
        
						create procedure [dbo].[sp_InsertAtomicCapType] 
						(@aGuid varbinary(16), @aName NVARCHAR(255), @aDesc NVARCHAR(255), @aProgid NVARCHAR(255), @aEditor NVARCHAR(255),
						@ap_id_prop int OUTPUT)
						as
						
						begin
            	INSERT INTO t_atomic_capability_type(tx_guid,tx_name,tx_desc,tx_progid,tx_editor) VALUES (
            	@aGuid, @aName, @aDesc, @aProgid, @aEditor)
            	  if (@@error <> 0) 
                  begin
                  select @ap_id_prop = -99
                  end
                  else
                  begin
                  select @ap_id_prop = @@identity
                  end
            end
				 
        ' 
END
GO
/****** Object:  StoredProcedure [dbo].[RemoveSubscription]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[RemoveSubscription]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
create procedure [dbo].[RemoveSubscription](
	@p_id_sub int,
	@p_systemdate datetime)
	as
	begin
 	declare @groupID int
	declare @maxdate datetime
  declare @icbID int
	declare @status int
	select @groupID = id_group,@maxdate = dbo.mtmaxdate()
	from t_sub where id_sub = @p_id_sub

  -- Look for an ICB pricelist and delete it if it exists
	select distinct @icbID = id_pricelist from t_pl_map where id_sub=@p_id_sub

  if (@groupID is not NULL)
		begin
		update t_gsubmember_historical set tt_end = @p_systemdate 
		where tt_end = @maxdate AND id_group = @groupID
		delete from t_gsubmember where id_group = @groupID
    delete from t_gsub_recur_map where id_group = @groupID
		-- note that we do not delete from t_group_sub
		end   
	delete from t_pl_map where id_sub = @p_id_sub
	delete from t_sub where id_sub = @p_id_sub
	update t_recur_value set tt_end = @p_systemdate 
	where id_sub = @p_id_sub and tt_end = @maxdate
	update t_sub_history set tt_end = @p_systemdate
	where tt_end = @maxdate AND id_sub = @p_id_sub

	if (@icbID is not NULL)
  begin
    exec sp_DeletePricelist @icbID, @status output
    if @status <> 0 return
  end

	end
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreateSubscriptionRecord]    Script Date: 06/02/2008 11:43:31 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateSubscriptionRecord]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
     
create Procedure [dbo].[CreateSubscriptionRecord] (
@p_id_sub int,
@p_id_sub_ext varbinary(16),
@p_id_acc int,
@p_id_group int,
@p_id_po int,
@p_dt_crt datetime,
@startdate  datetime,
@enddate datetime,
@p_systemdate datetime,
@status int OUTPUT
)
as
declare @realstartdate datetime
declare @realenddate datetime
declare @varMaxDateTime datetime
declare @tempStartDate datetime
declare @tempEndDate datetime
declare @onesecond_systemdate datetime
declare @temp_id_sub int
declare @temp_id_sub_ext varbinary(16)
declare @temp_id_acc int
declare @temp_id_group int
declare @temp_id_po int
declare @temp_dt_crt datetime

begin

-- detect directly adjacent records with a adjacent start and end date.  If the
-- key comparison matches successfully, use the start and/or end date of the original record 
-- instead.

select @realstartdate = @startdate,@realenddate = @enddate,@varMaxDateTime = dbo.mtmaxdate(),
  @onesecond_systemdate = dbo.subtractsecond(@p_systemdate)

 -- Someone changes the start date of an existing record so that it creates gaps in time
 -- Existing Record      |---------------------|
 -- modified record       	|-----------|
 -- modified record      |-----------------|
 -- modified record         |------------------|
	begin
		
		-- find the start and end dates of the original interval
		select 
		@tempstartdate = vt_start,
		@tempenddate = vt_end
    from
    t_sub_history
    where dbo.encloseddaterange(vt_start,vt_end,@realstartdate,@realenddate) = 1 AND
    id_sub = @p_id_sub and tt_end = @varMaxDateTime 

		-- the original date range is no longer true
		update t_sub_history
    set tt_end = @onesecond_systemdate
		where id_sub = @p_id_sub AND vt_start = @tempstartdate AND
		@tempenddate = vt_end AND tt_end = @varMaxDateTime

		-- adjust the two records end dates that are adjacent on the start and
		-- end dates; these records are no longer true
		update t_sub_history 
		set tt_end = @onesecond_systemdate where
		id_sub = @p_id_sub AND tt_end = @varMaxDateTime AND
		(vt_end = dbo.subtractSecond(@tempstartdate) OR vt_start = dbo.addsecond(@tempenddate))
    if (@@error <> 0 )
		begin
    select @status = 0
		end

		insert into t_sub_history 
		(id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,vt_start,vt_end,tt_start,tt_end)
		select 
			id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,vt_start,dbo.subtractsecond(@realstartdate),@p_systemdate,@varMaxDateTime
			from t_sub_history 
			where
			id_sub = @p_id_sub AND vt_end = dbo.subtractSecond(@tempstartdate)
		UNION ALL
		select
			id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,@realenddate,vt_end,@p_systemdate,@varMaxDateTime
			from t_sub_history
			where
			id_sub = @p_id_sub  AND vt_start = dbo.addsecond(@tempenddate)

	end

	-- detect directly adjacent records with a adjacent start and end date.  If the
	-- key comparison matches successfully, use the start and/or end date of the original record 
	-- instead.
	
	select @realstartdate = vt_start
	from 
	t_sub_history  where id_sub = @p_id_sub AND
		@startdate between vt_start AND dbo.addsecond(vt_end) and tt_end = @varMaxDateTime
	if @realstartdate is NULL begin
		select @realstartdate = @startdate
	end
	--CR 10620 fix: Do not add a second to end date
	select @realenddate = vt_end
	from
	t_sub_history  where id_sub = @p_id_sub AND
	@enddate between vt_start AND vt_end and tt_end = @varMaxDateTime
	if @realenddate is NULL begin
		select @realenddate = @enddate
	end

 -- step : delete a range that is entirely in the new date range
 -- existing record:      |----|
 -- new record:      |----------------|
 update  t_sub_history 
 set tt_end = @onesecond_systemdate
 where dbo.EnclosedDateRange(@realstartdate,@realenddate,vt_start,vt_end) =1 AND
 id_sub = @p_id_sub  AND tt_end = @varMaxDateTime 

 -- create two new records that are on around the new interval        
 -- existing record:          |-----------------------------------|
 -- new record                        |-------|
 --
 -- adjusted old records      |-------|       |--------------------|
  begin
    select
		@temp_id_sub = id_sub,
@temp_id_sub_ext = id_sub_ext,
@temp_id_acc = id_acc,
@temp_id_group = id_group,
@temp_id_po = id_po,
@temp_dt_crt = dt_crt

		,@tempstartdate = vt_start,
		@tempenddate = vt_end
    from
    t_sub_history
    where dbo.encloseddaterange(vt_start,vt_end,@realstartdate,@realenddate) = 1 AND
    id_sub = @p_id_sub and tt_end = @varMaxDateTime
    update     t_sub_history 
    set tt_end = @onesecond_systemdate where
    dbo.encloseddaterange(vt_start,vt_end,@realstartdate,@realenddate) = 1 AND
    id_sub = @p_id_sub AND tt_end = @varMaxDateTime
   
-- CR 14491 - Primary keys can not be null
if ((@temp_id_sub is not null))
begin

insert into t_sub_history 
   (id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,vt_start,vt_end,tt_start,tt_end)
   select 
    @temp_id_sub,@temp_id_sub_ext,@temp_id_acc,@temp_id_group,@temp_id_po,@temp_dt_crt,@tempStartDate,dbo.subtractsecond(@realstartdate),
    @p_systemdate,@varMaxDateTime
    where @tempstartdate is not NULL AND @tempStartDate <> @realstartdate
    -- the previous statement may fail
		if @realenddate <> @tempendDate AND @realenddate <> @varMaxDateTime begin
			insert into t_sub_history 
			(id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,vt_start,vt_end,tt_start,tt_end)
	    select
	    @temp_id_sub,@temp_id_sub_ext,@temp_id_acc,@temp_id_group,@temp_id_po,@temp_dt_crt,@realenddate,@tempEndDate,
	    @p_systemdate,@varMaxDateTime
		end
      
end

  -- the previous statement may fail
  end
 -- step 5: update existing payment records that are overlapping on the start
 -- range
 -- Existing Record |--------------|
 -- New Record: |---------|
 insert into t_sub_history
 (id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,vt_start,vt_end,tt_start,tt_end)
 select 
 id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,@realenddate,vt_end,@p_systemdate,@varMaxDateTime
 from 
 t_sub_history  where
 id_sub = @p_id_sub AND 
 vt_start > @realstartdate and vt_start < @realenddate 
 and tt_end = @varMaxDateTime
 
 update t_sub_history
 set tt_end = @onesecond_systemdate
 where
 id_sub = @p_id_sub AND 
 vt_start > @realstartdate and vt_start < @realenddate 
 and tt_end = @varMaxDateTime
 -- step 4: update existing payment records that are overlapping on the end
 -- range
 -- Existing Record |--------------|
 -- New Record:             |-----------|
 insert into t_sub_history
 (id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,vt_start,vt_end,tt_start,tt_end)
 select
 id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,vt_start,dbo.subtractsecond(@realstartdate),@p_systemdate,@varMaxDateTime
 from t_sub_history
 where
 id_sub = @p_id_sub AND 
 vt_end > @realstartdate AND vt_end < @realenddate
 AND tt_end = @varMaxDateTime
 update t_sub_history
 set tt_end = @onesecond_systemdate
 where id_sub = @p_id_sub AND 
  vt_end > @realstartdate AND vt_end < @realenddate
 AND tt_end = @varMaxDateTime
 -- used to be realenddate
 -- step 7: create the new payment redirection record.  If the end date 
 -- is not max date, make sure the enddate is subtracted by one second
 insert into t_sub_history 
 (id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,vt_start,vt_end,tt_start,tt_end)
 select 
 @p_id_sub,@p_id_sub_ext,@p_id_acc,@p_id_group,@p_id_po,@p_dt_crt,@realstartdate,
  case when @realenddate = dbo.mtmaxdate() then @realenddate else 
  @realenddate end,
  @p_systemdate,@varMaxDateTime
  
delete from t_sub where id_sub = @p_id_sub
insert into t_sub (id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,vt_start,vt_end)
select id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,vt_start,vt_end
from t_sub_history  where
id_sub = @p_id_sub and tt_end = @varMaxDateTime
 select @status = 1
 end
			' 
END
GO
/****** Object:  StoredProcedure [dbo].[PIResolutionByID]    Script Date: 06/02/2008 11:44:05 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[PIResolutionByID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
		      create proc [dbo].[PIResolutionByID](
		      @dt_session DATETIME, @id_pi_template INTEGER, @id_acc INTEGER)

		      as
					select 
		      typemap.id_po,
		      typemap.id_pi_instance,
		      sub.id_sub
		      from
		      -- select out the instances from the pl map (either need to follow 
		      -- up with a group by or assume one param table or add a unique entry
		      -- with a null param table/price list; I am assuming the null entry exists)
		      t_pl_map typemap 
		      -- Now that we have the correct list of instances we match them up with the
		      -- accounts on the billing interval being processed.  For each account grab the
		      -- information about the billing interval dates so that we can select the 
		      -- correct intervals to process.
		      -- Go get all subscriptions product offerings containing the proper discount
		      -- instances
		      , t_sub sub 
		      -- Go get the effective date of the subscription to the discount
		      where
		      -- Join criteria for t_sub
		      typemap.id_po = sub.id_po
		      -- join criteria for t_sub to t_effective_date
		      -- Find the subscription which contains the dt_session; there should be
		      -- at most one of these.
		      and (sub.vt_start <= @dt_session)
		      and (sub.vt_end >= @dt_session)
		      -- Select the unique instance record that includes an instance in a template
		      and typemap.id_paramtable is null
		      and typemap.id_pi_template = @id_pi_template
		      and sub.id_acc = @id_acc
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[CanBulkSubscribe]    Script Date: 06/02/2008 11:43:15 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CanBulkSubscribe]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
			create proc [dbo].[CanBulkSubscribe](@id_old_po as int,
										 @id_new_po as int,
										 @subdate as datetime,
										 @status as int output)
			as
			declare @conflictcount as int
			set @conflictcount = 0
			set @status = 0 -- success
			declare @countvar as int
			declare @totalnum as int

			-- step 1: are there any subscriptions that are already subscribed to the new product offering
			set @conflictcount = (select count(t_sub.id_sub) --t_sub.id_acc,t_subnew.id_acc
			from t_sub where t_sub.id_po = @id_new_po AND
			t_sub.vt_start <= @subdate AND t_sub.vt_end >= @subdate
			and t_sub.id_acc in (
				select sub2.id_acc from t_sub sub2 where sub2.id_po = @id_old_po AND
				sub2.vt_start <= @subdate AND sub2.vt_end >= @subdate
				)
			)
			if(@conflictcount > 0) begin
				set @status = 1
				return
			end

			-- step 2: does the destination product offering conflict with  
			select @countvar = count(id_pi_template),@totalnum = (select count(id_pi_template) from t_pl_map where id_po = @id_new_po)
			 from t_pl_map where id_po = @id_new_po AND id_pi_template in 
			(
			select id_pi_template from t_pl_map map where id_pi_template not in 
				-- find all templates from subscribed product offerings
				(select DISTINCT(id_pi_template) from t_pl_map where t_pl_map.id_po in 
					-- match all product offerings
					(select id_po from t_sub where 
					t_sub.vt_start <= @subdate AND t_sub.vt_end >= @subdate 
					-- get all of the accounts where they are currently subscribed to the original
					-- product offering
					AND t_sub.id_acc in (
						select id_acc from t_sub where id_po = @id_old_po AND
						t_sub.vt_start <= @subdate AND t_sub.vt_end >= @subdate
						)
					)
				)
			UNION
				select DISTINCT(id_pi_template) from t_pl_map where id_po = @id_old_po
			)

			if(@countvar <> @totalnum) begin
				set @status = 2
			end
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[sp_InsertRole]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_InsertRole]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
        
					  create procedure [dbo].[sp_InsertRole]
						(@aGuid VARBINARY(16), @aName NVARCHAR(255), @aDesc NVARCHAR(255),
						 @aCSRAssignable VARCHAR, @aSubAssignable VARCHAR, @ap_id_prop int OUTPUT)
						as
						
	          begin
             INSERT INTO t_role (tx_guid, tx_name, tx_desc, csr_assignable, subscriber_assignable) VALUES (@aGuid,
             @aName, @aDesc, @aCSRAssignable, @aSubAssignable)
						 if (@@error <> 0) 
							begin
              select @ap_id_prop = -99
              end
             else
              begin
              select @ap_id_prop = @@identity
              end
            end
				 
        ' 
END
GO
/****** Object:  UserDefinedFunction [dbo].[MTComputeEffectiveBeginDate]    Script Date: 06/02/2008 11:44:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MTComputeEffectiveBeginDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
  
	create function [dbo].[MTComputeEffectiveBeginDate](@type as int, @offset as int, @base as datetime,  
	@sub_begin datetime, @id_usage_cycle int) returns datetime  
	as
	begin  
	if (@type = 1)  
	begin  
	return @base  
	end  
	else if (@type = 2)  
	begin   
	return @sub_begin + @offset  
	end  
	else if (@type = 3)  
	begin  
	declare @next_interval_begin datetime  
	select @next_interval_begin = DATEADD(second, 1, dt_end) from t_pc_interval where @base between dt_start and dt_end and id_cycle = @id_usage_cycle  
	return @next_interval_begin  
	end  
	return null  
	end  
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[RemoveMemberFromRole]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[RemoveMemberFromRole]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
        
						CREATE PROCEDURE [dbo].[RemoveMemberFromRole]
						(
            @aRoleID INT,
            @aAccountID INT,
            @status  INT OUTPUT
						)
						AS
						
						Begin
						declare @accType VARCHAR(3)
						declare @polID INT
						declare @bCSRAssignableFlag VARCHAR(1)
						declare @bSubscriberAssignableFlag VARCHAR(1)
						declare @scratch INT
						select @status = 1
						SELECT @polID = id_policy FROM T_PRINCIPAL_POLICY WHERE id_acc = @aAccountID AND policy_type = ''A''
	          -- make the stored proc idempotent, only remove mapping record if
	          -- it''s there
							BEGIN
	            SELECT @scratch = id_policy FROM T_POLICY_ROLE WHERE id_policy = @polID 
							AND id_role = @aRoleID 
	            if (@scratch is null)
								begin
								  RETURN
								end
							END
						DELETE FROM T_POLICY_ROLE WHERE id_policy = @polID AND id_role = @aRoleID
						END 
         
        ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreateGSubMemberRecord]    Script Date: 06/02/2008 11:43:28 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateGSubMemberRecord]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
     
create Procedure [dbo].[CreateGSubMemberRecord] (
@p_id_group int,
@p_id_acc int,
@startdate  datetime,
@enddate datetime,
@p_systemdate datetime,
@status int OUTPUT
)
as
declare @realstartdate datetime
declare @realenddate datetime
declare @varMaxDateTime datetime
declare @tempStartDate datetime
declare @tempEndDate datetime
declare @onesecond_systemdate datetime
declare @temp_id_group int
declare @temp_id_acc int

begin

-- detect directly adjacent records with a adjacent start and end date.  If the
-- key comparison matches successfully, use the start and/or end date of the original record 
-- instead.

select @realstartdate = @startdate,@realenddate = @enddate,@varMaxDateTime = dbo.mtmaxdate(),
  @onesecond_systemdate = dbo.subtractsecond(@p_systemdate)

 -- Someone changes the start date of an existing record so that it creates gaps in time
 -- Existing Record      |---------------------|
 -- modified record       	|-----------|
 -- modified record      |-----------------|
 -- modified record         |------------------|
	begin
		
		-- find the start and end dates of the original interval
		select 
		@tempstartdate = vt_start,
		@tempenddate = vt_end
    from
    t_gsubmember_historical
    where dbo.encloseddaterange(vt_start,vt_end,@realstartdate,@realenddate) = 1 AND
    id_group = @p_id_group AND id_acc = @p_id_acc and tt_end = @varMaxDateTime 

		-- the original date range is no longer true
		update t_gsubmember_historical
    set tt_end = @onesecond_systemdate
		where id_group = @p_id_group AND id_acc = @p_id_acc AND vt_start = @tempstartdate AND
		@tempenddate = vt_end AND tt_end = @varMaxDateTime

		-- adjust the two records end dates that are adjacent on the start and
		-- end dates; these records are no longer true
		update t_gsubmember_historical 
		set tt_end = @onesecond_systemdate where
		id_group = @p_id_group AND id_acc = @p_id_acc AND tt_end = @varMaxDateTime AND
		(vt_end = dbo.subtractSecond(@tempstartdate) OR vt_start = dbo.addsecond(@tempenddate))
    if (@@error <> 0 )
		begin
    select @status = 0
		end

		insert into t_gsubmember_historical 
		(id_group,id_acc,vt_start,vt_end,tt_start,tt_end)
		select 
			id_group,id_acc,vt_start,dbo.subtractsecond(@realstartdate),@p_systemdate,@varMaxDateTime
			from t_gsubmember_historical 
			where
			id_group = @p_id_group AND id_acc = @p_id_acc AND vt_end = dbo.subtractSecond(@tempstartdate)
		UNION ALL
		select
			id_group,id_acc,@realenddate,vt_end,@p_systemdate,@varMaxDateTime
			from t_gsubmember_historical
			where
			id_group = @p_id_group AND id_acc = @p_id_acc  AND vt_start = dbo.addsecond(@tempenddate)

	end

	-- detect directly adjacent records with a adjacent start and end date.  If the
	-- key comparison matches successfully, use the start and/or end date of the original record 
	-- instead.
	
	select @realstartdate = vt_start
	from 
	t_gsubmember_historical  where id_group = @p_id_group AND id_acc = @p_id_acc AND
		@startdate between vt_start AND dbo.addsecond(vt_end) and tt_end = @varMaxDateTime
	if @realstartdate is NULL begin
		select @realstartdate = @startdate
	end
	--CR 10620 fix: Do not add a second to end date
	select @realenddate = vt_end
	from
	t_gsubmember_historical  where id_group = @p_id_group AND id_acc = @p_id_acc AND
	@enddate between vt_start AND vt_end and tt_end = @varMaxDateTime
	if @realenddate is NULL begin
		select @realenddate = @enddate
	end

 -- step : delete a range that is entirely in the new date range
 -- existing record:      |----|
 -- new record:      |----------------|
 update  t_gsubmember_historical 
 set tt_end = @onesecond_systemdate
 where dbo.EnclosedDateRange(@realstartdate,@realenddate,vt_start,vt_end) =1 AND
 id_group = @p_id_group AND id_acc = @p_id_acc  AND tt_end = @varMaxDateTime 

 -- create two new records that are on around the new interval        
 -- existing record:          |-----------------------------------|
 -- new record                        |-------|
 --
 -- adjusted old records      |-------|       |--------------------|
  begin
    select
		@temp_id_group = id_group,
@temp_id_acc = id_acc

		,@tempstartdate = vt_start,
		@tempenddate = vt_end
    from
    t_gsubmember_historical
    where dbo.encloseddaterange(vt_start,vt_end,@realstartdate,@realenddate) = 1 AND
    id_group = @p_id_group AND id_acc = @p_id_acc and tt_end = @varMaxDateTime
    update     t_gsubmember_historical 
    set tt_end = @onesecond_systemdate where
    dbo.encloseddaterange(vt_start,vt_end,@realstartdate,@realenddate) = 1 AND
    id_group = @p_id_group AND id_acc = @p_id_acc AND tt_end = @varMaxDateTime
   
-- CR 14491 - Primary keys can not be null
if ((@temp_id_group is not null) AND (@temp_id_acc is not null))
begin

insert into t_gsubmember_historical 
   (id_group,id_acc,vt_start,vt_end,tt_start,tt_end)
   select 
    @temp_id_group,@temp_id_acc,@tempStartDate,dbo.subtractsecond(@realstartdate),
    @p_systemdate,@varMaxDateTime
    where @tempstartdate is not NULL AND @tempStartDate <> @realstartdate
    -- the previous statement may fail
		if @realenddate <> @tempendDate AND @realenddate <> @varMaxDateTime begin
			insert into t_gsubmember_historical 
			(id_group,id_acc,vt_start,vt_end,tt_start,tt_end)
	    select
	    @temp_id_group,@temp_id_acc,@realenddate,@tempEndDate,
	    @p_systemdate,@varMaxDateTime
		end
      
end

  -- the previous statement may fail
  end
 -- step 5: update existing payment records that are overlapping on the start
 -- range
 -- Existing Record |--------------|
 -- New Record: |---------|
 insert into t_gsubmember_historical
 (id_group,id_acc,vt_start,vt_end,tt_start,tt_end)
 select 
 id_group,id_acc,@realenddate,vt_end,@p_systemdate,@varMaxDateTime
 from 
 t_gsubmember_historical  where
 id_group = @p_id_group AND id_acc = @p_id_acc AND 
 vt_start > @realstartdate and vt_start < @realenddate 
 and tt_end = @varMaxDateTime
 
 update t_gsubmember_historical
 set tt_end = @onesecond_systemdate
 where
 id_group = @p_id_group AND id_acc = @p_id_acc AND 
 vt_start > @realstartdate and vt_start < @realenddate 
 and tt_end = @varMaxDateTime
 -- step 4: update existing payment records that are overlapping on the end
 -- range
 -- Existing Record |--------------|
 -- New Record:             |-----------|
 insert into t_gsubmember_historical
 (id_group,id_acc,vt_start,vt_end,tt_start,tt_end)
 select
 id_group,id_acc,vt_start,dbo.subtractsecond(@realstartdate),@p_systemdate,@varMaxDateTime
 from t_gsubmember_historical
 where
 id_group = @p_id_group AND id_acc = @p_id_acc AND 
 vt_end > @realstartdate AND vt_end < @realenddate
 AND tt_end = @varMaxDateTime
 update t_gsubmember_historical
 set tt_end = @onesecond_systemdate
 where id_group = @p_id_group AND id_acc = @p_id_acc AND 
  vt_end > @realstartdate AND vt_end < @realenddate
 AND tt_end = @varMaxDateTime
 -- used to be realenddate
 -- step 7: create the new payment redirection record.  If the end date 
 -- is not max date, make sure the enddate is subtracted by one second
 insert into t_gsubmember_historical 
 (id_group,id_acc,vt_start,vt_end,tt_start,tt_end)
 select 
 @p_id_group,@p_id_acc,@realstartdate,
  case when @realenddate = dbo.mtmaxdate() then @realenddate else 
  @realenddate end,
  @p_systemdate,@varMaxDateTime
  
delete from t_gsubmember where id_group = @p_id_group AND id_acc = @p_id_acc
insert into t_gsubmember (id_group,id_acc,vt_start,vt_end)
select id_group,id_acc,vt_start,vt_end
from t_gsubmember_historical  where
id_group = @p_id_group AND id_acc = @p_id_acc and tt_end = @varMaxDateTime
 select @status = 1
 end
			' 
END
GO
/****** Object:  StoredProcedure [dbo].[GetLocalizedSiteInfo]    Script Date: 06/02/2008 11:43:44 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetLocalizedSiteInfo]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
          CREATE PROC [dbo].[GetLocalizedSiteInfo] @nm_space nvarchar(40), 
            @tx_lang_code varchar(10), @id_site int OUTPUT
          as
          if not exists (select * from t_localized_site where 
            nm_space = @nm_space and tx_lang_code = @tx_lang_code) 
          begin 
            insert into t_localized_site (nm_space, tx_lang_code) 
              values (@nm_space, @tx_lang_code)
            if ((@@error != 0) OR (@@rowcount != 1)) 
            begin
              select @id_site = -99
            end 
            else 
            begin 
              select @id_site = @@identity 
            end 
          end 
          else 
          begin 
            select @id_site = id_site from t_localized_site 
              where nm_space = @nm_space and tx_lang_code = @tx_lang_code 
          end
			 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[sp_InsertCapabilityInstance]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_InsertCapabilityInstance]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
        
					  CREATE procedure [dbo].[sp_InsertCapabilityInstance]
						(@aGuid VARCHAR(16), @aParentInstance int, @aPolicy int, @aCapType int,
						@ap_id_prop int OUTPUT)
						as
						
						begin
            	INSERT INTO t_capability_instance (tx_guid, id_parent_cap_instance, id_policy, id_cap_type) 
            	VALUES (cast (@aGuid as varbinary(16)), @aParentInstance, @aPolicy, @aCapType)
              if (@@error <> 0) 
                begin
                select @ap_id_prop = -99
                end
              else
                begin
                select @ap_id_prop = @@identity
                end
           	end
					 
        ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CheckAccountCreationBusinessRules]    Script Date: 06/02/2008 11:43:17 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckAccountCreationBusinessRules]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				CREATE PROCEDURE [dbo].[CheckAccountCreationBusinessRules](
				  @p_nm_space nvarchar(40),
				  @p_acc_type varchar(40),
				  @p_id_ancestor int,
					@status int OUTPUT)
				AS
				BEGIN
				  -- 1. check account and its ancestor business rules. 
					-- Only an account of type systemaccount can exist in
					-- these namespaces
					DECLARE @tx_typ_space AS varchar(40)
					SELECT 
				  	@tx_typ_space = tx_typ_space 
					FROM
				  	t_namespace 
					WHERE
				  	nm_space = @p_nm_space		
	
					IF (@tx_typ_space in (''system_user'', 
					                      ''system_auth'', 
					                      ''system_mcm'', 
					                      ''system_ops'', 
					                      ''system_rate'', 
																''system_csr''))
					BEGIN
						-- An account with this account type and namespace cannot be
						-- created
					  IF (@p_acc_type NOT in (''SYSTEMACCOUNT''))
						BEGIN
							-- MT_ACCOUNT_TYPE_AND_NAMESPACE_MISMATCH ((DWORD)0xE2FF0046L)
			  			SELECT @status = -486604732
							RETURN
						END
					END	

					-- If an account is not a subscriber or an independent account 
					-- and its namespace is system_mps, that shouldnt be allowed
					-- either
					IF (@tx_typ_space = ''system_mps'')
					BEGIN
					  IF (@p_acc_type IN (''SYSTEMACCOUNT''))
						BEGIN
							-- MT_ACCOUNT_TYPE_AND_NAMESPACE_MISMATCH ((DWORD)0xE2FF0046L)
			  			SELECT @status = -486604732
							RETURN
						END
					END
				
					SELECT @status = 1
				END	
			 
			 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[InsertChargeProperty]    Script Date: 06/02/2008 11:43:50 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[InsertChargeProperty]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			create proc [dbo].[InsertChargeProperty]
			@a_id_charge int,
			@a_id_prod_view_prop int,
			@a_id_charge_prop int OUTPUT
			as
			insert into t_charge_prop
      (
			id_charge,
			id_prod_view_prop
      )
      values
      (
			@a_id_charge,
			@a_id_prod_view_prop
      )
			select @a_id_charge_prop =@@identity
	' 
END
GO
/****** Object:  StoredProcedure [dbo].[GetNonBillAccountsWithBalance]    Script Date: 06/02/2008 11:43:45 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetNonBillAccountsWithBalance]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
            
       CREATE PROCEDURE [dbo].[GetNonBillAccountsWithBalance]
						(@BillGroup integer,
						 @strNamespace nvarchar(2000))
		as
		declare @return_code int

        CREATE TABLE #tmp_acc_amounts
          (tmp_seq int IDENTITY,
          namespace nvarchar(40),
          id_interval int,
          id_acc int,
          invoice_currency nvarchar(10),
          payment_ttl_amt numeric(18, 6),
          postbill_adj_ttl_amt numeric(18, 6),
          ar_adj_ttl_amt numeric(18, 6),
          previous_balance numeric(18, 6),
          tax_ttl_amt numeric(18, 6),
          current_charges numeric(18, 6),
          id_payer int,
          id_payer_interval int)
        CREATE TABLE #tmp_prev_balance
        ( id_acc int,
          previous_balance numeric(18, 6))
        CREATE TABLE #tmp_adjustments
        ( id_acc int,
          PrebillAdjAmt numeric(18, 6),
          PrebillTaxAdjAmt numeric(18, 6),
          PostbillAdjAmt numeric(18, 6),
          PostbillTaxAdjAmt numeric(18, 6))
        
        -- Create the driver table with all id_accs
		CREATE TABLE #tmp_all_accounts
		(tmp_seq int IDENTITY,
		 id_acc int NOT NULL,
		 namespace nvarchar(80) NOT NULL)

        EXEC MTSP_INSERTINVOICE_BALANCES @BillGroup, 1, NULL, @return_code OUTPUT
        
        SELECT 

          tacc.id_acc as AccountID,

          am.nm_login as AccountName,

          amar.ExtAccount as ExtAccountID,
          amar.ExtNamespace as ExtAccountNamespace,

          tacc.id_payer as PayerID,
          amp.nm_login as PayerName,

          ampar.ExtAccount as ExtPayerID,
          ampar.ExtNamespace as ExtPayerNamespace,

          tacc.id_payer_interval as PayerInterval,

          ISNULL(tpb.previous_balance, 0.0) 
            + payment_ttl_amt
            + ar_adj_ttl_amt 
            + ISNULL(tadj.PostbillAdjAmt, 0.0) as BalanceForward,

          tacc.current_charges
            + ISNULL(tadj.PrebillAdjAmt,0)
            + tax_ttl_amt as CurrentCharges,

          tacc.invoice_currency as Currency
        
        FROM #tmp_acc_amounts tacc
        LEFT OUTER JOIN #tmp_prev_balance tpb ON tpb.id_acc = tacc.id_acc
        LEFT OUTER JOIN #tmp_adjustments tadj ON tadj.id_acc = tacc.id_acc
        LEFT OUTER JOIN t_account_mapper am ON am.id_acc = tacc.id_acc and am.nm_space = @strNamespace
        LEFT OUTER JOIN VW_AR_ACC_MAPPER amar ON amar.id_acc = tacc.id_acc
        LEFT OUTER JOIN t_account_mapper amp ON amp.id_acc = tacc.id_payer and amp.nm_space = @strNamespace
        LEFT OUTER JOIN VW_AR_ACC_MAPPER ampar ON ampar.id_acc = tacc.id_payer
        WHERE (tacc.id_acc != tacc.id_payer)

        DROP TABLE #tmp_acc_amounts
        DROP TABLE #tmp_prev_balance
        DROP TABLE #tmp_adjustments
        DROP TABLE #tmp_all_accounts
        return 0
        
      ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CompleteReMaterialization]    Script Date: 06/02/2008 11:43:21 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CompleteReMaterialization]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
1) Copy billing group data from temporary tables to system tables.
2) Update t_billgroup_member_history
3) Update the materialization in 
    t_billgroup_materialization to ''Succeeded''
4) Delete data from temporary tables.

Returns the following error codes - for the given materialization:
   -1 : Unknown error occurred
   -2 : Cannot create billing group with zero accounts
   -3 : Something went wrong while executing RefreshBillingGroupConstraints
   -4 : Something went wrong while executing CleanupMaterialization sproc
=========================================================== */
CREATE PROCEDURE [dbo].[CompleteReMaterialization]
(
  @id_materialization INT,
  @dt_end DATETIME,
  @status INT OUTPUT
)
AS

BEGIN
   
   BEGIN TRAN
   -- initialize @status to failure (-1)
   SET @status = -1 

   DECLARE @billGroupMemberMoves TABLE (id_materialization_new INT NOT NULL, 
                                                                      id_materialization_old INT NOT NULL,
                                                                      id_acc INT NOT NULL,
                                                                      id_billgroup_new INT NOT NULL,
                                                                      id_billgroup_old INT NOT NULL,
                                                                      billgroup_name_new NVARCHAR(50) NOT NULL,
                                                                      billgroup_name_old NVARCHAR(50) NOT NULL,
                                                                      newStatus VARCHAR(1),
                                                                      oldStatus VARCHAR(1) NOT NULL)
   DECLARE @id_usage_interval INT
   
   -- Get the id_usage_interval for the given @id_materialization
   SELECT @id_usage_interval = id_usage_interval 
   FROM t_billgroup_materialization 
   WHERE id_materialization = @id_materialization

   -- copy billing groups from t_billgroup_tmp to t_billgroup
   -- only if they don''t exist in t_billgroup for the interval associated with
   -- this @id_materialization
   INSERT INTO t_billgroup (id_billgroup, tx_name, tx_description, id_usage_interval, id_parent_billgroup, tx_type)
   SELECT bgt.id_billgroup, bgt.tx_name, bgt.tx_description,
               bgm.id_usage_interval, bgm.id_parent_billgroup, bgm.tx_type
   FROM t_billgroup_tmp bgt 
   INNER JOIN t_billgroup_materialization bgm 
     ON bgm.id_materialization = bgt.id_materialization   
     WHERE bgt.id_materialization = @id_materialization AND
                 bgt.tx_name NOT IN (SELECT tx_name 
                                                   FROM t_billgroup 
                                                   WHERE id_usage_interval = @id_usage_interval)
    
    /* 
    copy data from t_billgroup_member_tmp (bgmt) to 
    t_billgroup_member(bgm) with the following conditions:
    
    if  (account in bgmt exists in bgm)
    {
       if (billing group for account in bgmt and billing group for account in bgm are not the same)
       {
          if (both billing groups are ''Open'')
          {
             (1) 
             Move account to new billing group
             Record ''succeeded''
             (1a) 
             If the old billing group becomes empty (ie. loses all accounts)
             then delete the old billing group and update history associated with it.
          }
          else 
          {
             (2)
             Record ''failed''
          }
       }
    }
    else
    {
       if (account lands in a billing group that''s ''Open'''')
       {
          (3)
          Move account to bgm
          Record ''succeeded''
       }
       else 
       {
          (4)
          Record ''failed''
       }
    }
   */
       
   
   
   /* Doing (1) from the above algorithm
        In t_billgroup_member, the id_acc will be unique amongst the billgroups for
        a given interval
   */
   INSERT @billGroupMemberMoves
   SELECT bgmt.id_materialization id_materialization_new, 
               bgmem.id_materialization id_materialization_old,
               bgmt.id_acc, 
               bg1.id_billgroup id_billgroup_new, 
               bg.id_billgroup id_billgroup_old, 
               bg1.tx_name billgroup_name_new,
               bg.tx_name billgroup_name_old,
               bgsNew.status newStatus, 
               bgsOld.status oldStatus
   FROM t_billgroup_member_tmp bgmt
   INNER JOIN t_billgroup_member bgmem
      ON bgmem.id_acc = bgmt.id_acc 
   INNER JOIN t_billgroup bg
      ON bg.id_billgroup = bgmem.id_billgroup AND
            bg.tx_name != bgmt.tx_name
   INNER JOIN t_billgroup_tmp bgt 
      ON bgt.tx_name = bgmt.tx_name AND
            bgt.id_materialization = bgmt.id_materialization
   INNER JOIN t_billgroup bg1
      ON bg1.tx_name = bgmt.tx_name
   LEFT OUTER JOIN vw_all_billing_groups_status bgsNew 
      ON bgsNew.id_billgroup = bg1.id_billgroup
   LEFT OUTER JOIN vw_all_billing_groups_status bgsOld
      ON bgsOld.id_billgroup = bg.id_billgroup
   WHERE 
       bgmt.id_materialization =  @id_materialization AND
       bg.id_billgroup IN (SELECT id_billgroup 
                                     FROM t_billgroup 
                                     WHERE id_usage_interval = @id_usage_interval) AND
       bg1.id_billgroup IN (SELECT id_billgroup 
                                       FROM t_billgroup 
                                       WHERE id_usage_interval = @id_usage_interval)
 
   /* Update history for account */
   UPDATE bgmh
   SET tt_end = @dt_end
   FROM t_billgroup_member_history bgmh 
   INNER JOIN @billGroupMemberMoves bgmt
      ON bgmt.id_acc = bgmh.id_acc AND
            bgmt.id_billgroup_old = bgmh.id_billgroup AND
            bgmt.id_materialization_old = bgmh.id_materialization
   WHERE bgmt.oldStatus = ''O'' AND
               (bgmt.newStatus = ''O'' OR bgmt.newStatus IS NULL)

   /* Delete account(s) from t_billgroup_member */
   DELETE t_billgroup_member 
   FROM t_billgroup_member bgm
   INNER JOIN @billGroupMemberMoves bgmt
      ON bgmt.id_billgroup_old = bgm.id_billgroup AND
            bgmt.id_acc = bgm.id_acc
   WHERE bgmt.oldStatus = ''O'' AND
               (bgmt.newStatus = ''O'' OR bgmt.newStatus IS NULL)

    /* Insert updated account(s) into t_billgroup_member */
    INSERT INTO t_billgroup_member (id_billgroup, id_acc, id_materialization, id_root_billgroup)
    SELECT bgmt.id_billgroup_new, bgmt.id_acc, bgmt.id_materialization_new, 
                dbo.GetBillingGroupAncestor(bgmt.id_billgroup_new)
    FROM @billGroupMemberMoves bgmt
    WHERE bgmt.oldStatus = ''O'' AND
                (bgmt.newStatus = ''O'' OR bgmt.newStatus IS NULL)

   /* Insert new history for account */
   INSERT INTO t_billgroup_member_history (id_billgroup, 
                                                                      id_acc, 
                                                                      id_materialization,
                                                                      tx_status,
                                                                      tt_start,
                                                                      tt_end)
   SELECT bgmt.id_billgroup_new, 
               bgmt.id_acc, 
               bgmt.id_materialization_new,
               ''Succeeded'',
               @dt_end,
               dbo.MTMaxDate()
   FROM @billGroupMemberMoves bgmt
   WHERE bgmt.oldStatus = ''O'' AND
               (bgmt.newStatus = ''O'' OR bgmt.newStatus IS NULL)

  /*
     Doing (1a) from the above algorithm
  */
   -- Delete old billgroup if it doesn''t have any accounts
   IF EXISTS (SELECT 1 
                FROM dbo.sysobjects
                WHERE id = OBJECT_ID(N''t_deleted_billgroups'') AND
                                   OBJECTPROPERTY(id, N''IsUserTable'') = 1) 
   BEGIN
      DROP TABLE t_deleted_billgroups
   END
   CREATE TABLE t_deleted_billgroups (id_billgroup INT NOT NULL)
 
   INSERT INTO t_deleted_billgroups
   SELECT id_billgroup
   FROM t_billgroup bg
   INNER JOIN @billGroupMemberMoves bgmoves
      ON bgmoves.id_billgroup_old = bg.id_billgroup AND
            bgmoves.id_billgroup_old NOT IN (SELECT id_billgroup
                                                                    FROM t_billgroup_member) 
   WHERE bgmoves.oldStatus = ''O'' AND
                (bgmoves.newStatus = ''O'' OR bgmoves.newStatus IS NULL)

   EXEC DeleteBillGroupData ''t_deleted_billgroups'' 
   DROP TABLE t_deleted_billgroups
 
  /* Doing (2) from the above algorithm. 
       Insert rows into t_billgroup_member_history for account moves into and out of ''Soft Closed'' or
       ''Hard Closed'' billing groups. These are not ''history'' rows because
       no change is happening to the account. The tt_start and tt_end times on these rows
       don''t matter. They are filtered based on tx_status = ''Failed''
   */
    INSERT INTO t_billgroup_member_history (id_billgroup, 
                                                                        id_acc, 
                                                                        id_materialization,
                                                                        tx_status,
                                                                        tt_start,
                                                                        tt_end,
                                                                        tx_failure_reason)
   SELECT NULL, 
               bgmt.id_acc, 
               bgmt.id_materialization_new,
               ''Failed'',
               @dt_end,
               @dt_end,
               ''Attempting to move this account from billing group ['' + 
               bgmt.billgroup_name_old +
                '']  to billing group ['' +
               bgmt.billgroup_name_new  + 
               ''] when one (or both) billing group is not in an Open state.''
   FROM @billGroupMemberMoves bgmt
   WHERE bgmt.oldStatus != ''O'' OR
               (bgmt.newStatus != ''O'' AND bgmt.newStatus IS NOT NULL)

    /* Clear billGroupMemberMoves */
   DELETE  @billGroupMemberMoves

   DECLARE @billUnassignedAccountMoves TABLE (id_materialization INT NOT NULL, 
                                                                                id_acc INT NOT NULL,
                                                                                id_billgroup INT NOT NULL,
                                                                                billgroup_name NVARCHAR(50) NOT NULL,
                                                                                status VARCHAR(1))

   /* Doing (3) from the above algorithm */
   INSERT @billUnassignedAccountMoves
   SELECT bgmt.id_materialization, 
               bgmt.id_acc, 
               bg.id_billgroup, 
               bg.tx_name,
               bgs.status
   FROM t_billgroup_member_tmp bgmt
   INNER JOIN t_billgroup_tmp bgt 
      ON bgt.tx_name = bgmt.tx_name AND
            bgt.id_materialization = bgmt.id_materialization
   INNER JOIN t_billgroup bg 
      ON bg.tx_name = bgt.tx_name
   LEFT OUTER JOIN vw_all_billing_groups_status bgs 
      ON bgs.id_billgroup = bg.id_billgroup 
   WHERE 
       bgmt.id_acc NOT IN (SELECT id_acc 
                                         FROM t_billgroup_member 
                                         WHERE id_billgroup IN (SELECT id_billgroup 
                                                                              FROM t_billgroup 
                                                                              WHERE id_usage_interval = @id_usage_interval)) AND
       bgmt.id_materialization = @id_materialization AND  
       bg.id_billgroup IN (SELECT id_billgroup 
                                     FROM t_billgroup 
                                     WHERE id_usage_interval = @id_usage_interval) 
 
    /* Insert updated account(s) into t_billgroup_member */
    INSERT INTO t_billgroup_member (id_billgroup, id_acc, id_materialization, id_root_billgroup)
    SELECT buam.id_billgroup, buam.id_acc, buam.id_materialization,
                dbo.GetBillingGroupAncestor(buam.id_billgroup)
    FROM @billUnassignedAccountMoves buam
    WHERE buam.status = ''O'' OR buam.status IS NULL
    
   /* Insert new history for account */
   INSERT INTO t_billgroup_member_history (id_billgroup, 
                                                                      id_acc, 
                                                                      id_materialization,
                                                                      tx_status,
                                                                      tt_start,
                                                                      tt_end)
   SELECT buam.id_billgroup, 
               buam.id_acc, 
               buam.id_materialization,
               ''Succeeded'',
               @dt_end,
               dbo.MTMaxDate()
   FROM @billUnassignedAccountMoves buam
   WHERE buam.status = ''O'' OR buam.status IS NULL
 
    /* Doing (4) from the above algorithm.
        Insert rows into t_billgroup_member_history. These are not ''history'' rows because
        no change is happening to the account. The tt_start and tt_end times on these rows
        don''t matter. They are filtered based on tx_status = ''Failed''
   */
    INSERT INTO t_billgroup_member_history (id_billgroup, 
                                                                        id_acc, 
                                                                        id_materialization,
                                                                        tx_status,
                                                                        tt_start,
                                                                        tt_end,
                                                                        tx_failure_reason)
   SELECT NULL, 
               buam.id_acc, 
               buam.id_materialization,
               ''Failed'',
               @dt_end,
               @dt_end,
                ''Attempting to assign this account to the billing group ['' + 
               buam.billgroup_name +
                '']  when the  billing group is not in an Open state.''
   FROM @billUnassignedAccountMoves buam
   WHERE status != ''O'' AND status IS NOT NULL
 
   /* Check that each billing group in t_billgroup has atleast one account  */
   IF EXISTS (SELECT bg.id_billgroup
                   FROM t_billgroup bg
                   WHERE bg.id_billgroup NOT IN (SELECT id_billgroup 
                                                                     FROM t_billgroup_member bgm))
   BEGIN
      SET @status = -2
      ROLLBACK
      RETURN 
   END

   /* Clear @billUnassignedAccountMoves */
   DELETE  @billUnassignedAccountMoves

   /* Copy over billing group constraints */
  EXEC ResetBillingGroupConstraints @id_usage_interval, @status OUTPUT
  IF (@status != 0) 
       BEGIN
          SET @status = -3
          ROLLBACK
          RETURN 
       END
   /* Reset status */
   SET @status = -1

   /* Delete temporary data and update t_billgroup_materialization */
   EXEC CleanupMaterialization @id_materialization, 
                                                 @dt_end, 
                                                 ''Succeeded'', 
                                                 NULL, 
                                                 @status OUTPUT

    IF (@status != 0) 
       BEGIN
          SET @status = -4
          ROLLBACK
          RETURN 
       END

   -- set @status to success
   SET @status = 0 

   COMMIT TRAN

END
' 
END
GO
/****** Object:  StoredProcedure [dbo].[OpenBillingGroup]    Script Date: 06/02/2008 11:44:04 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[OpenBillingGroup]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
Attempts to ''Open'' the given billing group.

Returns the following error codes:
   -1 : Unknown error occurred
   -2 : @id_billgroup does not exist
   -3 : The billgroup is not soft closed
   -4 : Unable to find _StartRoot instance for @id_billgroup
   -5 : Not all instances, which depend on the billing group, have been reversed successfully
   -6 : Could not update billing group status to ''C''
=========================================================== */
CREATE PROCEDURE [dbo].[OpenBillingGroup]
(
  @dt_now DATETIME,     -- MetraTech system date
  @id_billgroup INT,        -- specific billing group to reopen, the billing group must be soft-closed
  @ignoreDeps INT,         -- whether to ignore the reverse dependencies for re-opening the billing group
  @pretend INT,                -- if pretend is true, the billing group is not actually reopened
  @status INT OUTPUT     -- return code: 0 is successful
)
AS

BEGIN
  BEGIN TRAN

  SELECT @status = -1

  -- checks that the billing group exists
  IF NOT EXISTS (SELECT id_billgroup 
                          FROM t_billgroup
                          WHERE id_billgroup = @id_billgroup)
    BEGIN
       SET @status = -2
       ROLLBACK
       RETURN 
     END

  -- checks that the billing group is soft closed
  DECLARE @billingGroupStatus VARCHAR(1)
 
  SELECT @billingGroupStatus = status
  FROM vw_all_billing_groups_status
  WHERE id_billgroup = @id_billgroup

  IF (@billingGroupStatus != ''C'')
     BEGIN
       SET @status = -3
       ROLLBACK
       RETURN 
     END
 
  --
  -- retrieves the instance ID of the start root event for the given billing group
  --
  DECLARE @id_instance INT
  SELECT @id_instance = inst.id_instance
  FROM t_recevent_inst inst
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  WHERE
    -- event must be active
    evt.dt_activated <= @dt_now and
    (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
    -- instance must match the given billing group
    inst.id_arg_billgroup = @id_billgroup AND
    evt.tx_name = ''_StartRoot'' AND
    evt.tx_type = ''Root''

  IF @id_instance IS NULL
  BEGIN
    -- start root instance was not found!
    SELECT @status = -4
    ROLLBACK
    RETURN
  END
  
  --
  -- checks start root''s reversal dependencies
  --
  IF @ignoreDeps = 0
  BEGIN
    DECLARE @count INT

    SELECT @count = COUNT(*)
    FROM GetEventReversalDeps(@dt_now, @id_instance) deps
    WHERE deps.tx_status <> ''NotYetRun''

    IF @count > 0
    BEGIN
      -- not all instances, which depend on the billing group, have been reversed successfully
      SELECT @status = -5
      ROLLBACK
      RETURN
    END   
  END

  -- just pretending, so don''t do the update
  IF @pretend != 0
  BEGIN
    SELECT @status = 0 -- success
    COMMIT
    RETURN
  END  

  EXEC UpdateBillingGroupStatus @id_billgroup, ''O''
  
  IF (@@ERROR != 0)
    BEGIN
       SELECT @status = -6
       ROLLBACK
       RETURN
    END  

   SET @status = 0 -- success
   COMMIT
 
END
  ' 
END
GO
/****** Object:  StoredProcedure [dbo].[AddCounterParam]    Script Date: 06/02/2008 11:43:00 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddCounterParam]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			create proc [dbo].[AddCounterParam]
                  @id_lang_code int,
									@id_counter int,
									@id_counter_param_type int,
									@nm_counter_Value nvarchar(255),
                  @nm_name nvarchar(255),
                  @nm_desc nvarchar(255),
                  @nm_display_name nvarchar(255),
									@identity int OUTPUT
			AS
			DECLARE @identity_value int
			BEGIN TRAN
        exec InsertBaseProps @id_lang_code, 190, ''N'', ''N'', @nm_name, @nm_desc, @nm_display_name, @identity_value output
			INSERT INTO t_counter_params 
				(id_counter_param, id_counter, id_counter_param_meta, Value) 
			VALUES 
				(@identity_value, @id_counter, @id_counter_param_type, @nm_counter_value)
			SELECT 
				@identity = @identity_value
			COMMIT TRAN
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[AddCounterParamType]    Script Date: 06/02/2008 11:43:01 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddCounterParamType]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
						CREATE PROC [dbo].[AddCounterParamType]			
									@id_lang_code int,
									@n_kind int,
									@nm_name nvarchar(255),
									@id_counter_type int,
									@nm_param_type varchar(255),
									@nm_param_dbtype varchar(255),
									@id_prop int OUTPUT 
			      AS
			      DECLARE @identity_value int
			      BEGIN TRAN
			      exec InsertBaseProps @id_lang_code, @n_kind, ''N'', ''N'', @nm_name, NULL, NULL, @identity_value output
			      INSERT INTO t_counter_params_metadata
					              (id_prop, id_counter_meta, ParamType, DBType) 
				    VALUES 
					              (@identity_value, @id_counter_type, @nm_param_type, @nm_param_dbtype)
            select @id_prop = @identity_value
      			COMMIT TRAN
    ' 
END
GO
/****** Object:  StoredProcedure [dbo].[AddCounterType]    Script Date: 06/02/2008 11:43:01 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddCounterType]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				create proc [dbo].[AddCounterType]
					  		  @id_lang_code int,
									@n_kind int,
									@nm_name nvarchar(255),
									@nm_desc nvarchar(255),
									@nm_formula_template varchar(1000),
									@valid_for_dist char(1),
									@id_prop int OUTPUT 
			AS
			begin
			declare @t_count int	
			declare @temp_nm_name nvarchar(255)
			declare @temp_id_lang_code int
			declare @identity_value int
			declare @t_base_props_count INT
			
			select @id_prop = -1
      select @temp_nm_name = @nm_name
			select @temp_id_lang_code = @id_lang_code

      SELECT @t_base_props_count = COUNT(*) FROM T_BASE_PROPS				
      WHERE T_BASE_PROPS.nm_name = @nm_name
			SELECT @t_count = COUNT(*) FROM t_vw_base_props
				WHERE t_vw_base_props.nm_name = @temp_nm_name and t_vw_base_props.id_lang_code = @temp_id_lang_code
      IF (@t_base_props_count <> 0)
				begin	
 				select @id_prop = -1
				end			

			IF (@t_count = 0)
			  begin
				exec InsertBaseProps @id_lang_code, @n_kind, ''N'', ''N'', @nm_name, @nm_desc, null, @identity_value OUTPUT
		    INSERT INTO t_counter_metadata (id_prop, FormulaTemplate, b_valid_for_dist) values (@identity_value, 
				    @nm_formula_template, @valid_for_dist)
				select @id_prop = @identity_value
			  end
       end
			' 
END
GO
/****** Object:  StoredProcedure [dbo].[AddCounterInstance]    Script Date: 06/02/2008 11:42:59 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddCounterInstance]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
					create proc [dbo].[AddCounterInstance]
					            @id_lang_code int,
											@n_kind int,
											@nm_name nvarchar(255),
											@nm_desc nvarchar(255),
											@counter_type_id int, 
											@id_prop int OUTPUT 
					as
					begin
						DECLARE @identity_value int
						exec InsertBaseProps @id_lang_code, @n_kind, ''N'', ''N'', @nm_name, @nm_desc, null, @identity_value output
					INSERT INTO t_counter (id_prop, id_counter_type) values (@identity_value, @counter_type_id)
					SELECT 
						@id_prop = @identity_value
					end
        ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreateCounterPropDef]    Script Date: 06/02/2008 11:43:26 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateCounterPropDef]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
					CREATE PROC [dbo].[CreateCounterPropDef]
											@id_lang_code int,
											@n_kind int,
											@nm_name nvarchar(255),
											@nm_display_name nvarchar(255),
											@id_pi int,
											@nm_servicedefprop nvarchar(255),
											@nm_preferredcountertype nvarchar(255),
											@n_order int, 
											@id_prop int OUTPUT 
					AS
					DECLARE @identity_value int
						DECLARE @id_locale int
					BEGIN TRAN
						exec InsertBaseProps @id_lang_code, @n_kind, ''N'', ''N'', @nm_name, NULL, @nm_display_name, @identity_value output
						INSERT INTO t_counterpropdef 
							(id_prop, id_pi, nm_servicedefprop, n_order, nm_preferredcountertype) 
						VALUES 
							(@identity_value, @id_pi, @nm_servicedefprop, @n_order, @nm_preferredcountertype)
						SELECT 
						@id_prop = @identity_value
					COMMIT TRAN
       ' 
END
GO
/****** Object:  StoredProcedure [dbo].[MoveAccount]    Script Date: 06/02/2008 11:44:00 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MoveAccount]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
create  procedure [dbo].[MoveAccount] 
	(@new_parent int,
	 @account_being_moved int,
   @vt_move_start datetime,
   @p_enforce_same_corporation varchar,
   @status int output,
   @p_id_ancestor_out int output,
   @p_ancestor_type varchar(40) output,
   @p_acc_type varchar(40) output)
as
begin
declare @vt_move_end datetime
set @vt_move_end = dbo.MTMaxDate()

declare @vt_move_start_trunc datetime
set @vt_move_start_trunc = dbo.MTStartOfDay(@vt_move_start)

-- plug business rules back in
declare @varMaxDateTime as datetime
declare @AccCreateDate as datetime
declare @AccMaxCreateDate as datetime
declare @p_dt_start datetime
declare @realstartdate as datetime
declare @p_id_ancestor as int
declare @p_id_descendent as int
declare @ancestor_acc_type as int
declare @descendent_acc_type as int


set @p_dt_start = @vt_move_start_trunc
set @p_id_ancestor = @new_parent
set @p_id_descendent = @account_being_moved


select @realstartdate = dbo.mtstartofday(@p_dt_start) 
select @varMaxDateTime = max(vt_end) from t_account_ancestor where id_descendent = @p_id_descendent
and id_ancestor = 1

select @AccCreateDate = dbo.mtminoftwodates(dbo.mtstartofday(ancestor.dt_crt),dbo.mtstartofday(descendent.dt_crt)),
@ancestor_acc_type = ancestor.id_type,
@descendent_acc_type = descendent.id_type
from t_account ancestor
inner join t_account descendent ON 
ancestor.id_acc = @p_id_ancestor and
descendent.id_acc = @p_id_descendent


select @p_ancestor_type = name 
from t_account_type
where id_type = @ancestor_acc_type


select @p_acc_type = name 
from t_account_type
where id_type = @descendent_acc_type


--begin business rules check

	select @AccMaxCreateDate = 
	dbo.mtmaxoftwodates(dbo.mtstartofday(ancestor.dt_crt),dbo.mtstartofday(descendent.dt_crt))
	from t_account ancestor,t_account descendent where ancestor.id_acc = @p_id_ancestor and
	descendent.id_acc = @p_id_descendent
	if dbo.mtstartofday(@p_dt_start) < dbo.mtstartofday(@AccMaxCreateDate)  begin
		-- MT_CANNOT_MOVE_ACCOUNT_BEFORE_START_DATE
		select @status = -486604750
		return
	end 
	
	-- step : make sure that the new ancestor is not actually a child
	select @status = count(*) 
	from t_account_ancestor 
	where id_ancestor = @p_id_descendent 
	and id_descendent = @p_id_ancestor AND 
  	@realstartdate between vt_start AND vt_end
	if @status > 0 
   	begin 
		-- MT_NEW_PARENT_IS_A_CHILD
	 select @status = -486604797
	 return
  	end 

	select @status = count(*) 
	from t_account_ancestor 
	where id_ancestor = @p_id_ancestor 
	and id_descendent = @p_id_descendent 
	and num_generations = 1
	and @realstartdate >= vt_start 
	and vt_end = @varMaxDateTime
	if @status > 0 
	begin 
		-- MT_NEW_ANCESTOR_IS_ALREADY_ A_ANCESTOR
	 select @status = 1
	 return
	end 


      -- step : make sure that the account is not archived or closed
	select @status = count(*)  from t_account_state 
	where id_acc = @p_id_Descendent
	and (dbo.IsClosed(@status) = 1 OR dbo.isArchived(@status) = 1) 
	and @realstartdate between vt_start AND vt_end
	if (@status > 0 )
	begin
	   -- OPERATION_NOT_ALLOWED_IN_CLOSED_OR_ARCHIVED
	select @status = -469368827
	end 

	-- step : make sure that the account is not a corporate account
	--only check next 2 business rules if p_enforce_same_corporation rule is turned on
	if @p_enforce_same_corporation = 1
	begin
		if (dbo.iscorporateaccount(@p_id_descendent,@p_dt_start) = 1)
		-- MT_CANNOT_MOVE_CORPORATE_ACCOUNT
			begin
			select @status = -486604770
			return
			end 
		-- do this check if the original ancestor of the account being moved is not -1 
		-- or the new ancestor is not -1
		declare @originalAncestor integer
		select @originalAncestor = id_ancestor from t_account_ancestor 
			where id_descendent =  @p_id_descendent
			and num_generations = 1
			and @vt_move_start_trunc >= vt_start and @vt_move_start_trunc <= vt_end

		if (@originalAncestor <> -1 AND @p_id_ancestor <> -1 AND dbo.IsInSameCorporateAccount(@p_id_ancestor,@p_id_descendent,@realstartdate) <> 1) begin
			-- MT_CANNOT_MOVE_BETWEEN_CORPORATE_HIERARCHIES
			select @status = -486604759
			return
		end
	end

	--check that both ancestor and descendent are subscriber accounts.  This check has to be recast.. you can 
	-- only move if the new ancestor allows children of type @descendent_acc_type
	if @descendent_acc_type not in (
	select id_descendent_type from t_acctype_descendenttype_map
	where id_type = @ancestor_acc_type)
	BEGIN
	-- MT_ANCESTOR_OF_INCORRECT_TYPE
	select @status = -486604714
	return
	END

	-- check that only accounts whose type says b_canHaveSyntheticRoot is true can have -1 as an ancestor.
	if (@p_id_ancestor = -1)
	BEGIN
	declare @syntheticroot varchar(1)
	select @syntheticroot = b_CanhaveSyntheticRoot from t_account_type where id_type = @descendent_acc_type
	if (@syntheticroot <> ''1'')
	BEGIN
	--MT_ANCESTOR_INVALID_SYNTHETIC_ROOT
		select @status = -486604713
		return
	END
	END
	--this check is removed in Kona.
	--if(@b_is_ancestor_folder <> ''1'')
	--BEGIN
	-- MT_CANNOT_MOVE_TO_NON_FOLDER_ACCOUNT
	--select @status = -486604726
	--return
	--END

-- end business rules

--METRAVIEW DATAMART 

declare @tmp_t_dm_account table(id_dm_acc int,id_acc int,vt_start datetime,vt_end datetime)
insert into @tmp_t_dm_account  select * from t_dm_account where id_acc in 
(
select distinct id_descendent from t_account_ancestor where id_ancestor = @account_being_moved
)
--Deleting all the entries from ancestor table
delete from t_dm_account_ancestor where id_dm_descendent in (select id_dm_acc from @tmp_t_dm_account)
delete from t_dm_account where id_dm_acc in (select id_dm_acc from @tmp_t_dm_account)

select 
aa2.id_ancestor,
aa2.id_descendent,
aa2.num_generations,
aa2.b_children,
dbo.MTMaxOfTwoDates(@vt_move_start_trunc, dbo.MTMaxOfTwoDates(dbo.MTMaxOfTwoDates(aa1.vt_start, aa2.vt_start), aa3.vt_start)) as vt_start,
dbo.MTMinOfTwoDates(@vt_move_end, dbo.MTMinOfTwoDates(dbo.MTMinOfTwoDates(aa1.vt_end, aa2.vt_end), aa3.vt_end)) as vt_end,
aa2.tx_path
into #deletethese
from
t_account_ancestor aa1
inner join t_account_ancestor aa2 on aa1.id_ancestor=aa2.id_ancestor and aa1.vt_start <= aa2.vt_end and aa2.vt_start <= aa1.vt_end and aa2.vt_start <= @vt_move_end and @vt_move_start_trunc <= aa2.vt_end
inner join t_account_ancestor aa3 on aa2.id_descendent=aa3.id_descendent and aa3.vt_start <= aa2.vt_end and aa2.vt_start <= aa3.vt_end and aa3.vt_start <= @vt_move_end and @vt_move_start_trunc <= aa3.vt_end
where
aa1.id_descendent=@account_being_moved
and
aa1.num_generations > 0
and 
aa1.vt_start <= @vt_move_end 
and 
@vt_move_start_trunc <= aa1.vt_end
and
aa3.id_ancestor=@account_being_moved

-- select old direct ancestor id
select @p_id_ancestor_out = id_ancestor from #deletethese
where num_generations = 1 and @vt_move_start_trunc between vt_start and vt_end


--select * from #deletethese

-- The four statements of the sequenced delete follow.  Watch carefully :-)
--
-- Create a new interval for the case in which the applicability interval of the update
-- is contained inside the period of validity of the existing interval
-- [------------------] (existing)
--    [-----------] (update)
insert into t_account_ancestor(id_ancestor, id_descendent, num_generations,b_children, vt_start, vt_end,tx_path)
select aa.id_ancestor, aa.id_descendent, aa.num_generations, d.b_children,d.vt_start, d.vt_end,
case when aa.id_descendent = 1 then
    aa.tx_path + d.tx_path
    else
    d.tx_path + ''/'' + aa.tx_path
    end
from
t_account_ancestor aa
inner join #deletethese d on aa.id_ancestor=d.id_ancestor and aa.id_descendent=d.id_descendent and 
	aa.num_generations=d.num_generations and aa.vt_start < d.vt_start and aa.vt_end > d.vt_end

-- Update end date of existing records for which the applicability interval of the update
-- starts strictly inside the existing record:
-- [---------] (existing)
--    [-----------] (update)
-- or
-- [---------------] (existing)
--    [-----------] (update)
update t_account_ancestor
set
t_account_ancestor.vt_end = dateadd(s, -1, d.vt_start)
--select *
from
t_account_ancestor aa 
inner join #deletethese d on aa.id_ancestor=d.id_ancestor and aa.id_descendent=d.id_descendent and 
	aa.num_generations=d.num_generations and aa.vt_start < d.vt_start and aa.vt_end > d.vt_start

-- Update start date of existing records for which the effectivity interval of the update
-- ends strictly inside the existing record:
--              [---------] (existing)
--    [-----------] (update)
update t_account_ancestor
set
t_account_ancestor.vt_start = dateadd(s, 1, d.vt_end)
--select *
from
t_account_ancestor aa 
inner join #deletethese d on aa.id_ancestor=d.id_ancestor and aa.id_descendent=d.id_descendent and 
	aa.num_generations=d.num_generations and aa.vt_start <= d.vt_end and aa.vt_end > d.vt_end

-- Delete existing records for which the effectivity interval of the update
-- contains the existing record:
--       [---------] (existing)
--     [---------------] (update)
delete aa
--select *
from
t_account_ancestor aa 
inner join #deletethese d on aa.id_ancestor=d.id_ancestor and aa.id_descendent=d.id_descendent and 
	aa.num_generations=d.num_generations and aa.vt_start >= d.vt_start and aa.vt_end <= d.vt_end

-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-- SEQUENCED INSERT JOIN
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-- Now do the sequenced insert into select from with the sequenced
-- cross join as the source of the data.

insert into t_account_ancestor(id_ancestor, id_descendent, num_generations,b_children, vt_start, vt_end,tx_path)
select aa1.id_ancestor, 
aa2.id_descendent, 
aa1.num_generations+aa2.num_generations+1 as num_generations,
aa2.b_children, 
dbo.MTMaxOfTwoDates(@vt_move_start_trunc, dbo.MTMaxOfTwoDates(aa1.vt_start, aa2.vt_start)) as vt_start,
dbo.MTMinOfTwoDates(@vt_move_end, dbo.MTMinOfTwoDates(aa1.vt_end, aa2.vt_end)) as vt_end,
case when aa2.id_descendent = 1 then
    aa1.tx_path + aa2.tx_path
    else
    aa1.tx_path + ''/'' + aa2.tx_path
    end
from
t_account_ancestor aa1
inner join t_account_ancestor aa2 on aa1.vt_start < aa2.vt_end and aa2.vt_start < aa1.vt_end and aa2.vt_start < @vt_move_end and @vt_move_start_trunc < aa2.vt_end
where 
aa1.id_descendent = @new_parent 
and 
aa1.vt_start < @vt_move_end 
and 
@vt_move_start_trunc < aa1.vt_end
and 
aa2.id_ancestor = @account_being_moved

-- Implement the coalescing step.
-- TODO: Improve efficiency by restricting the updates to the rows that
-- might need coalesing.
WHILE 1=1
BEGIN
update t_account_ancestor 
set t_account_ancestor.vt_end = (
	select max(aa2.vt_end)
	from
	t_account_ancestor as aa2
	where
	t_account_ancestor.id_ancestor=aa2.id_ancestor
	and
	t_account_ancestor.id_descendent=aa2.id_descendent
	and
	t_account_ancestor.num_generations=aa2.num_generations
	and
	t_account_ancestor.vt_start < aa2.vt_start
	and
	dateadd(s,1,t_account_ancestor.vt_end) >= aa2.vt_start
	and
	t_account_ancestor.vt_end < aa2.vt_end
	and
	t_account_ancestor.tx_path=aa2.tx_path
)
where
exists (
	select *
	from
	t_account_ancestor as aa2
	where
	t_account_ancestor.id_ancestor=aa2.id_ancestor
	and
	t_account_ancestor.id_descendent=aa2.id_descendent
	and
	t_account_ancestor.num_generations=aa2.num_generations
	and
	t_account_ancestor.vt_start < aa2.vt_start
	and
	dateadd(s,1,t_account_ancestor.vt_end) >= aa2.vt_start
	and
	t_account_ancestor.vt_end < aa2.vt_end
	and
	t_account_ancestor.tx_path=aa2.tx_path
)
and id_descendent in (select id_descendent from #deletethese)

IF @@rowcount <= 0 BREAK
END

delete from t_account_ancestor 
where
exists (
	select *
	from t_account_ancestor aa2
	where
	t_account_ancestor.id_ancestor=aa2.id_ancestor
	and
	t_account_ancestor.id_descendent=aa2.id_descendent
	and
	t_account_ancestor.num_generations=aa2.num_generations
	and
	t_account_ancestor.tx_path=aa2.tx_path
	and
 	(
	(aa2.vt_start < t_account_ancestor.vt_start and t_account_ancestor.vt_end <= aa2.vt_end)
	or
	(aa2.vt_start <= t_account_ancestor.vt_start and t_account_ancestor.vt_end < aa2.vt_end)
	)
)
and id_descendent in (select id_descendent from #deletethese)

	update new set b_Children = ''Y'' from t_account_ancestor new where
	id_descendent = @new_parent
	and b_children=''N''	

	update old set b_Children = ''N'' from t_account_ancestor old where
	id_descendent = @p_id_ancestor_out and
	not exists (select 1 from t_account_ancestor new where new.id_ancestor=old.id_descendent
	and num_generations <>0 )

--DataMart insert new id_dm_acc for moving account and descendents
		insert into t_dm_account(id_acc,vt_start,vt_end) select anc.id_descendent, anc.vt_start, anc.vt_end
		from t_account_ancestor	anc
		inner join @tmp_t_dm_account acc on anc.id_descendent = acc.id_acc
		where anc.id_ancestor=1
		and acc.vt_end = @varMaxDateTime
	
		insert into t_dm_account_ancestor
		select dm2.id_dm_acc, dm1.id_dm_acc, aa1.num_generations
		from
		t_account_ancestor aa1
		inner join t_dm_account dm1 on aa1.id_descendent=dm1.id_acc and aa1.vt_start <= dm1.vt_end and dm1.vt_start <= aa1.vt_end
		inner join t_dm_account dm2 on aa1.id_ancestor=dm2.id_acc and aa1.vt_start <= dm2.vt_end and dm2.vt_start <= aa1.vt_end
		inner join @tmp_t_dm_account acc on aa1.id_descendent = acc.id_acc
		where dm1.id_acc <> dm2.id_acc
		and dm1.vt_start >= dm2.vt_start
		and dm1.vt_end <= dm2.vt_end
		and acc.vt_end = @varMaxDateTime

		--we are adding 0 level record for all children of moving account
		insert into t_dm_account_ancestor select dm1.id_dm_acc,dm1.id_dm_acc,0 	
		from 
		t_dm_account dm1
		inner join @tmp_t_dm_account acc on dm1.id_acc = acc.id_acc
		and acc.vt_end = @varMaxDateTime

select @status=1
END
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[CheckGroupSubBusinessRules]    Script Date: 06/02/2008 11:43:19 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckGroupSubBusinessRules]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
create procedure [dbo].[CheckGroupSubBusinessRules](
	@p_name nvarchar(255),
	@p_desc nvarchar(255),
	@p_startdate datetime,
	@p_enddate datetime,
	@p_id_po int,
	@p_proportional varchar,
	@p_discountaccount int,
	@p_CorporateAccount int,
	@p_existingID int,
	@p_id_usage_cycle integer,
	@p_systemdate datetime,
	@p_enforce_same_corporation varchar,
	@p_status int OUTPUT
)
as
begin 
declare @existingPO integer
declare @constrainedcycletype integer
declare @groupsubCycleType integer
declare @corporatestartdate datetime
select @p_status = 0

-- verify that the corporate account and the product offering have the same currency.
if (@p_enforce_same_corporation = ''1'')
begin
	if (dbo.IsAccountAndPOSameCurrency(@p_CorporateAccount, @p_id_po) = ''0'')
	begin

		-- MT_ACCOUNT_PO_CURRENCY_MISMATCH

		select @p_status = -486604729

		return
	end
end

-- verify that the discount account, if not null has the same currency as the po.
if (@p_enforce_same_corporation = ''0'' AND @p_discountaccount is not NULL)
begin
   if (dbo.IsAccountAndPOSameCurrency(@p_discountaccount, @p_id_po) = ''0'')
   begin
	-- MT_ACCOUNT_PO_CURRENCY_MISMATCH
	select @p_status = -486604729
	return
   end
end

if @p_enddate is NULL
	select @p_enddate = dbo.MTMaxDate()
	
	
	-- verify that the product offering exists and the effective date is kosher
if (@p_proportional = ''N'' )
 begin
 if (@p_discountaccount is NULL AND dbo.POContainsDiscount(@p_id_po) = 1)
	begin
	-- MT_GROUP_SUB_DISCOUNT_ACCOUNT_REQUIRED
	select @p_status = -486604787
	return
	end 
 end
	-- verify that the account is actually a corporate account
  -- during the interval [@p_startdate, @p_enddate]
  -- this is done by requiring that the account is corporate
	-- at @p_startdate and at @p_enddate and that there are no
  -- gaps during [@p_startdate, @p_enddate] such that the account
  -- is not a corporate account.
  -- DBlair - Note that this is more complicated than it really needs
  -- to be because I have written it as a "generic" sequenced
  -- referential integrity constraint (see Snodgrass'' book for definition).
  -- I wanted to follow the pattern, since it is very easy to make
  -- mistakes inventing temporal database constructs in an ad-hoc
  -- way.
--BP: Only return MT_GROUP_SUB_CORPORATE_ACCOUNT_INVALID error if
-- a business rule that prohibits cross-corporation operations is enforced
-- Otherwise we create all group subscriptions as global (id_corp = 1)
--Another way to do this would be to ignore below check if corporation id
-- is 1. However this would introduce some complications during pc import/export and upgrades
if(@p_enforce_same_corporation = ''1'')
begin
	if 
		not exists(
			select * 
			from t_account_ancestor aa
			inner join t_account a on a.id_acc = aa.id_descendent
			inner join t_account_type at on at.id_type = a.id_type
			where 
			at.b_IsCorporate = ''1''
			and
			aa.id_descendent=@p_CorporateAccount
			and
			aa.vt_start <= @p_startdate
			and
			aa.vt_end >= @p_startdate
		)
		or not exists (
			select * 
			from t_account_ancestor aa
			inner join t_account a on a.id_acc = aa.id_descendent
			inner join t_account_type at on at.id_type = a.id_type
			where 
			at.b_IsCorporate = ''1''
			and
			aa.id_descendent=@p_CorporateAccount
			and
			aa.vt_start <= @p_enddate
			and
			aa.vt_end >= @p_enddate
		)
		or exists (
			select * 
			-- This finds a record that ends during the
			-- interval...
			from t_account_ancestor aa
			inner join t_account a on a.id_acc = aa.id_descendent
			inner join t_account_type at on at.id_type = a.id_type
			where 
			at.b_IsCorporate = ''1''
			and
			aa.id_descendent=@p_CorporateAccount
			and
			@p_startdate <= aa.vt_end
			and
			aa.vt_end < @p_enddate
			-- ... and there is not corp. account record that extends
			-- its validity.
			and
			not exists (
				select * 
				from t_account_ancestor aa2
			  inner join t_account a on a.id_acc = aa2.id_descendent
			  inner join t_account_type at on at.id_type = a.id_type
			  where 
			  at.b_IsCorporate = ''1''
				and
				aa2.vt_start <= dateadd(s, 1, aa.vt_end)
				and
				aa2.vt_end > aa.vt_end	
			)
		)
		begin
		-- MT_GROUP_SUB_CORPORATE_ACCOUNT_INVALID
		select @p_status = -486604786
		return
		end
end
 -- make sure start date is before end date
	-- MT_GROUPSUB_STARTDATE_AFTER_ENDDATE
if (@p_enddate is not null )
	begin
	if (@p_startdate > @p_enddate)
		begin
		select @p_status = -486604782
		return
		end 
	end
	-- verify that the group subscription name does not conflict with an existing
	-- group subscription
	--  MT_GROUP_SUB_NAME_EXISTS -486604784
begin
	select @p_status = 0
	select @p_status = id_group  from t_group_sub where lower(@p_name) = lower(tx_name) AND
	(@p_existingID <> id_group OR @p_existingID is NULL)
	if (@p_status <> 0) begin
		select @p_status = -486604784
		return
	end 
	if (@p_status is null) begin
		select @p_status = 0
		end
end
-- verify that the usage cycle type matched that of the 
-- product offering
select @constrainedcycletype = dbo.poconstrainedcycletype(@p_id_po),
		@groupsubCycleType = id_cycle_type 
from
t_usage_cycle
where id_usage_cycle = @p_id_usage_cycle
if @constrainedcycletype > 0 AND
	@constrainedcycletype <> @groupsubCycleType begin
-- MT_GROUP_SUB_CYCLE_TYPE_MISMATCH
	select @p_status = -486604762
return
end
 -- check that the discount account has in its ancestory tree 
	-- the corporate account
-- BP: Only return MT_DISCOUNT_ACCOUNT_MUST_BE_IN_CORPORATE_HIERARCHY error if
-- a business rule that prohibits cross-corporation operations is enforced.
-- Otherwise we create all group subscriptions as global (id_corp = 1)
-- Another way to do this would be to ignore below check if corporation id
-- is 1. However this would introduce some complications during pc import/export and upgrades
if (@p_enforce_same_corporation = ''1'' AND @p_discountaccount is not NULL)
	begin
		select @p_status = max(id_ancestor)  
		from t_account_ancestor 
		where id_descendent = @p_discountaccount 
		and id_ancestor = @p_CorporateAccount
	if (@p_status is NULL)
		begin
		-- MT_DISCOUNT_ACCOUNT_MUST_BE_IN_CORPORATE_HIERARCHY
		select @p_status = -486604760
		return
		end 
	end 

	-- make sure the start date is after the start date of the corporate account
	-- BP: Only return MT_CANNOT_CREATE_GROUPSUB_BEFORE_CORPORATE_START_DATE error if
	-- a business rule that prohibits cross-corporation operations is enforced.
	-- Otherwise we create all group subscriptions as global (id_corp = 1)
	-- Another way to do this would be to ignore below check if corporation id
	-- is 1. However this would introduce some complications during pc import/export and upgrades
	if (@p_enforce_same_corporation = ''1'')
	begin
		select @corporatestartdate = dbo.mtstartofday(dt_crt) from t_account where id_acc = @p_CorporateAccount
		if @corporatestartdate > @p_startdate begin
			-- MT_CANNOT_CREATE_GROUPSUB_BEFORE_CORPORATE_START_DATE
			select @p_status = -486604747
			return
		end 
	end

-- done
select @p_status = 1
end
			 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[DeployAllPartitionedTables]    Script Date: 06/02/2008 11:43:38 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeployAllPartitionedTables]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			/*
				Proc: DeployAllPartitionedTables

				Calls DeployPartitionedTable for all partitioned tables.

			*/
			create proc [dbo].[DeployAllPartitionedTables]
			AS
			begin

			-- Env setup
			set nocount on

			-- Abort if system isn''t enabled for partitioning
			if dbo.IsSystemPartitioned() = 0
			begin
				raiserror(''System not enabled for partitioning.'',0,1)
				return 1
			end

			-- Error handling and row counts
			declare @err int   -- last error
			declare @rc int	-- row count

			declare @tab varchar(300)
			declare tabcur cursor for 
				select nm_table_name from t_prod_view order by id_prod_view

			open tabcur
			fetch tabcur into @tab

			while (@@fetch_status >= 0) begin
				print char(13) + ''Deploying '' + @tab

				exec DeployPartitionedTable @tab

				fetch tabcur into @tab
			end
			deallocate tabcur

			-- After depolying all partitioned tables, ensure all
			-- partition databases are in full recovery mode
			declare partn cursor for
				select partition_name from t_partition 
				where b_active = ''Y''

			declare @partnm varchar(3000)		-- partition name
			open partn

			print ''Checking database recovery modes...''
			-- Iterate partitions, set recovery mode to full
			while (1=1) begin	
				fetch partn into @partnm
				if (@@fetch_status <> 0)
					break

				if (databasepropertyex(@partnm, ''recovery'') <> ''FULL'') begin
					print ''   Database '' + @partnm + '': Setting RECOVERY mode to FULL ''
					exec(''alter database '' + @partnm + '' set recovery full'')
				end

			end -- while
			deallocate partn

			end	-- proc
 	' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreateUniqueKeyTables]    Script Date: 06/02/2008 11:43:32 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateUniqueKeyTables]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      /*
      	CreateUniqueKeyTables
      
      	Creates and loads all unique key tables for a partitioned 
      	product view.
      
      	@tabname - name of a partitioned view
      
      */
      create proc [dbo].[CreateUniqueKeyTables] 
      	(
      	@tabname varchar(200)
      	) as
      begin
      
      -- Env set up
      set nocount on
      declare @err int  -- error code
      declare @rc int   -- row count
      declare @ret int  -- proc return code
      
      -- Abort if system isn''t enabled for partitioning
      if dbo.IsSystemPartitioned() = 0
      begin
      	raiserror(''System not enabled for partitioning.'',0,1)
      	return 1
      end
      
      --
      -- Create Keys
      --
      
      -- Select all unique cons for a partitioned table
      declare ukcur cursor for
      	select uc.nm_table_name
      	from t_unique_cons uc
      	join t_prod_view pv
      		on uc.id_prod_view = pv.id_prod_view
      	where pv.nm_table_name = @tabname
      	order by uc.id_unique_cons
      
      -- Iterate each uk and create
      declare @cons varchar(300)   -- unique key constraint name
      declare @ins varchar(1000)	-- returned insert trigger component
      declare @isnew char(1) -- Y if uk needs inital loading
      declare @cnt int
      declare @loadlist table ( -- list of uk''s to load and other info
      	cons varchar(300),		-- name of uk
      	isnew char(1), 			-- if it was just created
      	ins varchar(500)	   -- insert sql fragment
      	)  
      
      set @ins = ''''
      set @cnt = 0
      open ukcur
      
      while (1=1)
      begin
      	fetch ukcur into @cons
      	if (@@fetch_status <> 0) 
      		break
      
      	set @cnt = @cnt + 1
      
      	-- Create the uk tables
      	exec @ret = CreateUniqueKeyTable @cons, @ins output, @isnew output
      	if (@ret <> 0) begin
      		raiserror(''Unique key table [%s] not created.'', 16,1, @cons)
      		return 1
      	end
      
      	-- Collect sql fragment and other info for this uk
      	insert @loadlist values (@cons, @isnew, @ins)
      
      end 
      deallocate ukcur
      
      -- If the partitioned table has no constraints, just ignore it
      if (@cnt < 1) begin
      	raiserror(''No unique constraints found for [%s]'',0,1, @tabname)
      	return --0
      end
      
      --
      -- Load Keys
      --
      
      -- Setup for iterating partitions
      declare partn cursor for
      	select id_partition, partition_name
      	from t_partition 
      	where b_active = ''Y''
      
      declare @instrig varchar(1000)  -- insert sql
      declare @partnm varchar(3000)		-- partition name
      declare @partid varchar(3000)		-- partition id
      open partn
      
      -- Iterate partitions, loading the new unique keys
      while (1=1) begin	
      	fetch partn into @partid, @partnm
      	if (@@fetch_status <> 0)
      		break
      
      	print char(13) + ''Partition: '' + @partnm
      
      	-- Setup to iterate unique keys
      	declare uklist cursor for
      		select cons, isnew, ins from @loadlist
      
      	declare @uk varchar(300)
      	open uklist
      
      	-- Iterate unique key tables and load if new
      	while (1=1) begin
      		fetch uklist into @uk, @isnew, @ins
      		if (@@fetch_status <> 0)
      			break
      
      		-- Load uk from this parition if new
      		if (@isnew = ''Y'') begin
      			print ''   Loading: '' + @uk
      
      			-- The body of the insert trigger is the loading code
      			declare @loadcmd varchar(1000)
      			set @loadcmd = replace(@ins, ''inserted'', @partnm + ''..'' + @tabname)
      			exec(@loadcmd)
      
      			select @err = @@error, @rc = @@rowcount
      			if (@err <> 0) begin
      				raiserror(''Cannot load unique key [%s] from [%s]'', 16,1, @uk, @partnm)
      				deallocate uklist
      				deallocate partn
      				return 1
      			end
      		end
      
      	end
      	deallocate uklist
      
      end
      deallocate partn
      
      end --proc
 	' 
END
GO
/****** Object:  StoredProcedure [dbo].[GetBalances]    Script Date: 06/02/2008 11:43:42 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[GetBalances]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
    
---------------------------------------------------------
-- returns all balances for account as of end of interval
-- return codes:
-- O = OK
-- 1 = currency mismatch
---------------------------------------------------------
CREATE PROCEDURE [dbo].[GetBalances]( 
@id_acc int,
@id_interval int,
@previous_balance numeric(18, 6) OUTPUT,
@balance_forward numeric(18, 6) OUTPUT,
@current_balance numeric(18, 6) OUTPUT,
@currency nvarchar(3) OUTPUT,
@estimation_code int OUTPUT, -- 0 = NONE: no estimate, all balances taken from t_invoice
                             -- 1 = CURRENT_BALANCE: balance_forward and current_balance estimated, @previous_balance taken from t_invoice
                             -- 2 = PREVIOUS_BALANCE: all balances estimated 
@return_code int OUTPUT
)
AS
BEGIN
DECLARE
  @balance_date datetime,
  @unbilled_prior_charges numeric(18, 6), -- unbilled charges from interval after invoice and before this one
  @previous_charges numeric(18, 6),       -- payments, adjsutments for this interval
  @current_charges numeric(18, 6),        -- current charges for this interval
  @interval_start datetime,
  @tmp_amount numeric(18, 6),
  @tmp_currency nvarchar(3)

  SET @return_code = 0

  -- step1: check for existing t_invoice, and use that one if exists
  SELECT @current_balance = current_balance,
    @balance_forward = current_balance - invoice_amount - tax_ttl_amt,
    @previous_balance = @balance_forward - payment_ttl_amt - postbill_adj_ttl_amt - ar_adj_ttl_amt,
    @currency = invoice_currency
  FROM t_invoice
  WHERE id_acc = @id_acc
  AND id_interval = @id_interval
  
  IF NOT @current_balance IS NULL
    BEGIN
    SET @estimation_code = 0 
    RETURN --done
    END

  -- step2: get balance (as of @interval_start) from previous invoice
  --set @interval_start = (select dt_start from t_usage_interval where id_interval = @id_interval)

  -- AR: Bug fix for 10238, when billing cycle is changed.

  select @interval_start =
	CASE WHEN aui.dt_effective IS NULL THEN
		ui.dt_start
	     ELSE dateadd(s, 1, aui.dt_effective)
	END
  from t_acc_usage_interval aui
	inner join t_usage_interval ui on aui.id_usage_interval = ui.id_interval
	where aui.id_acc = @id_acc
	AND ui.id_interval = @id_interval

  exec GetLastBalance @id_acc, @interval_start, @previous_balance output, @balance_date output, @currency output

  -- step3: calc @unbilled_prior_charges
  set @unbilled_prior_charges = 0

  -- add unbilled payments, and ar adjustments
  SELECT @tmp_amount = SUM(au.Amount),
    @tmp_currency = au.am_currency
  FROM t_acc_usage au
   INNER JOIN t_prod_view pv on au.id_view = pv.id_view
   INNER JOIN t_acc_usage_interval aui on au.id_acc = aui.id_acc and au.id_usage_interval = aui.id_usage_interval
   INNER JOIN t_usage_interval ui on aui.id_usage_interval = ui.id_interval
  WHERE pv.nm_table_name in (''t_pv_Payment'', ''t_pv_ARAdjustment'')
    AND au.id_acc = @id_acc
    AND ui.dt_end > @balance_date
    AND ui.dt_start < @interval_start
  GROUP BY au.am_currency

  IF @@ROWCOUNT > 1 OR (@@ROWCOUNT = 1 AND @tmp_currency <> @currency)
  BEGIN
    SET @return_code = 1 -- currency mismatch
    RETURN 1
  END
  
  SET @tmp_amount = isnull(@tmp_amount, 0)
  SET @unbilled_prior_charges = @unbilled_prior_charges + @tmp_amount

  SET @tmp_amount = 0.0
  
  -- add unbilled current charges
  SELECT @tmp_amount = SUM(isnull(au.Amount, 0.0)) +
                       SUM(isnull(au.Tax_Federal,0.0)) +
                       SUM(isnull(au.Tax_State,0.0)) +
                       SUM(isnull(au.Tax_County,0.0)) +
                       SUM(isnull(au.Tax_Local,0.0)) +
                       SUM(isnull(au.Tax_Other,0.0)),
    @tmp_currency = au.am_currency
  FROM t_acc_usage au
    inner join t_view_hierarchy vh on au.id_view = vh.id_view
    left outer join t_pi_template piTemplated2 on piTemplated2.id_template=au.id_pi_template
    left outer join t_base_props pi_type_props on pi_type_props.id_prop=piTemplated2.id_pi
    inner join t_enum_data enumd2 on au.id_view=enumd2.id_enum_data
    INNER JOIN t_acc_usage_interval aui on au.id_acc = aui.id_acc and au.id_usage_interval = aui.id_usage_interval
    INNER JOIN t_usage_interval ui on aui.id_usage_interval = ui.id_interval
  WHERE
    vh.id_view = vh.id_view_parent
    AND au.id_acc = @id_acc
    AND ((au.id_pi_template is null and au.id_parent_sess is null) or (au.id_pi_template is not null and piTemplated2.id_template_parent is null))
    AND (pi_type_props.n_kind IS NULL or pi_type_props.n_kind <> 15 or (enumd2.nm_enum_data) NOT LIKE ''%_TEMP'')
    AND ui.dt_end > @balance_date
    AND ui.dt_start < @interval_start
  GROUP BY au.am_currency

  IF @@ROWCOUNT > 1 OR (@@ROWCOUNT = 1 AND @tmp_currency <> @currency)
  BEGIN
    SET @return_code = 1 -- currency mismatch
    RETURN 1
  END

  SET @tmp_amount = isnull(@tmp_amount, 0)
  SET @unbilled_prior_charges = @unbilled_prior_charges + @tmp_amount

  -- add unbilled pre-bill and post-bill adjustments
  SET @unbilled_prior_charges = @unbilled_prior_charges + isnull(
    (SELECT SUM(isnull(PrebillAdjAmt, 0.0)) +
            SUM(isnull(PostbillAdjAmt, 0.0)) +
            SUM(isnull(PrebillTaxAdjAmt, 0.0)) +
            SUM(isnull(PostbillTaxAdjAmt, 0.0))
     FROM vw_adjustment_summary
     WHERE id_acc = @id_acc
     AND dt_end > @balance_date
     AND dt_start < @interval_start), 0)


  -- step4: add @unbilled_prior_charges to @previous_balance if any found
  IF @unbilled_prior_charges <> 0
    BEGIN
    SET @estimation_code = 2
    SET @previous_balance = @previous_balance + @unbilled_prior_charges
    END
  ELSE
    SET @estimation_code = 1

  -- step5: get previous charges
  SELECT
    @previous_charges = SUM(au.Amount),
    @tmp_currency = au.am_currency
  FROM t_acc_usage au
   INNER JOIN t_prod_view pv on au.id_view = pv.id_view
  WHERE pv.nm_table_name in (''t_pv_Payment'', ''t_pv_ARAdjustment'')
  AND au.id_acc = @id_acc
  AND au.id_usage_interval = @id_interval
  GROUP BY au.am_currency

  IF @@ROWCOUNT > 1 OR (@@ROWCOUNT = 1 AND @tmp_currency <> @currency)
  BEGIN
    SET @return_code = 1 -- currency mismatch
    RETURN 1
  END

  IF @previous_charges IS NULL
    SET @previous_charges = 0

  -- add post-bill adjustments
  SET @previous_charges = @previous_charges + isnull(
    (SELECT SUM(isnull(PostbillAdjAmt, 0.0)) + 
            SUM(isnull(PostbillTaxAdjAmt, 0.0)) FROM vw_adjustment_summary
     WHERE id_acc = @id_acc AND id_usage_interval = @id_interval), 0)


  -- step6: get current charges
  SELECT
   @current_charges = SUM(isnull(au.Amount, 0.0)) +
                      SUM(isnull(au.Tax_Federal,0.0)) + 
                      SUM(isnull(au.Tax_State,0.0)) +
                      SUM(isnull(au.Tax_County,0.0)) +
                      SUM(isnull(au.Tax_Local,0.0)) +
                      SUM(isnull(au.Tax_Other,0.0)),
   @tmp_currency = au.am_currency
  FROM t_acc_usage au
    inner join t_view_hierarchy vh on au.id_view = vh.id_view
    left outer join t_pi_template piTemplated2 on piTemplated2.id_template=au.id_pi_template
    left outer join t_base_props pi_type_props on pi_type_props.id_prop=piTemplated2.id_pi
    inner join t_enum_data enumd2 on au.id_view=enumd2.id_enum_data
  WHERE
    vh.id_view = vh.id_view_parent
  AND au.id_acc = @id_acc
  AND ((au.id_pi_template is null and au.id_parent_sess is null) or (au.id_pi_template is not null and piTemplated2.id_template_parent is null))
  AND (pi_type_props.n_kind IS NULL or pi_type_props.n_kind <> 15 or (enumd2.nm_enum_data) NOT LIKE ''%_TEMP'')
  AND au.id_usage_interval = @id_interval
  GROUP BY au.am_currency

  IF @@ROWCOUNT > 1 OR (@@ROWCOUNT = 1 AND @tmp_currency <> @currency)
  BEGIN
    SET @return_code = 1 -- currency mismatch
    RETURN 1
  END

  IF @current_charges IS NULL
    SET @current_charges = 0

  -- add pre-bill adjustments
  SET @current_charges = @current_charges + isnull(
    (SELECT SUM(isnull(PrebillAdjAmt, 0.0) +
                isnull(PrebillTaxAdjAmt, 0.0)) FROM vw_adjustment_summary
     WHERE id_acc = @id_acc AND id_usage_interval = @id_interval), 0)

  SET @balance_forward = @previous_balance + @previous_charges
  SET @current_balance = @balance_forward + @current_charges
END
     ' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdateBaseProps]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateBaseProps]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			create procedure [dbo].[UpdateBaseProps](
			@a_id_prop int,
			@a_id_lang int,
			@a_nm_name NVARCHAR(255),
			@a_nm_desc NVARCHAR(255),
			@a_nm_display_name NVARCHAR(255))
		AS
		begin
      declare @old_id_name int
      declare @id_name int
      declare @old_id_desc int
      declare @id_desc int
      declare @old_id_display_name int
      declare @id_display_name int
			select @old_id_name = n_name, @old_id_desc = n_desc, 
			@old_id_display_name = n_display_name
     	from t_base_props where id_prop = @a_id_prop
			exec UpsertDescription @a_id_lang, @a_nm_name, @old_id_name, @id_name output
			exec UpsertDescription @a_id_lang, @a_nm_desc, @old_id_desc, @id_desc output
			exec UpsertDescription @a_id_lang, @a_nm_display_name, @old_id_display_name, @id_display_name output
			UPDATE t_base_props
				SET n_name = @id_name, n_desc = @id_desc, n_display_name = @id_display_name,
						nm_name = @a_nm_name, nm_desc = @a_nm_desc, nm_display_name = @a_nm_display_name
				WHERE id_prop = @a_id_prop
		END
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[DeleteBaseProps]    Script Date: 06/02/2008 11:43:35 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeleteBaseProps]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      create procedure [dbo].[DeleteBaseProps](
				@a_id_prop int) 
      as
			begin
        declare @id_desc_display_name int
        declare @id_desc_name int
        declare @id_desc_desc int
     		SELECT @id_desc_name = n_name, @id_desc_desc = n_desc, 
				@id_desc_display_name = n_display_name
		 		from t_base_props where id_prop = @a_id_prop
				exec DeleteDescription @id_desc_display_name
				exec DeleteDescription @id_desc_name
				exec DeleteDescription @id_desc_desc
				DELETE FROM t_base_props WHERE id_prop = @a_id_prop
			end
		' 
END
GO
/****** Object:  View [dbo].[VW_ADJUSTMENT_DETAILS]    Script Date: 06/02/2008 11:44:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[VW_ADJUSTMENT_DETAILS]'))
EXEC dbo.sp_executesql @statement = N'
          CREATE view [dbo].[VW_ADJUSTMENT_DETAILS] as
			select distinct
				ajt.id_adj_trx,
				ajt.id_reason_code,
				ajt.id_acc_creator,
				ajt.id_acc_payer,
				ajt.c_status,
				ajt.dt_crt AS AdjustmentCreationDate,
				ajt.dt_modified,
				ajt.id_aj_type,
				ajt.id_aj_template ''id_aj_template'',
				ajt.id_aj_instance ''id_aj_instance'',
				ajt.id_usage_interval AS AdjustmentUsageInterval,
				ajt.tx_desc,
				ajt.tx_default_desc,
				ajt.n_adjustmenttype,
				isnull(ajtemplatedesc.tx_desc,'''') as ''AdjustmentTemplateDisplayName'',
				isnull(ajinstancedesc.tx_desc,'''') as ''AdjustmentInstanceDisplayName'',
				CASE WHEN (rcbp.nm_name IS NULL) THEN '''' ELSE rcbp.nm_name END  AS ReasonCodeName,
				CASE WHEN (rcbp.nm_desc IS NULL) THEN '''' ELSE rcbp.nm_desc END  AS ReasonCodeDescription,
				CASE WHEN (rcdesc.tx_desc IS NULL) THEN '''' ELSE rcdesc.tx_desc END  AS ReasonCodeDisplayName,
				isnull(ajinstancedesc.id_lang_code,ajtemplatedesc.id_lang_code) as ''LanguageCode'',
				ajinfo.AtomicPrebillAdjAmt AS PrebillAdjAmt,
				ajinfo.AtomicPostbillAdjAmt AS PostbillAdjAmt,
				ajinfo.*
				FROM t_adjustment_transaction ajt
				INNER JOIN VW_AJ_INFO ajinfo ON ajt.id_sess = ajinfo.id_sess
				--resolve adjustment template or instance name
				INNER JOIN t_base_props ajtemplatebp ON ajt.id_aj_template = ajtemplatebp.id_prop
				left outer JOIN t_description  ajtemplatedesc ON ajtemplatebp.n_display_name = ajtemplatedesc.id_desc
				left outer JOIN t_base_props ajinstancebp ON ajt.id_aj_instance = ajinstancebp.id_prop
				LEFT OUTER JOIN t_description  ajinstancedesc ON ajinstancebp.n_display_name = ajinstancedesc.id_desc
				left outer join t_description des2 on des2.id_lang_code = ajtemplatedesc.id_lang_code and des2.id_desc =  ajinstancebp.n_display_name
				left outer join t_description des3 on des3.id_lang_code = ajinstancedesc.id_lang_code and des3.id_desc =  ajtemplatebp.n_display_name   
				--resolve adjustment reason code name
				INNER JOIN t_base_props rcbp ON ajt.id_reason_code = rcbp.id_prop
				INNER JOIN t_description  rcdesc ON rcbp.n_display_name = rcdesc.id_desc
				and
				rcdesc.id_lang_code = isnull(ajinstancedesc.id_lang_code,ajtemplatedesc.id_lang_code)
				WHERE ajt.c_status = ''A''
				and
				( ajtemplatedesc.id_lang_code=ajinstancedesc.id_lang_code
				or des2.id_lang_code is null
				or des3.id_lang_code is null
				)
				'
GO
/****** Object:  View [dbo].[VW_NOTDELETED_ADJ_DETAILS]    Script Date: 06/02/2008 11:44:17 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[VW_NOTDELETED_ADJ_DETAILS]'))
EXEC dbo.sp_executesql @statement = N'
          CREATE view [dbo].[VW_NOTDELETED_ADJ_DETAILS] as
           select
          ajt.id_adj_trx,
          ajt.id_reason_code,
          ajt.id_acc_creator,
          ajt.id_acc_payer,
          ajt.c_status,
          ajt.dt_crt AS AdjustmentCreationDate,
          ajt.dt_modified,
          ajt.id_aj_type,
          ajt.id_aj_template,
          ajt.id_aj_instance,
          ajt.id_usage_interval AS AdjustmentUsageInterval,
          ajt.tx_desc,
          ajt.tx_default_desc,
          ajt.n_adjustmenttype,
          CASE WHEN (ajtemplatedesc.tx_desc IS NULL) THEN '''' ELSE ajtemplatedesc.tx_desc END  AS AdjustmentTemplateDisplayName,
          CASE WHEN (ajinstancedesc.tx_desc IS NULL) THEN '''' ELSE ajinstancedesc.tx_desc END  AS AdjustmentInstanceDisplayName,
          CASE WHEN (rcbp.nm_name IS NULL) THEN '''' ELSE rcbp.nm_name END  AS ReasonCodeName,
          CASE WHEN (rcbp.nm_desc IS NULL) THEN '''' ELSE rcbp.nm_desc END  AS ReasonCodeDescription,
          CASE WHEN (rcdesc.tx_desc IS NULL) THEN '''' ELSE rcdesc.tx_desc END  AS ReasonCodeDisplayName,
          ajtemplatedesc.id_lang_code AS LanguageCode,
          ajinfo.AtomicPrebillAdjAmt AS PrebillAdjAmt,
          ajinfo.AtomicPostbillAdjAmt AS PostbillAdjAmt,
          ajinfo.*
          FROM t_adjustment_transaction ajt
          INNER JOIN VW_AJ_INFO ajinfo ON ajt.id_sess = ajinfo.id_sess
          --resolve adjustment template or instance name
          INNER JOIN t_base_props ajtemplatebp ON ajt.id_aj_template = ajtemplatebp.id_prop
          INNER JOIN t_description  ajtemplatedesc ON ajtemplatebp.n_display_name = ajtemplatedesc.id_desc
          LEFT OUTER JOIN t_base_props ajinstancebp ON ajt.id_aj_instance = ajinstancebp.id_prop
          LEFT OUTER JOIN t_description  ajinstancedesc ON ajinstancebp.n_display_name = ajinstancedesc.id_desc
          --resolve adjustment reason code name
          INNER JOIN t_base_props rcbp ON ajt.id_reason_code = rcbp.id_prop
          INNER JOIN t_description  rcdesc ON rcbp.n_display_name = rcdesc.id_desc
          and rcdesc.id_lang_code = isnull(ajinstancedesc.id_lang_code,ajtemplatedesc.id_lang_code)
          WHERE ajt.c_status IN (''A'', ''P'')
          AND 
          (
          ajinstancedesc.id_lang_code IS NULL OR  (ajinstancedesc.id_lang_code = ajtemplatedesc.id_lang_code)
          )
				'
GO
/****** Object:  UserDefinedFunction [dbo].[CheckGroupMembershipCycleConstraint]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CheckGroupMembershipCycleConstraint]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
CREATE FUNCTION [dbo].[CheckGroupMembershipCycleConstraint]
(
  @dt_now DATETIME, -- system date
  @id_group INT     -- group ID to check
)
RETURNS INT  -- 1 for success, otherwise negative decimal error code 
AS
BEGIN

  -- this function enforces the business rule given in CR9906
  -- a group subscription to a PO containing a BCR priceable item
  -- should only have member''s with payers that have a usage cycle
  -- that matches the one specified by the group subscription.
  -- at any point in time, this cycle consistency should hold true. 

  -- looks up the PO the group is subscribed to
  DECLARE @id_po INT
  SELECT @id_po = sub.id_po
  FROM t_group_sub gs
  INNER JOIN t_sub sub ON sub.id_group = gs.id_group
  WHERE gs.id_group = @id_group

  -- this check only applies to PO''s that contain a BCR priceable item
  IF dbo.POContainsBillingCycleRelative(@id_po) = 1 -- true
  BEGIN
    
    -- attempts to find a usage cycle mismatch for the member''s payers of the group sub
    -- ideally there should be none
    DECLARE @violator INT
    SELECT TOP 1 @violator = gsm.id_acc
    FROM t_gsubmember gsm
    INNER JOIN t_group_sub gs ON gs.id_group = gsm.id_group
    INNER JOIN t_sub sub ON sub.id_group = gs.id_group
    INNER JOIN t_payment_redirection payer ON 
      payer.id_payee = gsm.id_acc AND
      -- checks all payer''s who overlap with the group sub
      payer.vt_end >= sub.vt_start AND
      payer.vt_start <= sub.vt_end
    INNER JOIN t_acc_usage_cycle auc ON
      auc.id_acc = payer.id_payer AND
      -- cycle mismatch
      auc.id_usage_cycle <> gs.id_usage_cycle
    WHERE 
      -- checks only the requested group
      gs.id_group = @id_group AND
      -- only consider current or future group subs
      -- don''t worry about group subs in the past
      ((@dt_now BETWEEN sub.vt_start AND sub.vt_end) OR
       (sub.vt_start > @dt_now))

    IF @@rowcount > 0
      -- MT_GROUP_SUB_MEMBER_CYCLE_MISMATCH
      RETURN -486604730
  END
  
  -- success
  RETURN 1
END
  ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CompleteChildGroupCreation]    Script Date: 06/02/2008 11:43:20 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CompleteChildGroupCreation]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
1) Delete child group accounts for parent billing group from t_billgroup_member
2) Update t_billgroup_member_history to reflect the deletion
3) Insert child billing group data into t_billgroup from t_billgroup_tmp
4) Insert child billing group data into t_billgroup_member
5) Update t_billgroup_member_history to reflect the addition
6) Delete data from t_billgroup_tmp
7) Delete data from t_billgroup_member_tmp
8) Update t_billgroup_materialization

Returns the following error codes:
   -1 : Unknown error occurred
   -2 : The given id_materialization has a NULL id_parent_billgroup
=========================================================== */
CREATE PROCEDURE [dbo].[CompleteChildGroupCreation]
(
  @id_materialization INT,
  @dt_end DATETIME,
  @status INT OUTPUT
)
AS

BEGIN
   -- initialize @status to failure (-1)
   SET @status = -1 

   -- BEGIN TRAN
   
   DECLARE @id_parent_billgroup INT

   SELECT @id_parent_billgroup = id_parent_billgroup
   FROM t_billgroup_materialization
   WHERE id_materialization = @id_materialization

   /* Error if there is no id_parent_billgroup is NULL */
   IF @id_parent_billgroup IS NULL
      BEGIN
         SET @status = -2
         -- ROLLBACK
         RETURN 
      END

   -- delete child group accounts for parent billing group from t_billgroup_member
   DELETE  bgm
   FROM t_billgroup_member bgm
   INNER JOIN t_billgroup_member_tmp bgmt
      ON bgmt.id_acc = bgm.id_acc
   WHERE bgmt.id_materialization = @id_materialization AND
               bgm.id_billgroup = @id_parent_billgroup
   
   -- update t_billgroup_member_history to reflect the deletion
   UPDATE bgmh
   SET tt_end = @dt_end
   FROM t_billgroup_member_history bgmh 
   INNER JOIN t_billgroup_member_tmp bgmt
      ON bgmt.id_acc = bgmh.id_acc
   WHERE bgmt.id_materialization = @id_materialization AND
               bgmh.id_billgroup = @id_parent_billgroup

   -- insert child billing group data into t_billgroup from t_billgroup_tmp
   INSERT INTO t_billgroup (id_billgroup, 
                                           tx_name, 
                                           tx_description, 
                                           id_usage_interval, 
                                           id_parent_billgroup, 
                                           tx_type)
   SELECT bgt.id_billgroup, 
               bgt.tx_name, 
               bgt.tx_description, 
               bgm.id_usage_interval, 
               bgm.id_parent_billgroup, 
               bgm.tx_type
   FROM t_billgroup_tmp bgt    
   INNER JOIN t_billgroup_materialization bgm 
       ON bgm.id_materialization = bgt.id_materialization
   WHERE bgm.id_materialization = @id_materialization

   -- insert child billing group data into t_billgroup_member
  INSERT INTO t_billgroup_member (id_billgroup, id_acc, id_materialization, id_root_billgroup)
  SELECT bgt.id_billgroup, bgmt.id_acc, @id_materialization, 
              dbo.GetBillingGroupAncestor(bgt.id_billgroup) 
  FROM t_billgroup_member_tmp bgmt
  INNER JOIN t_billgroup_tmp bgt 
     ON bgt.tx_name = bgmt.tx_name  
  WHERE bgmt.id_materialization =  @id_materialization AND
              bgt.id_materialization = @id_materialization  

   -- update t_billgroup_member_history to reflect the addition
  INSERT INTO t_billgroup_member_history (id_billgroup, 
                                                                      id_acc, 
                                                                      id_materialization,
                                                                      tx_status,
                                                                      tt_start,
                                                                      tt_end)
  SELECT bgt.id_billgroup, 
              bgmt.id_acc, 
              @id_materialization,
              ''Succeeded'',
              @dt_end,
              dbo.MTMaxDate()
  FROM t_billgroup_member_tmp bgmt
  INNER JOIN t_billgroup_tmp bgt 
     ON bgt.tx_name = bgmt.tx_name  
  WHERE bgmt.id_materialization =  @id_materialization AND
              bgt.id_materialization = @id_materialization   

   -- set @status to success
   SET @status = 0 

   -- COMMIT TRAN

END
' 
END
GO
/****** Object:  StoredProcedure [dbo].[Backup_partitions_Differential]    Script Date: 06/02/2008 11:43:12 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Backup_partitions_Differential]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
Create PROCEDURE [dbo].[Backup_partitions_Differential] (@path nvarchar(4000), @database_name nvarchar(4000) =null,
@force_flag char(1) = ''N'',@litespeed char(1) = ''N'')
AS
/*
		How to run this stored procedure
		exec Backup_partitions_Differential @path=''c:\backup\archive'',@database_name=null,@force_flag=null,@litespeed=''N''
		or
		exec Backup_partitions_Differential @path=''c:\backup\archive'',@database_name=null,@force_flag=null,@litespeed=''Y''
		or
		exec Backup_partitions_Differential @path=''c:\backup\archive'',@database_name=''netmeter'',@force_flag=null,@litespeed=''Y''
*/
BEGIN
DECLARE @SQLStmt nvarchar(4000)
SET NOCOUNT ON
declare @intervalstart int
declare @intervalend int
declare @partname nvarchar(4000)
declare @getdate datetime
declare @getdate1 varchar(8)
declare @getdate2 varchar(8)
declare @dbname nvarchar(100)
declare @start nvarchar(255)
declare @end nvarchar(255)
declare @rowcount int
declare @maxdate datetime
set @maxdate = dbo.MTMaxdate() 
set @rowcount = 0
select @getdate = getdate(), @getdate1 = CONVERT(VARCHAR(8), GETDATE(), 112), @getdate2 = REPLACE(CONVERT(VARCHAR(8), GETDATE(), 108), '':'', '''')
--create table #partition(partname nvarchar(4000))

if (@litespeed not in (''N'',''Y'')) or (@force_flag not in (''N'',''Y''))
BEGIN
	PRINT ''Specify the correct value for litespeed  and force_flag input parameter''
	return -1
END

if (@database_name is null)
begin
	select @dbname = db_name()
	if not exists (select 1 from t_backup_partition where partname = @dbname and type = ''F'')
	begin
			exec Backup_partitions_full @path,@dbname,''Y''
	end
	else
	begin
		if (@litespeed = ''N'')
		begin
			SET @SQLStmt = ''backup database '' + @dbname + '' to disk='''''' + @path + ''\'' + @dbname + ''_D_'' 
				+ @getdate1 + @getdate2 + ''.BAK'''' with DIFFERENTIAL,init,skip''
		end
		else
		begin
			SET @SQLStmt = ''EXEC master.dbo.xp_backup_database @database='''''' + @dbname + '''''' ,@filename='''''' + @path + ''\'' + @dbname + ''_D_'' 
				+ @getdate1 + @getdate2 + ''.BAK'''' ,@with = ''''DIFFERENTIAL'''',@init= 1, @compressionlevel=3''
		end
		PRINT @SQLStmt 
		EXECUTE (@SQLStmt)
		insert into t_backup_partition(partname,type,last_backup_time,partition_status)
		values ( @dbname,''D'',@getdate,''O'')
	end	
	DECLARE part CURSOR FOR select partition_name from t_partition --where dbname not in (select name from t_archive_partition)
	open part
	fetch part into @partname
	WHILE @@FETCH_STATUS = 0
	BEGIN
		if not exists (select 1 from t_backup_partition where partname = @partname and type = ''F'')
		begin
			exec Backup_partitions_full @path,@partname,''Y''
		end
		else
		begin
			--print @partname
			select @intervalstart = id_interval_start, @intervalend= id_interval_end from t_partition 
			where partition_name = @partname
			if exists 
				(
				select 1 from t_usage_interval
				where tx_interval_status <> ''H''
				and id_interval between @intervalstart and @intervalend
				and not exists (select 1 from t_archive_partition where partition_name=@partname
				and status = ''A'' and tt_end = @maxdate)			
				union all
				select 1 from t_partition where partition_name = @partname and b_default = ''Y''
				union all
				select 1 from t_partition where id_partition not in
				(select id_partition from t_partition_interval_map)
				and partition_name = @partname)
			begin
				if (@litespeed = ''N'')
				begin
					SET @SQLStmt = ''backup database '' + @partname + '' to disk='''''' + @path + ''\'' + @partname + ''_D_'' 
						+ @getdate1 + @getdate2 + ''.BAK'''' with DIFFERENTIAL,init,skip''
				end
				else
				begin
					SET @SQLStmt = ''EXEC master.dbo.xp_backup_database @database='''''' + @partname + '''''' ,@filename='''''' + @path + ''\'' + @partname + ''_D_'' 
						+ @getdate1 + @getdate2 + ''.BAK'''' ,@with = ''''DIFFERENTIAL'''',@init= 1, @compressionlevel=3''
				end
	      PRINT @SQLStmt 
	      EXECUTE (@SQLStmt)
				insert into t_backup_partition(partname,type,last_backup_time,partition_status)
				values ( @partname,''D'',@getdate,''O'')
				set @rowcount = @@rowcount
			end
			if (@rowcount = 0)
			begin 
				if exists 
					(select 1 from t_partition part
					inner join t_archive_partition archive
					on part.partition_name = archive.partition_name
					where part.partition_name = @partname
					and not exists
						(select 1 from t_backup_partition back1
						where part.partition_name = back1.partname
						and
						((back1.last_backup_time is not null and type = ''F'' and partition_status = ''A'') or (last_backup_time is not null and type = ''D'' and partition_status = ''A''))
						and not exists (select 1 from t_query_log log1
						where log1.c_timestamp > back1.last_backup_time))
						and status = ''A'' and tt_end=@maxdate
					)
				begin
						if (@litespeed = ''N'')
						begin
							SET @SQLStmt = ''backup database '' + @partname + '' to disk='''''' + @path + ''\'' + @partname + ''_D_A_'' 
								+ @getdate1 + @getdate2 + ''.BAK'''' with DIFFERENTIAL,init,skip''
						end
						else
						begin
							SET @SQLStmt = ''EXEC master.dbo.xp_backup_database @database='''''' + @partname + '''''' ,@filename='''''' + @path + ''\'' + @partname + ''_D_A_'' 
								+ @getdate1 + @getdate2 + ''.BAK'''' ,@with = ''''DIFFERENTIAL'''',@init= 1, @compressionlevel=3''
						end
			      PRINT @SQLStmt 
			      EXECUTE (@SQLStmt)
						insert into t_backup_partition(partname,type,last_backup_time,partition_status)
						values ( @partname,''D'',@getdate,''A'')
						set @rowcount = @@rowcount
				end
			end
			if (@rowcount = 0)
			begin 
				if exists 
					(select 1 from t_partition part
					where partition_name = @partname
					and id_partition in
					(select id_partition from t_partition_interval_map)
					and @partname not in (select partition_name from t_partition where b_default = ''Y'')
					and not exists
						(
						select 1 from t_usage_interval usage
						where tx_interval_status <> ''H''
						and id_interval between @intervalstart and @intervalend
						)
					and not exists
					(
					select 1 from t_backup_partition back1
					where part.partition_name = back1.partname
					and
					((back1.last_backup_time is not null and type = ''F'' and partition_status = ''A'') or (back1.last_backup_time is not null and type = ''F'' and partition_status = ''H'') 
					or (last_backup_time is not null and type = ''D'' and partition_status = ''H'') or (last_backup_time is not null and type = ''D'' and partition_status = ''A''))
						and not exists (select 1 from t_query_log log1
						where log1.c_timestamp > back1.last_backup_time))
					)
				begin
						if (@litespeed = ''N'')
						begin
							SET @SQLStmt = ''backup database '' + @partname + '' to disk='''''' + @path + ''\'' + @partname + ''_D_H_'' 
								+ @getdate1 + @getdate2 + ''.BAK'''' with DIFFERENTIAL,init,skip''
						end
						else
						begin
							SET @SQLStmt = ''EXEC master.dbo.xp_backup_database @database='''''' + @partname + '''''' ,@filename='''''' + @path + ''\'' + @partname + ''_D_H_'' 
								+ @getdate1 + @getdate2 + ''.BAK'''' ,@with = ''''DIFFERENTIAL'''',@init= 1, @compressionlevel=3''
						end
			      PRINT @SQLStmt 
			      EXECUTE (@SQLStmt)
						insert into t_backup_partition(partname,type,last_backup_time,partition_status)
						values ( @partname,''D'',@getdate,''H'')
						set @rowcount = @@rowcount
				end
			end
		set @rowcount = 0
		end
		fetch next from part into @partname
		end
		close part
		deallocate part
	end
else
begin
	if not exists (select 1 from t_backup_partition where partname = @database_name and type = ''F'')
	begin
			exec Backup_partitions_full @path,@database_name,''Y''
	end
	else
	begin
		if not exists (select 1 from t_partition where partition_name = @database_name)
		begin
			if (@litespeed = ''N'')
			begin
				SET @SQLStmt = ''backup database '' + @database_name + '' to disk='''''' + @path + ''\'' + @database_name + ''_D_'' 
					+ @getdate1 + @getdate2 + ''.BAK'''' with DIFFERENTIAL,init,skip''
			end
			else
			begin
				SET @SQLStmt = ''EXEC master.dbo.xp_backup_database @database='''''' + @database_name + '''''' ,@filename='''''' + @path + ''\'' + @database_name + ''_D_'' 
					+ @getdate1 + @getdate2 + ''.BAK'''' ,@with = ''''DIFFERENTIAL'''',@init= 1, @compressionlevel=3''
			end
			PRINT @SQLStmt 
			EXECUTE (@SQLStmt)
			insert into t_backup_partition(partname,type,last_backup_time,partition_status)
			values ( @database_name,''D'',@getdate,''O'')
		end
		else
		begin
			select @intervalstart = id_interval_start, @intervalend= id_interval_end from t_partition 
			where partition_name = @database_name
			if exists (select 1 from t_usage_interval
				where tx_interval_status <> ''H''
				and id_interval between @intervalstart and @intervalend
				and not exists (select 1 from t_archive_partition where partition_name=@database_name
				and status = ''A'' and tt_end = @maxdate)
				union all
				select 1 from t_partition where partition_name = @database_name and b_default = ''Y''
				union all
				select 1 from t_partition where id_partition not in
				(select id_partition from t_partition_interval_map)
				and partition_name = @database_name)
				begin
					if (@litespeed = ''N'')
					begin
						SET @SQLStmt = ''backup database '' + @database_name + '' to disk='''''' + @path + ''\'' + @database_name + ''_D_'' 
							+ @getdate1 + @getdate2 + ''.BAK'''' with DIFFERENTIAL,init,skip''
					end
					else
					begin
						SET @SQLStmt = ''EXEC master.dbo.xp_backup_database @database='''''' + @database_name + '''''' ,@filename='''''' + @path + ''\'' + @database_name + ''_D_'' 
							+ @getdate1 + @getdate2 + ''.BAK'''' ,@with = ''''DIFFERENTIAL'''',@init= 1, @compressionlevel=3''
					end
		      PRINT @SQLStmt 
		      EXECUTE (@SQLStmt)
					insert into t_backup_partition(partname,type,last_backup_time,partition_status)
					values ( @database_name,''D'',@getdate,''O'')
					set @rowcount = @@rowcount
			end
			if (@rowcount = 0)
			begin 
				if exists 
					(select 1 from t_partition part
					inner join t_archive_partition archive
					on part.partition_name = archive.partition_name
					where part.partition_name = @database_name
					and (not exists
						(select 1 from t_backup_partition back1
						where part.partition_name = back1.partname
						and
						((back1.last_backup_time is not null and type = ''F'' and partition_status = ''A'') or (last_backup_time is not null and type = ''D'' and partition_status = ''A''))
						and not exists (select 1 from t_query_log log1
						where log1.c_timestamp > back1.last_backup_time))
						or
						(@force_flag = ''Y''))
					and status = ''A'' and tt_end=@maxdate
					)
				begin
						if (@litespeed = ''N'')
						begin
							SET @SQLStmt = ''backup database '' + @database_name + '' to disk='''''' + @path + ''\'' + @database_name + ''_D_A_'' 
								+ @getdate1 + @getdate2 + ''.BAK'''' with DIFFERENTIAL,init,skip''
						end
						else
						begin
							SET @SQLStmt = ''EXEC master.dbo.xp_backup_database @database='''''' + @database_name + '''''' ,@filename='''''' + @path + ''\'' + @database_name + ''_D_A_'' 
								+ @getdate1 + @getdate2 + ''.BAK'''' ,@with = ''''DIFFERENTIAL'''',@init= 1, @compressionlevel=3''
						end
			      PRINT @SQLStmt 
			      EXECUTE (@SQLStmt)
						insert into t_backup_partition(partname,type,last_backup_time,partition_status)
						values ( @database_name,''D'',@getdate,''A'')
						set @rowcount = @@rowcount
				end	
			end
			if (@rowcount = 0)
			begin 
				if exists 
					(select 1 from t_partition part
					where partition_name = @database_name
					and id_partition in
						(select id_partition from t_partition_interval_map)
					and not exists
						(
						select 1 from t_usage_interval usage
						where tx_interval_status <> ''H''
						and id_interval between @intervalstart and @intervalend
						)
					and (not exists
					(
					select 1 from t_backup_partition back1
					where part.partition_name = back1.partname
					and
					((back1.last_backup_time is not null and type = ''F'' and partition_status = ''H'') or (back1.last_backup_time is not null and type = ''F'' and partition_status = ''A'') 
					or (last_backup_time is not null and type = ''D'' and partition_status = ''H'') or (last_backup_time is not null and type = ''D'' and partition_status = ''A''))
						and not exists (select 1 from t_query_log log1
						where log1.c_timestamp > back1.last_backup_time))
					)
					or
					(@force_flag = ''Y''))
				begin
					if (@litespeed = ''N'')
					begin
						SET @SQLStmt = ''backup database '' + @database_name + '' to disk='''''' + @path + ''\'' + @database_name + ''_D_H_'' 
							+ @getdate1 + @getdate2 + ''.BAK'''' with DIFFERENTIAL,init,skip''
					end
					else
					begin
						SET @SQLStmt = ''EXEC master.dbo.xp_backup_database @database='''''' + @database_name + '''''' ,@filename='''''' + @path + ''\'' + @database_name + ''_D_H_'' 
							+ @getdate1 + @getdate2 + ''.BAK'''' ,@with = ''''DIFFERENTIAL'''',@init= 1, @compressionlevel=3''
					end
		      PRINT @SQLStmt 
		      EXECUTE (@SQLStmt)
					insert into t_backup_partition(partname,type,last_backup_time,partition_status)
					values ( @database_name,''D'',@getdate,''H'')
					set @rowcount = @@rowcount
				end
			end
		end	
	end
end
RETURN 0 
END
 	' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdStateFromClosedToArchived]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdStateFromClosedToArchived]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				CREATE PROCEDURE [dbo].[UpdStateFromClosedToArchived] (
					@system_date datetime,
					@dt_start datetime,
					@dt_end datetime,
					@age int,
					@status INT output)
				AS
				Begin
					declare @varMaxDateTime datetime
					declare @varSystemGMTDateTimeSOD datetime

					SELECT @status = -1

					-- Use the true current GMT time for the tt_ dates
					SELECT @varSystemGMTDateTimeSOD = dbo.mtstartofday(@system_date)

					-- Set the maxdatetime into a variable
					SELECT @varMaxDateTime = dbo.MTMaxDate()

					-- Save the id_acc
					CREATE TABLE #updatestate_1(id_acc int)
					INSERT INTO #updatestate_1 (id_acc)
					SELECT ast.id_acc 
					FROM t_account_state ast
					WHERE ast.vt_end = @varMaxDateTime
					AND ast.status = ''CL'' 
					AND ast.vt_start BETWEEN (dbo.mtstartofday(@dt_start) - @age) AND 
					                         (DATEADD(s, -1, dbo.mtstartofday(@dt_end) + 1) - @age)

					EXECUTE UpdateStateRecordSet
					@system_date,
					@varSystemGMTDateTimeSOD,
					''CL'', ''AR'',
					@status OUTPUT

					DROP TABLE #updatestate_1
					
					RETURN
				END
				' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdateStateFromClosedToPFB]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateStateFromClosedToPFB]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				CREATE PROCEDURE [dbo].[UpdateStateFromClosedToPFB] (
					@system_date datetime,
					@dt_start datetime,
					@dt_end datetime,
					@status INT output)
				AS
				Begin
					declare @varMaxDateTime datetime
					declare @varSystemGMTDateTime datetime 
					declare @varSystemGMTBDateTime datetime  
					declare @varSystemGMTEDateTime datetime 
					declare @ref_date_mod DATETIME

					select @status = -1

					-- Use the true current GMT time for the tt_ dates
					SELECT @varSystemGMTDateTime = @system_date

					-- Set the maxdatetime into a variable
					select @varMaxDateTime = dbo.MTMaxDate()

					select @varSystemGMTBDateTime = dbo.mtstartofday(@dt_start - 1)
					select @varSystemGMTEDateTime = DATEADD(s, -1, dbo.mtstartofday(@dt_end) + 1)

					-- Save those id_acc whose state MAY be updated to a temp table (had usage the previous day)
					create table #updatestate_0 (id_acc int)
					INSERT INTO #updatestate_0 (id_acc)
					SELECT DISTINCT id_acc 
					FROM (SELECT id_acc FROM t_acc_usage au
					      WHERE au.dt_crt between @varSystemGMTBDateTime and @varSystemGMTEDateTime) ttt
					-- Also save id_acc that had adjustments in the approved state
					UNION
					SELECT DISTINCT id_acc_payer AS id_acc 
  					FROM (SELECT id_acc_payer FROM t_adjustment_transaction ajt
					      WHERE  ajt.c_status = ''A'' AND 
					      ajt.dt_modified between @varSystemGMTBDateTime and @varSystemGMTEDateTime) ttt
					-- Save those id_acc whose state WILL be updated to a temp 
					-- table (has CL state)
					create table #updatestate_1(id_acc int)
					INSERT INTO #updatestate_1 (id_acc)
					SELECT tmp0.id_acc 
					FROM t_account_state ast, #updatestate_0 tmp0
					WHERE ast.id_acc = tmp0.id_acc
					AND ast.vt_end = @varMaxDateTime
					AND ast.status = ''CL''

					EXECUTE UpdateStateRecordSet
					@system_date,
					@varSystemGMTDateTime,
					''CL'', ''PF'',
					@status OUTPUT

					DROP TABLE #updatestate_0
					DROP TABLE #updatestate_1
					
					RETURN
				END
				' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdateStateFromPFBToClosed]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateStateFromPFBToClosed]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				CREATE proc [dbo].[UpdateStateFromPFBToClosed] (
					@id_billgroup INT,
					@ref_date DATETIME,
					@system_date datetime,
					@status INT OUTPUT)
				AS
 				BEGIN
					DECLARE @ref_date_mod DATETIME, @varMaxDateTime DATETIME, @ref_date_modSOD DATETIME

					SELECT @status = -1
					-- Set the maxdatetime into a variable
					SELECT @varMaxDateTime = dbo.MTMaxDate()

					IF (@ref_date IS NULL)
					BEGIN
						SELECT @ref_date_mod = @system_date
					END
					ELSE
					BEGIN
						SELECT @ref_date_mod = @ref_date
					END

					SELECT @ref_date_modSOD = dbo.mtstartofday(@ref_date_mod)

					-- Save those id_acc whose state MAY be updated to a temp table 
					-- (had usage the previous day)
					CREATE TABLE #updatestate_0 (id_acc int)
					INSERT INTO #updatestate_0 (id_acc)
					SELECT id_acc 
					FROM t_billgroup_member
					WHERE id_billgroup = @id_billgroup

          -- Add the payees for the payers
          INSERT INTO #updatestate_0 (id_acc)
	        SELECT pa.id_payee 
	        FROM t_billgroup_member bgm
          INNER JOIN t_payment_redirection pa ON pa.id_payer = bgm.id_acc
          WHERE bgm.id_billgroup = @id_billgroup AND
                @ref_date_mod between pa.vt_start AND pa.vt_end AND
                pa.id_payee NOT IN (SELECT id_acc FROM #updatestate_0)

					-- Save those id_acc whose state WILL be updated to a temp 
					-- table (has PF state)
					CREATE TABLE #updatestate_1(id_acc int)
					INSERT INTO #updatestate_1 (id_acc)
					SELECT tmp0.id_acc 
					FROM t_account_state ast, #updatestate_0 tmp0
					WHERE ast.id_acc = tmp0.id_acc
					AND ast.vt_end = @varMaxDateTime
					AND ast.status = ''PF''
					AND @ref_date_mod BETWEEN vt_start and vt_end

					-- ------------------------------------------------------------
					-- ------------------- t_sub & t_sub_history ------------------
					-- ------------------------------------------------------------
					-- update all of the current subscriptions in t_sub_history 
					-- where the account ID matches and tt_end = dbo.mtmaxdate().  
					-- Set tt_end = systemtime.

					-- add a new record to t_sub_history where vt_end is the account 
					-- close date.
					-- Update the end date of the relevant subscriptions in t_sub 
					-- where id_acc = closed accounts
					-- Set vt_end = account close date.

					-- follow same pattern for t_gsubmember_historical and t_gsubmember.
					declare @varSystemGMTDateTime datetime
					SELECT @varSystemGMTDateTime = @system_date
					declare @rowcnt int
					SELECT @rowcnt = count(*)
					FROM #updatestate_1

					IF @rowcnt > 0
					BEGIN
					UPDATE t_sub_history 
					SET tt_end = DATEADD(ms, -10, @varSystemGMTDateTime)
					WHERE ((@ref_date_mod between vt_start and vt_end) OR 
					       (@ref_date_mod <= vt_start))
					AND tt_end = @varMaxDateTime
					AND EXISTS (SELECT NULL FROM #updatestate_1 tmp
							WHERE tmp.id_acc = t_sub_history.id_acc)

					INSERT INTO t_sub_history (
						id_sub,
						id_sub_ext,
						id_acc,
						id_po,
						dt_crt,
						id_group,
						vt_start,
						vt_end,
						tt_start,
						tt_end )
					SELECT 
						sub.id_sub,
						sub.id_sub_ext,
						sub.id_acc,
						sub.id_po,
						sub.dt_crt,
						sub.id_group,
						sub.vt_start,
						--@ref_date_mod,
						dbo.subtractsecond(@ref_date_modSOD),
						@varSystemGMTDateTime,
						@varMaxDateTime
					FROM t_sub sub, #updatestate_1 tmp
					WHERE sub.id_acc = tmp.id_acc
					AND ((@ref_date_mod between sub.vt_start and sub.vt_end) OR 
					     (@ref_date_mod <= vt_start))

					-- Update the vt_end field of the Current records for the accounts
					UPDATE t_sub 
					SET vt_end = dbo.subtractsecond(@ref_date_modSOD)
					WHERE ((@ref_date_mod between vt_start and vt_end) OR 
					       (@ref_date_mod <= vt_start))
					AND EXISTS (SELECT NULL FROM #updatestate_1 tmp
							WHERE tmp.id_acc = t_sub.id_acc)
					-- ------------------------------------------------------------
					-- ------------------- t_sub & t_sub_history ------------------
					-- ------------------------------------------------------------

					-- ------------------------------------------------------------
					-- ------------ t_gsubmember & t_gsubmember_historical --------
					-- ------------------------------------------------------------
					UPDATE t_gsubmember_historical 
					SET tt_end = DATEADD(ms, -10, @varSystemGMTDateTime)
					WHERE ((@ref_date_mod between vt_start and vt_end) OR 
					       (@ref_date_mod <= vt_start))
					AND tt_end = @varMaxDateTime
					AND EXISTS (SELECT NULL FROM #updatestate_1 tmp
							WHERE tmp.id_acc = t_gsubmember_historical.id_acc)

					INSERT INTO t_gsubmember_historical (
						id_group,
						id_acc,
						vt_start,
						vt_end,
						tt_start,
						tt_end)
					SELECT 
						gsub.id_group,
						gsub.id_acc,
						gsub.vt_start,
						dbo.subtractsecond(@ref_date_modSOD),
						@varSystemGMTDateTime,
						@varMaxDateTime
					FROM t_gsubmember gsub, #updatestate_1 tmp
					WHERE gsub.id_acc = tmp.id_acc
					AND ((@ref_date_mod between vt_start and vt_end) OR 
				       (@ref_date_mod <= vt_start))

					-- Update the vt_end field of the Current records for the accounts
					UPDATE t_gsubmember 
					SET vt_end = dbo.subtractsecond(@ref_date_modSOD)
					WHERE ((@ref_date_mod between vt_start and vt_end) OR 
					       (@ref_date_mod <= vt_start))
					AND EXISTS (SELECT NULL FROM #updatestate_1 tmp
							WHERE tmp.id_acc = t_gsubmember.id_acc)
					END
					-- ------------------------------------------------------------
					-- ------------ t_gsubmember & t_gsubmember_historical --------
					-- ------------------------------------------------------------
					EXECUTE UpdateStateRecordSet
					@system_date,
					@ref_date_mod,
					''PF'', ''CL'',
					@status OUTPUT

					DROP TABLE #updatestate_0
					DROP TABLE #updatestate_1

					RETURN
				END
				' 
END
GO
/****** Object:  StoredProcedure [dbo].[Rev_UpdStateFromClosedToArchiv]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Rev_UpdStateFromClosedToArchiv]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				CREATE PROCEDURE [dbo].[Rev_UpdStateFromClosedToArchiv] (
					@system_date datetime, -- no longer used, 2-21-2003
					@dt_start datetime,
					@dt_end datetime,
					@age int,
					@status INT output)
				AS
				Begin
					declare @varMaxDateTime datetime
					-- declare @varSystemGMTDateTimeSOD datetime

					SELECT @status = -1

					-- Use the true current GMT time for the tt_ dates
					-- SELECT @varSystemGMTDateTimeSOD = dbo.mtstartofday(@system_date)

					-- Set the maxdatetime into a variable
					SELECT @varMaxDateTime = dbo.MTMaxDate()

					-- ======================================================================
					-- Identify the id_accs whose state need to be reversed to ''CL'' from ''AR''

					-- Save the id_acc
					CREATE TABLE #updatestate_00 (id_acc int)
					INSERT INTO  #updatestate_00 (id_acc)
					SELECT DISTINCT ast.id_acc 
					FROM t_account_state ast
					WHERE ast.status = ''CL'' 
					AND ast.vt_start BETWEEN (dbo.mtstartofday(@dt_start) - @age) AND 
					                         (DATEADD(s, -1, dbo.mtstartofday(@dt_end) + 1) - @age)
 					if (@@error <>0)
					begin
	  					RETURN
					end

					-- Currently have ''AR'' state
					CREATE TABLE #updatestate_0 (id_acc int, vt_start datetime, tt_start datetime)
					INSERT INTO  #updatestate_0 (id_acc, vt_start, tt_start)
					SELECT tmp.id_acc, ash.vt_start, ash.tt_start
					FROM #updatestate_00 tmp
					INNER JOIN t_account_state_history ash
						ON ash.id_acc = tmp.id_acc
						AND ash.status = ''AR''
						AND ash.tt_end = @varMaxDateTime 
						AND ash.vt_end = @varMaxDateTime 
						--AND ash.tt_start >= @system_date
 					if (@@error <>0)
					begin
	  					RETURN
					end

					-- Make sure these ''AR'' id_accs were immediately from the ''CL'' status
					-- And save these id_accs whose state WILL be updated to a temp 
					CREATE TABLE #updatestate_1(id_acc int, tt_end datetime)
					INSERT INTO #updatestate_1 (id_acc, tt_end)
					SELECT tmp.id_acc, ash.tt_end
					FROM #updatestate_0 tmp
					INNER JOIN t_account_state_history ash
						ON ash.id_acc = tmp.id_acc
						AND ash.status = ''CL''
						AND ash.vt_start < tmp.vt_start
						AND ash.vt_end = @varMaxDateTime 
						AND ash.tt_end = DATEADD(ms, -10, tmp.tt_start)
 					if (@@error <>0)
					begin
	  					RETURN
					end

					-- Reverse actions for the identified id_accs
					EXEC Reverse_UpdateStateRecordSet @system_date, @status OUTPUT

					DROP TABLE #updatestate_0
					DROP TABLE #updatestate_00
					DROP TABLE #updatestate_1
					
					--select @status=1
					RETURN
				END
				' 
END
GO
/****** Object:  StoredProcedure [dbo].[Rev_Updatestatefromclosedtopfb]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Rev_Updatestatefromclosedtopfb]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				CREATE PROCEDURE [dbo].[Rev_Updatestatefromclosedtopfb](
					@system_date datetime,
					@dt_start datetime,
					@dt_end datetime,
					@status INT output)
				AS
				Begin
					declare @varMaxDateTime datetime
					declare @varSystemGMTDateTime datetime 
					declare @varSystemGMTBDateTime datetime  
					declare @varSystemGMTEDateTime datetime 

					select @status = -1

					-- Use the true current GMT time for the tt_ dates
					SELECT @varSystemGMTDateTime = @system_date

					-- Set the maxdatetime into a variable
					select @varMaxDateTime = dbo.MTMaxDate()

					select @varSystemGMTBDateTime = dbo.mtstartofday(@dt_start - 1)
					select @varSystemGMTEDateTime = DATEADD(s, -1, dbo.mtstartofday(@dt_end) + 1)

					-- ======================================================================
					-- Identify the id_accs whose state need to be reversed to ''CL'' from ''PF''

					-- Save those id_acc whose state MAY be updated to a temp table
					-- (had usage between @dt_start and @dt_end)
					CREATE TABLE #updatestate_00 (id_acc int)
					INSERT INTO  #updatestate_00 (id_acc)
					SELECT DISTINCT id_acc 
					FROM (SELECT id_acc FROM t_acc_usage au
					      WHERE au.dt_crt between @varSystemGMTBDateTime and @varSystemGMTEDateTime) ttt
					-- consider adjustments as well as usage
					UNION 
					  SELECT DISTINCT id_acc_payer AS id_acc
  					FROM (SELECT id_acc_payer FROM t_adjustment_transaction ajt
					WHERE  ajt.c_status = ''A'' AND 
						ajt.dt_modified between @varSystemGMTBDateTime and @varSystemGMTEDateTime) ttt
 					if (@@error <>0)
					begin
	  					RETURN
					end

					-- Currently have ''PF'' state
					CREATE TABLE #updatestate_0 (id_acc int, vt_start datetime, tt_start datetime)
					INSERT INTO  #updatestate_0 (id_acc, vt_start, tt_start)
					SELECT tmp.id_acc, ash.vt_start, ash.tt_start
					FROM #updatestate_00 tmp
					INNER JOIN t_account_state_history ash
						ON ash.id_acc = tmp.id_acc
						AND ash.status = ''PF''
						AND ash.tt_end = @varMaxDateTime 
						AND ash.tt_start >= @system_date
 					if (@@error <>0)
					begin
	  					RETURN
					end

					-- Make sure these ''PF'' id_accs were immediately from the ''CL'' status
					-- And save these id_accs whose state WILL be updated to a temp 
					CREATE TABLE #updatestate_1(id_acc int, tt_end datetime)
					INSERT INTO #updatestate_1 (id_acc, tt_end)
					SELECT tmp.id_acc, ash.tt_end
					FROM #updatestate_0 tmp
					INNER JOIN t_account_state_history ash
						ON ash.id_acc = tmp.id_acc
						AND ash.status = ''CL''
						AND ash.vt_start < tmp.vt_start
						AND ash.vt_end = @varMaxDateTime 
						AND ash.tt_end = DATEADD(ms, -10, tmp.tt_start)
 					if (@@error <>0)
					begin
	  					RETURN
					end

					-- Reverse actions for the identified id_accs
					EXEC Reverse_UpdateStateRecordSet @system_date, @status OUTPUT

					DROP TABLE #updatestate_0
					DROP TABLE #updatestate_00
					DROP TABLE #updatestate_1
					
					--select @status=1
					RETURN
				END
				' 
END
GO
/****** Object:  StoredProcedure [dbo].[Rev_UpdateStateFromPFBToClosed]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[Rev_UpdateStateFromPFBToClosed]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				CREATE PROCEDURE [dbo].[Rev_UpdateStateFromPFBToClosed] (
					@id_billgroup INT,
					@ref_date DATETIME,
					@system_date datetime,
					@status INT OUTPUT)
				AS
 				BEGIN
					DECLARE @ref_date_mod DATETIME, 
						@varMaxDateTime DATETIME,
						@ref_date_modSOD DATETIME

					SELECT @status = -1
					-- Set the maxdatetime into a variable
					SELECT @varMaxDateTime = dbo.MTMaxDate()

					IF (@ref_date IS NULL)
					BEGIN
						SELECT @ref_date_mod = @system_date
					END
					ELSE
					BEGIN
						SELECT @ref_date_mod = @ref_date
					END

					SELECT @ref_date_modSOD = dbo.mtstartofday(@ref_date_mod)

					-- Save those id_acc whose state MAY be reversed to a temp table 
					CREATE TABLE #updatestate_0 (id_acc int, vt_start datetime, tt_start datetime)

					INSERT INTO #updatestate_0 (id_acc, vt_start, tt_start)
					SELECT bg.id_acc, ash.vt_start, ash.tt_start
					FROM t_billgroup_member bg
					INNER JOIN t_billgroup_materialization bgm 
						ON bg.id_materialization = bgm.id_materialization
					INNER JOIN t_usage_interval ui 
						ON ui.id_interval = bgm.id_usage_interval
					INNER JOIN t_account_state_history ash
						ON ash.id_acc = bg.id_acc
						AND ash.status = ''CL''
						AND ash.tt_end = @varMaxDateTime 
						AND ash.tt_start > ui.dt_end
					WHERE bg.id_billgroup = @id_billgroup
 					if (@@error <>0)
					begin
	  					RETURN
					end

					-- Add the payees for the payers selected in the previous step
					INSERT INTO #updatestate_0 (id_acc, vt_start, tt_start)
					SELECT pa.id_payee, ash.vt_start, ash.tt_start
					FROM t_billgroup_member bg
					INNER JOIN t_billgroup_materialization bgm 
						ON bg.id_materialization = bgm.id_materialization
					INNER JOIN t_usage_interval ui 
						ON ui.id_interval = bgm.id_usage_interval
					INNER JOIN t_payment_redirection pa 
					  ON pa.id_payer = bg.id_acc
					INNER JOIN t_account_state_history ash
						ON ash.id_acc = pa.id_payee
						AND ash.status = ''CL''
						AND ash.tt_end = @varMaxDateTime 
						AND ash.tt_start > ui.dt_end
					WHERE bg.id_billgroup = @id_billgroup AND
					      pa.id_payee NOT IN (SELECT id_acc FROM #updatestate_0)
 					if (@@error <>0)
					begin
	  					RETURN
					end


					-- Make sure these ''CL'' id_accs were immediately from the ''PF'' status
					-- And save those id_acc whose state WILL be updated to a temp 
					CREATE TABLE #updatestate_1(id_acc int, tt_end datetime)

					INSERT INTO #updatestate_1 (id_acc, tt_end)
					SELECT tmp.id_acc, ash.tt_end
					FROM #updatestate_0 tmp
					INNER JOIN t_account_state_history ash
						ON ash.id_acc = tmp.id_acc
						AND ash.status = ''PF''
						AND ash.vt_start < tmp.vt_start
						AND ash.vt_end = @varMaxDateTime 
						AND ash.tt_end = DATEADD(ms, -10, tmp.tt_start)
 					if (@@error <>0)
					begin
	  					RETURN
					end

					-- follow same pattern for t_gsubmember_historical and t_gsubmember.
					declare @varSystemGMTDateTime datetime
					SELECT @varSystemGMTDateTime = @system_date
					declare @rowcnt int
					SELECT @rowcnt = count(*)
					FROM #updatestate_1
 					if (@@error <>0)
					begin
	  					RETURN
					end

					IF @rowcnt > 0
					BEGIN
					-- ------------------------------------------------------------
					-- ------------------- reverse t_sub & t_sub_history ------------------
					-- ------------------------------------------------------------

						-- Find those records that were updated by the PFBToCL 
						-- and have not yet been updated again
						-- and thus can be reversed
						SELECT sh2.id_sub, sh2.vt_end, sh2.tt_end
						INTO #updatesub_1
						FROM (SELECT sh.id_sub, sh.tt_start
							FROM t_sub_history sh
							INNER JOIN #updatestate_1 tmp
								ON tmp.id_acc = sh.id_acc
								AND sh.vt_end = DATEADD(s, -1, @ref_date_modSOD)
								AND sh.tt_end = @varMaxDateTime
							) rev
						INNER JOIN t_sub_history sh2
							ON sh2.id_sub = rev.id_sub
							AND sh2.tt_end = DATEADD(ms, -10, rev.tt_start)
 						if (@@error <>0)
						begin
	  						RETURN
						end

						UPDATE t_sub_history
						SET tt_end = DATEADD(ms, -10, @system_date)
						FROM t_sub_history sh
						INNER JOIN #updatesub_1 tmp
							ON tmp.id_sub = sh.id_sub
							AND sh.tt_end = @varMaxDateTime
 						if (@@error <>0)
						begin
	  						RETURN
						end

						INSERT INTO t_sub_history
						(id_sub,id_sub_ext,id_acc,id_po,dt_crt,id_group,vt_start,vt_end,tt_start,tt_end )
						SELECT sh.id_sub,sh.id_sub_ext,sh.id_acc,sh.id_po,
							sh.dt_crt,sh.id_group,sh.vt_start,sh.vt_end,
							@system_date,@varMaxDateTime
						FROM t_sub_history sh
						INNER JOIN #updatesub_1 tmp
							ON tmp.id_sub = sh.id_sub
							AND tmp.tt_end = sh.tt_end
 						if (@@error <>0)
						begin
	  						RETURN
						end

						UPDATE t_sub
						SET vt_end = tmp.vt_end
						FROM t_sub sh
						INNER JOIN #updatesub_1 tmp
							ON tmp.id_sub = sh.id_sub
 						if (@@error <>0)
						begin
	  						RETURN
						end
					-- ------------------------------------------------------------
					-- ------------------- t_sub & t_sub_history ------------------
					-- ------------------------------------------------------------

					-- ------------------------------------------------------------
					-- ------------ reverse t_gsubmember & t_gsubmember_historical --------
					-- ------------------------------------------------------------

						-- Find those records that were updated by the PFBToCL 
						-- and have not yet been updated again
						-- and thus can be reversed
						SELECT gh2.id_group, gh2.id_acc, gh2.vt_start, gh2.vt_end, gh2.tt_end
						INTO #updategsub_1
						FROM (SELECT gh.id_group, gh.id_acc, gh.vt_start, gh.vt_end, gh.tt_start
							FROM t_gsubmember_historical gh
							INNER JOIN #updatestate_1 tmp
								ON tmp.id_acc = gh.id_acc
								AND gh.vt_end = DATEADD(s, -1, @ref_date_modSOD)
								AND gh.tt_end = @varMaxDateTime
							) rev
						INNER JOIN t_gsubmember_historical gh2
							ON gh2.id_group = rev.id_group
							AND gh2.id_acc = rev.id_acc
							AND gh2.vt_start = rev.vt_start
							AND gh2.tt_end = DATEADD(ms, -10, rev.tt_start)
 						if (@@error <>0)
						begin
	  						RETURN
						end

						UPDATE t_gsubmember_historical
						SET tt_end = DATEADD(ms, -10, @system_date)
						FROM t_gsubmember_historical gh
						INNER JOIN #updategsub_1 tmp
							ON tmp.id_group = gh.id_group
							AND tmp.id_acc = gh.id_acc
							AND tmp.vt_start = gh.vt_start
							AND gh.tt_end = @varMaxDateTime
 						if (@@error <>0)
						begin
	  						RETURN
						end

						INSERT INTO t_gsubmember_historical
						(id_group, id_acc, vt_start, vt_end, tt_start, tt_end)
						SELECT gh.id_group, gh.id_acc, gh.vt_start, gh.vt_end,
							@system_date,@varMaxDateTime
						FROM t_gsubmember_historical gh
						INNER JOIN #updategsub_1 tmp
							ON tmp.id_group = gh.id_group
							AND tmp.id_acc = gh.id_acc
							AND tmp.vt_start = gh.vt_start
							AND tmp.tt_end = gh.tt_end
 						if (@@error <>0)
						begin
	  						RETURN
						end

						UPDATE t_gsubmember
						SET vt_end = tmp.vt_end
						FROM t_gsubmember gh
						INNER JOIN #updategsub_1 tmp
							ON tmp.id_group = gh.id_group
							AND tmp.id_acc = gh.id_acc
							AND tmp.vt_start = gh.vt_start
 						if (@@error <>0)
						begin
	  						RETURN
						end

					-- ------------------------------------------------------------
					-- ------------ t_gsubmember & t_gsubmember_historical --------
					-- ------------------------------------------------------------
					END
					-- Reverse actions for the identified id_accs
					EXEC Reverse_UpdateStateRecordSet @system_date, @status OUTPUT

					--select @status = 1
					DROP TABLE #updatestate_0
					DROP TABLE #updatestate_1

					RETURN
				END
				' 
END
GO
/****** Object:  StoredProcedure [dbo].[CompleteMaterialization]    Script Date: 06/02/2008 11:43:21 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CompleteMaterialization]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
		
/* ===========================================================
1) Copy billing group data from temporary tables to system tables.
2) Update t_billgroup_member_history
3) Update the materialization in 
    t_billgroup_materialization to ''Succeeded''
4) Delete data from temporary tables.

Return:
-1 if unknown error occurred
-2 if each billing group in t_billgroup does not have atleast one account
-3 if something went wrong while executing RefreshBillingGroupConstraints
-4 if something went wrong while executing CleanupMaterialization sproc
=========================================================== */
CREATE PROCEDURE [dbo].[CompleteMaterialization]
(
  @id_materialization INT,
  @dt_end DATETIME,
  @status INT OUTPUT
)
AS

BEGIN
   -- initialize @status to failure (-1)
   SET @status = -1 

   BEGIN TRAN
   -- copy data from t_billgroup_tmp to t_billgroup
   INSERT INTO t_billgroup (id_billgroup, tx_name, tx_description, id_usage_interval, id_parent_billgroup, tx_type)
   SELECT bgt.id_billgroup, bgt.tx_name, bgt.tx_description, bgm.id_usage_interval, bgm.id_parent_billgroup, bgm.tx_type
   FROM t_billgroup_tmp bgt    
   INNER JOIN t_billgroup_materialization bgm ON bgm.id_materialization = bgt.id_materialization
   WHERE bgm.id_materialization = @id_materialization

	--create temp table to hold all the ancestor accounts
  DECLARE @RootBillGroup TABLE (id_billgroup int primary key,id_root_billgroup int)
  INSERT INTO @RootBillGroup select id_billgroup,dbo.GetBillingGroupAncestor(id_billgroup) from t_billgroup_tmp
-- copy data from t_billgroup_member_tmp to t_billgroup_member
  INSERT INTO t_billgroup_member (id_billgroup, id_acc, id_materialization, id_root_billgroup)
  SELECT bgt.id_billgroup, 
              bgmt.id_acc, 
              @id_materialization, 
              rg.id_root_billgroup
  FROM t_billgroup_member_tmp bgmt
  INNER JOIN t_billgroup_tmp bgt 
     ON bgt.tx_name = bgmt.tx_name  
  inner join @RootBillGroup rg on rg.id_billgroup = bgt.id_billgroup
  WHERE bgmt.id_materialization =  @id_materialization AND
              bgt.id_materialization = @id_materialization  
   

-- update t_billgroup_member_history
  declare @maxdate datetime
  set @maxdate = dbo.MTMaxDate()
  INSERT INTO t_billgroup_member_history (id_billgroup, 
                                                                      id_acc, 
                                                                      id_materialization,
                                                                      tx_status,
                                                                      tt_start,
                                                                      tt_end)
  SELECT bgt.id_billgroup, 
              bgmt.id_acc, 
              @id_materialization,
              ''Succeeded'',
              @dt_end,
              @maxdate
  FROM t_billgroup_member_tmp bgmt
  INNER JOIN t_billgroup_tmp bgt 
     ON bgt.tx_name = bgmt.tx_name  
  WHERE bgmt.id_materialization =  @id_materialization AND
              bgt.id_materialization = @id_materialization   

  -- store the id_usage_interval
  DECLARE @id_usage_interval INT
  SELECT @id_usage_interval = id_usage_interval
  FROM t_billgroup_materialization
  WHERE id_materialization = @id_materialization
  
  /* Copy over billing group constraints */
  EXEC ResetBillingGroupConstraints @id_usage_interval, @status OUTPUT
  IF (@status != 0) 
       BEGIN
          SET @status = -2
          ROLLBACK
          RETURN 
       END
   /* Reset status */
   SET @status = -1

   /* Check that each billing group in t_billgroup has atleast one account  */
   IF EXISTS (SELECT bg.id_billgroup
                   FROM t_billgroup bg
                   WHERE bg.id_billgroup NOT IN (SELECT id_billgroup 
                                                                     FROM t_billgroup_member bgm)
					and id_usage_interval = @id_usage_interval)
   BEGIN
      SET @status = -3
      ROLLBACK
      RETURN 
   END

   /* Delete temporary data and update t_billgroup_materialization */
   EXEC CleanupMaterialization @id_materialization, 
                                                @dt_end, 
                                                ''Succeeded'', 
                                                NULL, 
                                                @status OUTPUT

    IF (@status != 0) 
       BEGIN
          SET @status = -4
          ROLLBACK
          RETURN 
       END

   -- set @status to success
   SET @status = 0 

   COMMIT TRAN

END
' 
END
GO
/****** Object:  StoredProcedure [dbo].[SoftCloseBillingGroups]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SoftCloseBillingGroups]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
-- ===========================================================
-- Soft closes one or more billing groups.
-- 1) It is an ERROR for both id_billgroup and id_interval to be non-null
-- 2) If only id_billgroup is non-null, then that billing group will be soft closed, if it is in the ''Open'' state
-- 3) If only id_interval is non-null then all ''Open'' billing groups for that interval will be soft closed
-- 4) If both id_billgroup and id_interval are null, then all ''Open'' billing groups for all intervals 
--     (automatically detected based on grace periods) are soft closed

-- @status is set to the following values:
--   0  - if the procedure executes successfully
--  -1 - if an unknown error occurs
--  -2 - if both @id_billgroup and @id_interval are specified
-- ===========================================================
CREATE PROCEDURE [dbo].[SoftCloseBillingGroups]
(
  @dt_now DATETIME,       -- MetraTech system date
  @id_billgroup INT,          -- specific billing group to close or null 
  @id_interval INT,            -- specific usage interval to close or null for automatic detection based on grace periods
  @pretend INT,                 -- if pretend is true no billing groups are closed but instead are just returned
  @n_count INT OUTPUT,   -- the number of billing groups closed (or that would have been closed)
  @status INT OUTPUT      -- error status
)
AS
  
  BEGIN TRAN

  -- Initialize @status
  SET @status = -1
  -- Initialize @n_count
  SET @n_count = 0

  DECLARE @closing_billgroup TABLE
  (
    id_billgroup INT NOT NULL,
    id_interval INT NOT NULL,
    id_usage_cycle INT NOT NULL,
    id_cycle_type INT NOT NULL,
    dt_start DATETIME NOT NULL,
    dt_end DATETIME NOT NULL,
    tx_billgroup_status VARCHAR(1) NOT NULL
  )

  -- ERROR if both @id_billgroup and @id_interval are non null
  IF (@id_billgroup IS NOT NULL AND @id_interval IS NOT NULL)
  BEGIN
     SET @status = -2
     ROLLBACK
     RETURN 
  END

  -- If both @id_billgroup and @id_interval are NULL, then select all ''Open'' billing groups
  -- for all valid intervals (based on grace periods)
  IF (@id_billgroup IS NULL AND @id_interval IS NULL)
    BEGIN
       -- looks at all the billing groups in the system
       INSERT INTO @closing_billgroup
       SELECT bgs.id_billgroup, 
                   ui.id_interval, 
                   ui.id_usage_cycle, 
                   uct.id_cycle_type, 
                   ui.dt_start, 
                   ui.dt_end, 
                   ''C''
       FROM vw_all_billing_groups_status bgs
       INNER JOIN t_usage_interval ui ON ui.id_interval = bgs.id_usage_interval
       INNER JOIN t_usage_cycle uc ON uc.id_usage_cycle = ui.id_usage_cycle
       INNER JOIN t_usage_cycle_type uct ON uct.id_cycle_type = uc.id_cycle_type
       WHERE
           CASE WHEN uct.n_grace_period IS NOT NULL 
                    THEN ui.dt_end + uct.n_grace_period -- take into account the cycle type''s grace period
                    ELSE @dt_now -- the grace period has been disabled, so don''t close this interval
          END < @dt_now AND
          bgs.Status = ''O'' -- ui.tx_interval_status = ''O''

          -- Set the row count
          SET @n_count = @@ROWCOUNT
    END
  ELSE
    
       -- If only id_interval is non-null then soft close all ''Open'' billing groups for this interval
       --  (regardless of grace period/end date)
       IF (@id_interval IS NOT NULL)
          BEGIN
             INSERT INTO @closing_billgroup
             SELECT bgs.id_billgroup, 
                         ui.id_interval, 
                         ui.id_usage_cycle, 
                         uct.id_cycle_type, 
                         ui.dt_start, 
                         ui.dt_end, 
                         ''C''
             FROM vw_all_billing_groups_status bgs
             INNER JOIN t_usage_interval ui ON ui.id_interval = bgs.id_usage_interval
             INNER JOIN t_usage_cycle uc ON uc.id_usage_cycle = ui.id_usage_cycle
             INNER JOIN t_usage_cycle_type uct ON uct.id_cycle_type = uc.id_cycle_type
             WHERE bgs.status = ''O'' AND 
                         bgs.id_usage_interval = @id_interval

             SET @n_count = @@ROWCOUNT
          END
       ELSE
          BEGIN
             -- If we are here then we have a non null @id_billgroup. Soft close it.
             INSERT INTO @closing_billgroup
             SELECT bgs.id_billgroup, 
                         ui.id_interval, 
                         ui.id_usage_cycle, 
                         uct.id_cycle_type, 
                         ui.dt_start, 
                         ui.dt_end, 
                         ''C''
             FROM vw_all_billing_groups_status bgs
             INNER JOIN t_usage_interval ui ON ui.id_interval = bgs.id_usage_interval
             INNER JOIN t_usage_cycle uc ON uc.id_usage_cycle = ui.id_usage_cycle
             INNER JOIN t_usage_cycle_type uct ON uct.id_cycle_type = uc.id_cycle_type
             WHERE bgs.status = ''O'' AND 
                         bgs.id_billgroup = @id_billgroup

             SET @n_count = @@ROWCOUNT
          END
   -- only closes the billing groups if pretend is false
  IF @pretend = 0
  BEGIN
   
    -- Update the status of the accounts for the billing group in t_acc_usage_interval
    UPDATE aui 
    SET aui.tx_status = ''C''
    FROM t_acc_usage_interval aui 
    INNER JOIN @closing_billgroup cbg 
       ON cbg.id_interval = aui.id_usage_interval
    INNER JOIN t_billgroup_member bgm 
       ON bgm.id_acc = aui.id_acc AND
             bgm.id_billgroup = cbg.id_billgroup

    -- adds instance entries for each billing group that is closed
    INSERT INTO t_recevent_inst(id_event,
                                                  id_arg_billgroup,
                                                  id_arg_root_billgroup,
                                                  id_arg_interval,
                                                  dt_arg_start,
                                                  dt_arg_end,
                                                  b_ignore_deps,
                                                  dt_effective,
                                                  tx_status)
    SELECT 
      evt.id_event id_event,
      CASE WHEN evt.tx_billgroup_support = ''Interval'' THEN NULL 
               ELSE cbg.id_billgroup 
               END id_arg_billgroup,
      CASE WHEN evt.tx_billgroup_support = ''Interval'' THEN NULL 
               ELSE dbo.GetBillingGroupAncestor(cbg.id_billgroup)
               END id_arg_root_billgroup,
      cbg.id_interval id_arg_interval,
      NULL dt_arg_start,
      NULL dt_arg_end,
      ''N'' b_ignore_deps,
      NULL dt_effective,
      -- the start root event is created as Succeeded
      -- the end root event is created as ReadyToRun (for auto hard close)
      -- all others are created as  NotYetRun
      CASE WHEN evt.tx_name = ''_StartRoot'' AND evt.tx_type = ''Root'' THEN ''Succeeded'' 
           WHEN evt.tx_name = ''_EndRoot''   AND evt.tx_type = ''Root'' THEN ''ReadyToRun'' ELSE
           ''NotYetRun'' 
      END tx_status
    FROM @closing_billgroup cbg
    INNER JOIN t_usage_cycle uc ON uc.id_usage_cycle = cbg.id_usage_cycle
    INNER JOIN t_recevent_schedule sch ON 
               -- the schedule is not constrained in any way
               ((sch.id_cycle_type IS NULL AND sch.id_cycle IS NULL) OR
               -- the schedule''s cycle type is constrained
               (sch.id_cycle_type = uc.id_cycle_type) OR
               -- the schedule''s cycle is constrained
               (sch.id_cycle = uc.id_usage_cycle))
    INNER JOIN t_recevent evt ON evt.id_event = sch.id_event
    INNER JOIN t_billgroup bg ON bg.id_billgroup = cbg.id_billgroup 
    WHERE 
      -- event must be active
      evt.dt_activated <= @dt_now and
      (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
      -- event must be of type: root, end-of-period or checkpoint
      (evt.tx_type in (''Root'', ''EndOfPeriod'', ''Checkpoint'')) AND
     -- do not insert BillingGroup adapters for pull lists
     NOT EXISTS (SELECT 1 
                         FROM t_billgroup bg1
                         WHERE bg1.tx_type = ''PullList'' AND
                                     bg1.id_billgroup = bg.id_billgroup
                         AND EXISTS
                         (SELECT 1
 	             FROM t_recevent re1
                         WHERE re1.tx_billgroup_support = ''BillingGroup'' AND
                                     re1.id_event = evt.id_event)) AND      

      evt.id_event NOT IN 
      (
        -- only adds instances if they are missing
        -- this guards against extra instances after closing -> reopening -> closing
        SELECT evt.id_event
        FROM @closing_billgroup cbg 
        INNER JOIN t_billgroup bg ON bg.id_billgroup = cbg.id_billgroup
        -- check that interval-only instances are not regenerated
        -- check that billing-group instances are not regenerated
        -- check that account-only instances are not regenerated
        INNER JOIN t_recevent_inst inst ON inst.id_arg_interval = cbg.id_interval AND
                                                                (inst.id_arg_billgroup = cbg.id_billgroup OR
                                                                 -- inst.id_arg_root_billgroup = bg.id_parent_billgroup OR
                                                                 inst.id_arg_billgroup IS NULL)
        INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
        WHERE  
          -- event must be active
          evt.dt_activated <= @dt_now and
          (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) 
       
      )
      GROUP BY evt.id_event, 
                       CASE WHEN evt.tx_billgroup_support = ''Interval'' THEN NULL 
                               ELSE cbg.id_billgroup 
                               END,
                        CASE WHEN evt.tx_billgroup_support = ''Interval'' THEN NULL 
                                 ELSE dbo.GetBillingGroupAncestor(cbg.id_billgroup)
                                 END,
                       cbg.id_interval,
                       CASE WHEN evt.tx_name = ''_StartRoot'' AND evt.tx_type = ''Root'' THEN ''Succeeded'' 
                                WHEN evt.tx_name = ''_EndRoot''   AND evt.tx_type = ''Root'' THEN ''ReadyToRun'' 
                                ELSE ''NotYetRun'' 
                       END

  END
  SET @status = 0
  SELECT * FROM @closing_billgroup
  COMMIT
  ' 
END
GO
/****** Object:  StoredProcedure [dbo].[OpenUsageInterval]    Script Date: 06/02/2008 11:44:05 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[OpenUsageInterval]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[OpenUsageInterval]
(
  @dt_now DATETIME,     -- MetraTech system date
  @id_interval INT,     -- specific usage interval to reopen, the interval must be soft-closed
  @ignoreDeps INT,      -- whether to ignore the reverse dependencies for re-opening the interval
  @pretend INT,         -- if pretend is true, the interval is not actually reopened
  @status INT OUTPUT    -- return code: 0 is successful
)
AS

BEGIN
  BEGIN TRAN

  SELECT @status = -999

  -- checks that the interval is soft closed
  DECLARE @count INT
  SELECT @count = COUNT(*)
  FROM t_usage_interval
  WHERE 
    id_interval = @id_interval AND
    tx_interval_status = ''C''
 
  IF @count = 0
  BEGIN
    SELECT @count = COUNT(*)
    FROM t_usage_interval
    WHERE id_interval = @id_interval

    IF @count = 0
      -- interval not found
      SELECT @status = -1
    ELSE
      -- interval not soft closed
      SELECT @status = -2
  
    ROLLBACK
    RETURN
  END

  --
  -- retrieves the instance ID of the start root event for the given interval
  --
  DECLARE @id_instance INT
  SELECT @id_instance = inst.id_instance
  FROM t_recevent_inst inst
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  WHERE
    -- event must be active
    evt.dt_activated <= @dt_now and
    (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
    -- instance must match the given interval
    inst.id_arg_interval = @id_interval AND
    evt.tx_name = ''_StartRoot'' AND
    evt.tx_type = ''Root''

  IF @id_instance IS NULL
  BEGIN
    -- start root instance was not found!
    SELECT @status = -3
    ROLLBACK
    RETURN
  END
  
  
  --
  -- checks start root''s reversal dependencies
  --
  IF @ignoreDeps = 0
  BEGIN
    SELECT @count = COUNT(*)
    FROM GetEventReversalDeps(@dt_now, @id_instance) deps
    WHERE deps.tx_status <> ''NotYetRun''

    IF @count > 0
    BEGIN
      -- not all instances in the interval have been reversed successfuly
      SELECT @status = -4
      ROLLBACK
      RETURN
    END   
  END

  -- just pretending, so don''t do the update
  IF @pretend != 0
  BEGIN
    SELECT @status = 0 -- success
    COMMIT
    RETURN
  END  

  UPDATE t_usage_interval SET tx_interval_status = ''O''
  WHERE 
    id_interval = @id_interval AND
    tx_interval_status = ''C''

  IF @@ROWCOUNT = 1
  BEGIN
    SELECT @status = 0 -- success
    COMMIT
  END
  ELSE
  BEGIN
    -- couldn''t update the interval
    SELECT @status = -5
    ROLLBACK
  END
END
  ' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdIntervalStatusToHardClosed]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdIntervalStatusToHardClosed]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
         
/* ===========================================================
If the @ignoreBillingGroups is 1, then 
  (a) Update the accounts in t_acc_usage_interval to ''H'' for the given interval
  (b) Update the status of the interval to ''H'' in t_usage_interval
Else
  Update the status of the given interval to ''H'', if all the accounts for that
  interval in t_acc_usage_interval are ''H''

Returns one of the following:
 O : No error
-1 : Unknown error
-2 : Payer accounts in the interval are Open
=========================================================== */
CREATE PROCEDURE [dbo].[UpdIntervalStatusToHardClosed]
(
   @id_interval INT,
   @ignoreBillingGroups INT,
   @status INT OUTPUT
)
AS

BEGIN
   SET @status = -1
   
   IF (@ignoreBillingGroups = 1)
     BEGIN
       /* Update all accounts in t_acc_usage_interval for the given interval to ''H'' */
       UPDATE t_acc_usage_interval SET tx_status = ''H''
       WHERE id_usage_interval = @id_interval
       
       /* Update t_usage_interval for the given interval to ''H'' */
       UPDATE t_usage_interval SET tx_interval_status = ''H''
       WHERE id_interval = @id_interval 
       SET @status = 0
     END
   ELSE
     BEGIN
         -- All paying accounts in the interval that are ''H''
     IF (SELECT COUNT(AccountID) 
          FROM vw_paying_accounts 
          WHERE IntervalID = @id_interval AND State = ''H'') 
          =
          -- All paying accounts in the interval
          (SELECT COUNT(AccountID)  
           FROM vw_paying_accounts
           WHERE IntervalID = @id_interval)
     BEGIN
        UPDATE t_usage_interval 
        SET tx_interval_status = ''H''
        WHERE id_interval = @id_interval 
        SET @status = 0
     END
     ELSE
     BEGIN
       SET @status = -2
     END
   END
END

   ' 
END
GO
/****** Object:  StoredProcedure [dbo].[HardCloseExpiredIntervals_npa]    Script Date: 06/02/2008 11:43:47 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[HardCloseExpiredIntervals_npa]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
Update the status of the given interval to ''H'', if all the accounts for that
interval in t_acc_usage_interval are ''H''
=========================================================== */
CREATE PROCEDURE [dbo].[HardCloseExpiredIntervals_npa]
(
   @dt_now DATETIME,
   @n_count INT OUTPUT
)
AS

BEGIN

-- Initialize @n_count
SET @n_count = 0

UPDATE ui
SET tx_interval_status = ''H''
FROM t_usage_interval ui 
INNER JOIN dbo.GetExpiredIntervals (@dt_now, 1) ei -- expired, non-materialized intervals
   ON ei.id_interval = ui.id_interval
WHERE NOT EXISTS (SELECT 1                                    -- no paying accounts
                                FROM vw_paying_accounts pa
                                WHERE pa.IntervalID = ui.id_interval) AND
ui.tx_interval_status <> ''H''
 
SET @n_count = @@ROWCOUNT

END
   ' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdExpiredIntervalsToBlocked]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdExpiredIntervalsToBlocked]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
Updates the status for all expired, non-materialized intervals to ''B'' 
(if the existing status is not ''H'') meaning that no new accounts will 
be mapped to this interval. 
===========================================================*/
CREATE PROCEDURE [dbo].[UpdExpiredIntervalsToBlocked]
(
   @dt_now DATETIME,
   @n_count INT OUTPUT
)
AS

BEGIN

-- Initialize @n_count
SET @n_count = 0

UPDATE ui
SET tx_interval_status = ''B''
FROM t_usage_interval ui 
INNER JOIN dbo.GetExpiredIntervals (@dt_now, 1) ei
   ON ei.id_interval = ui.id_interval
WHERE
   ui.tx_interval_status = ''O'' 

SET @n_count = @@ROWCOUNT

END
 
         ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreateBillGroupMaterialization]    Script Date: 06/02/2008 11:43:24 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateBillGroupMaterialization]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
Inserts a row in t_billgroup_materialization 
Returns the materialization id

Returns:
-1 if an unknown error has occurred
-2 could not clean temporary data
-3 if this interval is hard closed
-4 if this interval does not have any paying accounts
-5 if atleast one interval-only adapter has executed successfully for the given interval
     and it''s a rematerialization or a user defined billing group creation
-6 if an ''EOP'' adapter associated with the given interval is ''Running'' or ''Reversing''
-7 if a full materialization has already happened for the given interval
-8 if a materialization is in progress for the given interval
=========================================================== */
CREATE PROCEDURE [dbo].[CreateBillGroupMaterialization]
(
  @id_user_acc INT,
  @dt_start DATETIME,
  @id_parent_billgroup INT,
  @id_usage_interval INT,
  @tx_type VARCHAR(20),
  @id_materialization INT OUTPUT,
  @status INT OUTPUT
)
AS

BEGIN
   BEGIN TRAN
   -- initialize @status to unknown error
   SET @status = -1 
   SET @id_materialization = 0
   
   /* Clean out temporary data */
   EXEC CleanupMaterialization NULL,  NULL, NULL, NULL, @status OUTPUT
   IF (@status != 0) 
       BEGIN
          SET @status = -2
          ROLLBACK
          RETURN 
       END
                  
   /* Reset status */   
   SET @status = -1 
                               
   /* Return error if this interval is hard closed */
   IF EXISTS(SELECT id_interval
                  FROM t_usage_interval
                  WHERE id_interval = @id_usage_interval AND
                              tx_interval_status = ''H'')
      BEGIN
           SET @status = -3
           ROLLBACK
           RETURN 
      END

    /* Return error if this interval does not have any paying accounts */
   IF NOT EXISTS(SELECT 1
                          FROM vw_paying_accounts 
                          WHERE IntervalID = @id_usage_interval)
      BEGIN
           SET @status = -4
           ROLLBACK
           RETURN 
      END

   /* Error if atleast one interval-only adapter has executed successfully for the given interval 
       for a rematerialization */
   IF ((@tx_type = ''Rematerialization'' OR @tx_type = ''UserDefined'') AND
        EXISTS (SELECT id_instance
                    FROM t_recevent_inst ri
                    INNER JOIN t_recevent re
                         ON re.id_event = ri.id_event
                    WHERE ri.id_arg_interval = @id_usage_interval AND
                                re.tx_billgroup_support = ''Interval'' AND
                                re.tx_type = ''EndOfPeriod'' AND
                                ri.tx_status = ''Succeeded''))
    BEGIN
       SET @status = -5
       ROLLBACK
       RETURN 
     END

   /* Return error if there are any EOP adapter instances running or reversing in this interval */
   IF EXISTS(SELECT id_instance 
                  FROM t_recevent_inst ri
                  INNER JOIN t_recevent re 
                      ON re.id_event = ri.id_event
                  WHERE ri.id_arg_interval = @id_usage_interval AND
                              re.tx_type = ''EndOfPeriod'' AND
                              ri.tx_status IN (''Running'', ''Reversing''))
       BEGIN
           SET @status = -6
           ROLLBACK
           RETURN 
       END

   /* Return error if this is a pull list and the parent billing group is not soft closed 
   IF (@tx_type = ''PullList'' AND 
       EXISTS (SELECT status 
                   FROM vw_all_billing_groups_status 
                   WHERE id_billgroup = @id_parent_billgroup AND
                               status != ''C''))
       BEGIN
           SET @status = -7
           ROLLBACK
           RETURN 
       END */
   
   IF NOT EXISTS (SELECT id_materialization 
	               FROM t_billgroup_materialization bm
	               WHERE bm.tx_status = ''InProgress'' AND
	               bm.id_usage_interval = @id_usage_interval) 
   
       BEGIN
              /* Cannot have more than one ''Full'' materialization for a given interval */
              IF (@tx_type = ''Full'' AND EXISTS (SELECT id_materialization 
	                                                      FROM t_billgroup_materialization bm
	                                                      WHERE bm.tx_status = ''Succeeded'' AND
                                                                              bm.tx_type = ''Full'' AND
	                                                                  bm.id_usage_interval = @id_usage_interval))
                 BEGIN
                      SET @status = -7
                      ROLLBACK
                      RETURN 
                 END
              ELSE
                 BEGIN
                    -- insert a new row into t_billgroup_materialization
                    INSERT INTO t_billgroup_materialization 
                         (id_user_acc, dt_start, id_parent_billgroup, id_usage_interval, tx_status, tx_type)
                    VALUES  (@id_user_acc, @dt_start, @id_parent_billgroup, @id_usage_interval, ''InProgress'', @tx_type)
           
                    -- assign the new identity created
                    SET @id_materialization = @@IDENTITY
                    SET @status = 0
                    COMMIT
                 END
        END
    ELSE 
        BEGIN
           SET @status = -8
           ROLLBACK
           RETURN 
        END
END
' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreateUsagePartitions]    Script Date: 06/02/2008 11:43:33 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateUsagePartitions]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      /*
      	Proc: CreateUsagePartitions
      
      	Creates usage partitions for active and unassigned intervals.  Updates
      	the t_partition to match.
      
      */
      create proc [dbo].[CreateUsagePartitions]
      as
      begin
      
      /* Set environment for this session
      */
      set nocount on
      
      -- Abort if system isn''t enabled for partitioning
      if dbo.IsSystemPartitioned() = 0
      begin
      	raiserror(''System not enabled for partitioning.'',0,1)
      	return 1
      end
      
      /* Specs for creating partitions	
      */
      declare @enabled char(1)
      declare @cycle int
      declare @datasize int
      declare @logsize int
      declare @path varchar(500)
      
      /* Vars for iterating through the new partition list
      */
      declare @cur cursor
      declare @partition_name nvarchar(100)
      declare @dt_start datetime
      declare @dt_end datetime
      declare @interval_start int
      declare @interval_end int
      declare @result varchar(500) -- result of db create
      declare @parts table (
      	partition_name nvarchar(100),
      	dt_start datetime,
      	dt_end datetime,
      	interval_start int,
      	interval_end int,
      	result varchar(500) )
      
      /* Error handling and such
      */
      declare @err int -- sql errors
      declare @rc  int	-- row counts
      declare @ret int 	-- called proc returns
      
      /* Get list of new partition names
      */
      exec GeneratePartitionSequence @cur out
      
      /* Get database size params
      */
      select @datasize = partition_data_size,
      		@logsize = partition_log_size
      from t_usage_server
      
      /* Determine if this is a conversion and include 
      	hard-closed intervals if so.
      */
      declare @intervalstatus varchar(10)
      set @intervalstatus = ''[BO]''
      if objectproperty(object_id(''t_acc_usage''),''istable'') = 1
      	set @intervalstatus = ''[HBO]''
      
      /* Get first row of partition info
      */
      fetch @cur into
      	@dt_start, @dt_end, @interval_start, @interval_end
      
      --select	@dt_start, @dt_end, @interval_start, @interval_end	
      
      /* Iterate through partition sequence
      */
      while (@@fetch_status = 0)
      begin
      	/* Construct database name
      	*/
      	set @partition_name = ''N_'' + convert(varchar, @dt_start, 102) + ''_'' 
      			+ convert(varchar, @dt_end, 102)
      	set @partition_name = replace(@partition_name, ''.'', '''')
      
      	/* Get next path name
      	*/
      	exec GetNextStoragePath @path out
      
      	/* Create the partition database and check exception
      	*/
      	exec @ret = CreatePartitionDatabase @partition_name, @path, @datasize, @logsize
      
      	if (@ret <> 0) begin
      		raiserror(''Cannot create partition database [%s]'', 16, 1, @partition_name)
      		return 1
      	end
      
      	/* Insert partition metadata and assign intervals to the 
      		new partition.
      	*/
      
      	begin tran
      
      		/* Insert new partition record
      		*/
      		insert into t_partition (
      			partition_name, b_default, dt_start, dt_end, id_interval_start,
      			id_interval_end, b_active)
      			values (
      			rtrim(@partition_name), ''N'', @dt_start, @dt_end, @interval_start,
      			@interval_end, ''Y'')
      
      		select @err = @@error, @rc = @@rowcount
      		if (@err <> 0) begin
      			raiserror(''Cannot update t_partition table for: [%s]'', 
      					16, 1, @partition_name)
      			rollback 
      			deallocate @cur
      			return 1
      		end
      	
      	commit tran
      
      	/* Store partition info in local table var
      	*/
      	insert into @parts values (
      		@partition_name, @dt_start, @dt_end, @interval_start, @interval_end,
      		@result)
      
      	/* Get next patition info
      	*/
      	fetch @cur into
      		@dt_start, @dt_end, @interval_start, @interval_end	
      	--print ''status='' + str(@@fetch_status)
      
      end -- while loop
      
      /* Deallocate the cursor
      */
      close @cur
      deallocate @cur
      
      /* Create or fixup the default partition 
      */
      exec @ret = CreateDefaultPartition
      
      if (@ret <> 0) begin
      	raiserror(''Default partition not created.'', 16, 1)
      	return 1
      end
      
      /* Finished creating databases. 
      
      	Include default partition info with new partition list 
      	if new partitions were created. Return the list as result 
      	set for reporting.
      */
      
      if exists(select top 1 * from @parts) begin
      	insert into @parts
      		select partition_name, dt_start, dt_end,
      		id_interval_start, id_interval_end, ''''
      		from t_partition
      		where b_default  = ''Y''
      end
      
      select * from @parts
      	order by dt_start
      
      end
 	' 
END
GO
/****** Object:  StoredProcedure [dbo].[updatesub]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[updatesub]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[updatesub] (
@p_id_sub INT,
@p_dt_start datetime,
@p_dt_end datetime,
@p_nextcycleafterstartdate VARCHAR,
@p_nextcycleafterenddate VARCHAR,
@p_id_po INT,
@p_id_acc INT,
@p_systemdate datetime,
@p_status INT OUTPUT,
@p_datemodified varchar OUTPUT
)
AS
BEGIN
	DECLARE @real_begin_date as datetime
	DECLARE @real_end_date as datetime
	declare @varMaxDateTime datetime
	declare @temp_guid varbinary(16)
	declare @id_group as integer
  	declare @cycle_type as integer
  	declare @po_cycle as integer

	select @varMaxDateTime = dbo.MTMaxDate()
	-- step 1: compute usage cycle dates if necessary
	select @p_status = 0
	SELECT @temp_guid = id_sub_ext
	FROM t_sub
	WHERE id_sub = @p_id_sub

	if @p_id_acc is not NULL
        begin
	
		IF (@p_nextcycleafterstartdate = ''Y'') begin
			select @real_begin_date =dbo.nextdateafterbillingcycle (@p_id_acc, @p_dt_start) 
		end
		ELSE begin
			select @real_begin_date = @p_dt_start
		END
		IF (@p_nextcycleafterenddate = ''Y'') begin
		-- CR 5785: make sure the end date of the subscription if using billing cycle
		-- relative is at the end of the current billing cycle
			select @real_end_date = dbo.subtractsecond (
		                        dbo.nextdateafterbillingcycle (@p_id_acc, @p_dt_end))
		end
		ELSE begin
			select @real_end_date = @p_dt_end
		END
		-- step 2: if the begin date is after the end date, make the begin date match the end date
		IF (@real_begin_date > @real_end_date) begin
			select @real_begin_date = @real_end_date
		END 
		select @p_status = dbo.checksubscriptionconflicts (
		                 @p_id_acc,@p_id_po,@real_begin_date,@real_end_date,
		                 @p_id_sub)
		IF (@p_status <> 1) begin
		  RETURN
		END

		-- check if the po is BCR constrained.  If it is, make sure that the 
		-- usage cycles for all the payers during the subscription interval
		-- matches the cycle type on the po.
		IF EXISTS (
		  SELECT 1
		  FROM
			t_payment_redirection pr 
		  INNER JOIN t_acc_usage_cycle auc ON pr.id_payer=auc.id_acc
		  INNER JOIN t_usage_cycle uc ON uc.id_usage_cycle = auc.id_usage_cycle
			WHERE
		  pr.id_payee = @p_id_acc
		  AND
			pr.vt_start <= @real_end_date 
		  AND
		  @real_begin_date <= pr.vt_end
			AND
		  EXISTS (
		    SELECT 1 FROM t_pl_map plm
		    WHERE plm.id_paramtable IS NULL AND plm.id_po=@p_id_po
		    AND
		    (
		      EXISTS (
		        SELECT 1 FROM t_aggregate a WHERE a.id_prop = plm.id_pi_instance 
		        AND a.id_cycle_type IS NOT NULL AND a.id_cycle_type <> uc.id_cycle_type
		      ) OR EXISTS (
		        SELECT 1 FROM t_discount d WHERE d.id_prop = plm.id_pi_instance 
		        AND d.id_cycle_type IS NOT NULL AND d.id_cycle_type <> uc.id_cycle_type
		      ) OR EXISTS (
		        SELECT 1 FROM t_recur r WHERE r.id_prop = plm.id_pi_instance AND r.tx_cycle_mode = ''BCR Constrained''
		        AND r.id_cycle_type IS NOT NULL AND r.id_cycle_type <> uc.id_cycle_type
		      )
		    )
		  )
		)
		BEGIN
		SET @p_status = -289472464 -- MTPCUSER_CYCLE_CONFLICTS_WITH_ACCOUNT_CYCLE (0xEEBF0030)
		RETURN
		END
		
		IF EXISTS (
		  SELECT 1
		  FROM
			t_payment_redirection pr 
		  INNER JOIN t_acc_usage_cycle auc ON pr.id_payer=auc.id_acc
		  INNER JOIN t_usage_cycle uc ON uc.id_usage_cycle = auc.id_usage_cycle
			WHERE
		  pr.id_payee = @p_id_acc
		  AND
			pr.vt_start <= @real_end_date 
		  AND
		  @real_begin_date <= pr.vt_end
			AND
		  EXISTS (
		    SELECT 1 FROM t_pl_map plm
		    WHERE plm.id_paramtable IS NULL AND plm.id_po=@p_id_po
		    AND EXISTS (
		        SELECT 1 FROM t_recur rc WHERE rc.id_prop = plm.id_pi_instance AND rc.tx_cycle_mode = ''EBCR''
		        AND NOT (((rc.id_cycle_type = 4) OR (rc.id_cycle_type = 5))
		        AND ((uc.id_cycle_type = 4) OR (uc.id_cycle_type = 5)))
		        AND NOT (((rc.id_cycle_type = 1) OR (rc.id_cycle_type = 7) OR (rc.id_cycle_type = 8))
		        AND ((uc.id_cycle_type = 1) OR (uc.id_cycle_type = 7) OR (uc.id_cycle_type = 8)))  
		    )
		  )
		)
		BEGIN
		SET  @p_status = -289472444 -- MTPCUSER_EBCR_CYCLE_CONFLICTS_WITH_ACCOUNT_CYCLE (0xEEBF0044)
		RETURN
		END

	end
	else begin
		select @real_begin_date = @p_dt_start
		select @real_end_date = @p_dt_end
		select @id_group = id_group from t_sub where id_sub = @p_id_sub
	end

	-- verify that the start and end dates are inside the product offering effective
	-- date
	exec AdjustSubDates @p_id_po,@real_begin_date,@real_end_date,
		@real_begin_date OUTPUT,@real_end_date OUTPUT,@p_datemodified OUTPUT,
		@p_status OUTPUT
	if @p_status <> 1 begin
		return
	end

	exec CreateSubscriptionRecord @p_id_sub,@temp_guid,@p_id_acc,@id_group,
		@p_id_po,@p_systemdate,@real_begin_date,@real_end_date,
		@p_systemdate,@p_status OUTPUT
END
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[AcknowledgeCheckpoint]    Script Date: 06/02/2008 11:42:56 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AcknowledgeCheckpoint]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
Modified from the previous version to use billing groups information.
=========================================================== */
CREATE PROCEDURE [dbo].[AcknowledgeCheckpoint]
(
  @dt_now DATETIME,
  @id_instance INT,
  @b_ignore_deps VARCHAR(1),
  @id_acc INT,
  @tx_detail nvarchar(2048),
  @status INT OUTPUT
)
AS

BEGIN

  -- NOTE: for now, just use the calling procedure''s transaction

  SELECT @status = -99

  -- enforces that the checkpoints dependencies are satisfied
  IF (@b_ignore_deps = ''N'')
  BEGIN
    DECLARE @unsatisfiedDeps INT
    SELECT @unsatisfiedDeps = COUNT(*) 
    FROM GetEventExecutionDeps (@dt_now, @id_instance)
    WHERE tx_status <> ''Succeeded''

    IF (@unsatisfiedDeps > 0)
    BEGIN
      SELECT @status = -4  -- deps aren''t satisfied
      RETURN
    END
  END

  -- updates the checkpoint instance''s state to ''Succeeded''
  UPDATE t_recevent_inst
  SET tx_status = ''Succeeded'', b_ignore_deps = @b_ignore_deps, dt_effective = NULL
  FROM t_recevent_inst inst
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  -- INNER JOIN t_usage_interval ui ON ui.id_interval = inst.id_arg_interval
  INNER JOIN vw_all_billing_groups_status bgs ON bgs.id_billgroup = inst.id_arg_billgroup
  WHERE 
    -- event is active
    evt.dt_activated <= @dt_now AND
    (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
    inst.id_instance = @id_instance AND
    -- checkpoint must presently be in the NotYetRun state
    inst.tx_status IN (''NotYetRun'') AND
    -- interval, if any, must be in the closed state
    -- ui.tx_interval_status = ''C''
    bgs.status = ''C''

  -- if the update was made, return successfully
  IF (@@ROWCOUNT = 1)
  BEGIN

    -- records the action
    INSERT INTO t_recevent_inst_audit(id_instance,id_acc,tx_action,b_ignore_deps,dt_effective,tx_detail,dt_crt)
    VALUES(@id_instance, @id_acc, ''Acknowledge'', @b_ignore_deps, NULL, @tx_detail, @dt_now) 
    SELECT @status = 0
    RETURN
  END

  --
  -- otherwise, attempts to figure out what went wrong
  --
  DECLARE @count INT
  SELECT @count = COUNT(*) FROM t_recevent_inst WHERE id_instance = @id_instance

  IF (@count = 0)
  BEGIN
    -- the instance does not exist
    SELECT @status = -1
    RETURN
  END

  SELECT @count = COUNT(*)
  FROM t_recevent_inst inst
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  WHERE 
    -- event is active
    evt.dt_activated <= @dt_now AND
    (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
    inst.tx_status = ''NotYetRun'' AND
    inst.id_instance = @id_instance

  IF (@count = 0)
  BEGIN
    -- instance is not in the proper state
    SELECT @status = -2
    RETURN
  END

  SELECT @count = COUNT(*)  
  FROM t_recevent_inst inst
  -- INNER JOIN t_usage_interval ui ON ui.id_interval = inst.id_arg_interval
   INNER JOIN vw_all_billing_groups_status bgs ON bgs.id_billgroup = inst.id_arg_billgroup
  WHERE 
    inst.id_instance = @id_instance AND
    -- ui.tx_interval_status = ''C''
    bgs.status = ''C''

  IF (@count = 0)
  BEGIN
    -- end-of-period instance''s usage interval is not in the proper state
    SELECT @status = -5 
    RETURN
  END

  -- couldn''t submit for some other unknown reason 
  SELECT @status = -99 
END
   ' 
END
GO
/****** Object:  StoredProcedure [dbo].[UnacknowledgeCheckpoint]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UnacknowledgeCheckpoint]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
Modified from the previous version to use billing groups information.
=========================================================== */
CREATE PROCEDURE [dbo].[UnacknowledgeCheckpoint]
(
  @dt_now DATETIME,
  @id_instance INT,
  @b_ignore_deps VARCHAR(1),
  @id_acc INT,
  @tx_detail nvarchar(2048),
  @status INT OUTPUT
)
AS

BEGIN

  -- NOTE: for now, just use the calling procedure''s transaction

  SELECT @status = -99

  -- enforces that the checkpoints dependencies are satisfied
  IF (@b_ignore_deps = ''N'')
  BEGIN
    DECLARE @unsatisfiedDeps INT
    SELECT @unsatisfiedDeps = COUNT(*) 
    FROM GetEventReversalDeps (@dt_now, @id_instance)
    WHERE tx_status <> ''NotYetRun''

    IF (@unsatisfiedDeps > 0)
    BEGIN
      SELECT @status = -4  -- deps aren''t satisfied
      RETURN
    END
  END

  -- updates the checkpoint instance''s state to ''NotYetRun''
  UPDATE t_recevent_inst
  SET tx_status = ''NotYetRun'', b_ignore_deps = @b_ignore_deps, dt_effective = NULL
  FROM t_recevent_inst inst
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  -- INNER JOIN t_usage_interval ui ON ui.id_interval = inst.id_arg_interval
  INNER JOIN vw_all_billing_groups_status bgs ON bgs.id_billgroup = inst.id_arg_billgroup
  WHERE 
    -- event is active
    evt.dt_activated <= @dt_now AND
    (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
    inst.id_instance = @id_instance AND
    -- checkpoint must presently be in the Succeeded or Failed state
    inst.tx_status IN (''Succeeded'', ''Failed'') AND
    -- interval, if any, must be in the closed state
    -- ui.tx_interval_status = ''C''
    bgs.status = ''C''

  -- if the update was made, return successfully
  IF (@@ROWCOUNT = 1)
  BEGIN

    -- records the action
    INSERT INTO t_recevent_inst_audit(id_instance,id_acc,tx_action,b_ignore_deps,dt_effective,tx_detail,dt_crt)
    VALUES(@id_instance, @id_acc, ''Unacknowledge'', @b_ignore_deps, NULL, @tx_detail, @dt_now) 

    SELECT @status = 0
    RETURN
  END

  --
  -- otherwise, attempts to figure out what went wrong
  --
  DECLARE @count INT
  SELECT @count = COUNT(*) FROM t_recevent_inst WHERE id_instance = @id_instance

  IF (@count = 0)
  BEGIN
    -- the instance does not exist
    SELECT @status = -1
    RETURN
  END

  SELECT @count = COUNT(*)
  FROM t_recevent_inst inst
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  WHERE 
    -- event is active
    evt.dt_activated <= @dt_now AND
    (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
    inst.tx_status IN (''Succeeded'', ''Failed'') AND
    inst.id_instance = @id_instance

  IF (@count = 0)
  BEGIN
    -- instance is not in the proper state
    SELECT @status = -2
    RETURN
  END

  SELECT @count = COUNT(*)  
  FROM t_recevent_inst inst
  -- INNER JOIN t_usage_interval ui ON ui.id_interval = inst.id_arg_interval
  INNER JOIN vw_all_billing_groups_status bgs ON bgs.id_billgroup = inst.id_arg_billgroup
  WHERE 
    inst.id_instance = @id_instance AND
    -- ui.tx_interval_status = ''C''
    bgs.status = ''C''

  IF (@count = 0)
  BEGIN
    -- end-of-period instance''s usage interval is not in the proper state
    SELECT @status = -5 
    RETURN
  END

  -- couldn''t submit for some other unknown reason 
  SELECT @status = -99 
END
   ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CanExecuteEventDeps]    Script Date: 06/02/2008 11:43:15 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CanExecuteEventDeps]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
create PROCEDURE [dbo].[CanExecuteEventDeps] (
	@dt_now DATETIME, 
	@id_instances VARCHAR(4000)
	)
AS

BEGIN

  SELECT
    orig_evt.tx_name OriginalEventName,
    orig_evt.tx_display_name OriginalEventDisplayName,
    evt.tx_display_name EventDisplayName,
    evt.tx_type EventType,
    deps.OriginalInstanceID,
    deps.EventID,
    deps.EventName,
    deps.InstanceID,
    deps.ArgIntervalID,
    deps.ArgStartDate,
    deps.ArgEndDate,
    deps.Status,
    /*  the corrective action that must occur */
    CASE deps.Status WHEN ''NotYetRun'' THEN ''Execute''
                    WHEN ''Failed'' THEN ''Reverse''
                    WHEN ''ReadyToRun'' THEN ''Cancel''
                    WHEN ''Reversing'' THEN ''TryAgainLater''
                    ELSE ''Unknown'' END AS Action,
    isnull(deps.BillGroupName, ''Not Available'') BillGroupName
  FROM
  (
    SELECT 
      MIN(deps.id_orig_instance) OriginalInstanceID,
      deps.id_event EventID,
      deps.tx_name EventName,
      deps.id_instance InstanceID,
      deps.id_arg_interval ArgIntervalID,
      deps.dt_arg_start ArgStartDate,
      deps.dt_arg_end ArgEndDate,
      deps.tx_status Status,
      bg.tx_name BillGroupName
    FROM GetEventExecutionDeps(@dt_now, @id_instances) deps
    LEFT OUTER JOIN t_billgroup bg ON bg.id_billgroup = deps.id_billgroup
    WHERE 
      /* excludes input instances */
      (deps.id_instance NOT IN (select * from dbo.csvtoint(@id_instances)) 
			  OR deps.id_instance IS NULL) AND
      /* only look at deps that need an action to be taken */
      deps.tx_status NOT IN (''Succeeded'', ''ReadyToRun'', ''Running'')
    GROUP BY 
      deps.id_instance,
      deps.id_event,
      deps.tx_name,
      deps.id_arg_interval,
      deps.dt_arg_start,
      deps.dt_arg_end,
      deps.tx_status,
      bg.tx_name
  ) deps
  INNER JOIN t_recevent evt ON evt.id_event = deps.EventID
  INNER JOIN t_recevent_inst orig_inst ON orig_inst.id_instance = deps.OriginalInstanceID
  INNER JOIN t_recevent orig_evt ON orig_evt.id_event = orig_inst.id_event

END
 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CanReverseEventDeps]    Script Date: 06/02/2008 11:43:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CanReverseEventDeps]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
create PROCEDURE [dbo].[CanReverseEventDeps] (
	@dt_now DATETIME, 
	@id_instances VARCHAR(4000)
	)
AS

BEGIN

  SELECT
    orig_evt.tx_name OriginalEventName,
    orig_evt.tx_display_name OriginalEventDisplayName,
    evt.tx_display_name EventDisplayName,
    evt.tx_type EventType,
    evt.tx_reverse_mode ReverseMode,
    deps.OriginalInstanceID,
    deps.EventID,
    deps.EventName,
    deps.InstanceID,
    deps.ArgIntervalID,
    deps.ArgStartDate,
    deps.ArgEndDate,
    deps.Status,
    /* the corrective action that must occur */
    CASE deps.Status WHEN ''Succeeded'' THEN ''Reverse''
                    WHEN ''Failed'' THEN ''Reverse''
                    WHEN ''ReadyToRun'' THEN ''Cancel''
                    WHEN ''Running'' THEN ''TryAgainLater''
                    ELSE ''Unknown'' END Action,
    {fn ifnull(deps.BillGroupName, ''Not Available'')} BillGroupName
  FROM
  (
    SELECT 
      MIN(deps.id_orig_instance) OriginalInstanceID,
      deps.id_event EventID,
      deps.tx_name EventName,
      deps.id_instance InstanceID,
      deps.id_arg_interval ArgIntervalID,
      deps.dt_arg_start ArgStartDate,
      deps.dt_arg_end ArgEndDate,
      deps.tx_status Status,
      bg.tx_name BillGroupName
    FROM GetEventReversalDeps(@dt_now, @id_instances) deps
    LEFT OUTER JOIN t_billgroup bg ON bg.id_billgroup = deps.id_billgroup
    WHERE 
      /* excludes input instances */
      (deps.id_instance NOT IN (select * from dbo.csvtoint(@id_instances)) 
          OR deps.id_instance IS NULL) AND
      /* only look at deps that need an action to be taken */
      deps.tx_status NOT IN (''NotYetRun'', ''ReadyToReverse'', ''Reversing'')
    GROUP BY 
      deps.id_instance,
      deps.id_event,
      deps.tx_name,
      deps.id_arg_interval,
      deps.dt_arg_start,
      deps.dt_arg_end,
      deps.tx_status,
      bg.tx_name
  ) deps
  INNER JOIN t_recevent evt ON evt.id_event = deps.EventID
  INNER JOIN t_recevent_inst orig_inst ON orig_inst.id_instance = deps.OriginalInstanceID
  INNER JOIN t_recevent orig_evt ON orig_evt.id_event = orig_inst.id_event

end
 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CopyAdapterInstances]    Script Date: 06/02/2008 11:43:21 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CopyAdapterInstances]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
1) Clone t_recevent_inst data for the new billing group
2) Clone t_recevent_run data for the new billing group
3) Clone t_recevent_run_details data for the new billing group 
4) Clone t_recevent_run_batch data for the new billing group

Returns the following error codes:
   -1 : Unknown error occurred
   -2 : The given id_materialization has a NULL id_parent_billgroup
   -3 : The given id_materialization is not a ''PullList'' 
   -4 : The given id_materialization is not ''InProgress'' 
   -5 : No billing group id found in t_billgroup_tmp for the given id_materialization
   -6 : No instances need to be copied
=========================================================== */
CREATE PROCEDURE [dbo].[CopyAdapterInstances]
(
   @id_materialization INT,
   @status INT OUTPUT,
   @id_billgroup_parent INT OUTPUT,
   @id_billgroup_child INT OUTPUT
)
AS
   -- BEGIN TRAN

   DECLARE @tx_materialization_status VARCHAR(10)
   DECLARE @tx_materialization_type VARCHAR(10)
   DECLARE @id_usage_interval INT

   /* Initialize output variables */
   SET @status = -1
   SET @id_billgroup_parent = -1
   SET @id_billgroup_child = -1
    
   SELECT @id_billgroup_parent = id_parent_billgroup, 
               @tx_materialization_status = tx_status, 
               @tx_materialization_type = tx_type,
               @id_usage_interval = id_usage_interval
   FROM t_billgroup_materialization 
   WHERE id_materialization = @id_materialization
   
   /* Error if id_parent_billgroup is NULL */
   IF @id_billgroup_parent IS NULL
       BEGIN
         SET @status = -2
         -- ROLLBACK
         RETURN 
      END

   /* Error if tx_type is not a PullList */
   IF @tx_materialization_type != ''PullList''
       BEGIN
         SET @status = -3
         -- ROLLBACK
         RETURN 
      END

    /* Error if tx_status is not InProgress */
    IF @tx_materialization_status != ''InProgress''
       BEGIN
         SET @status = -4
         -- ROLLBACK
         RETURN 
      END
   
   -- Get the id_billgroup for the pull list being created
   SELECT @id_billgroup_child = id_billgroup
   FROM t_billgroup_tmp 
   WHERE id_materialization = @id_materialization

   IF @id_billgroup_child IS NULL
       BEGIN
         SET @status = -5
         -- ROLLBACK
         RETURN 
      END

   
   /*
       We need to clone those adapter instances from the
       parent billing group which have an adapter granularity of ''Account''
       t_recevent.tx_billgroup_support = ''Account''
   */
   
   /* Get the existing t_recevent_inst which will be copied */
   DECLARE @newInstances TABLE (id_instance_temp INT IDENTITY(1000,1) NOT NULL,
                                                       id_instance_parent INT,
                                                       id_instance_child INT,
                                                       id_event INT,
                                                       tx_status VARCHAR(14),
                                                       id_run_parent INT, 
                                                       id_run_child INT)

   INSERT @newInstances
   SELECT id_instance,
               NULL,
               ri.id_event,
               tx_status,
               NULL,
               NULL
   FROM t_recevent_inst ri
   INNER JOIN t_recevent re 
      ON re.id_event = ri.id_event
   WHERE ri.id_arg_billgroup = @id_billgroup_parent AND
               ri.id_arg_interval =  @id_usage_interval AND
               re.tx_billgroup_support IN (''Account'')

   /* Return if there''s nothing to be copied */
   DECLARE @newInstancesCount INT
   SELECT @newInstancesCount = COUNT(id_instance_temp) 
   FROM @newInstances

   IF (@newInstancesCount = 0)
       BEGIN
         SET @status = 0
         -- ROLLBACK
         RETURN 
      END

   /* Iterate over the items in @newInstances, creating copies */
   DECLARE @id_instance_temp INT
   DECLARE @id_instance_parent INT
   DECLARE @id_instance_child INT
   DECLARE @id_run_temp INT
   DECLARE @id_run_parent INT
   DECLARE @id_run_child INT
   DECLARE @id_run_parent_out INT
   DECLARE @id_run_child_out INT
   DECLARE @newRunsCount INT
   DECLARE @tx_instance_status VARCHAR(14)
   DECLARE @min_id_run_temp INT

   SET @id_instance_temp = 1000
   
   WHILE (@id_instance_temp < (1000 + @newInstancesCount))
       BEGIN
           -- retrieve the id_instance which needs to be copied
           SELECT @id_instance_parent = id_instance_parent,
                       @tx_instance_status = tx_status
           FROM @newInstances
           WHERE id_instance_temp = @id_instance_temp

           -- copy
           INSERT t_recevent_inst
           SELECT id_event, 
                       id_arg_interval,
                       @id_billgroup_child, 
                       dbo.GetBillingGroupAncestor(@id_billgroup_child), 
                       dt_arg_start, 
                       dt_arg_end,
                       b_ignore_deps, 
                       dt_effective, 
                       tx_status
           FROM t_recevent_inst
           WHERE id_instance = @id_instance_parent

           -- update @newInstances with the id_instance_child
           SET @id_instance_child = @@IDENTITY
           UPDATE @newInstances
           SET id_instance_child = @id_instance_child
           WHERE id_instance_temp = @id_instance_temp

                        /* copy the rows in t_recevent_run for id_instance_parent */
                         

	          	-- Declare @newRuns
	          	DECLARE @newRuns TABLE (id_run_temp INT IDENTITY(1000,1) NOT NULL,
	                                          	         id_run_parent INT, 
		                                             id_run_child INT,
		                                             tx_type VARCHAR(14), 
		                                             dt_start DATETIME)
	
	          	-- populate @newRuns with the parent rows
	          	INSERT @newRuns
	          	SELECT id_run,
	             	NULL,
	                      tx_type,
	                     dt_start
	          FROM t_recevent_run
	          WHERE id_instance = @id_instance_parent
	
	          --  set the count of @newRuns
	          SELECT @newRunsCount = COUNT(id_run_temp) 
	          FROM @newRuns
	
       	          IF (@newRunsCount > 0)
	              BEGIN
	                  SELECT @min_id_run_temp = MIN(id_run_temp)
                              FROM @newRuns

                              SET @id_run_temp = @min_id_run_temp
	            
	                  WHILE (@id_run_temp < (@min_id_run_temp + @newRunsCount))
	                      BEGIN
	                          -- retrieve the id_run which needs to be copied
		              SELECT @id_run_parent = id_run_parent
		              FROM @newRuns
		              WHERE id_run_temp = @id_run_temp
	   
	                          -- get the run id for the child
	                          EXEC GetCurrentID ''receventrun'', @id_run_child OUTPUT
	
	                          -- copy
	                          INSERT t_recevent_run
	                          SELECT @id_run_child, @id_instance_child, 
	                                       tx_type, id_reversed_run, tx_machine, 
	                                       dt_start, dt_end, tx_status, tx_detail
	                          FROM t_recevent_run
	                          WHERE id_run = @id_run_parent
	
	                           -- update @newRuns with the id_run_child
	                           UPDATE @newRuns
	                           SET id_run_child = @id_run_child
	                           WHERE id_run_temp = @id_run_temp
	
	                          -- increment @id_run_temp
	                          SET @id_run_temp = @id_run_temp + 1
	
	                      END  -- the inner while loop ends here
	                      
	                      /*
	                          Get the @id_run_parent_out and @id_run_child_out. This logic must remain 
	                          the same as the logic in the ''DetermineReversibleEvents''  StoredProc which
	                          calculates ''RunIDToReverse''       
	                      */
	                    
	                      IF (@tx_instance_status = ''Succeeded'' OR 
	                          @tx_instance_status = ''Failed'')
	                      BEGIN
	                           SELECT @id_run_parent_out = @id_run_parent,
	                                       @id_run_child_out = @id_run_child
			   FROM @newRuns nr
			   WHERE tx_type = ''Execute'' AND
			               dt_start IN (SELECT MAX(dt_start) 
			                                  FROM @newRuns)
	
	                            -- update @newInstances with the appropriate parent run and child run
	                            UPDATE @newInstances
	                            SET id_run_parent = @id_run_parent_out,
	                                   id_run_child = @id_run_child_out
	                            WHERE id_instance_temp = @id_instance_temp
	                      END
	                      
	
	                      /* Copy t_recevent_run_details data for the new billing group */
                                  IF EXISTS (SELECT id_run 
                                                  FROM t_recevent_run_details rd
                                                  INNER JOIN @newRuns nr ON nr.id_run_parent = rd.id_run)
                                     BEGIN       
		                INSERT INTO t_recevent_run_details(id_run,
						                          tx_type,
						                          tx_detail,
						                          dt_crt)
  	                            SELECT nr.id_run_child,
			                rd.tx_type,
			                rd.tx_detail,
			                rd.dt_crt
		               FROM t_recevent_run_details rd
		               INNER JOIN @newRuns nr ON nr.id_run_parent = rd.id_run 
                                    END 
	
	                      /* Copy t_recevent_run_batch data for the new billing group  */
                                  IF EXISTS (SELECT id_run 
                                                  FROM t_recevent_run_batch rb
                                                  INNER JOIN @newRuns nr ON nr.id_run_parent = rb.id_run)	
                                  BEGIN	        
                                       INSERT INTO t_recevent_run_batch(id_run, tx_batch_encoded)
		               SELECT nr.id_run_child, rb.tx_batch_encoded
		               FROM t_recevent_run_batch rb
		               INNER JOIN @newRuns nr ON nr.id_run_parent = rb.id_run
                                  END

                               DELETE @newRuns
	
	              END

           -- increment @id_instance_temp
           SET @id_instance_temp = @id_instance_temp + 1
       END

   SET @status = 0
   SELECT * FROM @newInstances

   -- COMMIT   
   
         ' 
END
GO
/****** Object:  StoredProcedure [dbo].[addsubscriptionbase]    Script Date: 06/02/2008 11:43:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[addsubscriptionbase]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
CREATE procedure [dbo].[addsubscriptionbase](
@p_id_acc int,
@p_id_group int,
@p_id_po int,
@p_startdate datetime,
@p_enddate datetime,
@p_GUID varbinary(16),
@p_systemdate datetime,
@p_id_sub int,
@p_status int output,
@p_datemodified varchar output)
as
declare @varSystemGMTDateTime datetime,
				@varMaxDateTime datetime,
				@realstartdate datetime,
				@realenddate datetime,
				@realguid varbinary(16)
begin
	select @varMaxDateTime = dbo.mtmaxdate()  

	select @p_status = 0
	exec AdjustSubDates @p_id_po,@p_startdate,@p_enddate,@realstartdate OUTPUT,
		@realenddate OUTPUT,@p_datemodified OUTPUT,@p_status OUTPUT
	
	if @p_status <> 1 begin
		return
	end

	-- Check availability of the product offering
	select @p_status = case 
		when ta.n_begintype = 0 or ta.n_endtype = 0 then -289472451
		when ta.n_begintype <> 0 and ta.dt_start > @p_systemdate then -289472449
		when ta.n_endtype <> 0 and ta.dt_end < @p_systemdate then -289472450
		else 1
		end 
	from t_po po 
	inner join t_effectivedate ta on po.id_avail=ta.id_eff_date
	where
	po.id_po=@p_id_po

	if (@p_status <> 1) begin
    return
	end

if (@p_id_acc is not NULL) begin
	select @p_status = dbo.CheckSubscriptionConflicts(@p_id_acc,@p_id_po,@realstartdate,@realenddate,-1)
	if (@p_status <> 1) begin
    return
	end

 -- check if the po is BCR constrained.  If it is, make sure that the 
-- usage cycles for all the payers during the subscription interval
-- matches the cycle type on the po.
IF EXISTS (
  SELECT 1
  FROM
	t_payment_redirection pr 
  INNER JOIN t_acc_usage_cycle auc ON pr.id_payer=auc.id_acc
  INNER JOIN t_usage_cycle uc ON uc.id_usage_cycle = auc.id_usage_cycle
	WHERE
  pr.id_payee = @p_id_acc
  AND
	pr.vt_start <= @realenddate 
  AND
  @realstartdate <= pr.vt_end
	AND
  EXISTS (
    SELECT 1 FROM t_pl_map plm
    WHERE plm.id_paramtable IS NULL AND plm.id_po=@p_id_po
    AND
    (
      EXISTS (
        SELECT 1 FROM t_aggregate a WHERE a.id_prop = plm.id_pi_instance 
        AND a.id_cycle_type IS NOT NULL AND a.id_cycle_type <> uc.id_cycle_type
      ) OR EXISTS (
        SELECT 1 FROM t_discount d WHERE d.id_prop = plm.id_pi_instance 
        AND d.id_cycle_type IS NOT NULL AND d.id_cycle_type <> uc.id_cycle_type
      ) OR EXISTS (
        SELECT 1 FROM t_recur r WHERE r.id_prop = plm.id_pi_instance AND r.tx_cycle_mode = ''BCR Constrained''
        AND r.id_cycle_type IS NOT NULL AND r.id_cycle_type <> uc.id_cycle_type
      )
    )
  )
)
BEGIN
SET @p_status = -289472464 -- MTPCUSER_CYCLE_CONFLICTS_WITH_ACCOUNT_CYCLE (0xEEBF0030)
RETURN
END

IF EXISTS (
  SELECT 1
  FROM
	t_payment_redirection pr 
  INNER JOIN t_acc_usage_cycle auc ON pr.id_payer=auc.id_acc
  INNER JOIN t_usage_cycle uc ON uc.id_usage_cycle = auc.id_usage_cycle
	WHERE
  pr.id_payee = @p_id_acc
  AND
	pr.vt_start <= @realenddate 
  AND
  @realstartdate <= pr.vt_end
	AND
  EXISTS (
    SELECT 1 FROM t_pl_map plm
    WHERE plm.id_paramtable IS NULL AND plm.id_po=@p_id_po
    AND EXISTS (
        SELECT 1 FROM t_recur rc WHERE rc.id_prop = plm.id_pi_instance AND rc.tx_cycle_mode = ''EBCR''
        AND NOT (((rc.id_cycle_type = 4) OR (rc.id_cycle_type = 5))
        AND ((uc.id_cycle_type = 4) OR (uc.id_cycle_type = 5)))
        AND NOT (((rc.id_cycle_type = 1) OR (rc.id_cycle_type = 7) OR (rc.id_cycle_type = 8))
        AND ((uc.id_cycle_type = 1) OR (uc.id_cycle_type = 7) OR (uc.id_cycle_type = 8)))  
    )
  )
)
BEGIN
SET  @p_status = -289472444 -- MTPCUSER_EBCR_CYCLE_CONFLICTS_WITH_ACCOUNT_CYCLE (0xEEBF0044)
RETURN
END
end

if (@p_GUID is NULL)
	begin
	select @realguid = newid()
	end
else
	begin
	select @realguid = @p_GUID
	end 
	exec CreateSubscriptionRecord @p_id_sub,@realguid,@p_id_acc,
		@p_id_group,@p_id_po,@p_systemdate,@realstartdate,@realenddate,
		@p_systemdate,@status = @p_status OUTPUT
end
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdateGroupSubMembership]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateGroupSubMembership]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
create procedure [dbo].[UpdateGroupSubMembership](
@p_id_acc int,
@p_id_sub int,
@p_id_po int,
@p_id_group int,	
@p_startdate datetime,
@p_enddate datetime,
@p_systemdate datetime,
@p_status int OUTPUT,
@p_datemodified varchar OUTPUT
)
as
begin
declare @realstartdate datetime
declare @realenddate datetime

	exec AdjustGsubMemberDates @p_id_sub,@p_startdate,@p_enddate,
	@realstartdate OUTPUT,@realenddate OUTPUT,@p_datemodified OUTPUT,@p_status OUTPUT
	if @p_status <> 1 begin
		return
	end


 -- check that the new date does not conflict with another subscription
	-- to the same product offering
select @p_status = dbo.checksubscriptionconflicts(@p_id_acc,@p_id_po,@realstartdate,@realenddate,@p_id_sub) 
if (@p_status <> 1)
	begin
	return
	end 
-- end business rule checks
begin
	exec CreateGSubMemberRecord @p_id_group,@p_id_acc,@realstartdate,@realenddate,
		@p_systemdate,@p_status OUTPUT
	if (@@error <> 0)
		begin
		-- not in group subscription, MT_GROUPSUB_ACCOUNT_NOT_IN_GROUP_SUB
		select @p_status = -486604777 
		end
-- done
end
end
		 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreatePartitionedView]    Script Date: 06/02/2008 11:43:28 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreatePartitionedView]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      /*
      	Proc: CreatePartitionedView
      
      	Create a union-all view across all of a table''s partitions.
      
      	@tabname -- name of view to create
      */
      create proc [dbo].[CreatePartitionedView]
      	@tabname varchar(300) -- name of view to create
      AS
      begin
      
      -- Abort if system isn''t enabled for partitioning
      if dbo.IsSystemPartitioned() = 0 begin
      	raiserror(''System not enabled for partitioning.'',0,1)
      	return 1
      end
      
      -- Error handling and row counts
      declare @err int   -- last error
      declare @rc int	-- row count
      
      -- This local table will store a list of partitions for deployment
      declare @partns table (
      	id_partition int,
      	partition_name varchar(100),
      	b_default char(1),
      	dt_start datetime,
      	dt_end datetime,
      	interval_start int,
      	interval_end int
      	)
      
      -- Get list of partitions to include in view.
      insert into @partns
      	select p.id_partition, partition_name, b_default,
      		dt_start, dt_end, id_interval_start, id_interval_end
      	from t_partition p
      	where b_active = ''Y''
      	order by dt_end
      
      -- If no rows are found then the table is not deployed correctly.
      select @rc = @@rowcount, @err = @@error
      if (@rc < 1) begin
      	raiserror(''No partitions found.'', 16, 1)
      	return 1
      end
      
      -- Begin ddl construction
      declare @pname varchar(300)

-- Need 8+ buffers to reach 64k sql statement limit
declare @cmd0 varchar(8000)
declare @cmd1 varchar(8000)
declare @cmd2 varchar(8000)
declare @cmd3 varchar(8000)
declare @cmd4 varchar(8000)
declare @cmd5 varchar(8000)
declare @cmd6 varchar(8000)
declare @cmd7 varchar(8000)
declare @cmd8 varchar(8000)
declare @bufcap int
      declare @clause varchar(8000)

-- init ddl buffer segements 
set @cmd0 = ''create view '' + @tabname + '' as '' + char(13)
set @cmd1 = ''''
set @cmd2 = ''''
set @cmd3 = ''''
set @cmd4 = ''''
set @cmd5 = ''''
set @cmd6 = ''''
set @cmd7 = ''''
set @cmd8 = ''''
set @bufcap = 8000
      
      declare partcur cursor for 
      	select partition_name from @partns
      
      open partcur
      fetch partcur into @pname
      
declare @i int
set @i = 0
      while (@@fetch_status >= 0) begin
      
	set @clause = ''select * from '' + @pname + ''..'' + @tabname + char(13)
      
	-- prepend union all after first iteration
	if (@i > 0) begin
		set @clause = ''union all '' + char(13) + @clause
	end
	set @i = @i + 1

	-- not a perfectly use of buffer segements, because whole
	-- sql ddl clauses are packed into segements, not bytes
	if ((len(@cmd0) + len(@clause)) <= @bufcap) begin
		set @cmd0 = @cmd0 + @clause
	end
	else if ((len(@cmd1) + len(@clause)) <= @bufcap) begin
		set @cmd1 = @cmd1 + @clause
	end
	else if ((len(@cmd2) + len(@clause)) <= @bufcap) begin
		set @cmd2 = @cmd2 + @clause
	end
	else if ((len(@cmd3) + len(@clause)) <= @bufcap) begin
		set @cmd3 = @cmd3 + @clause
	end
	else if ((len(@cmd4) + len(@clause)) <= @bufcap) begin
		set @cmd4 = @cmd4 + @clause
	end
	else if ((len(@cmd5) + len(@clause)) <= @bufcap) begin
		set @cmd5 = @cmd5 + @clause
	end
	else if ((len(@cmd6) + len(@clause)) <= @bufcap) begin
		set @cmd6 = @cmd6 + @clause
	end
	else if ((len(@cmd7) + len(@clause)) <= @bufcap) begin
		set @cmd7 = @cmd7 + @clause
	end
	else if ((len(@cmd8) + len(@clause)) <= @bufcap) begin
		set @cmd8 = @cmd8 + @clause 
	end 
	else begin
		raiserror(''View DDL for [%s] exceeds max 72,000 characters.'', 16, 1, @tabname)
      		return 1
      	end
      	
       	fetch partcur into @pname
      
      end
      deallocate partcur
      
      -- Drop the old view if it exists
print ''Building partitioned view...'' + @tabname
      if exists (select * from  information_schema.views
      				where table_name = @tabname)
      begin
      	declare @dropcmd varchar(500)
      	set @dropcmd = ''drop view '' + @tabname
      	exec(@dropcmd)
      	select @rc = @@rowcount, @err = @@error
      	if (@err <> 0) begin
      		raiserror(''Cannot drop old view [%s]'', 16, 1, @tabname)
      		return 1
      	end
      end
      
/*
-- Print the buffer segments
print replicate(''#'', 19)
print @cmd0
print @cmd1
print @cmd2
print @cmd3
print @cmd4
print @cmd5
print @cmd6
print @cmd7
print @cmd8
print replicate(''#'', 19)

-- Print buffer segments lengths
print ''partns:'' + str(@i)
print ''cmd0:'' + str(len(@cmd0))
print ''cmd1:'' + str(len(@cmd1))
print ''cmd2:'' + str(len(@cmd2))
print ''cmd3:'' + str(len(@cmd3))
print ''cmd4:'' + str(len(@cmd4))
print ''cmd5:'' + str(len(@cmd5))
print ''cmd6:'' + str(len(@cmd6))
print ''cmd7:'' + str(len(@cmd7))
print ''cmd8:'' + str(len(@cmd8))
print ''buflen:'' + str(len(@cmd0) + len(@cmd1) + len(@cmd2) + 
	len(@cmd3) + len(@cmd4) + len(@cmd5) + len(@cmd6) + 
	len(@cmd7) + len(@cmd8))
*/

      -- Create the new view
exec(@cmd0 + @cmd1 + @cmd2 + @cmd3 + @cmd4 + @cmd5 + @cmd6 + @cmd7 + @cmd8)

      select @rc = @@rowcount, @err = @@error
      if (@err <> 0) begin
      	raiserror(''Cannot create new view for [%s]'', 16, 1, @tabname)
      	return 1
      end
      
      end	-- proc
 	' 
END
GO
/****** Object:  StoredProcedure [dbo].[DupPartitionedTable]    Script Date: 06/02/2008 11:43:40 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DupPartitionedTable]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
      
 		 /*
			Proc: DupPartitionedTable

			Duplicates a partitioned table to a new partition.  Or duplicates
			an original table to the default partition.  All columns, the primary
			key, foreign keys, range constraint are included.

		*/
		create proc [dbo].[DupPartitionedTable]
			@tabname varchar(300), -- name of table to depoly
			@srcdb varchar(200),  -- source database (partition or NetMeter)
			@destdb varchar(200),  -- destination partition database
			@rowscopied int out	 -- number of rows copied to new table
		AS
		begin

		-- Abort if system isn''t enabled for partitioning
		if dbo.IsSystemPartitioned() = 0 begin
			raiserror(''System not enabled for partitioning.'',0,1)
			return 1
		end

		-- Fully qualified table names
		declare 	@srctab varchar(300)  -- fully qualified source table name
		declare 	@newtab varchar(300)  -- fully qualified new table name
		set @srctab = @srcdb + ''.dbo.'' + @tabname
		set @newtab = @destdb + ''.dbo.'' + @tabname

		-- Abort if desination already exists
		if (select object_id(@newtab)) is not null
		begin
			raiserror(''Table [%s] already exists on [%s].'', 
				0, 1, @tabname, @destdb)
			return 0
		end

		-- Error handling and row counts
		declare @err int	-- last error
		declare @rc int	-- last rowcount

		-- Get range constraints for target table and default flag
		-- for destination database.  The destintaion db must be active.
		declare @interval_start int
		declare @interval_end int
		declare @b_default char(1)

		select @interval_start = id_interval_start,	
			@interval_end = id_interval_end,
			@b_default = b_default
		from t_partition
		where partition_name = @destdb
			and b_active = ''Y''

		select @rc = @@rowcount, @err = @@error
		if (@rc <> 1 or @err <> 0) begin	
			raiserror(''Database [%s] is not an active partition.'', 16,1, @destdb)
			return 1
		end

		-- Compose range constraint ddl
		declare @rangeddl varchar(400)
		declare @range varchar(300)

		set @range = dbo.GetPartitionPredicate(@interval_start, @interval_end)

		set @rangeddl = ''alter table '' + @newtab + '' add constraint pc_'' + @tabname 
			+ '' check '' + @range

		-- Get the primary key columns from source table
		declare @cmd varchar(2000)
		set @cmd =
			''declare pkcur cursor global for
				select column_name --, kcu.constraint_name, ordinal_position, 
					from '' + @srcdb + ''.INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu
					join '' + @srcdb + ''.INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc
							on kcu.constraint_name = tc.constraint_name
					where kcu.table_name = '''''' + @tabname + ''''''
						and kcu.constraint_catalog = '''''' + @srcdb + ''''''
						and tc.constraint_type = ''''PRIMARY KEY''''
					order by ordinal_position''
		exec (@cmd)

		open pkcur
		declare @pkddl	varchar(300)  -- final csv for pk ddl
		declare @colname varchar(300)

		fetch pkcur into @colname
		set @pkddl = ''''  -- ignore CONCAT_NULL_YIELDS_NULL

		-- Concat pk columns for primary key ddl
		while @@fetch_status >= 0	begin
			set @pkddl = @pkddl + @colname + '', ''
			fetch pkcur into @colname
		end -- fetching pk columns
		deallocate pkcur

		-- Compose primary key ddl
		set @pkddl = left(@pkddl, len(@pkddl)-1)  -- chop trailing comma
		set @pkddl = ''alter table '' + @newtab + '' add constraint pk_'' + @tabname + 
					'' primary key clustered ('' + @pkddl + '')''

		-- Compose table dup ddl.  Includes data copy from source table
		set @cmd = ''select * into '' + @newtab + 
					'' from '' + @srctab +
					'' where '' + @range

		-- Create the table
		print ''Creating table: '' + @newtab 
		--print @cmd
		exec (@cmd)
		select @rowscopied = @@rowcount, @err = @@error
		if (@@error <> 0) begin
			raiserror(''Could not create table %s'', 16, 1, @newtab)
			return 1
		end

		raiserror(''  %i rows copied to [%s]'', 0, 1, @rowscopied, @destdb)

		-- Apply PK
		print ''Applying primary key...''
		--print @pkddl
		exec (@pkddl)
		select @rc = @@rowcount, @err = @@error
		if (@err <> 0) begin
			raiserror(''Could not apply primary key on table %s'', 16, 1, @newtab)
			return 1
		end

		-- Apply range constraint
		print ''Applying the range constraint...''
		--print @rangeddl
		exec (@rangeddl)
		if (@@error <> 0) begin
			raiserror(''Could not apply range constraint to table %s'', 16, 1, @newtab)
			return 1
		end

--Code to add non-clustered indexes
		declare @column_name nvarchar(4000)
		declare @index_name nvarchar(4000)
		declare @key_ordinal nvarchar(4000)
		declare @str nvarchar(4000)
		declare @sql nvarchar(4000)
		set @str = ''''        
		-- g. cieplik 11/25/07  Fix for Sql Server 2005, which uses the new ''sys'' tables, removed the INDEXPROPERTY function, this function only 
		-- works with an ID for the current database. When running against a partitioned database the alais "a"
		-- will be "N_Default" which is not the current database the INDEXPROPERTY will return NULL and the indexs
		-- will not be copied to the new partition.
		set @sql = ''declare index_name cursor for
		select distinct i.name from '' + @srcdb + ''.sys.indexes i
		inner join '' + @srcdb + ''.sys.objects o ON o.object_id = i.object_id
		inner join '' + @srcdb + ''.sys.stats s on i.object_id = s.object_id
		where i.object_id in (select object_id from '' + @srcdb + ''.sys.objects where name = '''''' + @tabname + '''''')
		and i.is_hypothetical <> 1
		and i.type_desc <> ''''CLUSTERED''''
		and s.auto_created = 0
		and o.type = (''''U'''')      
		and i.name not in (select constraint_name from '' + @srcdb + ''.information_schema.table_constraints where table_name = '''''' + @tabname + '''''')''      
		exec (@sql)
		open index_name
		fetch next from index_name into @index_name
		while (@@fetch_status = 0)
		begin
		  -- g. cieplik 11/25/07  Fix for Sql Server 2005, which uses the new ''sys'' tables,removed the INDEXPROPERTY function
			set @sql = ''declare column_name cursor for
			select distinct c.name,ic.key_ordinal from '' + @srcdb + ''.sys.objects o
			INNER JOIN '' + @srcdb + ''.sys.indexes i ON o.object_id = i.object_id
			INNER JOIN '' + @srcdb + ''.sys.index_columns ic ON i.object_id = ic.object_id
			And i.index_id = ic.index_id
			INNER JOIN '' + @srcdb + ''.sys.columns c ON ic.object_id = c.object_id
			AND ic.column_id = c.column_id
			INNER JOIN '' + @srcdb + ''.sys.stats s on i.object_id = s.object_id
			WHERE o.type = ''''U'''' and o.name = '''''' + @tabname + ''''''
			AND i.is_hypothetical <> 1
			AND i.type_desc <> ''''CLUSTERED''''
			AND s.auto_created = 0
			and i.name = '''''' + @index_name + '''''' order by  c.name,ic.key_ordinal''
			exec (@sql)
			open column_name
			fetch next from column_name into @column_name,@key_ordinal
			while (@@fetch_status = 0)
			begin
				if (@str <> '''') set @str = @str + '',''
				set @str = @str + @column_name 
				fetch next from column_name into @column_name,@key_ordinal
			end
			close column_name
			deallocate column_name
		set @sql = ''create index '' + @index_name  + '' on '' + @newtab + ''('' + @str + '')''
		exec (@sql)
		set @str = ''''
		fetch next from index_name into @index_name
		end
		close index_name
		deallocate index_name

		end -- proc
 	' 
END
GO
/****** Object:  StoredProcedure [dbo].[BulkSubscriptionChange]    Script Date: 06/02/2008 11:43:13 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[BulkSubscriptionChange]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
create proc [dbo].[BulkSubscriptionChange](
@id_old_po as int,
@id_new_po as int,
@date as datetime,
@nextbillingcycle as varchar(1),
@p_systemdate datetime,
@new_sub int,
@p_status int output
)
as
DECLARE @CursorVar CURSOR	
DECLARE @count as int
declare @i as int
declare @id_acc as int
declare @start_date as datetime
declare @end_date as datetime
declare @id_sub as int
declare @varmaxdatetime datetime
declare @subext as varbinary(16)
declare @realenddate as datetime
declare @datemodified as varchar(1)
SET @p_status = 1
-- lock everything down as tight as possible!
--SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
begin 
select @varmaxdatetime = dbo.mtmaxdate ()
-- should we update the end effective date of the 
-- old product offering here?
-- create a cursor that holds a static list of all old
-- subscriptions that have end dates later than the old date
set @CursorVar = CURSOR STATIC FOR
	select id_acc,vt_start,vt_end,id_sub
	from t_sub
	where t_sub.id_po = @id_old_po AND
	t_sub.vt_end >= @date
	AND id_group is NULL
OPEN @CursorVar
set @count = @@cursor_rows
set @i = 0
while @i < @count begin
	FETCH NEXT FROM @CursorVar into @id_acc,@start_date,@end_date,@id_sub
	set @i = (select @i + 1)
	select @subext = CAST(newid() as varbinary(16))


	select @realenddate = case when @nextbillingcycle = ''Y'' AND @date is not null then
		dbo.subtractsecond(dbo.NextDateAfterBillingCycle(@id_acc,@date))
	else
		dbo.subtractsecond(@date)
	end		

        -- it is possible that @date <= @end_date <= @realenddate
        -- for this case treat as though subscription doesn''t match at all
        if @end_date <= @realenddate 
          continue

        -- either delete or update the old subscription
        if @realenddate >= @start_date
        begin
	  -- update the old subscription use the specified date
	  update t_sub set vt_end = @realenddate where
	  id_sub = @id_sub

	  -- update the old subscription tt_end
	 UPDATE t_sub_history
           SET tt_end = dbo.subtractsecond (@p_systemdate)
	 WHERE id_sub = @id_sub
	 and tt_end = @varmaxdatetime

	 -- insert the new record
	 INSERT INTO t_sub_history
         SELECT id_sub, id_sub_ext, id_acc, id_po, dt_crt, id_group,
         vt_start, @realenddate, @p_systemdate, @varmaxdatetime
         FROM t_sub_history
         WHERE id_sub = @id_sub
         AND tt_end = dbo.subtractsecond (@p_systemdate)
        end
        else
        begin
	  -- update the old subscription use the specified date
	  delete from t_sub where id_sub = @id_sub
	  -- update the old subscription tt_end
	 UPDATE t_sub_history
           SET tt_end = dbo.subtractsecond (@p_systemdate)
	 WHERE id_sub = @id_sub
	 and tt_end = @varmaxdatetime
        end

	exec AddNewSub  
		@id_acc,
		@date,
		@end_date,
		@nextbillingcycle, -- next billing cycle after start date
		''N'',
		@id_new_po,
		@subext,
		@p_systemdate,
		@new_sub,
		@p_status OUTPUT,
		@datemodified OUTPUT

	-- if @new_status is not 0 then raise an error
	-- CR 11160: set output result parameter and return error
	if @p_status <> 1 
	begin
		CLOSE @CursorVar
		DEALLOCATE @CursorVar	
		return
	end
	/* CR 12529 - increment the id */
	set @new_sub = @new_sub + 1
end 
CLOSE @CursorVar
DEALLOCATE @CursorVar
end
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[DetermineExecutableEvents]    Script Date: 06/02/2008 11:43:39 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DetermineExecutableEvents]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[DetermineExecutableEvents] (@dt_now DATETIME, @id_instances VARCHAR(4000))
AS

BEGIN
  BEGIN TRAN

  DECLARE @deps TABLE
  (
  id_orig_event INT NOT NULL,
  tx_orig_billgroup_support VARCHAR(15),-- useful for debugging
  id_orig_instance INT NOT NULL,
  id_orig_billgroup INT,                               -- useful for debugging
  tx_orig_name VARCHAR(255) NOT NULL, -- useful for debugging
  tx_name nvarchar(255) NOT NULL,           -- useful for debugging
  id_event INT NOT NULL,
  tx_billgroup_support VARCHAR(15),         -- useful for debugging
  id_instance INT,
  id_billgroup INT,                                       -- useful for debugging
  id_arg_interval INT,
  dt_arg_start DATETIME,
  dt_arg_end DATETIME,
  tx_status VARCHAR(14),
  b_critical_dependency VARCHAR(1)
  )

  INSERT INTO @deps  
  SELECT * from GetEventExecutionDeps(@dt_now, @id_instances) order by id_arg_interval

  --
  -- returns the final rowset of all events that are ''ReadyToRun'' and
  -- have satisfied dependencies. the rows are sorted in the order
  -- that they should be executed. 
  --
  SELECT 
    evt.tx_name EventName,
    evt.tx_class_name ClassName,
    evt.tx_config_file ConfigFile,
    evt.tx_extension_name Extension,
    evt.tx_type EventType,
    inst.id_instance InstanceID,
    inst.id_arg_interval ArgInterval,
    inst.id_arg_billgroup ArgBillingGroup,
    inst.dt_arg_start ArgStartDate,
    inst.dt_arg_end ArgEndDate,
    dependedon.total DependentScore
  FROM t_recevent_inst inst
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  INNER JOIN 
  (
    -- counts the total amount of dependencies per runnable instance
    SELECT 
      deps.id_orig_instance,
      COUNT(*) total
    FROM @deps deps
    GROUP BY
      deps.id_orig_instance 
  ) total_deps ON total_deps.id_orig_instance = inst.id_instance
  INNER JOIN 
  (
    -- counts the amount of satisfied dependencies per runnable instance
    SELECT 
      deps.id_orig_instance,
      COUNT(*) total
    FROM @deps deps
    WHERE deps.tx_status = ''Succeeded''
    GROUP BY
      deps.id_orig_instance 
  ) sat_deps ON sat_deps.id_orig_instance = inst.id_instance
  INNER JOIN 
  (
    -- determines how ''depended on'' each runnable instance is
    -- the most ''depended on'' instance should be run first in order
    -- to unblock the largest amount of other adapters in the shortest amount of time
    SELECT 
      inst.id_orig_instance,
      COUNT(*) total
    FROM @deps inst
    INNER JOIN t_recevent_dep dep ON dep.id_dependent_on_event = inst.id_orig_event
    GROUP BY
      inst.id_orig_instance
  ) dependedon ON dependedon.id_orig_instance = inst.id_instance
  -- LEFT OUTER JOIN t_usage_interval ui ON ui.id_interval = inst.id_arg_interval
  LEFT OUTER JOIN vw_all_billing_groups_status bgs 
      ON bgs.id_billgroup = inst.id_arg_billgroup
   WHERE
   (total_deps.total = sat_deps.total OR inst.b_ignore_deps = ''Y'') AND
   -- instance''s effective date has passed or is NULL (''Execute Later'')
  (inst.dt_effective IS NULL OR inst.dt_effective <= @dt_now)  AND
   -- billing group, if any, must be in the closed state
  (inst.id_arg_billgroup IS NULL OR bgs.status = ''C'') 
  ORDER BY dependedon.total DESC, inst.id_instance ASC

  COMMIT
END
' 
END
GO
/****** Object:  StoredProcedure [dbo].[DetermineReversibleEvents]    Script Date: 06/02/2008 11:43:39 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DetermineReversibleEvents]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
Determines reversible instances.
=========================================================== */
CREATE PROCEDURE [dbo].[DetermineReversibleEvents] (@dt_now DATETIME, @id_instances VARCHAR(4000))
AS

BEGIN
  BEGIN TRAN

  DECLARE @deps TABLE
  (
   id_orig_event INT NOT NULL,
  tx_orig_billgroup_support VARCHAR(15),-- useful for debugging
  id_orig_instance INT NOT NULL,
  id_orig_billgroup INT,                               -- useful for debugging
  tx_orig_name VARCHAR(255) NOT NULL, -- useful for debugging
  tx_name nvarchar(255) NOT NULL,           -- useful for debugging
  id_event INT NOT NULL,
  tx_billgroup_support VARCHAR(15),         -- useful for debugging
  id_instance INT,
  id_billgroup INT,                                       -- useful for debugging
  id_arg_interval INT,
  dt_arg_start DATETIME,
  dt_arg_end DATETIME,
  tx_status VARCHAR(14),
  b_critical_dependency VARCHAR(1)
  )
  INSERT INTO @deps  
  SELECT * from GetEventReversalDeps(@dt_now, @id_instances)

  --
  -- returns the final rowset of all events that are ''ReadyToRun'' and
  -- have satisfied dependencies. the rows are sorted in the order
  -- that they should be executed. 
  --
  SELECT 
    evt.tx_name EventName,
    evt.tx_class_name ClassName,
    evt.tx_config_file ConfigFile,
    evt.tx_extension_name Extension,
    evt.tx_reverse_mode ReverseMode,
    evt.tx_type EventType,
    run.id_run RunIDToReverse,
    inst.id_instance InstanceID,
    inst.id_arg_interval ArgInterval,
    inst.id_arg_billgroup ArgBillingGroup,
    inst.dt_arg_start ArgStartDate,
    inst.dt_arg_end ArgEndDate,
    dependedon.total DependentScore
  FROM t_recevent_inst inst
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  INNER JOIN
  (
    -- finds the the run to reverse (the last execution''s run ID)
    SELECT 
      id_instance,
      MAX(dt_start) dt_start
    FROM t_recevent_run run
    WHERE tx_type = ''Execute''
    GROUP BY
      id_instance
  ) maxrun ON maxrun.id_instance = inst.id_instance
  INNER JOIN t_recevent_run run ON run.dt_start = maxrun.dt_start AND
                                   run.id_instance = maxrun.id_instance
  INNER JOIN 
  (
    -- counts the total amount of dependencies per reversible instance
    SELECT 
      deps.id_orig_instance,
      COUNT(*) total
    FROM @deps deps
    GROUP BY
      deps.id_orig_instance 
  ) total_deps ON total_deps.id_orig_instance = inst.id_instance
  INNER JOIN 
  (
    -- counts the amount of satisfied dependencies per reversible instance
    SELECT 
      deps.id_orig_instance,
      COUNT(*) total
    FROM @deps deps
    WHERE deps.tx_status = ''NotYetRun''
    GROUP BY
      deps.id_orig_instance 
  ) sat_deps ON sat_deps.id_orig_instance = inst.id_instance
  INNER JOIN 
  (
    -- determines how ''depended on'' (from an forward perspective) each instance is
    -- the least ''depended on'' instance should be run first in order
    -- to unblock the largest amount of other adapters in the shortest amount of time
    SELECT 
      inst.id_orig_instance,
      COUNT(*) total
    FROM @deps inst
    INNER JOIN t_recevent_dep dep ON dep.id_dependent_on_event = inst.id_orig_event
    GROUP BY
      inst.id_orig_instance
  ) dependedon ON dependedon.id_orig_instance = inst.id_instance
  LEFT OUTER JOIN vw_all_billing_groups_status bgs 
      ON bgs.id_billgroup = inst.id_arg_billgroup
  WHERE
    (total_deps.total = sat_deps.total OR inst.b_ignore_deps = ''Y'') AND
    -- instance''s effective date has passed or is NULL (''Execute Later'')
    (inst.dt_effective IS NULL OR inst.dt_effective <= @dt_now) AND
    -- billing group, if any, must be in the closed state
    (inst.id_arg_billgroup IS NULL OR bgs.status = ''C'') 
  ORDER BY dependedon.total ASC, inst.id_instance ASC

  COMMIT
END
' 
END
GO
/****** Object:  StoredProcedure [dbo].[MarkEventAsFailed]    Script Date: 06/02/2008 11:43:58 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MarkEventAsFailed]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[MarkEventAsFailed]
(
  @dt_now DATETIME,
  @id_instance INT,
  @id_acc INT,
  @tx_detail nvarchar(2048),
  @tx_machine VARCHAR(128),
  @status INT OUTPUT
)
AS

BEGIN
  BEGIN TRAN
  SELECT @status = -99

  UPDATE t_recevent_inst 
  SET tx_status = ''Failed''
  WHERE 
    id_instance = @id_instance AND
    tx_status = ''Succeeded''
  
  IF @@ROWCOUNT = 1  -- successfully updated
  BEGIN
    -- inserts a run to record the fact that the status was changed
    -- this is important for ''cancel'' to work correctly in reverse situations
    DECLARE @id_run INT
    EXEC GetCurrentID ''receventrun'', @id_run OUTPUT
    INSERT INTO t_recevent_run
    (
      id_run,
      id_instance,
      tx_type,
      id_reversed_run,
      tx_machine,
      dt_start,
      dt_end,
      tx_status,
      tx_detail
    )
    VALUES 
    (
      @id_run,
      @id_instance,
      ''Execute'',
      NULL,
      @tx_machine,
      @dt_now,
      @dt_now,
      ''Failed'',
      ''Manually changed status to Failed''
    )

    -- audits the action
    INSERT INTO t_recevent_inst_audit(id_instance,id_acc,tx_action,b_ignore_deps,dt_effective,tx_detail,dt_crt)
    VALUES(@id_instance, @id_acc, ''MarkAsFailed'', NULL, NULL, @tx_detail, @dt_now) 

    SELECT @status = 0  -- success
    COMMIT
    RETURN
  END

  --
  -- update did not occur, so lets figure out why
  --

  -- does the instance exist?
  SELECT 1
  FROM t_recevent_inst 
  WHERE 
    id_instance = @id_instance

  IF @@ROWCOUNT = 0
  BEGIN
    SELECT @status = -1  -- instance does not exist
    ROLLBACK
    RETURN -1
  END

  SELECT @status = -2  -- instance was not in a valid state
  ROLLBACK
  RETURN -2

END
  ' 
END
GO
/****** Object:  StoredProcedure [dbo].[MarkEventAsSucceeded]    Script Date: 06/02/2008 11:43:59 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MarkEventAsSucceeded]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[MarkEventAsSucceeded]
(
  @dt_now DATETIME,
  @id_instance INT,
  @id_acc INT,
  @tx_detail nvarchar(2048),
  @tx_machine VARCHAR(128),
  @status INT OUTPUT
)
AS

BEGIN
  BEGIN TRAN

  SELECT @status = -99

  UPDATE t_recevent_inst 
  SET tx_status = ''Succeeded''
  WHERE 
    id_instance = @id_instance AND
    tx_status = ''Failed''
  
  IF @@ROWCOUNT = 1  -- successfully updated
  BEGIN
    -- inserts a run to record the fact that the status was changed
    -- this is important for ''cancel'' to work correctly in reverse situations
    DECLARE @id_run INT
    EXEC GetCurrentID ''receventrun'', @id_run OUTPUT
    INSERT INTO t_recevent_run
    (
      id_run,
      id_instance,
      tx_type,
      id_reversed_run,
      tx_machine,
      dt_start,
      dt_end,
      tx_status,
      tx_detail
    )
    VALUES 
    (
      @id_run,
      @id_instance,
      ''Execute'',
      NULL,
      @tx_machine,
      @dt_now,
      @dt_now,
      ''Succeeded'',
      ''Manually changed status to Succeeded''
    )

    -- audits the action
    INSERT INTO t_recevent_inst_audit(id_instance,id_acc,tx_action,b_ignore_deps,dt_effective,tx_detail,dt_crt)
    VALUES(@id_instance, @id_acc, ''MarkAsSucceeded'', NULL, NULL, @tx_detail, @dt_now) 

    SELECT @status = 0  -- success
    COMMIT
    RETURN
  END

  --
  -- update did not occur, so lets figure out why
  --

  -- does the instance exist?
  SELECT 1
  FROM t_recevent_inst 
  WHERE 
    id_instance = @id_instance

  IF @@ROWCOUNT = 0
  BEGIN
    SELECT @status = -1  -- instance does not exist
    ROLLBACK
    RETURN -1
  END

  SELECT @status = -2  -- instance was not in a valid state
  ROLLBACK
  RETURN -2

END 
  ' 
END
GO
/****** Object:  StoredProcedure [dbo].[MarkEventAsNotYetRun]    Script Date: 06/02/2008 11:43:59 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[MarkEventAsNotYetRun]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[MarkEventAsNotYetRun]
(
  @dt_now DATETIME,
  @id_instance INT,
  @id_acc INT,
  @tx_detail nvarchar(2048),
  @tx_machine VARCHAR(128),
  @status INT OUTPUT
)
AS

BEGIN
  BEGIN TRAN
  SELECT @status = -99

  UPDATE t_recevent_inst 
  SET tx_status = ''NotYetRun''
  WHERE 
    id_instance = @id_instance AND
    tx_status = ''Failed''
  
  IF @@ROWCOUNT = 1  -- successfully updated
  BEGIN
    -- inserts a run to record the fact that the status was changed
    -- this is important for ''cancel'' to work correctly in reverse situations
    DECLARE @id_run INT
    EXEC GetCurrentID ''receventrun'', @id_run OUTPUT
    INSERT INTO t_recevent_run
    (
      id_run,
      id_instance,
      tx_type,
      id_reversed_run,
      tx_machine,
      dt_start,
      dt_end,
      tx_status,
      tx_detail
    )
    VALUES 
    (
      @id_run,
      @id_instance,
      ''Reverse'',
      NULL,
      @tx_machine,
      @dt_now,
      @dt_now,
      ''Succeeded'',
      ''Manually changed status to NotYetRun''
    )

    -- audits the action
    INSERT INTO t_recevent_inst_audit(id_instance,id_acc,tx_action,b_ignore_deps,dt_effective,tx_detail,dt_crt)
    VALUES(@id_instance, @id_acc, ''MarkAsNotYetRun'', NULL, NULL, @tx_detail, @dt_now) 

    SELECT @status = 0  -- success
    COMMIT
    RETURN
  END

  --
  -- update did not occur, so lets figure out why
  --

  -- does the instance exist?
  SELECT 1
  FROM t_recevent_inst 
  WHERE 
    id_instance = @id_instance

  IF @@ROWCOUNT = 0
  BEGIN
    SELECT @status = -1  -- instance does not exist
    ROLLBACK
    RETURN -1
  END

  SELECT @status = -2  -- instance was not in a valid state
  ROLLBACK
  RETURN -2

END
  ' 
END
GO
/****** Object:  StoredProcedure [dbo].[IsAccBillableNPayingForOthers]    Script Date: 06/02/2008 11:43:58 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[IsAccBillableNPayingForOthers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
					create procedure [dbo].[IsAccBillableNPayingForOthers](
						@id_acc int,
						@ref_date datetime,
						@status int output) 
					as
					begin
				 		-- step 1: Check if this account is billable first
						-- MT_ACCOUNT_IS_NOT_BILLABLE ((DWORD)0xE2FF0005L)
				 		if (dbo.IsAccountBillable(@id_acc) = ''N'')
						  begin
							select @status = -486604795
							return
				 		  end 
				 		-- step 2: Now that this account is billable, check if this 
				 		-- account has any non paying subscribers (payees)
						-- MT_ACCOUNT_PAYING_FOR_OTHERS ((DWORD)0xE2FF0030L)
				 		if (dbo.IsAccountPayingForOthers(@id_acc,@ref_date) = ''Y'')
						  begin
							select @status = -486604752
							return
				 		  end 
				 		-- success
						
						select @status = 1
						return
					end
				' 
END
GO
/****** Object:  View [dbo].[vw_unassigned_accounts]    Script Date: 06/02/2008 11:44:17 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[vw_unassigned_accounts]'))
EXEC dbo.sp_executesql @statement = N'
  
-- ===========================================================
-- Create a VIEW [on t_acc_usage_interval, t_billgroup_member and t_billgroup] which specifies
-- the following for each interval:

-- the unassigned accounts i.e. the accounts for the interval which are not assigned
-- to any billing group
-- ===========================================================
CREATE VIEW [dbo].[vw_unassigned_accounts] AS
SELECT pa.IntervalID, pa.AccountID, pa.State
FROM vw_paying_accounts pa  
WHERE  pa.AccountID NOT IN (SELECT id_acc 
			            FROM t_billgroup_member bgm 
			            INNER JOIN t_billgroup bg 
                                                ON bg.id_billgroup = bgm.id_billgroup AND
			                  bg.id_usage_interval = pa.IntervalID)
GROUP BY pa.IntervalID, pa.AccountID, pa.State
	'
GO
/****** Object:  View [dbo].[t_vw_pilookup]    Script Date: 06/02/2008 11:44:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_pilookup]'))
EXEC dbo.sp_executesql @statement = N'
create view [dbo].[t_vw_pilookup]
(
dt_start,
dt_end,
nm_name,
id_acc,
id_pi_template,
id_po,
id_pi_instance,
id_sub
)
as
select
sub.dt_start dt_start,
sub.dt_end dt_end,
base.nm_name,
sub.id_acc id_acc,
typemap.id_pi_template,
typemap.id_po,
typemap.id_pi_instance,
sub.id_sub
from
dbo.t_vw_effective_subs sub
 INNER JOIN dbo.t_pl_map typemap on typemap.id_po = sub.id_po AND
  typemap.id_po = sub.id_po and typemap.id_paramtable is null
 INNER JOIN dbo.t_base_props base on base.id_prop=typemap.id_pi_template
'
GO
/****** Object:  StoredProcedure [dbo].[SequencedUpsertGsubRecur]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SequencedUpsertGsubRecur]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
		create procedure [dbo].[SequencedUpsertGsubRecur] 
			@p_id_group_sub int,
			@p_id_prop int,
			@p_id_acc int,
			@p_vt_start datetime,
			@p_vt_end datetime,
			@p_tt_current datetime,
			@p_tt_max datetime,
			@p_status int OUTPUT
		as
		begin
	  	  set @p_status = 0
	  	  DECLARE @p_id_po INTEGER

		  select @p_id_po = id_po 
			from t_sub sub
			inner join t_group_sub gsub
			on sub.id_group = gsub.id_group
			where gsub.id_group = @p_id_group_sub

   		       -- Check that both account and PO have the same currency
		      if (dbo.IsAccountAndPOSameCurrency(@p_id_acc, @p_id_po) = ''0'')
		       begin
			-- MT_ACCOUNT_PO_CURRENCY_MISMATCH
			select @p_status = -486604729
			return
		       end		  
		  exec SequencedDeleteGsubRecur @p_id_group_sub, @p_id_prop, @p_vt_start, @p_vt_end, @p_tt_current, @p_tt_max, @p_status output
      if @p_status <> 0 return
		  exec SequencedInsertGsubRecur @p_id_group_sub, @p_id_prop, @p_id_acc, @p_vt_start, @p_vt_end, @p_tt_current, @p_tt_max, @p_status output
		end
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[SequencedUpsertAccOwnership]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SequencedUpsertAccOwnership]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
				
				create procedure [dbo].[SequencedUpsertAccOwnership]
	    	@p_id_owner int,
		    @p_id_owned int,
		    @p_id_relation_type int,
		    @p_percent int,
		    @p_vt_start datetime,
		    @p_vt_end datetime,
		    @p_tt_current datetime,
		    @p_tt_max datetime,
		    @p_status int OUTPUT
        as
        begin
          exec SequencedDeleteAccOwnership @p_id_owner, @p_id_owned, @p_vt_start, @p_vt_end, @p_tt_current, @p_tt_max, @p_status output
        if @p_status <> 0 return
        else
          exec SequencedInsertAccOwnership @p_id_owner, @p_id_owned, @p_id_relation_type, 
	      @p_percent, @p_vt_start, @p_vt_end, @p_tt_current, @p_tt_max, @p_status output
        END
				
			 ' 
END
GO
/****** Object:  View [dbo].[t_vw_allrateschedules]    Script Date: 06/02/2008 11:44:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[t_vw_allrateschedules]'))
EXEC dbo.sp_executesql @statement = N'
        
create view [dbo].[t_vw_allrateschedules]
  as
  select * from t_vw_allrateschedules_po with (noexpand)
  UNION ALL
  select * from t_vw_allrateschedules_pl with (noexpand)
		'
GO
/****** Object:  View [dbo].[vw_interval_billgroup_counts]    Script Date: 06/02/2008 11:44:16 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[vw_interval_billgroup_counts]'))
EXEC dbo.sp_executesql @statement = N'
-- ===========================================================
-- Create a VIEW [on t_acc_usage_interval, t_billgroup_member and t_billgroup] which specifies
-- the following for each interval which has billing groups :

-- the total number of billing groups
-- the number of open billing groups
-- the number of soft closed billing groups
-- the number of hard closed billing groups
-- ===========================================================
CREATE VIEW [dbo].[vw_interval_billgroup_counts] AS 
SELECT id_usage_interval, 
            SUM(CASE WHEN bgs.status = ''O'' OR bgs.status = ''C'' OR bgs.status = ''H'' 
                             THEN 1 ELSE 0 END) TotalGroupCount,

            SUM(CASE WHEN bgs.status = ''O'' THEN 1 ELSE 0 END) OpenGroupCount,
            SUM(CASE WHEN bgs.status = ''C'' THEN 1 ELSE 0 END) SoftClosedGroupCount,
            SUM(CASE WHEN bgs.status = ''H'' THEN 1 ELSE 0 END) HardClosedGroupCount
FROM vw_all_billing_groups_status bgs
GROUP BY id_usage_interval
	'
GO
/****** Object:  StoredProcedure [dbo].[sp_DeleteRateSchedule]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_DeleteRateSchedule]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
		create procedure [dbo].[sp_DeleteRateSchedule] 
			@a_rsID int
		as
		begin
			declare @id_effdate int
			declare @id_paramtbl int
			declare @nm_paramtbl NVARCHAR(255)
			declare @SQLString NVARCHAR(255)

			-- Find the information we need to delete rates
			set @id_effdate = (select id_eff_date from t_rsched where id_sched = @a_rsID)
			set @id_paramtbl = (select id_pt from t_rsched where id_sched = @a_rsID)			
			set @nm_paramtbl = (select nm_instance_tablename from t_rulesetdefinition where id_paramtable = @id_paramtbl)

			-- Create the delete statement for the particular rule table and execute it
			set @SQLString = N''delete from '' + @nm_paramtbl + '' where id_sched = '' + CAST(@a_rsID AS NVARCHAR(10))
			execute sp_executesql @SQLString

			-- Delete the remaining rate schedule info
			delete from t_rsched where id_sched = @a_rsID
			delete from t_effectivedate where id_eff_date = @id_effdate
			execute DeleteBaseProps @a_rsID
		end
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[HardCloseBillingGroup]    Script Date: 06/02/2008 11:43:47 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[HardCloseBillingGroup]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
Attempts to ''HardClose'' the given billing group.

Returns the following error codes:
   -1 : Unknown error occurred
   -2 : @id_billgroup does not exist
   -3 : The billgroup is already HardClosed
   -4 : This is the last billing group to be hard closed and there are unassigned accounts
          which are not hard closed
   -5 : Could not update billing group status to ''H''
=========================================================== */
CREATE PROCEDURE [dbo].[HardCloseBillingGroup]
(
  @id_billgroup INT,            -- specific billing group to hard close
  @status INT OUTPUT         -- return code: 0 is successful 
)
AS
    
BEGIN
  BEGIN TRAN

  SELECT @status = -1

     -- checks that the billing group exists
  IF NOT EXISTS (SELECT id_billgroup 
                          FROM t_billgroup
                          WHERE id_billgroup = @id_billgroup)
    BEGIN
       SET @status = -2
       ROLLBACK
       RETURN 
     END

  -- checks that the billing group is soft closed
  DECLARE @billingGroupStatus VARCHAR(1)
  DECLARE @intervalID INT
 
  SELECT @billingGroupStatus = status,
              @intervalID = id_usage_interval
  FROM vw_all_billing_groups_status
  WHERE id_billgroup = @id_billgroup

  IF (@billingGroupStatus = ''H'')
     BEGIN
       SET @status = -3
       ROLLBACK
       RETURN 
     END
 
  -- If this is the last billing group which is being hard closed for the interval 
  -- then make sure that all unassigned accounts have their status set to ''H''
  DECLARE @numHardClosedBillingGroups INT
  DECLARE @numBillingGroups INT
  DECLARE @lastBillingGroup INT

  SET @lastBillingGroup = 0
  
  SELECT @numHardClosedBillingGroups = COUNT(id_billgroup)
  FROM vw_all_billing_groups_status
  WHERE id_usage_interval = @intervalID AND
              status = ''H''

  SELECT @numBillingGroups = COUNT(id_billgroup)
  FROM vw_all_billing_groups_status
  WHERE id_usage_interval = @intervalID
 
  IF (@numHardClosedBillingGroups = (@numBillingGroups - 1))
  BEGIN
     SET @lastBillingGroup = 1
  END

  IF (@lastBillingGroup = 1)
     BEGIN
        IF EXISTS (SELECT AccountID 
                        FROM vw_unassigned_accounts
                        WHERE IntervalID = @intervalID AND
                                    State != ''H'')
           
          BEGIN
	  SET @status = -4
	  ROLLBACK
	  RETURN 
          END                  
     END
  
  -- Update the billing group status to ''H''
  EXEC UpdateBillingGroupStatus @id_billgroup, ''H''
  
  -- Update the status in t_usage_interval to hard closed, if possible.
  DECLARE @status1 INT
  EXEC UpdIntervalStatusToHardClosed @intervalID, 0, @status1 OUTPUT
  
  IF (@@ERROR != 0)
    BEGIN
       SELECT @status = -5
       ROLLBACK
       RETURN
    END   
 
  SET @status = 0 -- success
  COMMIT

END
  ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreatePaymentRecord]    Script Date: 06/02/2008 11:43:29 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreatePaymentRecord]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			 
CREATE PROCEDURE  [dbo].[CreatePaymentRecord] (
  @Payer  int,
  @NPA int,
  @startdate  datetime,
  @enddate datetime,
  @payerbillable varchar(1),
  @systemdate datetime,
  @p_fromUpdate char(1),
  @p_enforce_same_corporation varchar(1),
  @p_account_currency nvarchar(5),
  @status int OUTPUT)
  as
  begin

  declare @realstartdate datetime
  declare @realenddate datetime
  declare @accCreateDate datetime
  declare @billableFlag varchar(1)
  declare @payer_state varchar(10)

  select @status = 0
  select @realstartdate = dbo.mtstartofday(@startdate)    
  if (@enddate is NULL)
    begin
    select @realenddate = dbo.mtstartofday(dbo.MTMaxDate()) 
    end
 else
   begin
	if @enddate <> dbo.mtstartofday(dbo.MTMaxDate())
		select @realenddate = DATEADD(d, 1,dbo.mtstartofday(@enddate))
	else
		select @realenddate = @enddate
    end

	select @AccCreateDate = dbo.mtstartofday(dt_crt) from t_account where id_acc = @NPA
	if @realstartdate < @AccCreateDate 
	begin
		-- MT_PAYMENT_DATE_BEFORE_ACCOUNT_STARDATE
		select @status = -486604753
		return
	end
	if @realstartdate = @realenddate begin
		-- MT_PAYMENT_START_AND_END_ARE_THE_SAME
		select @status = -486604735
		return
	end
	if @realstartdate > @realenddate begin
		-- MT_PAYMENT_START_AFTER_END
		select @status = -486604734
		return
	end
	 /* 
		NPA: Non Paying Account
	  Assumptions: The system has already checked if an existing payment
	  redirection record exists.  The user is asked whether the 
	  system should truncate the existing payment redirection record.
	  business rule checks:
	  MT_ACCOUNT_CAN_NOT_PAY_FOR_ITSELF (0xE2FF0007L, -486604793)
	  ACCOUNT_IS_NOT_BILLABLE (0xE2FF0005L,-486604795)
	  MT_PAYMENT_RELATIONSHIP_EXISTS (0xE2FF0006L, -486604794)
	  step 1: Account can not pay for itself
	if (@Payer = @NPA)
	begin
		select @status = -486604793
		return
		end  
	 */
	if (@Payer <> -1)
	begin
		select @billableFlag = case when @payerbillable is NULL then
			dbo.IsAccountBillable(@payer)	else @payerbillable end
		 -- step 2: The account is in a state such that new payment records can be created
		if (@billableFlag = ''0'') begin
			-- MT_ACCOUNT_IS_NOT_BILLABLE
		select @status = -486604795
			return
		end
	
	
	
		-- make sure that the paying account is active for the entire payment period
		select TOP 1 @payer_state = status from t_account_state
		where dbo.enclosedDateRange(vt_start,vt_end,@realstartdate,@realenddate) = 1 AND
		id_acc = @payer
		if @payer_state is NULL OR @payer_state <> ''AC'' begin
			-- MT_PAYER_IN_INVALID_STATE
			select @status = -486604736
			return
		end
	

		-- always check that payer and payee are on the same currency
		-- (if they are not the same, of course)
		-- if @p_account_currency parameter was passed as empty string, then 
		-- the call is coming either from MAM, and the currency is not available,
		-- or the call is coming from account update session, where currency is not being
	-- updated. In both cases it won''t hurt to resolve it from t_av_internal and check
		-- that it matches payer currency.. ok, in Kona, an account that can never be a payer
		-- need not have a currency, handle this.
		if(@NPA <> @payer)
		begin
			if((LEN(@p_account_currency) = 0) OR (LEN(@p_account_currency) is null))
			begin
			SELECT @p_account_currency = c_currency from t_av_internal WHERE id_acc = @NPA
				if (@p_account_currency is null)
				begin
				  -- check if the account type has the b_canbepayer false, if it is then just assume that it has
				  -- the same currency as the prospective payer.
	  			  declare @NPAPayerRule varchar(1)
	  			  select @NPAPayerRule = b_CanBePayer from t_account_type atype
	  			  inner join t_account acc
	  			  on atype.id_type = acc.id_type
	  			  where acc.id_acc = @NPA
	  			  if (@NPAPayerRule = ''0'')
	  			    select @p_account_currency = c_currency from t_av_internal where id_acc = @payer
				end
			end
		
			declare @sameCurrency int
			select @sameCurrency = 
				(SELECT COUNT(payerav.id_acc)  from t_av_internal payerav
				where payerav.id_acc = @payer AND (payerav.c_currency) = (@p_account_currency)
				)
			if @sameCurrency = 0
			begin
				-- MT_PAYER_PAYEE_CURRENCY_MISMATCH
				select @status = -486604728
				return
			end
		end
		-- check that both the payer and Payee are in the same corporate account
		--only check this if business rule is enforced
		--only check this if the payee''s current ancestor is not -1
		declare @payeeCurrentAncestor integer
		select @payeeCurrentAncestor = id_ancestor from t_account_ancestor
		where id_descendent = @NPA and  @realstartdate between vt_start AND vt_end
	  and num_generations = 1
	 
		if (@p_enforce_same_corporation = 1 AND @payeeCurrentAncestor <> -1 AND dbo.IsInSameCorporateAccount(@payer,@NPA,@realstartdate) <> 1)
		begin
			-- MT_CANNOT_PAY_FOR_ACCOUNT_IN_OTHER_CORPORATE_ACCOUNT
			select @status = -486604758
			return
		end
	end
	-- return without doing work in cases where nothing needs to be done
	select @status = count(*) 
	from t_payment_redirection where id_payer = @payer AND id_payee = @NPA
	AND (
		(dbo.encloseddaterange(vt_start,vt_end,@realstartdate,@realenddate) = 1 AND @p_fromupdate = ''N'') 
		OR
		(vt_start <= @realstartdate AND vt_end = @realenddate AND @p_fromupdate = ''Y'')
	)
	if @status > 0 begin
		-- account is already paying for the account during the interval.  Simply ignore
		-- the action
		select @status = 1
		return
	end

	exec CreatePaymentRecordBitemporal @payer,@NPA,@realstartdate,@realenddate,@systemdate, @status OUTPUT
  IF @status <> 1
    RETURN -- failure

  -- post-operation business rule checks (relies on rollback of work done up until this point)
  DECLARE @check1 INT, @check2 INT, @check3 INT
  SELECT 
  -- CR9906: checks to make sure the new payer''s billing cycle matches all of the payee''s 
  -- group subscriptions'' BCR constraints
    @check1 = ISNULL(MIN(dbo.CheckGroupMembershipCycleConstraint(@systemdate, groups.id_group)), 1),
    -- EBCR cycle constraint checks
    @check2 = ISNULL(MIN(dbo.CheckGroupMembershipEBCRConstraint(@systemdate, groups.id_group)), 1)
  FROM 
  (
    -- gets all of the payee''s group subscriptions
    SELECT DISTINCT gsm.id_group id_group
    FROM t_gsubmember gsm
    WHERE gsm.id_acc = @NPA  -- payee ID
  ) groups

  IF (@check1 <> 1)
  BEGIN
    SET @status = @check1
    RETURN
  END
  ELSE IF (@check2 <> 1)
  BEGIN
    SET @status = @check2
    RETURN
  END

  SELECT  
    @check3 = ISNULL(MIN(dbo.CheckGroupReceiverEBCRConstraint(@systemdate, groups.id_group)), 1)
  FROM 
  (
    -- gets all of the payee''s receiverships
    SELECT DISTINCT gsrm.id_group id_group
    FROM t_gsub_recur_map gsrm
    WHERE gsrm.id_acc = @NPA  -- payee ID
  ) groups

  IF (@check3 <> 1)
    SET @status = @check3

  -- Part of bug fix for 13588  
  -- check that - if the payee has individual subscriptions to product offerings with BCR constraints, then the
  -- new payer''s cycle type satisfies those constraints.
 
  DECLARE @payer_cycle_type int
  DECLARE @check4 int

  set @payer_cycle_type = (select type.id_cycle_type 
    from t_acc_usage_cycle uc
    inner join t_usage_cycle ucc
    on uc.id_usage_cycle = ucc.id_usage_cycle
    inner join t_usage_cycle_type type
    on ucc.id_cycle_type = type.id_cycle_type
    where uc.id_acc = @payer)
  
  select top 1 @check4 = ISNULL(id_po, 1) from t_sub sub where id_acc = @NPA
  and id_group is null
  and @realenddate >= sub.vt_start and @realstartdate <= sub.vt_end
  and dbo.POContainsBillingCycleRelative(id_po) = 1
  and @payer_cycle_type <> dbo.poConstrainedCycleType(id_po)
  
  IF (@check4 <> 1)
    SET @status = -289472464

END
' 
END
GO
/****** Object:  StoredProcedure [dbo].[AddAccountToGroupSub]    Script Date: 06/02/2008 11:42:57 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddAccountToGroupSub]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
create procedure [dbo].[AddAccountToGroupSub](
	@p_id_sub int,             -- subscription ID of the group
	@p_id_group int,           -- group ID
	@p_id_po int,              -- product offering ID to which the group is subscribed
	@p_id_acc int,             -- account ID of the candidate member
	@p_startdate datetime,     -- date at which membership should begin
	@p_enddate datetime,       -- date at which membership should end
	@p_systemdate datetime,    -- current system time
	@p_enforce_same_corporation varchar,
	@p_status int OUTPUT,
	@p_datemodified varchar output)
as
begin
declare @existingID as int
declare @real_enddate as datetime
declare @real_startdate datetime
	select @p_status = 0
	-- step : if the end date is null get the max date
	-- XXX this is broken if the end date of the group subscription is not max date
	if (@p_enddate is null)
		begin
		select @real_enddate = dbo.MTMaxDate()
		end
	else
		begin
		if @p_startdate > @p_enddate begin
			-- MT_GROUPSUB_STARTDATE_AFTER_ENDDATE
			select @p_status = -486604782
			select @p_datemodified = ''N''
			return
		end

		select @real_enddate = @p_enddate
		end 
	select @real_startdate = dbo.mtmaxoftwodates(@p_startdate,t_sub.vt_start),
	@real_enddate = dbo.mtminoftwodates(@real_enddate,t_sub.vt_end) 
	from 
	t_sub where id_sub = @p_id_sub

	if (@real_startdate <> @p_startdate OR
	(@real_enddate <> @p_enddate AND @real_enddate <> dbo.mtmaxdate()))
		begin
			select @p_datemodified = ''Y''
		end
		else
		begin
			select @p_datemodified = ''N''
		end
	begin
	-- step : check that account is not already part of the group subscription
	-- in the specified date range
		select @existingID = id_acc from t_gsubmember where
	-- check againt the account
		id_acc = @p_id_acc AND id_group = @p_id_group
	-- make sure that the specified date range does not conflict with 
	-- an existing range
		AND dbo.overlappingdaterange(vt_start,vt_end,
		@real_startdate,@real_enddate) = 1
		if (@existingID = @p_id_acc)
			begin
			-- MT_ACCOUNT_ALREADY_IN_GROUP_SUBSCRIPTION 
			select @p_status = -486604790
			return
			end 
		if (@existingID is null)
			begin
			select @p_status = 0 
			end
	end
		-- step : verify that the date range is inside that of the group subscription
		begin
			select @p_status = dbo.encloseddaterange(vt_start,vt_end,@real_startdate,@real_enddate)  
			from t_sub where id_group = @p_id_group
			if (@p_status <> 1 ) 
			begin
			-- MT_GSUB_DATERANGE_NOT_IN_SUB_RANGE
			select @p_status = -486604789
			return
			end 
		if (@p_status is null) 
			begin
			-- MT_GROUP_SUBSCRIPTION_DOES_NOT_EXIST
			select @p_status = -486604788
			return 
		end
		end
		-- step : check that the account does not have any conflicting subscriptions
		-- note: checksubscriptionconflicts return 0 on success while the other
		-- functions return 1.  This should be fixed (CS 2-1-2001)
		select @p_status = dbo.checksubscriptionconflicts(@p_id_acc,@p_id_po,
		@real_startdate, @real_enddate,@p_id_sub) 
		if (@p_status <> 1 ) 
			begin
			 return
			end 
		
		-- bug fix for 13538.. This check is done better in CheckSubscriptionConflicts	
		-- Check that both account and PO have the same currency
		-- if (dbo.IsAccountAndPOSameCurrency(@p_id_acc, @p_id_po) = ''0'')
		-- begin
			-- MT_ACCOUNT_PO_CURRENCY_MISMATCH
			-- select @p_status = -486604729
			-- return
		-- end
		 -- make sure that the member is in the corporate account specified in 
		 -- the group subscription
		 -- only check this if Corp business rule is enforced.
		if (@p_enforce_same_corporation = ''1'')
		begin
			select @p_status = count(num_generations) from 
			t_account_ancestor ancestor
			INNER JOIN t_group_sub tg on tg.id_group = @p_id_group
			where ancestor.id_ancestor = tg.id_corporate_account AND
			ancestor.id_descendent = @p_id_acc AND
			@real_startdate between ancestor.vt_start AND ancestor.vt_end
			if (@p_status = 0 )
			begin
			-- MT_ACCOUNT_NOT_IN_GSUB_CORPORATE_ACCOUNT
			select @p_status = -486604769
			return
			end
		end
		
		-- check that account type of the member is compatible with the product offering
    -- since the absense of ANY mappings for the product offering means that PO is "wide open"
    -- we need to do 2 EXISTS queries

		if
		 exists (
      SELECT 1
      FROM t_po_account_type_map atmap 
      WHERE atmap.id_po = @p_id_po
    )
    --PO is not wide open - see if susbcription is permitted for the account type
    AND
    not exists (
      SELECT 1
      FROM  t_account tacc 
      INNER JOIN t_po_account_type_map atmap on atmap.id_po = @p_id_po AND atmap.id_account_type = tacc.id_type
      WHERE  tacc.id_acc = @p_id_acc
    )
    begin
      select @p_status = -289472435 -- MTPCUSER_CONFLICTING_PO_ACCOUNT_TYPE
      return
    end
    
    -- Check for MTPCUSER_ACCOUNT_TYPE_CANNOT_PARTICIPATE_IN_GSUB 0xEEBF004FL -289472433
    -- BR violation
    if
		 exists (
      SELECT 1
      FROM  t_account tacc 
      INNER JOIN t_account_type tacctype on tacc.id_type = tacctype.id_type
      WHERE tacc.id_acc = @p_id_acc AND tacctype.b_CanParticipateInGSub = ''0''
    )
    begin
      select @p_status = -289472433 -- MTPCUSER_ACCOUNT_TYPE_CANNOT_PARTICIPATE_IN_GSUB 
      return
    end
    
    

		
		 
		-- end business rule checks

	exec CreateGSubmemberRecord @p_id_group,@p_id_acc,@real_startdate,@real_enddate,@p_systemdate,@p_status OUTPUT

  -- post-creation business rule check (relies on rollback of work done up until this point)

  -- CR9906: check to make sure the newly added member does not violate a BCR constraint
  SELECT @p_status = dbo.CheckGroupMembershipCycleConstraint(@p_systemdate, @p_id_group)
  IF (@p_status <> 1)
    RETURN

  -- checks to make sure the member''s payer''s do not violate EBCR cycle constraints
  SELECT @p_status = dbo.CheckGroupMembershipEBCRConstraint(@p_systemdate, @p_id_group)
END
	
	' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdateCounterInstance]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateCounterInstance]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
					create proc [dbo].[UpdateCounterInstance]
											@id_lang_code int,
                      @id_prop int,
											@counter_type_id int,
											@nm_name nvarchar(255),
											@nm_desc nvarchar(255)
					AS
					BEGIN TRAN
            exec UpdateBaseProps @id_prop, @id_lang_code, NULL, @nm_desc, NULL
						UPDATE 
 							t_base_props  
						SET 
 							nm_name = @nm_name, nm_desc = @nm_desc 
						WHERE 
 							id_prop = @id_prop
 						UPDATE 
 							t_counter
						SET 
 							id_counter_type = @counter_type_id
						WHERE 
 							id_prop = @id_prop
					COMMIT TRAN
			 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[RemoveAdjustmentTypeProps]    Script Date: 06/02/2008 11:44:06 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[RemoveAdjustmentTypeProps]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
			    create proc [dbo].[RemoveAdjustmentTypeProps]
          @p_id_prop int
          AS
          BEGIN
            DECLARE @propid INT
            DECLARE CursorVar CURSOR STATIC
            FOR SELECT id_prop FROM T_ADJUSTMENT_TYPE_PROP WHERE id_adjustment_type =@p_id_prop
            OPEN CursorVar
            DELETE FROM T_ADJUSTMENT_TYPE_PROP WHERE id_adjustment_type =@p_id_prop
            FETCH NEXT FROM CursorVar into  @propid
            WHILE @@FETCH_STATUS = 0
            BEGIN
              exec DeleteBaseProps @propid
              FETCH NEXT FROM CursorVar into  @propid
            END
          CLOSE CursorVar
          DEALLOCATE CursorVar
          END
				' 
END
GO
/****** Object:  StoredProcedure [dbo].[RemoveCounterPropDef]    Script Date: 06/02/2008 11:44:06 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[RemoveCounterPropDef]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
                
					CREATE PROC [dbo].[RemoveCounterPropDef]
											@id_prop int
					AS
					DECLARE @id_locale int
					BEGIN TRAN
						DELETE FROM t_counter_map 
							WHERE id_cpd = @id_prop 
						DELETE FROM t_counterpropdef WHERE id_prop = @id_prop
            /* CR 14459 */
            exec DeleteBaseProps @id_prop
					COMMIT TRAN
        ' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdateCounterPropDef]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateCounterPropDef]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
					CREATE PROC [dbo].[UpdateCounterPropDef]
											@id_lang_code int,
											@id_prop int,
											@nm_name nvarchar(255),
											@nm_display_name nvarchar(255),
											@id_pi int,
											@nm_servicedefprop nvarchar(255),
											@nm_preferredcountertype nvarchar(255),
											@n_order int
					AS
					DECLARE @identity_value int
						DECLARE @id_locale int
					BEGIN TRAN
						exec UpdateBaseProps @id_prop, @id_lang_code, @nm_name, NULL, @nm_display_name
						UPDATE t_counterpropdef 
						SET
							nm_servicedefprop = @nm_servicedefprop,
							n_order = @n_order,
							nm_preferredcountertype = @nm_preferredcountertype
						WHERE id_prop = @id_prop
					COMMIT TRAN
         ' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdateGroupSubscription]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateGroupSubscription]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
create procedure [dbo].[UpdateGroupSubscription](
@p_id_group int,
@p_name nvarchar(255),
@p_desc nvarchar(255),
@p_startdate datetime,
@p_enddate datetime,
@p_proportional varchar,
@p_supportgroupops varchar,
@p_discountaccount int,
@p_CorporateAccount int,
@p_systemdate datetime,
@p_enforce_same_corporation varchar,
@p_status int OUTPUT,
@p_datemodified varchar OUTPUT
)
as
begin
	declare @idPO as int
	declare @idSUB as int
	declare @realenddate as datetime
	declare @oldstartdate as datetime
	declare @oldenddate as datetime
	declare @varMaxDateTime as datetime
	declare @idusagecycle int
	select @varMaxDateTime = dbo.MTMaxDate()
	

-- Section 1
	-- find the product offering ID
	select @idPO = id_po, @idusagecycle = tg.id_usage_cycle,@idSUB = t_sub.id_sub
	from t_sub 
	INNER JOIN t_group_sub tg on tg.id_group = @p_id_group
	where t_sub.id_group = @p_id_group
	

-- Section 2
	-- business rule checks
	if (@p_enddate is null)
		begin
		select @realenddate = @varMaxDateTime
		end
	else
		begin
		select @realenddate = @p_enddate
		end 
	exec CheckGroupSubBusinessRules @p_name,@p_desc,@p_startdate,@p_enddate,@idPO,
	@p_proportional,@p_discountaccount,@p_CorporateAccount,@p_id_group,@idusagecycle,@p_systemdate,@p_enforce_same_corporation, @p_status output
	if (@p_status <> 1) begin
		return
	end
	exec UpdateSub @idSUB,@p_startdate,@realenddate,''N'',''N'',@idPO,NULL,@p_systemdate,
		@p_status OUTPUT,@p_datemodified OUTPUT
	if @p_status <> 1 begin
		return
	end
	update t_group_sub set tx_name = @p_name,tx_desc = @p_desc,b_proportional = @p_proportional,
	id_corporate_account = @p_CorporateAccount,id_discountaccount = @p_discountaccount,
	b_supportgroupops = @p_supportgroupops
	where id_group = @p_id_group
	

-- Section 3
	-- Ok, here is how I propose to do this.
	-- First of all, we will end the current history of all memberships whose duration
	-- falls, partially or completely, out of the group subscription duration.
	-- This is accomplished with the following statement.
	update t_gsubmember_historical
	set tt_end = dateadd(s, -1, @p_systemdate)
	where id_group = @p_id_group 
		AND tt_end = @varMaxDateTime
		AND ((@p_startdate > vt_start) OR (@realenddate < vt_end))
		
-- TODO: When converting this procedure to oracle, sections 4, 5, and 6 have changed since 3.0.1
-- Section 4
	-- The next step involves inserting the new history of the memberships that were changed somehow.
	-- Except that we do not need to insert new history for the memberships that were *completely* left out
	-- of the group sub duration. Those are effectively deleted, and the last entry on t_gsubmember_history
	-- for them will have tt_end = systemdate.
	insert into t_gsubmember_historical (id_group,id_acc,vt_start,vt_end,tt_start,tt_end)
	select id_group,id_acc,
	dbo.mtmaxoftwodates(tgs.vt_start,@p_startdate),
	dbo.mtminoftwodates(tgs.vt_end,@realenddate),
	@p_systemdate,
	@varMaxDateTime
	from t_gsubmember tgs
	where tgs.id_group = @p_id_group
		and ((@p_startdate > vt_start and vt_end >= @p_startdate) OR (@realenddate < vt_end and vt_start <= @realenddate))

-- Section 5
	-- Finally, we will select the records that are still relevant to the current format of the group subscription
	-- and insert them from t_gsubmember_historical into t_gsubmember.
	
	-- First remove the old records
	delete from t_gsubmember where id_group = @p_id_group
	-- Then import the records that are relevant to this group subscription
	insert into t_gsubmember (id_group,id_acc,vt_start,vt_end)
		select id_group,id_acc,vt_start,vt_end
		from t_gsubmember_historical
		where id_group = @p_id_group and tt_end = @varMaxDateTime


  -- post-operation business rule checks (relies on rollback of work done up until this point)

  -- CR9906: check to make sure the newly added member does not violate a BCR constraint
  SELECT @p_status = dbo.CheckGroupMembershipCycleConstraint(@p_systemdate, @p_id_group)
  IF (@p_status <> 1)
    RETURN
  
  -- checks to make sure the member''s payer''s do not violate EBCR cycle constraints
  SELECT @p_status = dbo.CheckGroupMembershipEBCRConstraint(@p_systemdate, @p_id_group)
  IF (@p_status <> 1)
    RETURN

  -- checks to make sure the receiver''s payer''s do not violate EBCR cycle constraints
  SELECT @p_status = dbo.CheckGroupReceiverEBCRConstraint(@p_systemdate, @p_id_group)
end
		 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[CreateGroupSubscription]    Script Date: 06/02/2008 11:43:27 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[CreateGroupSubscription]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
create procedure [dbo].[CreateGroupSubscription](
@p_sub_GUID varbinary(16),
@p_group_GUID varbinary(16),
@p_name  nvarchar(255),
@p_desc nvarchar(255),
@p_usage_cycle int,
@p_startdate datetime,
@p_enddate datetime,
@p_id_po int,
@p_proportional varchar,
@p_supportgroupops varchar,
@p_discountaccount int,
@p_CorporateAccount int,
@p_systemdate datetime,
@p_enforce_same_corporation varchar,
@p_id_sub int,
@p_id_group int OUTPUT,
@p_status int OUTPUT,
@p_datemodified varchar OUTPUT
)
as
begin
declare @existingPO as int
declare @realenddate as datetime
declare @varMaxDateTime as datetime
select @p_datemodified = ''N''
 -- business rule checks
select @varMaxDateTime = dbo.MTMaxDate()
select @p_status = 0
exec CheckGroupSubBusinessRules @p_name,@p_desc,@p_startdate,@p_enddate,@p_id_po,@p_proportional,
@p_discountaccount,@p_CorporateAccount,NULL,@p_usage_cycle,@p_systemdate, @p_enforce_same_corporation, @p_status OUTPUT
if (@p_status <> 1) 
	begin
	return
	end 
	-- set the end date to max date if it is not specified
if (@p_enddate is null) 
	begin
	select @realenddate = @varMaxDateTime
	end
else
	begin
	select @realenddate = @p_enddate
	end 
	insert into t_group_sub (id_group_ext,tx_name,tx_desc,b_visable,b_supportgroupops,
	id_usage_cycle,b_proportional,id_discountAccount,id_corporate_account)
	select @p_group_GUID,@p_name,@p_desc,''N'',@p_supportgroupops,@p_usage_cycle,
	@p_proportional,@p_discountaccount,@p_CorporateAccount
	-- group subscription ID
	select @p_id_group =@@identity
 -- add group entry
  exec AddSubscriptionBase NULL,@p_id_group,@p_id_po,@p_startdate,@p_enddate,
	@p_group_GUID,@p_systemdate,@p_id_sub,@p_status output,@p_datemodified output
end
			' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdateUnassignedAccounts]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateUnassignedAccounts]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
1) Parses the comma separated account identifiers (@accountArray) using the user defined function ''CSVToInt''
2) Validates that there are no duplicate accounts in @accountArray
3) Validates that the accounts are unassigned
4) Validates that the accounts aren''t already in the state specified by @state
5) If @checkUsage is 1 then
       - Separates the accounts in @accountArray into accounts which
          have usage and those which don''t
       - Updates the status of the unassigned accounts which don''t have usage to @state
       - Returns the list of accounts which have usage
6) If @checkUsage is 0 then
        - Updates the status of all accounts in @accountArray to @state
7) If @isTransactional is 1 then the procedure uses a transaction otherwise
   it is non-transactional.
7) Updates the status of the interval to ''H'' if necessary

Returns the following error codes:
   -1 : Unknown error occurred
   -2 : No accounts in @accountArray
   -3 : Duplicate accounts in @accountArray 
   -4 : Account(s) in @accountArray not a member of the unassigned group of accounts 
   -5 : Accounts(s) in @accountArray already in state specified by @state
  
=========================================================== */
CREATE PROCEDURE [dbo].[UpdateUnassignedAccounts]
(
   @accountArray VARCHAR(4000),
   @id_interval INT,
   @state CHAR(1),
   @checkUsage INT,   -- 0 or 1
   @isTransactional INT, -- 0 or 1
   @status INT OUTPUT
)
AS
   IF (@isTransactional = 1)
      BEGIN
         BEGIN TRAN
      END
   
   SET @status = -1
 
   /* Hold the user specified account id''s in @accountArray */
   DECLARE @accounts TABLE
   ( 
      id_acc INT NOT NULL,
      hasUsage CHAR(1) NOT NULL
   )

  /* Insert the accounts in @accountArray into @accounts */
  INSERT INTO @accounts
  SELECT value, ''N'' FROM CSVToInt(@accountArray)
   
  /* Error if there are no accounts */
  IF (@@ROWCOUNT =  0)
    BEGIN
      SET @status = -2
       IF (@isTransactional = 1)
         BEGIN
            ROLLBACK
         END
      RETURN 
    END

   /* Error if there are duplicate accounts in @accounts */
    IF (EXISTS (SELECT id_acc 
                     FROM @accounts
	         GROUP BY id_acc
	         HAVING COUNT(id_acc) > 1))
      BEGIN
         SET @status = -3
          IF (@isTransactional = 1)
          BEGIN
             ROLLBACK
          END
         RETURN 
      END

   /* Error if the accounts in @accounts are not a member unassigned accounts */
   IF (NOT EXISTS (SELECT * 
                            FROM @accounts acc 
                            INNER JOIN vw_unassigned_accounts ua 
                                ON ua.AccountID = acc.id_acc
                            WHERE ua.IntervalID = @id_interval))
      BEGIN
         SET @status = -4
          IF (@isTransactional = 1)
          BEGIN
            ROLLBACK
          END
         RETURN 
      END

   /* Error if the accounts in @accounts are already in the state specified by @state */
   IF (EXISTS (SELECT * 
                    FROM @accounts acc 
                    INNER JOIN vw_unassigned_accounts ua 
                        ON ua.AccountID = acc.id_acc AND
                              ua.State = @state
                    WHERE ua.IntervalID = @id_interval))
      BEGIN
         SET @status = -5
          IF (@isTransactional = 1)
          BEGIN
            ROLLBACK
          END
         RETURN 
      END
   
   /* Separate accounts into two groups. Those that have usage and those that don''t.  */
   IF (@checkUsage = 1)
      BEGIN
	   UPDATE acc
	   SET hasUsage = ''Y''
	   FROM @accounts acc 
	   INNER JOIN t_acc_usage au
	      ON au.id_acc = acc.id_acc 
	   WHERE
	      au.id_usage_interval = @id_interval
	
	   /* Update the accounts which don''t have usage to @state */
	   UPDATE aui
	   SET tx_status = @state
	   FROM t_acc_usage_interval aui
	   INNER JOIN @accounts accounts
	      ON accounts.id_acc = aui.id_acc
	   WHERE
	      accounts.hasUsage = ''N'' AND
	      aui.id_usage_interval = @id_interval
       END
   ELSE
       BEGIN
              /* Update all accounts to @state */
	   UPDATE aui
	   SET tx_status = @state
	   FROM t_acc_usage_interval aui
	   INNER JOIN @accounts accounts
	      ON accounts.id_acc = aui.id_acc
	   WHERE
	      aui.id_usage_interval = @id_interval
        END
  
   SET @status = 0

   -- Update the status in t_usage_interval. The output status does not matter
   -- because the interval may not be updated to hard closed.
   DECLARE @status1 INT
   EXEC UpdIntervalStatusToHardClosed @id_interval, 0, @status1 OUTPUT

   /* Return the list of accounts which have usage */
   SELECT id_acc 
   FROM @accounts
   WHERE hasUsage = ''Y''
   
   IF (@isTransactional = 1)
      BEGIN
         COMMIT
      END   
         ' 
END
GO
/****** Object:  StoredProcedure [dbo].[StartUserDefinedGroupCreation]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[StartUserDefinedGroupCreation]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
                
/* ===========================================================
This procedure operates only on unassigned accounts for the given interval (obtained via id_materialization).

1) Check that no interval-only adapter has executed successfully
2) If @accountArray is NULL then use all the unassigned accounts for the given interval 
3) Parses the comma separated account identifiers (@accountArray, if non-NULL) using the user defined function ''CSVToInt''
2) Validates that there are no duplicate accounts in @accountArray
3) Validates that the accounts in @accountArray are from the set of unassigned accounts
4) Inserts name and description into t_billgroup_tmp
5) Inserts unassigned account ids into  t_billgroup_member_tmp

Returns the following error codes:
   -1 : Unknown error occurred
   -2 : Full materialization has not occurred for this interval
   -3 : Atleast one interval-only adapter has executed successfully
   -4 : There are no unassigned accounts for the interval
   -5 : @accountArray is non-NULL and no accounts in @accountArray
   -6 : @accountArray is non-NULL and duplicate accounts in @accountArray 
   -7 : @accountArray is non-NULL and one or more accounts do not belong to the set of unassigned accounts
   -8 : The given billing group name already exists
=========================================================== */
CREATE PROCEDURE [dbo].[StartUserDefinedGroupCreation]
(
   @id_materialization INT,
   @tx_name NVARCHAR(50),
   @tx_description NVARCHAR(200),
   @accountArray VARCHAR(4000),
   @status INT OUTPUT
)
AS
   BEGIN TRAN
   
   SET @status = -1
 
   /* Hold the user specified account ids in @accountArray */
   DECLARE @accounts TABLE
   ( 
      id_acc INT NOT NULL
   )

   /* Hold the unassigned account ids for this interval  */
   DECLARE @unassignedAccounts TABLE
   ( 
      id_acc INT NOT NULL
   )

   /* Store the interval id */
   DECLARE @id_interval INT
   SELECT @id_interval = id_usage_interval
   FROM t_billgroup_materialization
   WHERE id_materialization = @id_materialization

   -- CR 14312
   /* Error if a billing group with the given name already exists */
   IF EXISTS (SELECT tx_name 
              FROM t_billgroup bg
              WHERE tx_name = @tx_name AND 
                    id_usage_interval = @id_interval)
      BEGIN
       SET @status = -8
       ROLLBACK
       RETURN 
     END
     
   /* Error if full materialization has not been done on this interval */
   IF NOT EXISTS (SELECT id_materialization 
                           FROM t_billgroup_materialization 
                           WHERE tx_type = ''Full'' AND
                                       tx_status = ''Succeeded'' AND
                                       id_usage_interval = @id_interval)
    BEGIN
       SET @status = -2
       ROLLBACK
       RETURN 
     END
                                     
   /* Error if atleast one interval-only adapter has executed successfully */
   IF (EXISTS (SELECT id_instance
                    FROM t_recevent_inst ri
                    INNER JOIN t_recevent re
                         ON re.id_event = ri.id_event
                    WHERE ri.id_arg_interval = @id_interval AND
                                re.tx_billgroup_support = ''Interval'' AND
                                re.tx_type = ''EndOfPeriod'' AND
                                ri.tx_status = ''Succeeded''))
    BEGIN
       SET @status = -3
       ROLLBACK
       RETURN 
     END
    
   /* Get all the open unassigned accounts for the interval */
   INSERT @unassignedAccounts
   SELECT AccountID
   FROM vw_unassigned_accounts vua
    WHERE vua.State = ''O'' AND
               vua.IntervalID = @id_interval

   IF (SELECT COUNT(id_acc) FROM @unassignedAccounts) = 0
     BEGIN
       SET @status = -4
       ROLLBACK
       RETURN 
     END
  

    /* If @accountArray is NULL then transfer the accounts from @unassignedAccounts to
        @accounts and continue */
    IF (@accountArray IS NULL)
        BEGIN
            INSERT @accounts
            SELECT * FROM @unassignedAccounts
        END
    ELSE
        /* @accountArray is not NULL - do validations */
        BEGIN
             /* Insert the accounts in @accountArray into @accounts */
             INSERT INTO @accounts
             SELECT value FROM CSVToInt(@accountArray)

             /* Error if there are no accounts */
	 IF (@@ROWCOUNT =  0)
	    BEGIN
	      SET @status = -5
	      ROLLBACK
	      RETURN 
	    END

              /* Error if there are duplicate accounts in @accounts */
	  IF (EXISTS (SELECT id_acc 
	                   FROM @accounts
		       GROUP BY id_acc
		       HAVING COUNT(id_acc) > 1))
	      BEGIN
	         SET @status = -6
	         ROLLBACK
	         RETURN 
	      END

              /* Error if the accounts in @accounts are not a member of @unassignedAccounts */
                IF (EXISTS (SELECT id_acc 
                               FROM @accounts acc
                               WHERE id_acc NOT IN (SELECT id_acc FROM @unassignedAccounts)))
                  BEGIN
	         SET @status = -7
	         ROLLBACK
	         RETURN 
	      END
        END  -- end ELSE

   /* Insert row into t_billgroup_tmp */
   INSERT t_billgroup_tmp  (id_materialization, tx_name, tx_description) 
     VALUES (@id_materialization, @tx_name, @tx_description)

   /* Insert rows into t_billgroup_member_tmp */
   INSERT INTO t_billgroup_member_tmp (id_materialization, tx_name, id_acc)
   SELECT @id_materialization, @tx_name, acc.id_acc
   FROM @accounts acc 

   SET @status = 0
   COMMIT   
         ' 
END
GO
/****** Object:  StoredProcedure [dbo].[SubmitEventForExecution]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SubmitEventForExecution]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
Modified from the previous version to use billing groups information.
=========================================================== */
CREATE PROCEDURE [dbo].[SubmitEventForExecution]
(
  @dt_now DATETIME,
  @id_instance INT,
  @b_ignore_deps VARCHAR(1),
  @dt_effective DATETIME,
  @id_acc INT,
  @tx_detail nvarchar(2048),
  @status INT OUTPUT
)
AS

BEGIN

  BEGIN TRAN

  SELECT @status = -99

  -- if the event is a checkpoint, synchronously acknowledges it
  DECLARE @isCheckpoint INT
  SELECT @isCheckpoint = 1 
  FROM t_recevent_inst inst
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  WHERE 
    inst.id_instance = @id_instance AND
    evt.tx_type = ''Checkpoint''

  IF (@isCheckpoint = 1)
  BEGIN
    EXEC AcknowledgeCheckpoint @dt_now, @id_instance, @b_ignore_deps, @id_acc, @tx_detail, @status OUTPUT
    IF (@status = 0)
      COMMIT
    ELSE
      ROLLBACK
    RETURN 
  END

  -- updates the run state to ''ReadyToRun'' only after the run is valid
  UPDATE t_recevent_inst
  SET tx_status = ''ReadyToRun'', b_ignore_deps = @b_ignore_deps, dt_effective = @dt_effective
  FROM t_recevent_inst inst INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  LEFT OUTER JOIN vw_all_billing_groups_status bgs ON bgs.id_billgroup = inst.id_arg_billgroup
  LEFT OUTER JOIN t_usage_interval ui ON ui.id_interval = inst.id_arg_interval
  WHERE 
    -- event is active
    evt.dt_activated <= @dt_now AND
    (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
    inst.id_instance = @id_instance AND
    -- instance must presently be in the NotYetRun state
    -- or the ReadyToRun state (this allows updates to an already
    -- submitted instance)
    inst.tx_status IN (''NotYetRun'', ''ReadyToRun'') AND
    -- interval, if any, must be in the closed state
    -- (inst.id_arg_interval IS NULL OR ui.tx_interval_status = ''C'')
    -- billing group, if any, must be in the closed state
    -- interval, if any, must not be hard closed
    (inst.id_arg_interval IS NULL OR 
     inst.id_arg_billgroup IS NULL OR
     bgs.status = ''C'' OR
     ui.tx_interval_status != ''H'')

  -- if the update was made, return successfully
  IF (@@ROWCOUNT = 1)
  BEGIN

    -- records the action
    INSERT INTO t_recevent_inst_audit(id_instance,id_acc,tx_action,b_ignore_deps,dt_effective,tx_detail,dt_crt)
    VALUES(@id_instance, @id_acc, ''SubmitForExecution'', @b_ignore_deps, @dt_effective, @tx_detail, @dt_now) 

    COMMIT
    SELECT @status = 0
    RETURN
  END

  --
  -- otherwise, attempts to figure out what went wrong
  --
  DECLARE @count INT
  SELECT @count = COUNT(*) FROM t_recevent_inst WHERE id_instance = @id_instance

  IF (@count = 0)
  BEGIN
    -- the instance does not exist
    ROLLBACK
    SELECT @status = -1
    RETURN
  END


  SELECT @count = COUNT(*)  
  FROM t_recevent_inst inst
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  WHERE 
    -- event is active
    evt.dt_activated <= @dt_now AND
    (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
    inst.tx_status = ''NotYetRun'' AND
    inst.id_instance = @id_instance

  IF (@count = 0)
  BEGIN
    -- instance is not in the proper state
    ROLLBACK
    SELECT @status = -2
    RETURN
  END

  SELECT @count = COUNT(*)  
  FROM t_recevent_inst inst
  LEFT OUTER JOIN t_usage_interval ui ON ui.id_interval = inst.id_arg_interval
  LEFT OUTER JOIN vw_all_billing_groups_status bgs ON bgs.id_billgroup = inst.id_arg_billgroup
  WHERE 
    inst.id_instance = @id_instance AND
    -- (inst.id_arg_interval IS NULL OR ui.tx_interval_status = ''C'')
    -- billing group, if any, must be in the closed state
    -- interval, if any, must not be hard closed
    (inst.id_arg_interval IS NULL OR 
     inst.id_arg_billgroup IS NULL OR
     bgs.status = ''C'' OR
     ui.tx_interval_status != ''H'')

  IF (@count = 0)
  BEGIN
    -- end-of-period instance''s usage interval is not in the proper state
    ROLLBACK
    SELECT @status = -5 
    RETURN
  END

	  -- couldn''t submit for some other unknown reason 
  ROLLBACK
  SELECT @status = -99 
END
  ' 
END
GO
/****** Object:  StoredProcedure [dbo].[SubmitEventForReversal]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SubmitEventForReversal]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/* ===========================================================
Modified from the previous version to use billing groups information.
=========================================================== */
CREATE PROCEDURE [dbo].[SubmitEventForReversal]
(
  @dt_now DATETIME,
  @id_instance INT,
  @b_ignore_deps VARCHAR(1),
  @dt_effective DATETIME,
  @id_acc INT,
  @tx_detail nvarchar(2048),
  @status INT OUTPUT
)
AS

BEGIN

  BEGIN TRAN

  SELECT @status = -99

  -- if the instance is a checkpoint, synchronously unacknowledges it
  DECLARE @isCheckpoint INT
  SELECT @isCheckpoint = 1 
  FROM t_recevent_inst inst
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  WHERE 
    inst.id_instance = @id_instance AND
    evt.tx_type = ''Checkpoint''
  IF (@isCheckpoint = 1)
  BEGIN
    EXEC UnacknowledgeCheckpoint @dt_now, @id_instance, @b_ignore_deps, @id_acc, @tx_detail, @status OUTPUT
    IF (@status = 0)
      COMMIT
    ELSE
      ROLLBACK
    RETURN 
  END

  -- updates the instance''s state to ''ReadyToReverse''
  UPDATE t_recevent_inst
  SET tx_status = ''ReadyToReverse'', b_ignore_deps = @b_ignore_deps, dt_effective = @dt_effective
  FROM t_recevent_inst inst
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  LEFT OUTER JOIN t_usage_interval ui ON ui.id_interval = inst.id_arg_interval
  LEFT OUTER JOIN vw_all_billing_groups_status bgs ON bgs.id_billgroup = inst.id_arg_billgroup
  WHERE 
    -- event is active
    evt.dt_activated <= @dt_now AND
    (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
    evt.tx_reverse_mode IN (''Auto'', ''Custom'', ''NotNeeded'') AND
    inst.id_instance = @id_instance AND
    -- instance must have previously succeeded or failed
    inst.tx_status IN (''Succeeded'', ''Failed'', ''ReadyToReverse'') AND
    -- billing group, if any, must be in the closed state
    -- interval, if any, must not be hard closed
    (inst.id_arg_interval IS NULL OR 
     inst.id_arg_billgroup IS NULL OR
     bgs.status = ''C'' OR
     ui.tx_interval_status != ''H'')

  -- if the update was made, return successfully
  IF (@@ROWCOUNT = 1)
  BEGIN

    -- records the action
    INSERT INTO t_recevent_inst_audit(id_instance,id_acc,tx_action,b_ignore_deps,dt_effective,tx_detail,dt_crt)
    VALUES(@id_instance, @id_acc, ''SubmitForReversal'', @b_ignore_deps, @dt_effective, @tx_detail, @dt_now) 

    COMMIT
    SELECT @status = 0
    RETURN
  END

  --
  -- otherwise, attempts to figure out what went wrong
  --
  DECLARE @count INT
  SELECT @count = COUNT(*) FROM t_recevent_inst WHERE id_instance = @id_instance

  IF (@count = 0)
  BEGIN
    -- instance doesn''t exist at all
    ROLLBACK
    SELECT @status = -1 
    RETURN
  END

  SELECT @count = COUNT(*)
  FROM t_recevent_inst inst
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  WHERE 
    -- event is active
    evt.dt_activated <= @dt_now AND
    (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
    inst.tx_status IN (''Succeeded'', ''Failed'') AND
    inst.id_instance = @id_instance

  IF (@count = 0)
  BEGIN
    -- instance is not in the proper state
    ROLLBACK
    SELECT @status = -2
    RETURN
  END

  SELECT @count = COUNT(*)
  FROM t_recevent_inst inst
  INNER JOIN t_recevent evt ON evt.id_event = inst.id_event
  WHERE 
    -- event is active
    evt.dt_activated <= @dt_now AND
    (evt.dt_deactivated IS NULL OR @dt_now < evt.dt_deactivated) AND
    evt.tx_reverse_mode IN (''Auto'', ''Custom'', ''NotNeeded'') AND
    inst.id_instance = @id_instance

  IF (@count = 0)
  BEGIN
    -- event is not reversible 
    ROLLBACK
    SELECT @status = -3
    RETURN
  END

  SELECT @count = COUNT(*)  
  FROM t_recevent_inst inst
  LEFT OUTER JOIN t_usage_interval ui ON ui.id_interval = inst.id_arg_interval
  LEFT OUTER JOIN vw_all_billing_groups_status bgs ON bgs.id_billgroup = inst.id_arg_billgroup
  WHERE 
    inst.id_instance = @id_instance AND
    -- (inst.id_arg_interval IS NULL OR ui.tx_interval_status = ''C'')
    -- billing group, if any, must be in the closed state
    -- interval, if any, must not be hard closed
    (inst.id_arg_interval IS NULL OR 
     inst.id_arg_billgroup IS NULL OR
     bgs.status = ''C'' OR
     ui.tx_interval_status != ''H'')

  IF (@count = 0)
  BEGIN
    -- end-of-period instance''s usage interval is not in the proper state
    ROLLBACK
    SELECT @status = -5 
    RETURN
  END

  -- couldn''t submit for some other unknown reason 
  ROLLBACK
  SELECT @status = -99
END
  ' 
END
GO
/****** Object:  StoredProcedure [dbo].[DeployPartitionedTable]    Script Date: 06/02/2008 11:43:38 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DeployPartitionedTable]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
           /*
				Proc: DeployPartitionedTable

				Depolys a table onto partition databases. 

				@tabname nvarchar(300) -- name of table to depoly
			*/
			create proc [dbo].[DeployPartitionedTable]
				@tabname varchar(300) -- name of table to depoly
			as
			begin

			-- Abort if system isn''t enabled for partitioning
			if dbo.IsSystemPartitioned() = 0
			begin
				raiserror(''System not enabled for partitioning.'',0,1)
				return 1
			end

			-- Error handling and row counts
			declare @err int   -- last error
			declare @rc int	-- row count
			declare @ret int	-- proc return code

			-- Local table stores a list of partitions for deployment
			declare @partns table (
				id_partition int,
				partition_name varchar(100),
				b_default char(1),
				dt_start datetime,
				dt_end datetime,
				interval_start int,
				interval_end int
				)

			-- Get list of partition deployment targets.  The partitioned
			-- tables are depolyed to these databases.
			insert into @partns
				select p.id_partition, partition_name, b_default,
					dt_start, dt_end, id_interval_start, id_interval_end
				from t_partition p
				where b_active = ''Y''
				order by p.dt_end

			select @rc = @@rowcount, @err = @@error
			if (@rc < 2) begin
				raiserror(''Found %i active partitions. There should at least 2 (including default).'', 
					0, 1, @rc)
				return 1
			end

			-- Get the name of the default partition and make sure there''s only one.
			declare @defdb varchar(100)
			declare @defstart int
			declare @defend int
			select @defdb = partition_name, @defstart = id_interval_start, 
				@defend = id_interval_end
				from t_partition
				where b_default = ''Y'' and b_active = ''Y''

			select @rc = @@rowcount, @err = @@error
			if (@rc <> 1) begin
				raiserror(''Found %i active default partitions. There should be one.'', 
					0, 1, @rc)
				return 1
			end

			-- If no rows found then there are no active partitions 
			if (@rc < 1) begin
				raiserror(''There are no active partitions.'', 16, 1)
				return 1
			end

			-- If the table is really a table (in NetMeter), then this
			-- is a conversion and the source database is NetMeter.
			declare @b_conv int
			declare @srcdb varchar(200)

			set @b_conv = 0
			set @srcdb = @defdb

			if objectproperty(object_id(@tabname),''istable'') = 1
			begin
				set @b_conv = 1
				set @srcdb = db_name()
			end

			-- Duplicate the table to each target partition
			declare @destdb varchar(200)
			declare @interval_start int
			declare @interval_end int
			declare @b_default char(1)
			declare @rowscopied int
			declare @totalcopied int
			set @totalcopied = 0
			set @rowscopied = 0

			declare partcur cursor for 
				select partition_name, interval_start, interval_end, b_default
				from @partns
			--
			-- BEGIN TRAN
			--
			begin tran

			open partcur
			fetch partcur into @destdb, @interval_start, @interval_end, @b_default

			while (@@fetch_status >= 0) begin
				--print ''fetch: '' + str(@@fetch_status)

				-- Create table on the partition
				exec @ret = DupPartitionedTable @tabname, @srcdb, @destdb, @rowscopied out
				if (@ret <> 0) begin
					raiserror(''Cannot create table [%s] on [%s]'', 
						16, 1, @tabname, @destdb)
					deallocate partcur
					rollback
					return 1
				end

				-- Accumulate total rows for check against source table
				set @totalcopied = @totalcopied + @rowscopied

				fetch partcur into @destdb, @interval_start, @interval_end, @b_default
			end
			deallocate partcur

			-- Move data from target into partitioned tables
			declare @srcdata varchar(200)
			set @srcdata = @srcdb + ''.dbo.'' + @tabname

			-- Drop legacy table if converting
			-- Truncate default partition table if extending

			-- Don''t drop/truncate if there''s any data left in the source
			declare @ncmd nvarchar(1000)
			set @ncmd = ''select @cnt = count(*) from '' + @srcdata

			declare @rowcnt int
			exec @ret = sp_executesql @ncmd, N''@cnt int output'', @rowcnt output

			select @rc = @@rowcount, @err = @@error
			if (@err <> 0) begin
				raiserror(''Cannot determine number of rows left in source table [%s]'',
					16, 1, @srcdata)
				rollback
				return 1
			end

			select @totalcopied as totalrows, @rowcnt as rowcnt

			declare @op varchar(100)
			set @op = ''truncate''
			if (@totalcopied <> @rowcnt) begin
				if (@b_conv = 1) set @op = ''drop''
				raiserror(''Cannot %s table %s because it still contains data.'',
					16, 1, @op, @srcdata)
				rollback
				return 1
			end

			--exec( ''select count(*) as "rows left in source" from '' + @srcdata)

			-- Drop or truncate the source table
			if (@b_conv = 1) begin
				print ''Dropping legacy table...''
				--exec(''sp_rename '' + @tabname + '', '' + @tabname + ''_Orig'')
				exec(''drop table '' + @tabname)

				select @rc = @@rowcount, @err = @@error
				if (@err <> 0) begin
					raiserror(''Cannot drop table [%s]'', 16, 1, @tabname)
					rollback
					return 1
				end

			end
			else 
			begin
				print ''Truncating default partition table...''
				exec(''truncate table '' + @srcdata)

				select @rc = @@rowcount, @err = @@error
				if (@err <> 0) begin
					raiserror(''Cannot truncate table [%s]'', 16, 1, @srcdata)
					rollback
					return 1
				end
			end 

			-- Fixup table''s default constraint
			declare @cmd varchar(2000)

			-- Drop old default constraint, if it exists
			print ''Building default constraint...''
			set @cmd = ''if exists (select * from '' + @defdb 
				+ ''.information_schema.table_constraints where constraint_name = '''''' 
				+ ''pc_'' + @tabname + '''''') '' + char(13) 
				+ ''alter table '' + @defdb + ''..'' + @tabname 
				+ '' drop pc_'' + @tabname
			exec(@cmd)

			select @rc = @@rowcount, @err = @@error
			if (@err <> 0) begin
				raiserror(''Cannot drop default constraint on [%s]'', 16, 1, @tabname)
				rollback
				return 1
			end
				
			-- Add new default constraint
			set @cmd = ''alter table '' + @defdb + ''..'' + @tabname + ''
				add constraint pc_'' + @tabname + ''
				check '' + dbo.GetPartitionPredicate(@defstart, @defend)
			exec(@cmd)

			select @rc = @@rowcount, @err = @@error
			if (@err <> 0) begin
				raiserror(''Cannot add default constraint on [%s]'', 16, 1, @tabname)
				rollback
				return 1
			end

			-- Create the partitioned view for the table
			exec @ret = CreatePartitionedView @tabname
			if (@ret <> 0) begin
				raiserror(''Cannot create Partitioned view for table [%s]'', 16, 1, @tabname)
				rollback
				return 1
			end

			-- Create unique keys for the table
			exec @ret = CreateUniqueKeyTables @tabname
			if (@ret <> 0) begin
				raiserror(''Cannot create unique keys for table [%s]'', 16, 1, @tabname)
				rollback
				return 1
			end


			--
			-- COMMIT
			--
			commit

			end	-- proc
 	' 
END
GO
/****** Object:  StoredProcedure [dbo].[AddNewAccount]    Script Date: 06/02/2008 11:43:05 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[AddNewAccount]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
		
CREATE PROCEDURE [dbo].[AddNewAccount](
@p_id_acc_ext  varchar(16),
@p_acc_state  varchar(2),
@p_acc_status_ext  int,
@p_acc_vtstart  datetime,
@p_acc_vtend  datetime,
@p_nm_login  nvarchar(255),
@p_nm_space nvarchar(40),
@p_tx_password  nvarchar(64),
@p_langcode  varchar(10),
@p_profile_timezone  int,
@p_ID_CYCLE_TYPE  int,
@p_DAY_OF_MONTH  int,
@p_DAY_OF_WEEK  int,
@p_FIRST_DAY_OF_MONTH  int,
@p_SECOND_DAY_OF_MONTH int,
@p_START_DAY int,
@p_START_MONTH int,
@p_START_YEAR int,
@p_billable varchar,
@p_id_payer int,
@p_payer_startdate datetime,
@p_payer_enddate datetime,
@p_payer_login nvarchar(255),
@p_payer_namespace nvarchar(40),
@p_id_ancestor int,
@p_hierarchy_start datetime,
@p_hierarchy_end datetime,
@p_ancestor_name nvarchar(255),
@p_ancestor_namespace nvarchar(40),
@p_acc_type varchar(40),
@p_apply_default_policy varchar,
@p_systemdate datetime,
@p_enforce_same_corporation varchar,
-- pass the currency through to CreatePaymentRecord
-- stored procedure only to validate it against the payer
-- We have to do it, because the t_av_internal record
--is not created yet
@p_account_currency nvarchar(5),
@p_profile_id int,
@p_login_app varchar(40),
@accountID int,
@status  int OUTPUT,
@p_hierarchy_path varchar(4000) output,
@p_currency nvarchar(10) OUTPUT,
@p_id_ancestor_out int OUTPUT,
@p_corporate_account_id int OUTPUT,
@p_ancestor_type_out varchar(40) OUTPUT
)
as
	declare @existing_account as int
	declare @intervalID as int
	declare @intervalstart as datetime
	declare @intervalend as datetime
	declare @usagecycleID as int
	declare @acc_startdate as datetime
	declare @acc_enddate as datetime
	declare @payer_startdate as datetime
	declare @payer_enddate as datetime
	declare @ancestor_startdate as datetime
	declare @ancestor_enddate as datetime	declare @payerID as int
	declare @ancestorID as int
	declare @siteID as int
	declare @folderName nvarchar(255)
	declare @varMaxDateTime as datetime
	declare @IsNotSubscriber int
	declare @payerbillable as varchar(1)
	declare @authancestor as int
	declare @id_type as int
        declare @dt_end datetime

  set @p_ancestor_type_out = ''Err''
	-- step : validate that the account does not already exist.  Note 
	-- that this check is performed by checking the t_account_mapper table.
	-- However, we don''t check the account state so the new account could
	-- conflict with an account that is an archived state.  You would need
	-- to purge the archived account before the new account could be created.
	select @varMaxDateTime = dbo.MTMaxDate()
	select @existing_account = dbo.LookupAccount(@p_nm_login,@p_nm_space) 
	if (@existing_account <> -1) begin
	-- ACCOUNTMAPPER_ERR_ALREADY_EXISTS
	select @status = -501284862
	return
	end 

	-- check account creation business rules
	IF (@p_nm_login not in (''rm'', ''mps_folder''))
	BEGIN
	  exec CheckAccountCreationBusinessRules 
			 @p_nm_space, 
			 @p_acc_type, 
			 @p_id_ancestor, 
			 @status output
	  IF (@status <> 1)
		BEGIN
	  	RETURN
		END		
	END	

	-- step : populate the account start dates if the values were
	-- not passed into the sproc
	select 
	@acc_startdate = case when @p_acc_vtstart is NULL then dbo.mtstartofday(@p_systemdate) 
		else dbo.mtstartofday(@p_acc_vtstart) end,
	@acc_enddate = case when @p_acc_vtend is NULL then @varMaxDateTime 
		else dbo.mtstartofday(@p_acc_vtend) end
	-- step : populate t_account

 	select @id_type = id_type from t_account_type where name = @p_acc_type
	if (@p_id_acc_ext is null) begin
		insert into t_account(id_acc,id_acc_ext,dt_crt,id_type)
		select @accountID,newid(),@acc_startdate,@id_type 
	end
	else begin
		insert into t_account(id_acc,id_Acc_ext,dt_crt,id_type)
		select @accountID,convert(varbinary(16),@p_id_acc_ext),@acc_startdate,@id_type 
	end 
	-- step : get the account ID
	-- step : initial account state
	insert into t_account_state values (@accountID,
	@p_acc_state /*,p_acc_status_ext*/,
	@acc_startdate,@acc_enddate)
	insert into t_account_state_history values (@accountID,
	@p_acc_state /*,p_acc_status_ext*/,
	@acc_startdate,@acc_enddate,@p_systemdate,@varMaxDateTime)
	-- step : login and namespace information
	insert into t_account_mapper values (@p_nm_login,lower(@p_nm_space),@accountID)
	-- step : user credentials
	insert into t_user_credentials values (@p_nm_login,lower(@p_nm_space),@p_tx_password)

	-- step : t_profile. This looks like it is only for timezone information
	insert into t_profile values (@p_profile_id,''timeZoneID'',@p_profile_timezone,''System'')
	-- step : site user information
	exec GetlocalizedSiteInfo @p_nm_space,@p_langcode,@siteID OUTPUT
	insert into t_site_user values (@p_nm_login,@siteID,@p_profile_id)


  	--
  	-- associates the account with the Usage Server
  	--

	-- determines the usage cycle ID from the passed in date properties
	if (@p_ID_CYCLE_TYPE IS NOT NULL)
	BEGIN
		SELECT @usagecycleID = id_usage_cycle 
		FROM t_usage_cycle cycle 
	 	 WHERE
		 cycle.id_cycle_type = @p_ID_CYCLE_TYPE AND
	   	(@p_DAY_OF_MONTH = cycle.day_of_month OR @p_DAY_OF_MONTH IS NULL) AND
	   	(@p_DAY_OF_WEEK = cycle.day_of_week OR @p_DAY_OF_WEEK IS NULL) AND
	   	(@p_FIRST_DAY_OF_MONTH = cycle.FIRST_DAY_OF_MONTH OR @p_FIRST_DAY_OF_MONTH IS NULL) AND
	   	(@p_SECOND_DAY_OF_MONTH = cycle.SECOND_DAY_OF_MONTH OR @p_SECOND_DAY_OF_MONTH IS NULL) AND
	   	(@p_START_DAY = cycle.START_DAY OR @p_START_DAY IS NULL) AND
	   	(@p_START_MONTH = cycle.START_MONTH OR @p_START_MONTH IS NULL) AND
	   	(@p_START_YEAR = cycle.START_YEAR OR @p_START_YEAR IS NULL)
	
	  	-- adds the account to usage cycle mapping
		INSERT INTO t_acc_usage_cycle VALUES (@accountID, @usagecycleID)
	
	  	-- creates only needed intervals and mappings for this account only.
	  	-- other accounts affected by any new intervals (same cycle) will
	 	-- be associated later in the day via a usm -create
                -- Compare this logic to that in the batch case by noting the mapping between
                -- variables and temp table columns:
                --
                -- tmp.id_account = @accountID
                -- tmp.id_usage_cycle = @usagecycleID
                -- tmp.acc_vtstart = @acc_startdate
                -- tmp.acc_vtend = @acc_enddate
                -- tmp.acc_state = @p_acc_state
                --
                -- Note also that some predicates don''t depend on database tables
                -- and these become a surrounding IF statement

                -- Defines the date range that an interval must fall into to
                -- be considered ''active''.
                SELECT @dt_end = (@p_systemdate + n_adv_interval_creation) FROM t_usage_server

                IF 
                  -- Exclude archived accounts.
                  @p_acc_state <> ''AR'' 
                  -- The account has already started or is about to start.
                  AND @acc_startdate < @dt_end 
                  -- The account has not yet ended.
                  AND @acc_enddate >= @p_systemdate
                BEGIN
                INSERT INTO t_usage_interval(id_interval,id_usage_cycle,dt_start,dt_end,tx_interval_status)
                SELECT 
                  ref.id_interval,
                  ref.id_cycle,
                  ref.dt_start,
                  ref.dt_end,
                  ''O''  -- Open
                FROM 
                t_pc_interval ref                 
                WHERE
                /* Only add intervals that don''t exist */
                NOT EXISTS (SELECT 1 FROM t_usage_interval ui WHERE ref.id_interval = ui.id_interval)
                AND 
                ref.id_cycle = @usagecycleID AND
                -- Reference interval must at least partially overlap the [minstart, maxend] period.
                (ref.dt_end >= @acc_startdate AND 
                 ref.dt_start <= CASE WHEN @acc_enddate < @dt_end THEN @acc_enddate ELSE @dt_end END)

                INSERT INTO t_acc_usage_interval(id_acc,id_usage_interval,tx_status,dt_effective)
                SELECT
                  @accountID,
                  ref.id_interval,
                  ref.tx_interval_status,
		  NULL
                FROM 
                t_usage_interval ref 
                WHERE
                ref.id_usage_cycle = @usagecycleID AND
                -- Reference interval must at least partially overlap the [minstart, maxend] period.
                (ref.dt_end >= @acc_startdate AND 
                ref.dt_start <= CASE WHEN @acc_enddate < @dt_end THEN @acc_enddate ELSE @dt_end END)
                /* Only add mappings for non-blocked intervals */
                AND ref.tx_interval_status <> ''B''
              END
	END

	-- Non-billable accounts must have a payment redirection record
	if ( @p_billable = ''N'' AND 
	(@p_id_payer is NULL and
	(@p_id_payer is null AND @p_payer_login is NULL AND @p_payer_namespace is NULL))) begin
	-- MT_NONBILLABLE_ACCOUNTS_REQUIRE_PAYER
		select @status = -486604768
		return
	end
	-- default the payer start date to the start of the account  
	select @payer_startdate = case when @p_payer_startdate is NULL then @acc_startdate else dbo.mtstartofday(@p_payer_startdate) end,
	 -- default the payer end date to the end of the account if NULL
	@payer_enddate = case when @p_payer_enddate is NULL then @acc_enddate else dbo.mtstartofday(@p_payer_enddate) end,
	-- step : default the hierarchy start date to the account start date 
	@ancestor_startdate = case when @p_hierarchy_start is NULL then @acc_startdate else @p_hierarchy_start end,
	-- step : default the hierarchy end date to the account end date
	@ancestor_enddate = case when @p_hierarchy_end is NULL then @acc_enddate else @p_hierarchy_end end,
	-- step : resolve the ancestor ID if necessary
	@ancestorID = case when @p_ancestor_name is not NULL and @p_ancestor_namespace is not NULL then
		dbo.LookupAccount(@p_ancestor_name,@p_ancestor_namespace)  else 
		-- if the ancestor ID iis NULL then default to the root
		case when @p_id_ancestor is NULL then 1 else @p_id_ancestor end
	end,
	-- step : resolve the payer account if necessary
	@payerID = case when 	@p_payer_login is not null and @p_payer_namespace is not null then
		 dbo.LookupAccount(@p_payer_login,@p_payer_namespace) else 
			case when @p_id_payer is NULL then @accountID else @p_id_payer 
			end
		  end
	select id_acc from t_account where id_acc = @payerID 
	if (@@rowcount = 0)
	begin
		-- MT_CANNOT_RESOLVE_PAYING_ACCOUNT
		select @status = -486604792
		return
	end

	select id_acc from t_account where id_acc = @ancestorID
	if (@@rowcount= 0) 
		begin
			-- MT_CANNOT_RESOLVE_HIERARCHY_ACCOUNT
			select @status = -486604791
			return
		end 
	else
		begin
			SET @p_id_ancestor_out = @ancestorID
		end
	
	if ((@p_acc_type) = ''SYSTEMACCOUNT'') begin  -- any one who is not a system account is a subscriber
		select @IsNotSubscriber = 1
	end 
	-- we trust AddAccToHIerarchy to set the status to 1 in case of success
	declare @acc_type_out varchar(40)
	exec AddAccToHierarchy @ancestorID,@accountID,@ancestor_startdate,
	@ancestor_enddate,@acc_startdate,@p_ancestor_type_out output, @acc_type_out output, @status output
	if (@status <> 1)begin 
		return
	end 

	-- Populate t_dm_account and t_dm_account_ancestor table
	insert into t_dm_account select id_descendent, vt_start, vt_end from
	t_account_ancestor where id_ancestor=1 and id_descendent = @accountID
	insert into t_dm_account_ancestor select dm2.id_dm_acc, dm1.id_dm_acc, aa1.num_generations
	from t_account_ancestor aa1
	inner join t_dm_account dm1 on aa1.id_descendent=dm1.id_acc and aa1.vt_start <= dm1.vt_end and dm1.vt_start <= aa1.vt_end
	inner join t_dm_account dm2 on aa1.id_ancestor=dm2.id_acc and aa1.vt_start <= dm2.vt_end and dm2.vt_start <= aa1.vt_end
	where dm1.id_acc <> dm2.id_acc
	and dm1.vt_start >= dm2.vt_start
	and dm1.vt_end <= dm2.vt_end
	and aa1.id_descendent = @accountID
	insert into t_dm_account_ancestor select id_dm_acc,id_dm_acc,0	from t_dm_account where id_acc = @accountID
	-- pass in the current account''s billable flag when creating the payment 
	-- redirection record IF the account is paying for itself
	select @payerbillable = case when @payerID = @accountID then
		@p_billable else NULL end
	exec CreatePaymentRecord @payerID,@accountID,
	@payer_startdate,@payer_enddate,@payerbillable,@p_systemdate,''N'', @p_enforce_same_corporation, @p_account_currency, @status OUTPUT
	if (@status <> 1) begin
		return
	end   
	-- if "Apply Default Policy" flag is set, then
	-- figure out "ancestor" id based on account type in case the account is not
	--a subscriber
	--BP: 10/5 Make sure that t_principal_policy record is always there, otherwise ApplyRoleMembership will break
	declare @polid int
	exec Sp_Insertpolicy ''id_acc'', @accountID,''A'', @polID output
	if
		(UPPER(@p_apply_default_policy) = ''Y'' OR
		UPPER(@p_apply_default_policy) = ''T'' OR
		UPPER(@p_apply_default_policy) = ''1'') begin
    SET @authancestor = @ancestorID
		if (@IsNotSubscriber > 0) begin
		 	select @folderName = 
			 CASE 
				WHEN UPPER(@p_login_app) = ''CSR'' THEN ''csr_folder''
				WHEN UPPER(@p_login_app) = ''MOM'' THEN ''mom_folder''
				WHEN UPPER(@p_login_app) = ''MCM'' THEN ''mcm_folder''
				WHEN UPPER(@p_login_app) = ''MPS'' THEN ''mps_folder''
				END
			SELECT @authancestor = NULL
      SELECT @authancestor = id_acc  FROM t_account_mapper WHERE nm_login = @folderName
			AND nm_space = ''auth''
			if (@authancestor is null) begin
	 			select @status = 1
	 		end
		end 
		--apply default security policy
		if (@authancestor > 1) begin
			exec dbo.CloneSecurityPolicy @authancestor, @accountID , ''D'' , ''A''
		end
	End 
	select @p_hierarchy_path = tx_path  from t_account_ancestor
	where id_descendent = @accountID and (id_ancestor = 1 OR id_ancestor = -1)
	AND @ancestor_startdate between vt_start AND vt_end
	
	--resolve accounts'' corporation
	--select ancestor whose ancestor is of a type that has b_iscorporate set to true.
	select @p_corporate_account_id = ancestor.id_ancestor from t_account_ancestor ancestor
	inner join t_account acc on acc.id_acc = ancestor.id_ancestor
	inner join t_account_type atype on acc.id_type = atype.id_type
	where
	ancestor.id_descendent = @accountID and
	atype.b_iscorporate = ''1'' 
	AND @acc_startdate  BETWEEN ancestor.vt_start and ancestor.vt_end
	
  if (@p_corporate_account_id is null)
   set @p_corporate_account_id = @accountID
   
	if (@ancestorID <> 1 and @ancestorID <> -1)
	begin
		select @p_currency = c_currency from t_av_internal where id_acc = @ancestorID
		--if cross corp business rule is enforced, verify that currencies match
		if(@p_enforce_same_corporation = ''1'' AND ((@p_currency) <> (@p_account_currency)) )
		begin
			-- MT_CURRENCY_MISMATCH
			select @status = -486604737
			return
		end
  end

	-- done
	select @status = 1
		' 
END
GO
/****** Object:  StoredProcedure [dbo].[sp_DeletePricelist]    Script Date: 06/02/2008 11:44:07 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[sp_DeletePricelist]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
  
		create procedure [dbo].[sp_DeletePricelist] 
		(
			@a_plID int,
			@status INT OUTPUT
		)
		as
		begin
			declare @n_pl_maps as int
			declare @n_def_acc as int

			declare @CursorVar CURSOR 
			declare @count as int
			declare @i as int
			declare @id_rs as int
			
			set @n_pl_maps = (select count(*) from t_pl_map where id_pricelist = @a_plID)
			if (@n_pl_maps > 0)
			begin
				select @status = 1
				return
			end

			set @n_def_acc = (select count(*) from t_av_internal where c_pricelist = @a_plID)
			if (@n_def_acc > 0)
			begin
				select @status = 2
				return
			end
			
			set @i = 0
			set @CursorVar = CURSOR STATIC

			for select id_sched from t_rsched
					where id_pricelist = @a_plID
			open @CursorVar
			select @count = @@cursor_rows
			while @i < @count 
				begin
					fetch next from @CursorVar into @id_rs
					set @i = (select @i + 1)
					exec sp_DeleteRateSchedule @id_rs
				end
			close @CursorVar
			deallocate @CursorVar

			delete from t_pricelist where id_pricelist = @a_plID
			execute DeleteBaseProps @a_plID
			
			select @status = 0
			return (0)
		end
		
' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdatePaymentRecord]    Script Date: 06/02/2008 11:44:09 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdatePaymentRecord]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
create procedure [dbo].[UpdatePaymentRecord](
@p_payer int,
@p_payee int,
@p_oldstartdate datetime,
@p_oldenddate datetime,
@p_startdate datetime,
@p_enddate datetime,
@p_systemdate datetime,
@p_enforce_same_corporation varchar,
@p_account_currency nvarchar(5),
@p_status int OUTPUT
)
as
begin
declare @realoldstartdate datetime
declare @realoldenddate datetime
declare @realstartdate datetime
declare @realenddate datetime
declare @testenddate datetime
declare @billable char
declare @varMaxDateTime datetime
declare @accstartdate datetime
declare @tempvar int
select @varMaxDateTime = dbo.MTMaxDate()
select @p_status = 0
-- normalize dates
select @realstartdate = dbo.mtstartofday(@p_startdate) 
if (@p_enddate is null)
	begin
	select @realenddate = dbo.mtstartofday(@varMaxDateTime)  
	end
else
	begin
	select @realenddate = dbo.mtstartofday(@p_enddate) 
	end
select @realoldstartdate = dbo.mtstartofday(@p_oldstartdate) 
select @realoldenddate = dbo.mtstartofday(@p_oldenddate)  
 -- business rule checks
 -- if the account is not billable, we must make sure that they are 
	-- not changing the most recent payment redirection record''s end date from
	-- MTMaxDate(). 
select @testenddate = max(vt_end), @billable = c_billable from t_payment_redirection redir
INNER JOIN t_av_internal tav on tav.id_acc = @p_payee
where
redir.id_payee = @p_payee and redir.id_payer = @p_payer
group by c_billable
 -- if the enddate matches the record we are changing
if (@testenddate = @realoldstartdate AND
-- the user is changing the enddate and the account is not billable
@realoldenddate <> @realenddate AND @billable = ''0'')
	begin
	-- MT_PAYMENT_UDDATE_END_DATE_INVALID
	select @p_status = -486604780
	return
	end 
if (@p_oldenddate = @varMaxDateTime AND @p_enddate <> @varMaxDateTime) begin
	-- MT_CANNOT_MOVE_MODIFY_PAYMENT_ENDDATE_IF_INFINITE
	select @p_status = -486604749
	return
end
select @accstartdate = dbo.mtstartofday(dt_crt) from t_account where id_acc = @p_payee
if (@p_oldstartdate = @accstartdate AND @p_startdate <> @accstartdate) begin
	-- MT_CANNOT_MOVE_MODIFY_PAYMENT_STARTDATE_IF_ACC_STARTDATE
	select @p_status = -486604748
	return
end
-- end business rules
exec CreatePaymentRecord @p_payer,@p_payee,@realstartdate,@realenddate,NULL,@p_systemdate,''Y'', @p_enforce_same_corporation, 
												@p_account_currency, @p_status output
if (@p_status is null)
	begin
	-- MT_PAYMENTUPDATE_FAILED
	select @p_status = -486604781
	end
end
		 ' 
END
GO
/****** Object:  StoredProcedure [dbo].[UpdateAccount]    Script Date: 06/02/2008 11:44:08 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[UpdateAccount]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE PROCEDURE [dbo].[UpdateAccount] (
  @p_loginname nvarchar(255),
	@p_namespace nvarchar(40),
	@p_id_acc int,
	@p_acc_state varchar(2),
	@p_acc_state_ext int,
	@p_acc_statestart datetime,
	@p_tx_password nvarchar(64),
	@p_ID_CYCLE_TYPE int,
	@p_DAY_OF_MONTH  int,
	@p_DAY_OF_WEEK int,
	@p_FIRST_DAY_OF_MONTH int,
	@p_SECOND_DAY_OF_MONTH  int,
	@p_START_DAY int,
	@p_START_MONTH int,
	@p_START_YEAR int,
	@p_id_payer int,
	@p_payer_login nvarchar(255),
  @p_payer_namespace nvarchar(40),
	@p_payer_startdate datetime,
	@p_payer_enddate datetime,
	@p_id_ancestor int,
	@p_ancestor_name nvarchar(255),
	@p_ancestor_namespace nvarchar(40),
	@p_hierarchy_movedate datetime,
	@p_systemdate datetime,
	@p_billable varchar,
	@p_enforce_same_corporation varchar,
	--pass the currency through so that CreatePaymenrRecord
	--validates it, because the currency can be updated
	@p_account_currency nvarchar(5),
	@p_status int output,
	@p_cyclechanged int output,
	@p_newcycle int output,
	@p_accountID int output,
	@p_hierarchy_path varchar(4000) output,
	--if account is being moved, select old ancestor id
	@p_old_id_ancestor_out int output,
	--if account is being moved, select new ancestor id
	@p_id_ancestor_out int output,
	@p_corporate_account_id int OUTPUT,
	@p_ancestor_type varchar(40) OUTPUT,
	@p_acc_type varchar(40) OUTPUT
	)
as
begin
	declare @accountID int
	declare @oldcycleID int
	declare @usagecycleID int
	declare @intervalenddate datetime
	declare @intervalID int
	declare @pc_start datetime
	declare @pc_end datetime
	declare @oldpayerstart datetime
	declare @oldpayerend datetime
	declare @oldpayer int
	declare @payerenddate datetime
	declare @payerID int
	declare @AncestorID int
	
	declare @payerbillable varchar(1)
	select @accountID = -1
	select @oldcycleID = 0
	select @p_status = 0
	
	-- initialize the ancestor type (hack !!)
	set @p_ancestor_type = ''''
	
	set @p_old_id_ancestor_out = @p_id_ancestor  -- we assume no move.
	-- step : resolve the account if necessary
	if (@p_id_acc is NULL) begin
		if (@p_loginname is not NULL and @p_namespace is not NULL) begin
		select @accountID = dbo.LookupAccount(@p_loginname,@p_namespace) 
			if (@accountID < 0) begin
				-- MTACCOUNT_RESOLUTION_FAILED
					select @p_status = -509673460
      end
		end
		else 
			begin
  	-- MTACCOUNT_RESOLUTION_FAILED
      select @p_status = -509673460
		end 
	end
	else
	begin
		select @accountID = @p_id_acc
	end 
	if (@p_status < 0) begin
		return
	end
 -- step : update the account password if necessary.  catch error
 -- if the account does not exist or the login name is not valid.  The system
 -- should check that both the login name, namespace, and password are 
 -- required to change the password.
	if (@p_loginname is not NULL and @p_namespace is not NULL and 
			@p_tx_password is not NULL)
			begin
			 update t_user_credentials set tx_password = @p_tx_password
				where nm_login = @p_loginname and nm_space = @p_namespace
			 if (@@rowcount = 0) 
	       begin
				 -- MTACCOUNT_FAILED_PASSWORD_UPDATE
				 select @p_status =  -509673461
         end
      end
			-- step : figure out if we need to update the account''s billing cycle.  this
			-- may fail because the usage cycle information may not be present.
	begin
		select @usagecycleID = id_usage_cycle 
		from t_usage_cycle cycle where
	  cycle.id_cycle_type = @p_ID_CYCLE_TYPE 
		AND (@p_DAY_OF_MONTH = cycle.day_of_month or @p_DAY_OF_MONTH is NULL)
		AND (@p_DAY_OF_WEEK = cycle.day_of_week or @p_DAY_OF_WEEK is NULL)
		AND (@p_FIRST_DAY_OF_MONTH= cycle.FIRST_DAY_OF_MONTH  or @p_FIRST_DAY_OF_MONTH is NULL)
		AND (@p_SECOND_DAY_OF_MONTH = cycle.SECOND_DAY_OF_MONTH or @p_SECOND_DAY_OF_MONTH is NULL)
		AND (@p_START_DAY= cycle.START_DAY or @p_START_DAY is NULL)
		AND (@p_START_MONTH= cycle.START_MONTH or @p_START_MONTH is NULL)
		AND (@p_START_YEAR = cycle.START_YEAR or @p_START_YEAR is NULL)
    if (@usagecycleid is null)
		 begin
			SELECT @usagecycleID = -1
		 end
   end
	 select @oldcycleID = id_usage_cycle from
	 t_acc_usage_cycle where id_acc = @accountID
	 if (@oldcycleID <> @usagecycleID AND @usagecycleID <> -1)
	  begin

      -- checks to see if this account is affiliated with an EBCR charge
      SET @p_status = dbo.IsBillingCycleUpdateProhibitedByGroupEBCR(@p_systemdate, @p_id_acc)
      IF @p_status <> 1
        RETURN

      -- updates the account''s billing cycle mapping
      UPDATE t_acc_usage_cycle SET id_usage_cycle = @usagecycleID
      WHERE id_acc = @accountID

      -- post-operation business rule check (relies on rollback of work done up until this point)
      -- CR9906: checks to make sure the account''s new billing cycle matches all of it''s and/or payee''s 
      -- group subscription BCR constraints
      SELECT @p_status = ISNULL(MIN(dbo.CheckGroupMembershipCycleConstraint(@p_systemdate, groups.id_group)), 1)
      FROM 
      (
        -- gets all of the payer''s payee''s and/or the payee''s group subscriptions
        SELECT DISTINCT gsm.id_group id_group
        FROM t_gsubmember gsm
        INNER JOIN t_payment_redirection pay ON pay.id_payee = gsm.id_acc
        WHERE 
          pay.id_payer = @accountID OR
          -- TODO: is payee criteria necessary?  
          pay.id_payee = @accountID
      ) groups
      IF @p_status <> 1
        RETURN
    
			-- deletes any mappings to intervals in the future from the old cycle
			DELETE FROM t_acc_usage_interval 
			WHERE 
        t_acc_usage_interval.id_acc = @accountID AND
        id_usage_interval IN 
        ( 
          SELECT id_interval 
          FROM t_usage_interval ui
          INNER JOIN t_acc_usage_interval aui ON 
            t_acc_usage_interval.id_acc = @accountID AND
            aui.id_usage_interval = ui.id_interval
          WHERE dt_start > @p_systemdate
			  )

      -- only one pending update is allowed at a time
			-- deletes any previous update mappings which have not yet
      -- transitioned (dt_effective is still in the future)
			DELETE FROM t_acc_usage_interval 
      WHERE 
        dt_effective IS NOT NULL AND
        id_acc = @accountID AND
        dt_effective >= @p_systemdate

      -- gets the current interval''s end date
			SELECT @intervalenddate = ui.dt_end 
      FROM t_acc_usage_interval aui
			INNER JOIN t_usage_interval ui ON 
        ui.id_interval = aui.id_usage_interval AND
        @p_systemdate BETWEEN ui.dt_start AND ui.dt_end
		  WHERE aui.id_acc = @AccountID

      -- future dated accounts may not yet be associated with an interval (CR11047)
      IF @intervalenddate IS NOT NULL
      BEGIN
        -- figures out the new interval ID based on the end date of the current interval  
			  SELECT 
          @intervalID = id_interval,
         @pc_start = dt_start,
          @pc_end = dt_end 
			  FROM t_pc_interval
        WHERE
          id_cycle = @usagecycleID AND
			    dbo.addsecond(@intervalenddate) BETWEEN dt_start AND dt_end

        -- inserts the new usage interval if it doesn''t already exist
        -- (needed for foreign key relationship in t_acc_usage_interval)
			  INSERT INTO t_usage_interval
        SELECT 
          @intervalID,
          @usagecycleID,
          @pc_start,
          @pc_end,
          ''O''
			  WHERE @intervalID NOT IN (SELECT id_interval FROM t_usage_interval)

			  -- creates the special t_acc_usage_interval mapping to the interval of
        -- new cycle. dt_effective is set to the end of the old interval.
			  INSERT INTO t_acc_usage_interval 
			  SELECT @accountID, 
			         @intervalID, 
			         ISNULL(tx_interval_status, ''O''),
			         @intervalenddate
			  FROM t_usage_interval 
			  WHERE id_interval = @intervalID AND 
			        tx_interval_status != ''B''
      END

			-- indicate that the cycle changed
			select @p_newcycle = @UsageCycleID
			select @p_cyclechanged = 1

    END
    else
  	-- indicate to the caller that the cycle did not change
    begin
		select @p_newcycle = @UsageCycleID
    	select @p_cyclechanged = 0
    end

    -- step : update the payment redirection information.  Only update
    -- the payment information if the payer and payer_startdate is specified
    if ((@p_id_payer is NOT NULL OR (@p_payer_login is not NULL AND 
	@p_payer_namespace is not NULL)) AND @p_payer_startdate is NOT NULL) 
    begin
	-- resolve the paying account id if necessary
	if (@p_payer_login is not null and @p_payer_namespace is not null)
	begin
		select @payerId = dbo.LookupAccount(@p_payer_login,@p_payer_namespace) 
		if (@payerID = -1)
	 	begin 
			-- MT_CANNOT_RESOLVE_PAYING_ACCOUNT
	 		select @p_status = -486604792
	 		return
	 	end 
	end
	else
	begin
		select @payerID = @p_id_payer
	end 
		-- default the payer end date to the end of the account
	if (@p_payer_enddate is NULL)
	begin
		select @payerenddate = dbo.mtmaxdate()
	end 
	else
	begin 
		select @payerenddate = @p_payer_enddate
    	end 
	-- find the old payment information
	select @oldpayerstart = vt_start,@oldpayerend = vt_end ,@oldpayer = id_payer
	from t_payment_redirection
	where id_payee = @AccountID and
	dbo.overlappingdaterange(vt_start,vt_end,@p_payer_startdate,dbo.mtmaxdate())=1
	-- if the new record is in range of the old record and the payer is the same as the older payer,
	-- update the record
	if (@payerID = @oldpayer) 
        begin
		exec UpdatePaymentRecord @payerID,@accountID,@oldpayerstart,@oldpayerend,
		 @p_payer_startdate,@payerenddate,@p_systemdate,@p_enforce_same_corporation, @p_account_currency, @p_status output
		if (@p_status <> 1)
		 begin
			return
		 end 

  	end
  	else
	begin
	 	select @payerbillable = case when @payerID = @accountID then @p_billable else NULL end
	 	exec CreatePaymentRecord @payerID,@accountID,@p_payer_startdate,@payerenddate,@payerbillable,
		@p_systemdate,''N'', @p_enforce_same_corporation, @p_account_currency, @p_status output
	 	if (@p_status <> 1)
	  	begin
			return
		end
	end
    end
    -- check if the account has any payees before setting the account as Non-billable.  It is important
    -- that this check take place after creating any payment redirection records	
    if dbo.IsAccountBillable(@AccountID) = ''1'' AND @p_billable = ''N'' 
    begin
	if dbo.DoesAccountHavePayees(@AccountID,@p_systemdate) = ''Y''
        begin
		-- MT_ACCOUNT_NON_BILLABLE_AND_HAS_NON_PAYING_SUBSCRIBERS
		select @p_status = -486604767
			return
	end
    end

    --payer update done.
    
    
    --ancestor update begun
  if (((@p_ancestor_name is not null AND @p_ancestor_namespace is not NULL)
	 or @p_id_ancestor is not null) AND @p_hierarchy_movedate is not null)
    begin	 
	    if (@p_ancestor_name is not NULL and @p_ancestor_namespace is not NULL)
	    begin
		    select @ancestorID = dbo.LookupAccount(@p_ancestor_name,@p_ancestor_namespace) 

		    SET @p_id_ancestor_out = @ancestorID
		    if (@ancestorID = -1)
		    begin
			    -- MT_CANNOT_RESOLVE_HIERARCHY_ACCOUNT
			    select @p_status = -486604791
			    return
		    end 
	    end
  	  else
	    begin
		    select @ancestorID = @p_id_ancestor
	    end
	 
	    exec MoveAccount @ancestorID,@AccountID, @p_hierarchy_movedate, @p_enforce_same_corporation, @p_status output, @p_old_id_ancestor_out output, @p_ancestor_type output, @p_acc_type output

	    if (@p_status <> 1)
 	    begin
		    return
 	    end 

  end
  --ancestor update done

if (@p_old_id_ancestor_out is null)
begin
	set @p_old_id_ancestor_out = -1
end

if (@p_id_ancestor_out is null)
begin
	set @p_id_ancestor_out = -1
end
  
	-- step : resolve the hierarchy path based on the current time
 		begin
			select @p_hierarchy_path = tx_path  from t_account_ancestor
			where id_ancestor =1  and id_descendent = @AccountID and
				@p_systemdate between vt_start and vt_end

  		if (@p_hierarchy_path is null)
		 begin
			select @p_hierarchy_path = ''/''  
 	 	 end

 		end

	--resolve accounts'' corporation
	select @p_corporate_account_id = ancestor.id_ancestor from t_account_ancestor ancestor
	inner join t_account acc on ancestor.id_ancestor = acc.id_acc
	inner join t_account_type atype on atype.id_type = acc.id_type
	where
	  ancestor.id_descendent = @AccountID
		AND atype.b_iscorporate = ''1''
		AND @p_systemdate  BETWEEN ancestor.vt_start and ancestor.vt_end

  if (@p_corporate_account_id is null)
    set @p_corporate_account_id = @AccountID
    
 -- done
 select @p_accountID = @AccountID
 select @p_status = 1
 end
	
			 ' 
END
GO
