Compression Design Documentation
--------------------------------
10-aug-1998

billo

Purpose
-------

The purpose of compression in the metratech system is to minimize
bandwidth used in metering services.

Goals
-----

The major goals of this design are: to achieve maximum compression; to
assure future compatibility; to allow non-SDK users to easily
implement compressed meter messages; to assure message integrity.

1. maximum compression: The MSIX protocol includes completely
   specified structural information in every transaction.  For most
   services, the structural information is not only the same
   transaction after transaction, it is also a significant portion of
   data transmitted.  In fact, it generally is expected to be *larger*
   than the variable transaction data itself.  The simplest way to
   compress a message in this scheme is to eliminate completely the
   structural information from the message.  This will be done by
   making the strucure implicit in each message, by requiring that
   each party (client and server) know the message structure and
   format beforehand.

2. future compatiblity: included in the compression scheme is a
   mechanism for clients to obtain format information for specific
   service name and compression version pairs.  Also, there will be a
   mechanism for a client to obtain specific connectivity information
   about where to use those compressed schemes, including transport
   (HTTP, future TCP-based or future UDP-based transports), host name
   and port number.  In this way, the IP address/port name/host name
   combinations can be used as implicit specification of the service
   being metered, and the version of compressed protocol being used.

3. non-SDK implementation: the SDK is potentially too large and
   complex to fit the requirements of embedded controllers on network
   devices.  Programmers of these systems need a compression scheme
   that is easy to understand and trivial to implement.  Because of
   this, complex compression, message integrity or other algorithms
   are to be avoided.

4. message integrity: a highly compressed message scheme can be
   vulnerable to errors, since much of the context of the
   non-compressed message is not present.  Since this is the case, CRC
   or checksum fields are an essential part of the message.
   The intent of the integrity check in this system is more geared
   toward preventing misinterpretation of message than against data
   corruption.  The underlying transport is assumed to handle any data
   corruption issues.

Details
-------

1. The basic principle of the compression scheme is to use a
   "codebook" system.  Each party, the client and server will have a
   "codebook" which describes both how to construct (on the client
   side) and to parse (on the server side) a compressed message. 

   The codebook describes in machine- and human- readable form the
   byte-by-byte layout of a compressed message.  The general form of a
   message is:

	MESSAGE_COMPRESSION_PROTOCOL_ID

        MESSAGE_NAME

        MESSAGE_CKSUM

        MESSAGE_BODY

   Major components in the system are to be made for these general
   functions:

	- generating the codebook.

	- storage/lookup of the codebook on the server.

	- allowing the client to retrieve the codebook from the server.

        - negotiation of specific host/port/codebook version between
          client and server.

        - message parsing using codebook.

        - message construction using codebook.

2. Codebook Generation

   Should this be done by making a sample canonical MSIX message, then 
   feeding it into a generator of some kind?  Or is there an API to
   this, where the codebook is generated by C code?

3. Server Storage

   For each service, there may be many codebooks.  For each
   service/codebook combination, there should be some auxillary data,
   including transport type (HTTP only for now), and port number.
   This allows dumb devices to chatter at ports without even having to
   say what they're talking about, or worrying about compatibility.

   There must be some kind of server-side UI for creating, mapping and
   storing codebooks.

4. Codebook Retrieval and Version Negotiation

   A simple CGI retrieval mechanism should be provided on the server.

   From the client side, it should be a simple URL with parameters
   being service name and desired codebook version.  The codebook
   version should be two numbers: the highest and lowest version
   numbers acceptable to the client.  If either number is 0, then the
   acceptable version can be considered unbounded at that extreme.
   That is, if zero is specified as the lowest version, it means no
   version will be rejected because the version is too low; if zero is
   specified as the highest version, it means no version will be
   rejected because it is too high.

   It is generally expected that both numbers will be the same, and
   specify a particular codebook that is the only one the client can
   deal with.

5. Message Parsing

   When parsing a message, the server references a codebook.  The code
   book describes what each successive byte range represents.  The
   general form of a code book follows:

   NBYTES COMMAND [PARAMS]

   NBYTES specifies the size of the field.

   COMMAND specified the meaning of the field.  Possible commands are:

       VERSION
       MESSAGE_NAME 
       MESSAGE_CKSUM
       MSIX_ID
       MSIX_PROPERTY_TEXT   PROPNAME
       MSIX_PROPERTY_WTEXT  PROPNAME
       MSIX_PROPERTY_INT32  PROPNAME
       MSIX_PROPERTY_FLOAT  PROPNAME
       MSIX_PROPERTY_DOUBLE PROPNAME
       MSIX_PROPERTY_TIME   PROPNAME

   PARAMS are parameters that may be require for a command.  For
   example, a property command will always require the name of the
   property, but this is not transmitted in the message, since it is
   the same for all messages.

   The server essentially looks at the code book one line at a time,
   extracts the specified number of bytes into an appropriate
   structure, then takes action based on the command.  Action includes
   any needed byte-ordering transforms on the the data.

   The message parser knows it has reached the end of a message when
   it has processed all of the definitions in the codebook.  If the
   message ends before the codebook is processed, it is an error (the
   message is incomplete).  If there are still unread bytes after
   the entire codebook is processed, they are ignored.


6. Message Construction

   Message construction is simply the opposite of parsing. The client
   processes each instruction in the codebook, writing the bytes to
   the message block. 

   To assure byte-ordering and data-format issues, data will be
   written according to the XDR specification.

Implementation
--------------
1. Classes

   The MTCompressor class reads a codebook file and a message and
   provides appropriate hooks for taking actions.  This class also has
   the capability to define new compression schemes and write the
   codebook files. 

   The MTCompressor class also can read a codebook file and an MSIX
   session object hierarchy and dump a compressed message to a stream.

