Attribute VB_Name = "basBlowfishCBC"
Option Explicit
Option Base 0

' basBlowfishCBC: Wrapper functions to call Blowfish algorithms in CBC mode

' Version 5. January 2002. Speed improvements - thanks to Robert Garofalo.
' Version 4. 12 May 2001. Minor improvements as noted.
' These functions new in Version 2. First published 16 November 2000
'************************* COPYRIGHT NOTICE*************************
' This code was originally written in Visual Basic by David Ireland
' and is copyright (c) 2000-2 D.I. Management Services Pty Limited,
' ARR.

' You are free to use this code as part of your own applications
' provided you keep this copyright notice intact and acknowledge
' its authorship with the words:

'   "Contains cryptography software by David Ireland of
'   DI Management Services Pty Ltd <www.di-mgt.com.au>."

' If you use it as part of a web site, please include a link
' to our site in the form
' <A HREF="http://www.di-mgt.com.au/crypto.html">Cryptography
' Software Code</a>

' This code may only be used as part of an application. It may
' not be reproduced or distributed separately by any means without
' the express written permission of the author.

' David Ireland and DI Management Services Pty Limited make no
' representations concerning either the merchantability of this
' software or the suitability of this software for any particular
' purpose. It is provided "as is" without express or implied
' warranty of any kind.

' Please forward comments or bug reports to <code@di-mgt.com.au>.
' The latest version of this source code can be downloaded from
' www.di-mgt.com.au/crypto.html.
'****************** END OF COPYRIGHT NOTICE*************************

' The functions in this module are:
' blf_StringEncCBC(strData, strIV): Enciphers string strData with current key
' blf_StringDecCBC(strData, strIV): Deciphers string strData with current key
' blf_StringRawCBC(strData, strIV, bEncrypt): En/Deciphers string without padding
' blf_FileEncCBC(sFileIn, sFileOut, strIV): Enciphers file with name sFileIn
'   with current key and writes output to new file sFileOut
' blf_FileDecCBC(sFileIn, sFileOut, strIV): Deciphers file with name sFileIn
'   with current key and writes output to new file sFileOut

' In all cases, strIV is the 8-byte initialisation vector
' expressed as a 16-digit hex string

' To set current key, call blf_KeyInit(aKey())
'   where aKey() is the key as an array of Bytes

' Note: The blf_File functions use the file handling functions in basFileAPI

Public Function blf_StringEncCBC(strData As String, ByVal strIV As String) As String
' Encrypts string <strData> in CBC mode
' using hex string <strIV> as initialisation vector.
' Adds padding as per RFC 2630.
' Returns encrypted string.
' Requires key and boxes to be already set up.
' Version 5. Completely revised.
' The speed improvement here is due to Robert Garofalo.
    Dim strIn As String
    Dim strOut As String
    Dim nLen As Long
    Dim nBlocks As Long
    Dim i As Long
    Dim j As Long
    Dim aBytes() As Byte
    Dim sBlock As String * 8
    Dim iIndex As Long
    Dim aReg() As Byte    ' Feedback register
    
    ' Initialisation vector should be a 16-character hex string
    ' First make sure (NB it was passed ByVal):-
    If Len(strIV) < 16 Then
        strIV = strIV & String(16 - Len(strIV), "0")
    ElseIf Len(strIV) > 16 Then
        strIV = Left$(strIV, 16)
    End If
    ' then convert to an array of bytes
    aReg() = cv_BytesFromHex(strIV)
    
    ' Pad data string to multiple of 8 bytes
    strIn = PadString(strData)
    
    ' Calc number of 8-byte blocks
    nLen = Len(strIn)
    nBlocks = nLen \ 8
    ' Allocate output string here so we can use Mid$ below
    strOut = String(nLen, " ")
    
    ' Work through string in blocks of 8 bytes
    iIndex = 0
    For i = 1 To nBlocks
        ' Fetch next block from string
        sBlock = Mid$(strIn, iIndex + 1, 8)
        ' Convert to bytes
        aBytes() = StrConv(sBlock, vbFromUnicode)
        
        ' XOR with feedback register
        Call bXorBytes(aBytes, aReg, 8)
        
        ' Encrypt the block
        Call blf_EncryptBytes(aBytes())
        
        ' Store in feedback register
        Call bCopyBytes(aReg, aBytes, 8)
        
        ' Convert back to a string
        sBlock = StrConv(aBytes(), vbUnicode)
        ' Copy to output string
        Mid$(strOut, iIndex + 1, 8) = sBlock
        iIndex = iIndex + 8
    Next
    
    blf_StringEncCBC = strOut
    
End Function

Public Function blf_StringDecCBC(strData As String, ByVal strIV As String) As String
' Decrypts string <strData> in CBC mode
' using hex string <strIV> as initialisation vector.
' Assumes plaintext was padded as per RFC 2630.
' Returns decrypted string.
' Requires key and boxes to be already set up.
' Version 5. Completely revised.
' The speed improvement here is due to Robert Garofalo.
    Dim strIn As String
    Dim strOut As String
    Dim nLen As Long
    Dim nBlocks As Long
    Dim i As Long
    Dim j As Long
    Dim aBytes() As Byte
    Dim sBlock As String * 8
    Dim iIndex As Long
    Dim aReg() As Byte    ' Feedback register
    Dim aStore(7) As Byte   ' Temp storage for ciphertext block
    
    ' Initialisation vector should be a 16-character hex string
    ' First make sure (NB it was passed ByVal):-
    If Len(strIV) < 16 Then
        strIV = strIV & String(16 - Len(strIV), "0")
    ElseIf Len(strIV) > 16 Then
        strIV = Left$(strIV, 16)
    End If
    ' then convert to an array of bytes
    aReg() = cv_BytesFromHex(strIV)
    
    ' Calc number of 8-byte blocks
    strIn = strData
    nLen = Len(strIn)
    nBlocks = nLen \ 8
    ' Allocate output string here so we can use Mid$ below
    strOut = String(nLen, " ")
    
    ' Work through string in blocks of 8 bytes
    iIndex = 0
    For i = 1 To nBlocks
        ' Fetch next block from string
        sBlock = Mid$(strIn, iIndex + 1, 8)
        ' Convert to bytes
        aBytes() = StrConv(sBlock, vbFromUnicode)
        
        ' Store it
        Call bCopyBytes(aStore, aBytes, 8)
        
        ' Decrypt the block
        Call blf_DecryptBytes(aBytes())
        
        ' XOR with feedback register
        Call bXorBytes(aBytes, aReg, 8)
        
        ' Save ciphertext in feedback register
        Call bCopyBytes(aReg, aStore, 8)
        
        ' Convert back to a string
        sBlock = StrConv(aBytes(), vbUnicode)
        ' Append to output string
        Mid$(strOut, iIndex + 1, 8) = sBlock
        iIndex = iIndex + 8
    Next
    
    ' Remove padding
    strOut = UnpadString(strOut)
    
    blf_StringDecCBC = strOut
    
End Function

Public Function blf_StringEncRawCBC(strData As String, ByVal strIV As String) As String
' Encrypts string <strData> in CBC mode
' using hex string <strIV> as initialisation vector.
' Returns encrypted string.
' Requires key and boxes to be already set up.
' Version 5. New function without padding.
    Dim strIn As String
    Dim strOut As String
    Dim nLen As Long
    Dim nBlocks As Long
    Dim i As Long
    Dim j As Long
    Dim aBytes() As Byte
    Dim sBlock As String * 8
    Dim iIndex As Long
    Dim aReg() As Byte    ' Feedback register
    
    ' Initialisation vector should be a 16-character hex string
    ' First make sure (NB it was passed ByVal):-
    If Len(strIV) < 16 Then
        strIV = strIV & String(16 - Len(strIV), "0")
    ElseIf Len(strIV) > 16 Then
        strIV = Left$(strIV, 16)
    End If
    ' then convert to an array of bytes
    aReg() = cv_BytesFromHex(strIV)
    
    strIn = strData
    ' Calc number of 8-byte blocks
    nLen = Len(strIn)
    nBlocks = nLen \ 8
    ' Allocate output string here so we can use Mid$ below
    strOut = String(nLen, " ")
    
    ' Work through string in blocks of 8 bytes
    iIndex = 0
    For i = 1 To nBlocks
        ' Fetch next block from string
        sBlock = Mid$(strIn, iIndex + 1, 8)
        ' Convert to bytes
        aBytes() = StrConv(sBlock, vbFromUnicode)
        
        ' XOR with feedback register
        Call bXorBytes(aBytes, aReg, 8)
        
        ' Encrypt the block
        Call blf_EncryptBytes(aBytes())
        
        ' Store in feedback register
        Call bCopyBytes(aReg, aBytes, 8)
        
        ' Convert back to a string
        sBlock = StrConv(aBytes(), vbUnicode)
        ' Copy to output string
        Mid$(strOut, iIndex + 1, 8) = sBlock
        iIndex = iIndex + 8
    Next
    
    blf_StringEncRawCBC = strOut
    
End Function

Public Function blf_StringDecRawCBC(strData As String, ByVal strIV As String) As String
' Decrypts string <strData> in CBC mode
' using hex string <strIV> as initialisation vector.
' Returns decrypted string.
' Requires key and boxes to be already set up.
' Version 5. New version assuming no padding.
    Dim strIn As String
    Dim strOut As String
    Dim nLen As Long
    Dim nBlocks As Long
    Dim i As Long
    Dim j As Long
    Dim aBytes() As Byte
    Dim sBlock As String * 8
    Dim iIndex As Long
    Dim aReg() As Byte    ' Feedback register
    Dim aStore(7) As Byte   ' Temp storage for ciphertext block
    
    ' Initialisation vector should be a 16-character hex string
    ' First make sure (NB it was passed ByVal):-
    If Len(strIV) < 16 Then
        strIV = strIV & String(16 - Len(strIV), "0")
    ElseIf Len(strIV) > 16 Then
        strIV = Left$(strIV, 16)
    End If
    ' then convert to an array of bytes
    aReg() = cv_BytesFromHex(strIV)
    
    ' Calc number of 8-byte blocks
    strIn = strData
    nLen = Len(strIn)
    nBlocks = nLen \ 8
    ' Allocate output string here so we can use Mid$ below
    strOut = String(nLen, " ")
    
    ' Work through string in blocks of 8 bytes
    iIndex = 0
    For i = 1 To nBlocks
        ' Fetch next block from string
        sBlock = Mid$(strIn, iIndex + 1, 8)
        ' Convert to bytes
        aBytes() = StrConv(sBlock, vbFromUnicode)
        
        ' Store it
        Call bCopyBytes(aStore, aBytes, 8)
        
        ' Decrypt the block
        Call blf_DecryptBytes(aBytes())
        
        ' XOR with feedback register
        Call bXorBytes(aBytes, aReg, 8)
        
        ' Save ciphertext in feedback register
        Call bCopyBytes(aReg, aStore, 8)
        
        ' Convert back to a string
        sBlock = StrConv(aBytes(), vbUnicode)
        ' Append to output string
        Mid$(strOut, iIndex + 1, 8) = sBlock
        iIndex = iIndex + 8
    Next
    
    blf_StringDecRawCBC = strOut
    
End Function

Public Function blf_FileEncCBC(sFileIn As String, sFileOut As String, _
    strIV As String) As Boolean
' Encrypts file with name <sFileIn> and writes ciphertext to new file <sFileOut>
' in CBC mode using hex string <strIV> as initialisation vector
' Requires key and boxes to be initialised
' Any existing file <sFileOut> will be overwritten.
    Dim hFileIn As Long
    Dim hFileOut As Long
    Dim i As Long
    Dim nLen As Long, nPad As Long, nBlocks As Long
    Dim aBytes(7) As Byte   ' Block of 8 bytes
    Dim aReg() As Byte    ' Feedback register
    
    ' Open files for input and output
    ' Use Windows API functions to avoid unwanted padding
    ' Version 4: Changes to error handling as noted.
    hFileIn = ap_OpenFileReadOnly(sFileIn)
    If hFileIn = -1 Then
        Error 68    ' Add your own error handler here
    End If
    hFileOut = ap_OpenFileWrite(sFileOut)
    If hFileOut = -1 Then
        ' Version 4: Close input file before exit
        ' Thanks to Robert Garofalo for this.
        Call ap_CloseFile(hFileIn)
        Error 68    ' Add your own error handler here
    End If
    
    ' Convert IV hex string into bytes
    ' Version 5: use new conversion function
    aReg() = cv_BytesFromHex(strIV)
    
    ' Calculate padding required & no of 8-byte blocks
    nLen = FileLen(sFileIn)
    nBlocks = nLen \ 8
    nPad = (nBlocks + 1) * 8 - nLen
    
    ' Read in file in 8-byte blocks
    For i = 1 To nBlocks
        ' Fetch next block
        Call ap_GetBytes(hFileIn, aBytes, 8)
        ' XOR with feedback register
        Call bXorBytes(aBytes, aReg, 8)
        ' Encrypt and write to output file
        Call blf_EncryptBytes(aBytes)
        ' Store in feedback register
        Call bCopyBytes(aReg, aBytes, 8)
        ' Write to file
        Call ap_PutBytes(hFileOut, aBytes, 8)
    Next
    
    ' Read in and pad the last block
    Call ap_GetBytes(hFileIn, aBytes, 8)
    For i = 1 To nPad
        aBytes(8 - i) = nPad
    Next
    ' XOR with feedback register
    Call bXorBytes(aBytes, aReg, 8)
    ' Encrypt it
    Call blf_EncryptBytes(aBytes)
    ' Write to output file
    Call ap_PutBytes(hFileOut, aBytes, 8)
    
    Call ap_CloseFile(hFileIn)
    Call ap_CloseFile(hFileOut)
    
End Function

Public Function blf_FileDecCBC(sFileIn As String, sFileOut As String, _
    strIV As String) As Boolean
' Decrypts file with name <sFileIn> and writes plaintext to new file <sFileOut>
' in CBC mode using hex string <strIV> as initialisation vector
' Requires key and boxes to be initialised
' Any existing file <sFileOut> will be overwritten.
    Dim hFileIn As Long
    Dim hFileOut As Long
    Dim i As Long
    Dim nLen As Long, nPad As Long, nBlocks As Long
    Dim aBytes(7) As Byte   ' Block of 8 bytes
    Dim aReg() As Byte     ' Feedback register
    Dim aStore(7) As Byte   ' Temp store for cipher block
    
    ' Open files for input and output
    ' Use Windows API functions to avoid unwanted padding
    ' Version 4: Changes to error handling as noted.
    hFileIn = ap_OpenFileReadOnly(sFileIn)
    If hFileIn = -1 Then
        Error 68    ' Add your own error handler here
    End If
    hFileOut = ap_OpenFileWrite(sFileOut)
    If hFileOut = -1 Then
        ' Version 4: Close input file before exit
        ' Thanks to Robert Garofalo for this.
        Call ap_CloseFile(hFileIn)
        Error 68    ' Add your own error handler here
    End If
    
    ' Convert IV hex string into bytes
    ' Version 5: use new conversion function
    aReg() = cv_BytesFromHex(strIV)
    
    ' Calculate no of 8-byte blocks to read (should be a multiple of 8)
    nLen = FileLen(sFileIn)
    nBlocks = nLen \ 8
    
    ' Read in file in 8-byte blocks except last block
    For i = 1 To nBlocks - 1
        ' Fetch next cipher block
        Call ap_GetBytes(hFileIn, aBytes, 8)
        ' Store it
        Call bCopyBytes(aStore, aBytes, 8)
        ' Decrypt it
        Call blf_DecryptBytes(aBytes)
        ' XOR with feedback register
        Call bXorBytes(aBytes, aReg, 8)
        ' Save cipher block in register
        Call bCopyBytes(aReg, aStore, 8)
        ' Write to output file
        Call ap_PutBytes(hFileOut, aBytes, 8)
    Next
    
    ' Read in the last block
    Call ap_GetBytes(hFileIn, aBytes, 8)
    ' Decrypt
    Call blf_DecryptBytes(aBytes)
    ' XOR with feedback register
    Call bXorBytes(aBytes, aReg, 8)
    ' Write excluding padding
    nPad = aBytes(7)
    ' Version 4: Improved check, just in case!
    If nPad > 8 Or nPad < 0 Then
        nPad = 0
    End If
    Call ap_PutBytes(hFileOut, aBytes, 8 - nPad)
    
    Call ap_CloseFile(hFileIn)
    Call ap_CloseFile(hFileOut)
    
End Function

Private Sub bXorBytes(aByt1() As Byte, aByt2() As Byte, nBytes As Long)
' XOR's bytes in array aByt1 with array aByt2
' Returns results in aByt1
' i.e. aByt1() = aByt1() XOR aByt2()
    Dim i As Long
    For i = 0 To nBytes - 1
        aByt1(i) = aByt1(i) Xor aByt2(i)
    Next
End Sub

Private Sub bCopyBytes(aDest() As Byte, aSrc() As Byte, nBytes As Long)
' Copies nBytes from array aSrc() into aDest()
' i.e. set aDest() = aSrc()
' Assumes aDest is large enough.
    Dim i As Long
    For i = 0 To nBytes - 1
        aDest(i) = aSrc(i)
    Next
End Sub


