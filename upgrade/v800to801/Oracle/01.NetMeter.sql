--
-- Script generated by Schema Compare for Oracle 3.0.3.427 on 8/28/2014 3:46:36 PM
--
SET DEFINE OFF

ALTER TABLE tmp_rc ADD (c__quotebatchid RAW(16));

ALTER TABLE t_recur_window ADD (c__quotebatchid RAW(16));

/* *** start ADDS c__QuoteBatchId column to TMP_OLDRW  *** */ 
CREATE TABLE TMP_OLDRW_BACKUP AS
SELECT *
FROM TMP_OLDRW;
/

DROP TABLE TMP_OLDRW;
/

CREATE TABLE TMP_OLDRW ( C_CYCLEEFFECTIVEDATE, 
       C_CYCLEEFFECTIVESTART, 
       C_CYCLEEFFECTIVEEND, 
       C_SUBSCRIPTIONSTART, 
       C_SUBSCRIPTIONEND, 
       C_ADVANCE, 
       C__ACCOUNTID, 
       C__PAYINGACCOUNT, 
       C__PRICEABLEITEMINSTANCEID, 
       C__PRICEABLEITEMTEMPLATEID, 
       C__PRODUCTOFFERINGID, 
       C_PAYERSTART, 
       C_PAYEREND, 
       C__SUBSCRIPTIONID, 
       C_UNITVALUESTART, 
       C_UNITVALUEEND, 
       C_UNITVALUE, 
       C_BILLEDTHROUGHDATE, 
       C_LASTIDRUN, 
       C_MEMBERSHIPSTART, 
       C_MEMBERSHIPEND,
       c__QuoteBatchId, 
       ID_PAYER, 
       ID_PAYEE, 
       VT_START, 
       VT_END) AS
SELECT C_CYCLEEFFECTIVEDATE, 
       C_CYCLEEFFECTIVESTART, 
       C_CYCLEEFFECTIVEEND, 
       C_SUBSCRIPTIONSTART, 
       C_SUBSCRIPTIONEND, 
       C_ADVANCE, 
       C__ACCOUNTID, 
       C__PAYINGACCOUNT, 
       C__PRICEABLEITEMINSTANCEID, 
       C__PRICEABLEITEMTEMPLATEID, 
       C__PRODUCTOFFERINGID, 
       C_PAYERSTART, 
       C_PAYEREND, 
       C__SUBSCRIPTIONID, 
       C_UNITVALUESTART, 
       C_UNITVALUEEND, 
       C_UNITVALUE, 
       C_BILLEDTHROUGHDATE, 
       C_LASTIDRUN, 
       C_MEMBERSHIPSTART, 
       C_MEMBERSHIPEND,
       0, 
       ID_PAYER, 
       ID_PAYEE, 
       VT_START, 
       VT_END
FROM TMP_OLDRW_BACKUP;
/

UPDATE TMP_OLDRW SET c__QuoteBatchId = NULL;
/

ALTER TABLE TMP_OLDRW MODIFY c__QuoteBatchId raw(16);
DROP TABLE TMP_OLDRW_BACKUP;
/* *** end ADDS c__QuoteBatchId column to TMP_OLDRW  *** */ 

/* *** start ADDS c__QuoteBatchId column to TMP_OLDRW  *** */ 
CREATE TABLE TMP_OLDRW_BACKUP AS
SELECT *
FROM TMP_OLDRW;
/

DROP TABLE TMP_OLDRW;
/

CREATE TABLE TMP_OLDRW ( C_CYCLEEFFECTIVEDATE, 
       C_CYCLEEFFECTIVESTART, 
       C_CYCLEEFFECTIVEEND, 
       C_SUBSCRIPTIONSTART, 
       C_SUBSCRIPTIONEND, 
       C_ADVANCE, 
       C__ACCOUNTID, 
       C__PAYINGACCOUNT, 
       C__PRICEABLEITEMINSTANCEID, 
       C__PRICEABLEITEMTEMPLATEID, 
       C__PRODUCTOFFERINGID, 
       C_PAYERSTART, 
       C_PAYEREND, 
       C__SUBSCRIPTIONID, 
       C_UNITVALUESTART, 
       C_UNITVALUEEND, 
       C_UNITVALUE, 
       C_BILLEDTHROUGHDATE, 
       C_LASTIDRUN, 
       C_MEMBERSHIPSTART, 
       C_MEMBERSHIPEND,
       c__QuoteBatchId, 
       ID_PAYER, 
       ID_PAYEE, 
       VT_START, 
       VT_END) AS
SELECT C_CYCLEEFFECTIVEDATE, 
       C_CYCLEEFFECTIVESTART, 
       C_CYCLEEFFECTIVEEND, 
       C_SUBSCRIPTIONSTART, 
       C_SUBSCRIPTIONEND, 
       C_ADVANCE, 
       C__ACCOUNTID, 
       C__PAYINGACCOUNT, 
       C__PRICEABLEITEMINSTANCEID, 
       C__PRICEABLEITEMTEMPLATEID, 
       C__PRODUCTOFFERINGID, 
       C_PAYERSTART, 
       C_PAYEREND, 
       C__SUBSCRIPTIONID, 
       C_UNITVALUESTART, 
       C_UNITVALUEEND, 
       C_UNITVALUE, 
       C_BILLEDTHROUGHDATE, 
       C_LASTIDRUN, 
       C_MEMBERSHIPSTART, 
       C_MEMBERSHIPEND,
       0, 
       ID_PAYER, 
       ID_PAYEE, 
       VT_START, 
       VT_END
FROM TMP_OLDRW_BACKUP;
/

UPDATE TMP_OLDRW SET c__QuoteBatchId = NULL;
/

ALTER TABLE TMP_OLDRW MODIFY c__QuoteBatchId raw(16);
DROP TABLE TMP_OLDRW_BACKUP;
/* *** end ADDS c__QuoteBatchId column to TMP_OLDRW  *** */ 

CREATE GLOBAL TEMPORARY TABLE tmp_rc_1 (
  c_rcactiontype NVARCHAR2(255),
  c_rcintervalstart DATE NOT NULL,
  c_rcintervalend DATE NOT NULL,
  c_billingintervalstart DATE NOT NULL,
  c_billingintervalend DATE NOT NULL,
  c_rcintervalsubscriptionstart DATE NOT NULL,
  c_rcintervalsubscriptionend DATE NOT NULL,
  c_subscriptionstart DATE NOT NULL,
  c_subscriptionend DATE,
  c_advance CHAR NOT NULL,
  c_prorateonsubscription CHAR NOT NULL,
  c_prorateinstantly CHAR NOT NULL,
  c_unitvaluestart DATE NOT NULL,
  c_unitvalueend DATE NOT NULL,
  c_unitvalue NUMBER(22,10),
  c_ratingtype NUMBER(10) NOT NULL,
  c_prorateonunsubscription CHAR NOT NULL,
  c_prorationcyclelength NUMBER(10) NOT NULL,
  c__accountid NUMBER(10) NOT NULL,
  c__payingaccount NUMBER(10) NOT NULL,
  c__priceableiteminstanceid NUMBER(10) NOT NULL,
  c__priceableitemtemplateid NUMBER(10) NOT NULL,
  c__productofferingid NUMBER(10) NOT NULL,
  c_billedratedate DATE,
  c__subscriptionid NUMBER(10) NOT NULL,
  c__intervalid NUMBER(10),
  id_source_sess RAW(16),
  c__quotebatchid RAW(16),
  isarrearsrecalculation NUMBER(10) NOT NULL
)
ON COMMIT PRESERVE ROWS;

ALTER TABLE t_sub ADD (tx_quoting_batch RAW(16));

ALTER TABLE tmp_payer_changes RENAME COLUMN c__payingaccountdebit to c__payingaccount;

ALTER TABLE tmp_payer_changes DROP (c__payingaccountcredit);

ALTER TABLE tmp_newrw ADD (c__quotebatchid RAW(16));

CREATE GLOBAL TEMPORARY TABLE tmp_backoutarrearsusages (
  c__priceableiteminstanceid NUMBER(10) NOT NULL,
  c__priceableitemtemplateid NUMBER(10) NOT NULL,
  c__subscriptionid NUMBER(10) NOT NULL
)
ON COMMIT PRESERVE ROWS;

ALTER TABLE t_sub_history ADD (tx_quoting_batch RAW(16));

ALTER PACKAGE dbo COMPILE;

ALTER FUNCTION metratime COMPILE;

CREATE OR REPLACE function AllowInitialArrersCharge(
p_b_advance IN    char,
p_id_acc IN       integer,
p_sub_end IN      date,
p_current_date IN date,
p_isQuote IN      integer default 1)
RETURN smallint
IS
p_is_allow_create  smallint;
begin
	if p_b_advance = 'Y' then
		/* allows to create initial for ADVANCE */
		p_is_allow_create := 1;
	else
    if p_isQuote > 0 then
		/* disable to create initial for ARREARS in case of quote  */
      p_is_allow_create := 0;
    else
		/* Creates Initial charges in case it fits inder current interval*/
		select case when exists(select 1 from t_usage_interval us_int
					join t_acc_usage_cycle acc
					on us_int.id_usage_cycle = acc.id_usage_cycle
					where acc.id_acc = p_id_acc
					AND NVL(p_current_date, metratime(1,'RC')) BETWEEN DT_START AND DT_END
					AND p_sub_end BETWEEN DT_START AND DT_END
					)
				then 1
				else 0
			  end
		into p_is_allow_create
		from dual;
    
    end	if;
	end	if;
	  
	return p_is_allow_create;
end;
/

CREATE OR REPLACE procedure insertChargesIntoSvcTables (meterType1 in VARCHAR2, meterType2 in varchar2) as
    idRun INT;
    idMessage INT;
    idServiceFlat int;
    idServiceUdrc int;
    numBlocks int;
    v_block_next t_current_id.id_current%TYPE;
begin
    select count(1) into numBlocks from tmp_rc where (c_RCActionType like meterType1 or c_RcActionType like meterType2);
    if (numBlocks = 0) then return; end if;
    
/*    getidblock(numBlocks, 'id_dbqueuesch', idMessage);*/

    UPDATE t_current_id
        SET id_current    = id_current + numBlocks
        WHERE nm_current = 'id_dbqueuesch'
        RETURNING id_current
        INTO v_block_next;

    IF sql%FOUND
    THEN
        idMessage   := v_block_next - numBlocks;
    ELSE
        raise_application_error (-20001,
                                'T_CURRENT_ID Update failed for ' || 'id_dbqueuesch'
        );
    END IF;

    
/*    getIdBlock(numBlocks, 'id_dbqueuess', idRun);*/
    UPDATE t_current_id
        SET id_current    = id_current + numBlocks
        WHERE nm_current = 'id_dbqueuess'
        RETURNING id_current
        INTO v_block_next;

    IF sql%FOUND
    THEN
        idRun   := v_block_next - numBlocks;
    ELSE
        raise_application_error (-20001,
                                'T_CURRENT_ID Update failed for ' || 'id_dbqueuess'
        );
    END IF;


    SELECT id_enum_data into idServiceFlat FROM t_enum_data ted WHERE ted.nm_enum_data LIKE
         'metratech.com/flatrecurringcharge';
    SELECT id_enum_data into idServiceUdrc FROM t_enum_data ted WHERE ted.nm_enum_data LIKE
         'metratech.com/udrecurringcharge';
       
    INSERT INTO t_session
      SELECT idRun + ROW_NUMBER() OVER (ORDER BY id_Source_Sess) - 1 AS id_ss,
        id_source_sess,
        1 as id_partition
      FROM tmp_rc
        where (c_RCActionType like meterType1 or c_RcActionType like meterType2);

    INSERT INTO t_session_set
      SELECT idMessage + ROW_NUMBER() OVER (ORDER BY id_Source_Sess) - 1 AS id_message,
      idRun + ROW_NUMBER() OVER (ORDER BY id_Source_Sess) - 1 AS id_ss,
      case when c_unitValue IS NULL then idServiceFlat ELSE idServiceUdrc END AS id_svc,
      1 AS b_root,
      1 AS session_count,
      1 as id_partition
    FROM tmp_rc
      where (c_RCActionType like meterType1 or c_RcActionType like meterType2);
    
    INSERT INTO t_message
    select idMessage + ROW_NUMBER() OVER (ORDER BY id_Source_Sess) - 1 AS id_message,
        NULL as id_route,
        metratime(1,'RC') as dt_crt ,
        metratime(1,'RC') as dt_metered ,
        NULL as dt_assigned,
        NULL as id_listener,
        NULL as id_pipeline,
        NULL as dt_completed,
        NULL as id_feedback,
        NULL as tx_TransactionID,
        NULL as tx_sc_username,
        NULL as tx_sc_password,
        NULL as tx_sc_namespace,
        NULL as tx_sc_serialized,
        '127.0.0.1' as tx_ip_address,
      1 as id_partition
   FROM tmp_rc
     where (c_RCActionType like meterType1 or c_RcActionType like meterType2);
    
    INSERT INTO t_svc_FlatRecurringCharge
    (id_source_sess
    ,id_parent_source_sess
    ,id_external
    ,c_RCActionType
    ,c_RCIntervalStart
    ,c_RCIntervalEnd
    ,c_BillingIntervalStart
    ,c_BillingIntervalEnd
    ,c_RCIntervalSubscriptionStart
    ,c_RCIntervalSubscriptionEnd
    ,c_SubscriptionStart
    ,c_SubscriptionEnd
    ,c_Advance
    ,c_ProrateOnSubscription
    ,c_ProrateInstantly
    ,c_ProrateOnUnsubscription
    ,c_ProrationCycleLength
    ,c__AccountID
    ,c__PayingAccount
    ,c__PriceableItemInstanceID
    ,c__PriceableItemTemplateID
    ,c__ProductOfferingID
    ,c_BilledRateDate
    ,c__SubscriptionID
    ,c__IntervalID
    ,c__Resubmit
    ,c__TransactionCookie
    ,c__CollectionID,
    id_partition)
    SELECT
    id_source_sess
    ,NULL AS id_parent_source_sess
    ,NULL AS id_external
    ,c_RCActionType
    ,c_RCIntervalStart
    ,c_RCIntervalEnd
    ,c_BillingIntervalStart
    ,c_BillingIntervalEnd
    ,c_RCIntervalSubscriptionStart
    ,c_RCIntervalSubscriptionEnd
    ,c_SubscriptionStart
    ,c_SubscriptionEnd
    ,c_Advance
    ,c_ProrateOnSubscription
    ,c_ProrateInstantly
    ,c_ProrateOnUnsubscription
    ,c_ProrationCycleLength
    ,c__AccountID
    ,c__PayingAccount
    ,c__PriceableItemInstanceID
    ,c__PriceableItemTemplateID
    ,c__ProductOfferingID
    ,c_BilledRateDate
    ,c__SubscriptionID
    ,c__IntervalID
    ,'0' AS c__Resubmit
    ,NULL AS c__TransactionCookie
    ,c__QuoteBatchId AS c__CollectionID,
    1 as id_partition
FROM tmp_rc where c_UnitValue is null
    and (c_RCActionType like meterType1 or c_RcActionType like meterType2);
     
    INSERT INTO t_svc_UDRecurringCharge(
    id_source_sess
    ,id_parent_source_sess
    ,id_external
    ,c_RCActionType
    ,c_RCIntervalStart
    ,c_RCIntervalEnd
    ,c_BillingIntervalStart
    ,c_BillingIntervalEnd
    ,c_RCIntervalSubscriptionStart
    ,c_RCIntervalSubscriptionEnd
    ,c_SubscriptionStart
    ,c_SubscriptionEnd
    ,c_Advance
    ,c_ProrateOnSubscription
    ,c_UnitValueStart
    ,c_UnitValueEnd
    ,c_UnitValue
    ,c_RatingType
    ,c_ProrateOnUnsubscription
    ,c_ProrationCycleLength
    ,c_BilledRateDate
    ,c__SubscriptionID
    ,c__AccountID
    ,c__PayingAccount
    ,c__PriceableItemInstanceID
    ,c__PriceableItemTemplateID
    ,c__ProductOfferingID
    ,c__IntervalID
    ,c__Resubmit
    ,c__TransactionCookie
    ,c__CollectionID
    ,id_partition)
SELECT
    id_source_sess
    ,NULL AS id_parent_source_sess
    ,NULL AS id_external
    ,c_RCActionType
    ,c_RCIntervalStart
    ,c_RCIntervalEnd
    ,c_BillingIntervalStart
    ,c_BillingIntervalEnd
    ,c_RCIntervalSubscriptionStart
    ,c_RCIntervalSubscriptionEnd
    ,c_SubscriptionStart
    ,c_SubscriptionEnd
    ,c_Advance
    ,c_ProrateOnSubscription
    ,c_UnitValueStart
    ,c_UnitValueEnd
    ,c_UnitValue
    ,c_RatingType
    ,c_ProrateOnUnsubscription
    ,c_ProrationCycleLength
    ,c_BilledRateDate
    ,c__SubscriptionID
    ,c__AccountID
    ,c__PayingAccount
    ,c__PriceableItemInstanceID
    ,c__PriceableItemTemplateID
    ,c__ProductOfferingID
    ,c__IntervalID
    ,'0' AS c__Resubmit
    ,NULL AS c__TransactionCookie
    ,c__QuoteBatchId AS c__CollectionID
    ,1 as id_partition
   FROM tmp_rc where c_UnitValue is not null
     and (c_RCActionType like meterType1 or c_RcActionType like meterType2);
     
delete FROM tmp_rc where (c_RCActionType like meterType1 or c_RcActionType like meterType2);
end insertchargesintosvctables;
/

CREATE OR REPLACE PROCEDURE MeterUdrcFromRecurWindow (currentDate date, actionType VARCHAR2) AS
  enabled VARCHAR2(10);
BEGIN
  SELECT value INTO enabled FROM t_db_values WHERE parameter = N'InstantRc';
  IF (enabled = 'false') THEN RETURN; END IF;

  INSERT INTO TMP_UDRC
  SELECT
    pci.dt_start                                                                        AS c_RCIntervalStart,
    pci.dt_end                                                                          AS c_RCIntervalEnd,
    ui.dt_start                                                                         AS c_BillingIntervalStart,
    ui.dt_end                                                                           AS c_BillingIntervalEnd,
    dbo.mtmaxoftwodates(pci.dt_start, rw.c_SubscriptionStart)                           AS c_RCIntervalSubscriptionStart,
    dbo.mtminoftwodates(pci.dt_end, rw.c_SubscriptionEnd)                               AS c_RCIntervalSubscriptionEnd,
    rw.c_SubscriptionStart                                                              AS c_SubscriptionStart,
    rw.c_SubscriptionEnd                                                                AS c_SubscriptionEnd,
    CASE WHEN rw.c_advance  ='Y' THEN '1' ELSE '0' END                                  AS c_Advance,
    CASE WHEN rcr.b_prorate_on_activate ='Y' THEN '1' ELSE '0' END                      AS c_ProrateOnSubscription,
    trv.vt_start                                                                        AS c_UnitValueStart,
    trv.vt_end                                                                          AS c_UnitValueEnd,
    trv.n_value                                                                         AS c_UnitValue,
    rcr.n_rating_type                                                                   AS c_RatingType,
    CASE WHEN rcr.b_prorate_on_deactivate  ='Y' THEN '1' ELSE '0' END                   AS c_ProrateOnUnsubscription,
    CASE WHEN rcr.b_fixed_proration_length = 'Y' THEN fxd.n_proration_length ELSE 0 END AS c_ProrationCycleLength,
    rw.c__accountid                                                                     AS c__AccountID,
    rw.c__payingaccount                                                                 AS c__PayingAccount,
    rw.c__priceableiteminstanceid                                                       AS c__PriceableItemInstanceID,
    rw.c__priceableitemtemplateid                                                       AS c__PriceableItemTemplateID,
    rw.c__productofferingid                                                             AS c__ProductOfferingID,
    dbo.MTMinOfTwoDates(pci.dt_end,rw.c_SubscriptionEnd)                                AS c_BilledRateDate,
    rw.c__subscriptionid                                                                AS c__SubscriptionID,
    currentui.id_interval                                                               AS c__IntervalID
  FROM t_usage_interval ui
    INNER JOIN TMP_NEWRW rw
      ON rw.c_payerstart            < ui.dt_end AND rw.c_payerend          > ui.dt_start /* next interval overlaps with payer */
      AND rw.c_cycleeffectivestart  < ui.dt_end AND rw.c_cycleeffectiveend > ui.dt_start /* next interval overlaps with cycle */
      AND rw.c_membershipstart      < ui.dt_end AND rw.c_membershipend     > ui.dt_start /* next interval overlaps with membership */
      AND rw.c_SubscriptionStart    < ui.dt_end AND rw.c_SubscriptionEnd   > ui.dt_start
      AND rw.c_unitvaluestart       < ui.dt_end AND rw.c_unitvalueend      > ui.dt_start /* next interval overlaps with UDRC */
    INNER JOIN TMP_CHANGED_UNITS trv ON trv.id_sub = rw.C__SubscriptionID AND trv.id_prop = rw.c__PriceableItemInstanceID
      AND trv.vt_start < rw.c_UnitValueEnd AND trv.vt_end > rw.c_UnitValueStart
    INNER JOIN t_recur rcr ON rw.c__priceableiteminstanceid = rcr.id_prop
    INNER JOIN t_acc_usage_cycle auc ON auc.id_acc = rw.c__payingaccount AND auc.id_usage_cycle = ui.id_usage_cycle
    INNER JOIN t_usage_cycle ccl
      ON  ccl.id_usage_cycle = CASE
                            WHEN rcr.tx_cycle_mode = 'Fixed' THEN rcr.id_usage_cycle
                            WHEN rcr.tx_cycle_mode = 'BCR Constrained' THEN ui.id_usage_cycle
                            WHEN rcr.tx_cycle_mode = 'EBCR' THEN dbo.DeriveEBCRCycle(ui.id_usage_cycle, rw.c_SubscriptionStart, rcr.id_cycle_type)
                            ELSE NULL
                        END
    INNER JOIN t_usage_cycle_type fxd ON fxd.id_cycle_type = ccl.id_cycle_type
    INNER JOIN t_pc_interval pci ON pci.id_cycle = ccl.id_usage_cycle
      AND (
            (rcr.b_advance = 'Y' AND pci.dt_start BETWEEN ui.dt_start AND ui.dt_end)      /* If this is in advance, check if rc start falls in this interval */
            OR pci.dt_end BETWEEN ui.dt_start AND ui.dt_end                               /* or check if the cycle end falls into this interval */
            OR (pci.dt_start < ui.dt_start AND pci.dt_end > ui.dt_end)                    /* or this interval could be in the middle of the cycle */
          )
      AND pci.dt_end BETWEEN rw.c_payerstart AND rw.c_payerend                            /* rc start goes to this payer */
      AND rw.c_unitvaluestart      < pci.dt_end AND rw.c_unitvalueend      > pci.dt_start /* rc overlaps with this UDRC */
      AND rw.c_membershipstart     < pci.dt_end AND rw.c_membershipend     > pci.dt_start /* rc overlaps with this membership */
      AND rw.c_cycleeffectivestart < pci.dt_end AND rw.c_cycleeffectiveend > pci.dt_start /* rc overlaps with this cycle */
      AND rw.c_SubscriptionStart   < pci.dt_end AND rw.c_subscriptionend   > pci.dt_start /* rc overlaps with this subscription */
    INNER JOIN t_usage_interval currentui ON currentDate BETWEEN currentui.dt_start AND currentui.dt_end
      AND currentui.id_usage_cycle = ui.id_usage_cycle
  WHERE
    /* Only issue corrections if there's a previous iteration. */
    EXISTS (SELECT 1 FROM t_recur_value rv WHERE rv.id_sub = rw.c__SubscriptionID AND rv.tt_end < dbo.MTMaxDate())
    AND ui.dt_start < currentDate
    AND rw.c__IsAllowGenChargeByTrigger = 1;

  INSERT INTO TMP_RC
  SELECT actionType AS c_RCActionType,
         c_RCIntervalStart,
         c_RCIntervalEnd,
         c_BillingIntervalStart,
         c_BillingIntervalEnd,
         c_RCIntervalSubscriptionStart,
         c_RCIntervalSubscriptionEnd,
         c_SubscriptionStart,
         c_SubscriptionEnd,
         c_Advance,
         c_ProrateOnSubscription,
         'N' AS c_ProrateInstantly,
         c_UnitValueStart,
         c_UnitValueEnd,
         c_UnitValue,
         c_RatingType,
         c_ProrateOnUnsubscription,
         c_ProrationCycleLength,
         c__AccountID,
         c__PayingAccount,
         c__PriceableItemInstanceID,
         c__PriceableItemTemplateID,
         c__ProductOfferingID,
         c_BilledRateDate,
         c__SubscriptionID,
         c__IntervalID,
         SYS_GUID() AS idSourceSess,
         null
  FROM   TMP_UDRC;

  insertChargesIntoSvcTables('AdvanceCorrection','DebitCorrection');

  UPDATE  tmp_newrw rw
  SET     c_BilledThroughDate = currentDate
  WHERE   rw.c__IsAllowGenChargeByTrigger = 1;

END MeterUdrcFromRecurWindow;
/

CREATE OR REPLACE procedure CreateSubscriptionRecord (    p_id_sub IN integer, p_id_sub_ext IN raw, p_id_acc IN integer, p_id_group IN integer, p_id_po IN integer, p_dt_crt IN date, p_tx_quoting_batch IN raw,    p_startdate IN date,    p_enddate IN date,    p_systemdate IN date,    status OUT integer    )    as    realstartdate date;    realenddate date;    tempStartDate date;    tempEndDate date;    varMaxDateTime date;    onesecond_systemdate date;    temp_id_sub integer; temp_id_sub_ext raw(16); temp_id_acc integer; temp_id_group integer; temp_id_po integer; temp_dt_crt date; temp_tx_quoting_batch raw(16);     begin     select p_startdate,p_enddate,dbo.mtmaxdate(),dbo.subtractsecond(p_systemdate)       into realstartdate,realenddate,varMaxDateTime,onesecond_systemdate from dual;      status := 0;      /* Someone changes the start date of an existing record so that it creates gaps in time */     /* Existing Record      |---------------------| */     /* modified record        |-----------| */     /* modified record      |-----------------| */     /* modified record         |------------------| */     begin            /* find the start and end dates of the original interval */      select        vt_start,vt_end into tempstartdate,tempenddate     from     t_sub_history     where dbo.encloseddaterange(vt_start,vt_end,realstartdate,realenddate) = 1 AND     id_sub = p_id_sub and tt_end = varMaxDateTime ;       /* the original date range is no longer true */      update t_sub_history     set tt_end = onesecond_systemdate      where id_sub = p_id_sub AND vt_start = tempstartdate AND      tempenddate = vt_end AND tt_end = varMaxDateTime;        /* ---------------------moved from below-------------------------------------------------- */      /* adjust the two records end dates that are adjacent on the start and */      /* end dates; these records are no longer true */      update t_sub_history       set tt_end = onesecond_systemdate where      id_sub = p_id_sub AND tt_end = varMaxDateTime AND      (vt_end = dbo.subtractSecond(tempstartdate) OR vt_start = dbo.addsecond(tempenddate));      /* ----------------------------------------------------------------------- */       insert into t_sub_history       (id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,tx_quoting_batch,vt_start,vt_end,tt_start,tt_end)      select        id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,tx_quoting_batch,vt_start,dbo.subtractsecond(realstartdate),p_systemdate,varMaxDateTime       from t_sub_history        where       id_sub = p_id_sub AND vt_end = dbo.subtractSecond(tempstartdate)      UNION ALL      select       id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,tx_quoting_batch,realenddate,vt_end,p_systemdate,varMaxDateTime       from t_sub_history       where       id_sub = p_id_sub  AND vt_start = dbo.addsecond(tempenddate);       /* adjust the two records end dates that are adjacent on the start and */      /* end dates; these records are no longer true */      /**************************************************************************************      update t_sub_history       set tt_end = onesecond_systemdate where      id_sub = p_id_sub AND tt_end = varMaxDateTime AND      (vt_end = dbo.subtractSecond(tempstartdate) OR vt_start = dbo.addsecond(tempenddate));      **************************************************************************************/     exception when NO_DATA_FOUND then       status := 0;     end;      /* detect directly adjacent records with a adjacent start and end date.  If the */     /* key comparison matches successfully, use the start and/or end date of the original record  */     /* instead. */        if 1=1 then          begin           realstartdate := p_startdate;           realenddate := p_enddate;         end;         else        begin         select vt_start into realstartdate         from          t_sub_history  where id_sub = p_id_sub AND          p_startdate between vt_start AND dbo.addsecond(vt_end) and tt_end = varMaxDateTime;        exception when NO_DATA_FOUND then       select p_startdate into realstartdate from dual;        end;         begin         select vt_end into realenddate         from         t_sub_history  where id_sub = p_id_sub AND         p_enddate between vt_start AND dbo.addsecond(vt_end) and tt_end = varMaxDateTime;        exception when NO_DATA_FOUND then        select p_enddate into realenddate from dual;        end;        end if;      /* step : delete a range that is entirely in the new date range */     /* existing record:      |----| */     /* new record:      |----------------| */     update  t_sub_history      set tt_end = onesecond_systemdate     where dbo.EnclosedDateRange(realstartdate,realenddate,vt_start,vt_end) =1 AND     id_sub = p_id_sub  AND tt_end = varMaxDateTime;       /* create two new records that are on around the new interval         */     /* existing record:          |-----------------------------------| */     /* new record                        |-------| */     /*  */     /* adjusted old records      |-------|       |--------------------| */      begin     select     id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,tx_quoting_batch,vt_start,vt_end     into      temp_id_sub,temp_id_sub_ext,temp_id_acc,temp_id_group,temp_id_po,temp_dt_crt,temp_tx_quoting_batch,tempStartDate,tempEndDate     from     t_sub_history     where dbo.encloseddaterange(vt_start,vt_end,realstartdate,realenddate) = 1 AND     id_sub = p_id_sub and tt_end = varMaxDateTime ;     update     t_sub_history      set tt_end = onesecond_systemdate where     dbo.encloseddaterange(vt_start,vt_end,realstartdate,realenddate) = 1 AND     id_sub = p_id_sub AND tt_end = varMaxDateTime ;       insert into t_sub_history        (id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,tx_quoting_batch,vt_start,vt_end,tt_start,tt_end)       select      temp_id_sub,temp_id_sub_ext,temp_id_acc,temp_id_group,temp_id_po,temp_dt_crt,temp_tx_quoting_batch,tempStartDate,dbo.subtractsecond(realstartdate),     p_systemdate,varMaxDateTime from dual      where tempstartdate is not NULL AND tempStartDate <> realstartdate;     /* the previous statement may fail */     if realenddate <> tempendDate AND realenddate <> varMaxDateTime then       insert into t_sub_history        (id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,tx_quoting_batch,vt_start,vt_end,tt_start,tt_end)       select       temp_id_sub,temp_id_sub_ext,temp_id_acc,temp_id_group,temp_id_po,temp_dt_crt,temp_tx_quoting_batch,realenddate,tempEndDate,p_systemdate,varMaxDateTime       from dual;     end if;      exception when NO_DATA_FOUND then     status := 0;      end;     /* step 5: update existing payment records that are overlapping on the start */     /* range */     /* Existing Record |--------------| */     /* New Record: |---------| */     insert into t_sub_history     (id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,tx_quoting_batch,vt_start,vt_end,tt_start,tt_end)     select      id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,tx_quoting_batch,realenddate,vt_end,p_systemdate,varMaxDateTime     from      t_sub_history  where     id_sub = p_id_sub AND      vt_start > realstartdate and vt_start < realenddate      and tt_end = varMaxDateTime;             if 1=1 then         begin        update t_sub_history        set tt_end = onesecond_systemdate          where            id_sub = p_id_sub     and tt_end = varMaxDateTime;       end;       else begin         update t_sub_history         set tt_end = onesecond_systemdate         where     id_sub = p_id_sub AND      vt_start > realstartdate and vt_start < realenddate      and tt_end = varMaxDateTime;       end;       end if;     /* step 4: update existing payment records that are overlapping on the end */     /* range */     /* Existing Record |--------------| */     /* New Record:             |-----------| */     insert into t_sub_history     (id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,tx_quoting_batch,vt_start,vt_end,tt_start,tt_end)     select     id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,tx_quoting_batch,vt_start,dbo.subtractsecond(realstartdate),p_systemdate,varMaxDateTime     from t_sub_history     where     id_sub = p_id_sub AND      vt_end > realstartdate AND vt_end < realenddate     AND tt_end = varMaxDateTime;                if 1=1 then         begin      update t_sub_history      set tt_end = onesecond_systemdate      where id_sub = p_id_sub         AND tt_end = varMaxDateTime;       end;       else begin         update t_sub_history         set tt_end = onesecond_systemdate         where         id_sub = p_id_sub  AND       vt_end > realstartdate AND vt_end < realenddate      AND tt_end = varMaxDateTime;       end;       end if;     /* used to be realenddate */     /* step 7: create the new payment redirection record.  If the end date  */     /* is not max date, make sure the enddate is subtracted by one second */     insert into t_sub_history      (id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,tx_quoting_batch,vt_start,vt_end,tt_start,tt_end)     select      p_id_sub,p_id_sub_ext,p_id_acc,p_id_group,p_id_po,p_dt_crt,p_tx_quoting_batch,realstartdate,      case when realenddate = dbo.mtmaxdate() then realenddate else       realenddate end as realenddate,      p_systemdate,varMaxDateTime      from dual;          delete from t_sub where id_sub = p_id_sub;    insert into t_sub (id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,tx_quoting_batch,vt_start,vt_end)    select id_sub,id_sub_ext,id_acc,id_group,id_po,dt_crt,tx_quoting_batch,vt_start,vt_end    from t_sub_history  where id_sub = p_id_sub and tt_end = varMaxDateTime;     status := 1;     end;
/

ALTER PROCEDURE adjustsubdates COMPILE;

CREATE OR REPLACE PROCEDURE addsubscriptionbase (
   p_id_acc         IN       INTEGER,
   p_id_group       IN       INTEGER,
   p_id_po          IN       INTEGER,
   p_startdate      IN       DATE,
   p_enddate        IN       DATE,
   p_guid           IN       RAW,
   p_systemdate     IN       DATE,
   p_id_sub                  INTEGER,
   p_quoting_batchid  IN       VARCHAR2,
   p_status         OUT      INTEGER,
   p_datemodified   OUT      VARCHAR,
   p_allow_acc_po_curr_mismatch INTEGER default 0,
   p_allow_multiple_pi_sub_rcnrc INTEGER default 0
)
AS
   varmaxdatetime   DATE;
   realstartdate    DATE;
   realenddate      DATE;
   realguid         RAW (16);
   dummy            INT;
   tx_quoting_batchid RAW (16);
BEGIN
   varmaxdatetime := dbo.mtmaxdate ();
   p_status := 0;
   adjustsubdates (p_id_po,
                   p_startdate,
                   p_enddate,
                   realstartdate,
                   realenddate,
                   p_datemodified,
                   p_status
                  );

   IF p_status <> 1
   THEN
      RETURN;
   END IF; /* Check availability of the product offering */

   FOR i IN (SELECT (CASE
                        WHEN ta.n_begintype = 0 OR ta.n_endtype = 0
                           THEN -289472451
                        WHEN ta.n_begintype <> 0
                             AND ta.dt_start > p_systemdate
                           THEN -289472449
                        WHEN ta.n_endtype <> 0 AND ta.dt_end < p_systemdate
                           THEN -289472450
                        ELSE 1
                     END
                    ) tatus
               FROM t_po po INNER JOIN t_effectivedate ta ON po.id_avail =
                                                                ta.id_eff_date
              WHERE po.id_po = p_id_po)
   LOOP
      p_status := i.tatus;
   END LOOP;

   IF (p_status <> 1)
   THEN
      RETURN;
   END IF;

   IF (p_id_acc IS NOT NULL)
   THEN
      p_status :=
         dbo.checksubscriptionconflicts (p_id_acc,
                                         p_id_po,
                                         realstartdate,
                                         realenddate,
                                         -1,
                                         p_allow_acc_po_curr_mismatch,
                                         p_allow_multiple_pi_sub_rcnrc
                                        );

      IF (p_status <> 1)
      THEN
         RETURN;
      END IF; /* check if the po is BCR constrained.  If it is, make sure that the  usage cycles for all the payers during the subscription interval  matches the cycle type on the po. */

      SELECT COUNT (1)
        INTO dummy
        FROM t_payment_redirection pr INNER JOIN t_acc_usage_cycle auc ON pr.id_payer =
                                                                            auc.id_acc
             INNER JOIN t_usage_cycle uc ON uc.id_usage_cycle =
                                                            auc.id_usage_cycle
       WHERE pr.id_payee = p_id_acc
         AND pr.vt_start <= realenddate
         AND realstartdate <= pr.vt_end
         AND EXISTS (
                SELECT 1
                  FROM t_pl_map plm
                 WHERE plm.id_paramtable IS NULL
                   AND plm.id_po = p_id_po
                   AND (   EXISTS (
                              SELECT 1
                                FROM t_aggregate a
                               WHERE a.id_prop = plm.id_pi_instance
                                 AND a.id_cycle_type IS NOT NULL
                                 AND a.id_cycle_type <> uc.id_cycle_type)
                        OR EXISTS (
                              SELECT 1
                                FROM t_discount d
                               WHERE d.id_prop = plm.id_pi_instance
                                 AND d.id_cycle_type IS NOT NULL
                                 AND d.id_cycle_type <> uc.id_cycle_type)
                        OR EXISTS (
                              SELECT 1
                                FROM t_recur r
                               WHERE r.id_prop = plm.id_pi_instance
                                 AND r.tx_cycle_mode = 'BCR Constrained'
                                 AND r.id_cycle_type IS NOT NULL
                                 AND r.id_cycle_type <> uc.id_cycle_type)
                       ));

      IF (dummy > 0)
      THEN
         p_status := -289472464; /* MTPCUSER_CYCLE_CONFLICTS_WITH_ACCOUNT_CYCLE (0xEEBF0030) */
         RETURN;
      END IF;

      SELECT COUNT (1)
        INTO dummy
        FROM t_payment_redirection pr INNER JOIN t_acc_usage_cycle auc ON pr.id_payer =
                                                                            auc.id_acc
             INNER JOIN t_usage_cycle uc ON uc.id_usage_cycle =
                                                            auc.id_usage_cycle
       WHERE pr.id_payee = p_id_acc
         AND pr.vt_start <= realenddate
         AND EXISTS (
                SELECT 1
                  FROM t_pl_map plm
                 WHERE plm.id_paramtable IS NULL
                   AND plm.id_po = p_id_po
                   AND EXISTS (
                          SELECT 1
                            FROM t_recur rc
                           WHERE rc.id_prop = plm.id_pi_instance
                             AND rc.tx_cycle_mode = 'EBCR'
                             /*Weekly and biweekly can coexist*/
                             AND NOT (    (   (rc.id_cycle_type = 4)
                                           OR (rc.id_cycle_type = 5)
                                          )
                                      AND (   (uc.id_cycle_type = 4)
                                           OR (uc.id_cycle_type = 5)
                                          )
                                     )
                             /*Monthly, quarterly, semiannually, annually can coexist*/
                             AND NOT ((rc.id_cycle_type in (1,7,8,9))
                                      AND (uc.id_cycle_type in (1,7,8,9))
                                     )));

      IF (dummy > 0)
      THEN
         p_status := -289472444; /*MTPCUSER_EBCR_CYCLE_CONFLICTS_WITH_ACCOUNT_CYCLE (0xEEBF0044)*/
         RETURN;
      END IF;
   END IF;

   IF (p_guid IS NULL)
   THEN
      SELECT SYS_GUID ()
        INTO realguid
        FROM DUAL;
   ELSE
      realguid := p_guid;
   END IF;

   tx_quoting_batchid := p_quoting_batchid;
   createsubscriptionrecord (p_id_sub,
                             realguid,
                             p_id_acc,
                             p_id_group,
                             p_id_po,
                             p_systemdate,
                             tx_quoting_batchid,
                             realstartdate,
                             realenddate,
                             p_systemdate,
                             p_status
                            );
END;
/

CREATE OR REPLACE PROCEDURE addnewsub (
   p_id_acc                          INT,
   p_dt_start                        DATE,
   p_dt_end                          DATE,
   p_nextcycleafterstartdate         VARCHAR2,
   p_nextcycleafterenddate           VARCHAR2,
   p_id_po                           INTEGER,
   p_guid                            RAW,
   p_systemdate                      DATE,
   p_id_sub                          INTEGER,
   p_status                    OUT   INTEGER,
   p_datemodified              OUT   VARCHAR2,
   p_allow_acc_po_curr_mismatch      INTEGER default 0,
   p_allow_multiple_pi_sub_rcnrc     INTEGER default 0,
   p_quoting_batch_id                VARCHAR2 default null
)
AS
   real_begin_date   DATE;
   real_end_date     DATE;
   po_effstartdate   DATE;
   datemodified      VARCHAR (1);
BEGIN
   p_status := 0; /* compute usage cycle dates if necessary */

   IF p_nextcycleafterstartdate = 'Y'
   THEN
      real_begin_date := dbo.nextdateafterbillingcycle (p_id_acc, p_dt_start);
   ELSE
      real_begin_date := p_dt_start;
   END IF;

   IF p_nextcycleafterenddate = 'Y' AND p_dt_end IS NOT NULL
   THEN
      real_end_date := dbo.nextdateafterbillingcycle (p_id_acc, p_dt_end);
   ELSE
      real_end_date := p_dt_end;
   END IF;

   IF p_dt_end IS NULL
   THEN
      real_end_date := dbo.mtmaxdate ();
   END IF;

   addsubscriptionbase (p_id_acc,
                        NULL,
                        p_id_po,
                        real_begin_date,
                        real_end_date,
                        p_guid,
                        p_systemdate,
                        p_id_sub,
                        p_quoting_batch_id,
                        p_status,
                        p_datemodified,
                        p_allow_acc_po_curr_mismatch,
                        p_allow_multiple_pi_sub_rcnrc
                       );
END;
/

CREATE OR REPLACE PROCEDURE MeterCreditFromRecurWindow (currentDate DATE)
AS
    enabled       varchar2(10);
    v_newSubStart DATE;
    v_newSubEnd   DATE;
    v_curSubStart DATE;
    v_curSubEnd   DATE;
    /* Borders of updated Sub.End range will stand for internal v_subscriptionStart and v_subscriptionEnd to charge this range. */
    v_subscriptionStart        DATE;
    v_subscriptionEnd          DATE;
    v_rcAction                 VARCHAR2(20);
    v_isEndDateUpdated         CHAR(1 BYTE) := '0';
    /* Borders of updated Sub.Start range will stand for internal v_subscriptionStart2 and v_subscriptionEnd2 to charge this range. */
    v_subscriptionStart2       DATE;
    v_subscriptionEnd2         DATE;
    v_rcAction2                VARCHAR2(20);
    v_isStartDateUpdated       CHAR(1 BYTE) := '0';
    /* Values for full recharge of Arrears if End date update crosses EOP border */
    v_subscriptionStart3       DATE;
    v_subscriptionEnd3         DATE;
    v_rcAction3                VARCHAR2(20);
    
    
BEGIN
  SELECT value INTO enabled FROM t_db_values WHERE parameter = N'InstantRc';
  IF (enabled LIKE 'false') THEN RETURN; END IF;

  SELECT dbo.MTMinDate(), dbo.MTMinDate() INTO v_subscriptionStart, v_subscriptionEnd FROM dual;

  /* Assuming only 1 subscription can be changed at a time */
  BEGIN
    SELECT new_sub.vt_start, new_sub.vt_end, current_sub.vt_start, current_sub.vt_end
    INTO v_newSubStart,    v_newSubEnd,    v_curSubStart,        v_curSubEnd
    FROM TMP_NEWRW rw
        INNER JOIN t_sub_history new_sub ON new_sub.id_acc = rw.c__AccountID
            AND new_sub.id_sub = rw.c__SubscriptionID
            AND new_sub.tt_end = dbo.MTMaxDate()
        INNER JOIN t_sub_history current_sub ON current_sub.id_acc = rw.c__AccountID
            AND current_sub.id_sub = rw.c__SubscriptionID
            AND current_sub.tt_end = dbo.SubtractSecond(new_sub.tt_start)
    /* Work with RC only. Exclude UDRC. */
    WHERE rw.c_UnitValue IS NULL AND ROWNUM <= 1; /* Select only 1 PI*/
  EXCEPTION
    /* It is a new subscription or UDRC - nothing to recharge */
    WHEN NO_DATA_FOUND THEN
      RETURN;
  END;

  IF (v_newSubEnd <> v_curSubEnd) THEN
      /* TODO: Run only 1-st query if condition is true */
      v_isEndDateUpdated := '1';

      SELECT dbo.MTMinOfTwoDates(v_newSubEnd, v_curSubEnd),
             dbo.MTMaxOfTwoDates(v_newSubEnd, v_curSubEnd),
             CASE
                  WHEN v_newSubEnd > v_curSubEnd THEN
                       'Debit'
                  ELSE 'Credit'
             END
      INTO v_subscriptionStart, v_subscriptionEnd, v_rcAction FROM DUAL;
      /* Sub. start date has 23:59:59 time. We need next day and 00:00:00 time for the start date */
      SELECT dbo.AddSecond(v_subscriptionStart) INTO v_subscriptionStart FROM DUAL;

      IF (v_newSubEnd > v_curSubEnd) THEN
          v_subscriptionStart3 := v_curSubStart;
          v_subscriptionEnd3   := v_curSubEnd;
          v_rcAction3          := 'Credit';
      END IF;

      IF (v_newSubEnd < v_curSubEnd) THEN
          v_subscriptionStart3 := v_newSubStart;
          v_subscriptionEnd3   := v_newSubEnd;
          v_rcAction3          := 'Debit';
      END IF;
  END IF;

  IF (v_newSubStart <> v_curSubStart) THEN
      /* TODO: Run only 2-nd query if condition is true */
      v_isStartDateUpdated := '1';

      SELECT dbo.MTMinOfTwoDates(v_newSubStart, v_curSubStart),
             dbo.MTMaxOfTwoDates(v_newSubStart, v_curSubStart),
             CASE
                  WHEN v_newSubStart < v_curSubStart THEN
                       'InitialDebit'
                  ELSE 'InitialCredit'
             END
      INTO v_subscriptionStart2, v_subscriptionEnd2, v_rcAction2 FROM DUAL;
      /* Sub. end date has 00:00:00 time. We need previous day and 23:59:59 time for the end date */
      SELECT dbo.SubtractSecond(v_subscriptionEnd2) INTO v_subscriptionEnd2 FROM DUAL;
  END IF;

  INSERT INTO tmp_rc_1
  SELECT
         /* First, credit or debit the difference in the ending of the subscription.  If the new one is later, this will be a debit, otherwise a credit.
         * TODO: Remove this comment:"There's a weird exception when this is (a) an arrears charge, (b) the old subscription end was after the pci end date, and (c) the new sub end is inside the pci end date." */
         v_rcAction                                                                                 AS c_RCActionType,
         pci.dt_start                                                                               AS c_RCIntervalStart,
         pci.dt_end                                                                                 AS c_RCIntervalEnd,
         ui.dt_start                                                                                AS c_BillingIntervalStart,
         ui.dt_end                                                                                  AS c_BillingIntervalEnd,
         dbo.mtmaxoftwodates(pci.dt_start, v_subscriptionStart)                                     AS c_RCIntervalSubscriptionStart,
         dbo.mtminoftwodates(pci.dt_end, v_subscriptionEnd)                                         AS c_RCIntervalSubscriptionEnd,
         v_subscriptionStart                                                                        AS c_SubscriptionStart,
         v_subscriptionEnd                                                                          AS c_SubscriptionEnd,
         CASE WHEN rw.c_advance = 'Y' THEN '1' ELSE '0' END                                         AS c_Advance,
         CASE WHEN rcr.b_prorate_on_activate = 'Y' THEN '1' ELSE '0' END                            AS c_ProrateOnSubscription,
         CASE WHEN rcr.b_prorate_instantly = 'Y' THEN '1' ELSE '0' END                              AS c_ProrateInstantly, /* NOTE: c_ProrateInstantly - No longer used */
         rw.c_UnitValueStart                                                                        AS c_UnitValueStart,
         rw.c_UnitValueEnd                                                                          AS c_UnitValueEnd,
         rw.c_UnitValue                                                                             AS c_UnitValue,
         rcr.n_rating_type                                                                          AS c_RatingType,
         CASE WHEN rcr.b_prorate_on_deactivate = 'Y' THEN '1' ELSE '0' END                          AS c_ProrateOnUnsubscription,
         CASE WHEN rcr.b_fixed_proration_length = 'Y' THEN fxd.n_proration_length ELSE 0 END        AS c_ProrationCycleLength,
         rw.c__accountid                                                                            AS c__AccountID,
         rw.c__payingaccount                                                                        AS c__PayingAccount,
         rw.c__priceableiteminstanceid                                                              AS c__PriceableItemInstanceID,
         rw.c__priceableitemtemplateid                                                              AS c__PriceableItemTemplateID,
         rw.c__productofferingid                                                                    AS c__ProductOfferingID,
         dbo.MTMinOfTwoDates(pci.dt_end, v_subscriptionStart)                                       AS c_BilledRateDate,
         rw.c__subscriptionid                                                                       AS c__SubscriptionID,
         currentui.id_interval                                                                      AS c__IntervalID,
         SYS_GUID()                                                                                 AS id_source_sess,
         null                                                                                       AS c__QuoteBatchId,
         0                                                                                          AS IsArrearsRecalculation
  FROM   t_usage_interval ui
         INNER JOIN TMP_NEWRW rw
              ON  rw.c_payerstart          < ui.dt_end AND rw.c_payerend          > ui.dt_start /* next interval overlaps with payer */
              /* rw.c_cycleeffectivestart EQUAL TO v_subscriptionStart , rw.c_cycleeffectiveend EQUAL TO v_subscriptionEnd */
              AND rw.c_membershipstart     < ui.dt_end AND rw.c_membershipend     > ui.dt_start /* next interval overlaps with membership */
              AND v_subscriptionStart      < ui.dt_end AND v_subscriptionEnd      > ui.dt_start
              AND rw.c_unitvaluestart      < ui.dt_end AND rw.c_unitvalueend      > ui.dt_start /* next interval overlaps with UDRC */
         INNER JOIN t_recur rcr ON rw.c__priceableiteminstanceid = rcr.id_prop
         INNER JOIN t_acc_usage_cycle auc ON auc.id_acc = rw.c__payingaccount AND auc.id_usage_cycle = ui.id_usage_cycle
         INNER JOIN t_usage_cycle ccl
              ON  ccl.id_usage_cycle = CASE
                                            WHEN rcr.tx_cycle_mode = 'Fixed'           THEN rcr.id_usage_cycle
                                            WHEN rcr.tx_cycle_mode = 'BCR Constrained' THEN ui.id_usage_cycle
                                            WHEN rcr.tx_cycle_mode = 'EBCR'            THEN dbo.DeriveEBCRCycle(ui.id_usage_cycle, v_subscriptionStart, rcr.id_cycle_type)
                                            ELSE NULL
                                       END
         INNER JOIN t_usage_cycle_type fxd ON fxd.id_cycle_type = ccl.id_cycle_type
         INNER JOIN t_pc_interval pci ON pci.id_cycle = ccl.id_usage_cycle
              AND (
                      (rcr.b_advance = 'Y' AND pci.dt_start BETWEEN ui.dt_start AND ui.dt_end) /* If this is in advance, check if rc start falls in this interval */
                      OR pci.dt_end BETWEEN ui.dt_start AND ui.dt_end                          /* or check if the cycle end falls into this interval */
                      OR (pci.dt_start < ui.dt_start AND pci.dt_end > ui.dt_end)               /* or this interval could be in the middle of the cycle */
                  )
              AND pci.dt_end BETWEEN    rw.c_payerstart AND rw.c_payerend                         /* rc start goes to this payer */
              AND rw.c_unitvaluestart      < pci.dt_end AND rw.c_unitvalueend      > pci.dt_start /* rc overlaps with this UDRC */
              AND rw.c_membershipstart     < pci.dt_end AND rw.c_membershipend     > pci.dt_start /* rc overlaps with this membership */
              /* rw.c_cycleeffectivestart EQUAL TO v_subscriptionStart , rw.c_cycleeffectiveend EQUAL TO v_subscriptionEnd */
              AND v_subscriptionStart      < pci.dt_end AND v_subscriptionEnd      > pci.dt_start /* rc overlaps with this subscription */
         INNER JOIN t_usage_interval currentui ON currentDate BETWEEN currentui.dt_start AND currentui.dt_end
              AND currentui.id_usage_cycle = ui.id_usage_cycle
  WHERE
         ui.dt_start < currentDate
         AND v_isEndDateUpdated = '1'
         AND NOT (rw.c_advance = 'N' AND v_newSubEnd > ui.dt_end)
         /* Skip if this is an Arrears AND end date update crosses the EOP border (this case will be handled below) */
         AND NOT (rw.c_advance = 'N' AND v_subscriptionStart <= dbo.AddSecond(ui.dt_end) AND ui.dt_end < v_subscriptionEnd)

  UNION ALL

  SELECT
         /* Now, credit or debit the difference in the start of the subscription.  If the new one is earlier, this will be a debit, otherwise a credit*/
         v_rcAction2                                                                                AS c_RCActionType,
         pci.dt_start                                                                               AS c_RCIntervalStart,
         pci.dt_end                                                                                 AS c_RCIntervalEnd,
         ui.dt_start                                                                                AS c_BillingIntervalStart,
         ui.dt_end                                                                                  AS c_BillingIntervalEnd,
         dbo.mtmaxoftwodates(pci.dt_start, v_subscriptionStart2)                                    AS c_RCIntervalSubscriptionStart,
         /* If new Subscription Start somewhere in future, after EOP - always use End of RC cycle */
         CASE
              WHEN ui.dt_end <= v_subscriptionEnd2 THEN pci.dt_end
              ELSE dbo.mtminoftwodates(pci.dt_end, v_subscriptionEnd2)
         END                                                                                        AS c_RCIntervalSubscriptionEnd,
         v_subscriptionStart2                                                                       AS c_SubscriptionStart,
         v_subscriptionEnd2                                                                         AS c_SubscriptionEnd,
         CASE WHEN rw.c_advance = 'Y' THEN '1' ELSE '0' END                                         AS c_Advance,
         CASE WHEN rcr.b_prorate_on_activate = 'Y' THEN '1' ELSE '0' END                            AS c_ProrateOnSubscription,
         CASE WHEN rcr.b_prorate_instantly = 'Y' THEN '1' ELSE '0' END                              AS c_ProrateInstantly, /* NOTE: c_ProrateInstantly - No longer used */
         rw.c_UnitValueStart                                                                        AS c_UnitValueStart,
         rw.c_UnitValueEnd                                                                          AS c_UnitValueEnd,
         rw.c_UnitValue                                                                             AS c_UnitValue,
         rcr.n_rating_type                                                                          AS c_RatingType,
         CASE WHEN rcr.b_prorate_on_deactivate = 'Y' THEN '1' ELSE '0' END                          AS c_ProrateOnUnsubscription,
         CASE WHEN rcr.b_fixed_proration_length = 'Y' THEN fxd.n_proration_length ELSE 0 END        AS c_ProrationCycleLength,
         rw.c__accountid                                                                            AS c__AccountID,
         rw.c__payingaccount                                                                        AS c__PayingAccount,
         rw.c__priceableiteminstanceid                                                              AS c__PriceableItemInstanceID,
         rw.c__priceableitemtemplateid                                                              AS c__PriceableItemTemplateID,
         rw.c__productofferingid                                                                    AS c__ProductOfferingID,
         dbo.MTMinOfTwoDates(pci.dt_end, v_subscriptionStart2)                                      AS c_BilledRateDate,
         rw.c__subscriptionid                                                                       AS c__SubscriptionID,
         currentui.id_interval                                                                      AS c__IntervalID,
         SYS_GUID()                                                                                 AS id_source_sess,
         null                                                                                       AS c__QuoteBatchId,
         0                                                                                          AS IsArrearsRecalculation
  FROM   t_usage_interval ui
         INNER JOIN TMP_NEWRW rw
              ON  rw.c_payerstart          < ui.dt_end AND rw.c_payerend          > ui.dt_start /* next interval overlaps with payer */
              /* rw.c_cycleeffectivestart EQUAL TO v_subscriptionStart , rw.c_cycleeffectiveend EQUAL TO v_subscriptionEnd */
              AND rw.c_membershipstart     < ui.dt_end AND rw.c_membershipend     > ui.dt_start /* next interval overlaps with membership */
              AND v_subscriptionStart2     < ui.dt_end AND v_subscriptionEnd2     > ui.dt_start
              AND rw.c_unitvaluestart      < ui.dt_end AND rw.c_unitvalueend      > ui.dt_start /* next interval overlaps with UDRC */
         INNER JOIN t_recur rcr ON rw.c__priceableiteminstanceid = rcr.id_prop
         INNER JOIN t_acc_usage_cycle auc ON auc.id_acc = rw.c__payingaccount AND auc.id_usage_cycle = ui.id_usage_cycle
         INNER JOIN t_usage_cycle ccl
              ON  ccl.id_usage_cycle = CASE
                                            WHEN rcr.tx_cycle_mode = 'Fixed'           THEN rcr.id_usage_cycle
                                            WHEN rcr.tx_cycle_mode = 'BCR Constrained' THEN ui.id_usage_cycle
                                            WHEN rcr.tx_cycle_mode = 'EBCR'            THEN dbo.DeriveEBCRCycle(ui.id_usage_cycle, v_subscriptionStart2, rcr.id_cycle_type)
                                            ELSE NULL
                                       END
         INNER JOIN t_usage_cycle_type fxd ON fxd.id_cycle_type = ccl.id_cycle_type
         INNER JOIN t_pc_interval pci ON pci.id_cycle = ccl.id_usage_cycle
              AND (
                      (rcr.b_advance = 'Y' AND pci.dt_start BETWEEN ui.dt_start AND ui.dt_end) /* If this is in advance, check if rc start falls in this interval */
                      OR pci.dt_end BETWEEN ui.dt_start AND ui.dt_end                          /* or check if the cycle end falls into this interval */
                      OR (pci.dt_start < ui.dt_start AND pci.dt_end > ui.dt_end)               /* or this interval could be in the middle of the cycle */
                  )
              AND pci.dt_end BETWEEN    rw.c_payerstart AND rw.c_payerend                         /* rc start goes to this payer */
              AND rw.c_unitvaluestart      < pci.dt_end AND rw.c_unitvalueend      > pci.dt_start /* rc overlaps with this UDRC */
              AND rw.c_membershipstart     < pci.dt_end AND rw.c_membershipend     > pci.dt_start /* rc overlaps with this membership */
              /* rw.c_cycleeffectivestart EQUAL TO v_subscriptionStart , rw.c_cycleeffectiveend EQUAL TO v_subscriptionEnd */
              AND v_subscriptionStart2     < pci.dt_end AND v_subscriptionEnd2     > pci.dt_start /* rc overlaps with this subscription */
         INNER JOIN t_usage_interval currentui ON currentDate BETWEEN currentui.dt_start AND currentui.dt_end
              AND currentui.id_usage_cycle = ui.id_usage_cycle
  WHERE
         ui.dt_start < currentDate
         AND v_isStartDateUpdated = '1'
         AND NOT (rw.c_advance = 'N' AND v_newSubEnd > ui.dt_end)
         /* Skip if this is an Arrears AND end date update crosses the EOP border (this case will be handled below) */
         AND NOT (rw.c_advance = 'N' AND v_subscriptionStart <= dbo.AddSecond(ui.dt_end) AND ui.dt_end < v_subscriptionEnd)

  UNION ALL

  SELECT
         /* Handle the case if this is an Arrears AND end date update crosses the EOP border */
         v_rcAction3                                                                                AS c_RCActionType,
         pci.dt_start                                                                               AS c_RCIntervalStart,
         pci.dt_end                                                                                 AS c_RCIntervalEnd,
         ui.dt_start                                                                                AS c_BillingIntervalStart,
         ui.dt_end                                                                                  AS c_BillingIntervalEnd,
         dbo.mtmaxoftwodates(pci.dt_start, v_subscriptionStart3)                                    AS c_RCIntervalSubscriptionStart,
         dbo.mtminoftwodates(pci.dt_end, v_subscriptionEnd3)                                        AS c_RCIntervalSubscriptionEnd,
         v_subscriptionStart3                                                                       AS c_SubscriptionStart,
         v_subscriptionEnd3                                                                         AS c_SubscriptionEnd,
         CASE WHEN rw.c_advance = 'Y' THEN '1' ELSE '0' END                                         AS c_Advance,
         CASE WHEN rcr.b_prorate_on_activate = 'Y' THEN '1' ELSE '0' END                            AS c_ProrateOnSubscription,
         CASE WHEN rcr.b_prorate_instantly = 'Y' THEN '1' ELSE '0' END                              AS c_ProrateInstantly, /* NOTE: c_ProrateInstantly - No longer used */
         rw.c_UnitValueStart                                                                        AS c_UnitValueStart,
         rw.c_UnitValueEnd                                                                          AS c_UnitValueEnd,
         rw.c_UnitValue                                                                             AS c_UnitValue,
         rcr.n_rating_type                                                                          AS c_RatingType,
         CASE WHEN rcr.b_prorate_on_deactivate = 'Y' THEN '1' ELSE '0' END                          AS c_ProrateOnUnsubscription,
         CASE WHEN rcr.b_fixed_proration_length = 'Y' THEN fxd.n_proration_length ELSE 0 END        AS c_ProrationCycleLength,
         rw.c__accountid                                                                            AS c__AccountID,
         rw.c__payingaccount                                                                        AS c__PayingAccount,
         rw.c__priceableiteminstanceid                                                              AS c__PriceableItemInstanceID,
         rw.c__priceableitemtemplateid                                                              AS c__PriceableItemTemplateID,
         rw.c__productofferingid                                                                    AS c__ProductOfferingID,
         dbo.MTMinOfTwoDates(pci.dt_end, v_subscriptionStart3)                                      AS c_BilledRateDate,
         rw.c__subscriptionid                                                                       AS c__SubscriptionID,
         currentui.id_interval                                                                      AS c__IntervalID,
         SYS_GUID()                                                                                 AS id_source_sess,
         null                                                                                       AS c__QuoteBatchId,
         1                                                                                          AS IsArrearsRecalculation
  FROM   t_usage_interval ui
         INNER JOIN TMP_NEWRW rw
              ON  rw.c_payerstart          < ui.dt_end AND rw.c_payerend          > ui.dt_start /* next interval overlaps with payer */
              /* rw.c_cycleeffectivestart EQUAL TO v_subscriptionStart , rw.c_cycleeffectiveend EQUAL TO v_subscriptionEnd */
              AND rw.c_membershipstart     < ui.dt_end AND rw.c_membershipend     > ui.dt_start /* next interval overlaps with membership */
              AND v_subscriptionStart3     < ui.dt_end AND v_subscriptionEnd3     > ui.dt_start
              AND rw.c_unitvaluestart      < ui.dt_end AND rw.c_unitvalueend      > ui.dt_start /* next interval overlaps with UDRC */
         INNER JOIN t_recur rcr ON rw.c__priceableiteminstanceid = rcr.id_prop
         INNER JOIN t_acc_usage_cycle auc ON auc.id_acc = rw.c__payingaccount AND auc.id_usage_cycle = ui.id_usage_cycle
         INNER JOIN t_usage_cycle ccl
              ON  ccl.id_usage_cycle = CASE
                                            WHEN rcr.tx_cycle_mode = 'Fixed'           THEN rcr.id_usage_cycle
                                            WHEN rcr.tx_cycle_mode = 'BCR Constrained' THEN ui.id_usage_cycle
                                            WHEN rcr.tx_cycle_mode = 'EBCR'            THEN dbo.DeriveEBCRCycle(ui.id_usage_cycle, v_subscriptionStart3, rcr.id_cycle_type)
                                            ELSE NULL
                                       END
         INNER JOIN t_usage_cycle_type fxd ON fxd.id_cycle_type = ccl.id_cycle_type
         INNER JOIN t_pc_interval pci ON pci.id_cycle = ccl.id_usage_cycle
              AND (
                      (rcr.b_advance = 'Y' AND pci.dt_start BETWEEN ui.dt_start AND ui.dt_end) /* If this is in advance, check if rc start falls in this interval */
                      OR pci.dt_end BETWEEN ui.dt_start AND ui.dt_end                          /* or check if the cycle end falls into this interval */
                      OR (pci.dt_start < ui.dt_start AND pci.dt_end > ui.dt_end)               /* or this interval could be in the middle of the cycle */
                  )
              AND pci.dt_end BETWEEN    rw.c_payerstart AND rw.c_payerend                         /* rc start goes to this payer */
              AND rw.c_unitvaluestart      < pci.dt_end AND rw.c_unitvalueend      > pci.dt_start /* rc overlaps with this UDRC */
              AND rw.c_membershipstart     < pci.dt_end AND rw.c_membershipend     > pci.dt_start /* rc overlaps with this membership */
              /* rw.c_cycleeffectivestart EQUAL TO v_subscriptionStart , rw.c_cycleeffectiveend EQUAL TO v_subscriptionEnd */
              AND v_subscriptionStart3      < pci.dt_end AND v_subscriptionEnd3      > pci.dt_start /* rc overlaps with this subscription */
         INNER JOIN t_usage_interval currentui ON currentDate BETWEEN currentui.dt_start AND currentui.dt_end
              AND currentui.id_usage_cycle = ui.id_usage_cycle
  WHERE
         ui.dt_start < currentDate
         /* Handle the case if this is an Arrears AND end date update crosses the EOP border */
         AND rw.c_advance = 'N' AND v_subscriptionStart <= dbo.AddSecond(ui.dt_end) AND ui.dt_end < v_subscriptionEnd;

  /* Remove extra charges for RCs with No Proration (CORE-6789) */
  IF (v_isEndDateUpdated = 1) THEN
    /* PIs, that starts outside of End Date Update range, should not be handled here */
    DELETE FROM tmp_rc_1 WHERE c_ProrateOnUnsubscription = '0'
        AND c_RCIntervalStart < v_subscriptionStart
        AND IsArrearsRecalculation = 0;

    /* Turn On "Prorate On Subscription" if this is the 1-st RC Cycle */
    UPDATE tmp_rc_1
    SET c_ProrateOnSubscription = '1'
    WHERE c_ProrateOnUnsubscription = '1' AND v_newSubStart BETWEEN c_RCIntervalStart AND c_RCIntervalEnd;
  END IF;
  IF (v_isStartDateUpdated = 1) THEN
    /* PIs, that ends outside of Start Date Update range, should not be handled here */
    DELETE FROM tmp_rc_1 WHERE c_ProrateOnSubscription = '0' AND c_RCIntervalEnd > v_subscriptionEnd2
      AND v_subscriptionEnd2 < c_BillingIntervalEnd
      AND IsArrearsRecalculation = 0; /* If start date was updated To or From "after EOP date" all PIs should be charged. Don't delete anything. */
  END IF;

  INSERT INTO tmp_backoutArrearsUsages
  SELECT c__SubscriptionID, c__PriceableItemInstanceID, c__PriceableItemTemplateID
  FROM tmp_rc_1
  WHERE c_Advance = 0 AND c_BillingIntervalEnd BETWEEN v_curSubEnd AND v_newSubEnd;

  INSERT INTO tmp_rc
  SELECT c_RCActionType,
         c_RCIntervalStart,
         c_RCIntervalEnd,
         c_BillingIntervalStart,
         c_BillingIntervalEnd,
         c_RCIntervalSubscriptionStart,
         c_RCIntervalSubscriptionEnd,
         c_SubscriptionStart,
         c_SubscriptionEnd,
         c_Advance,
         c_ProrateOnSubscription,
         c_ProrateInstantly,
         c_UnitValueStart,
         c_UnitValueEnd,
         c_UnitValue,
         c_RatingType,
         c_ProrateOnUnsubscription,
         c_ProrationCycleLength,
         c__AccountID,
         c__PayingAccount,
         c__PriceableItemInstanceID,
         c__PriceableItemTemplateID,
         c__ProductOfferingID,
         c_BilledRateDate,
         c__SubscriptionID,
         c__IntervalID,
         id_source_sess,
         c__QuoteBatchId
  FROM tmp_rc_1;

  insertChargesIntoSvcTables('%Credit','%Debit');

  UPDATE tmp_newrw rw
  SET c_BilledThroughDate =
             CASE
                  WHEN rw.c__SubscriptionID IN (SELECT c__SubscriptionID FROM tmp_backoutArrearsUsages)
                    AND rw.c__PriceableItemInstanceID IN (SELECT c__PriceableItemInstanceID FROM tmp_backoutArrearsUsages)
                      THEN dbo.mtmindate()
                  ELSE currentDate
             END
  WHERE rw.c__IsAllowGenChargeByTrigger = 1;

  /*We can get an no data exception if there are no previous subscriptions; just return in this case.*/
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN;
end MeterCreditFromRecurWindow;
/

CREATE OR REPLACE PROCEDURE updatesub (
   p_id_sub                          INT,
   p_dt_start                        DATE,
   p_dt_end                          DATE,
   p_nextcycleafterstartdate         VARCHAR2,
   p_nextcycleafterenddate           VARCHAR2,
   p_id_po                           INT,
   p_id_acc                          INT,
   p_systemdate                      DATE,
   p_status                    OUT   INT,
   p_datemodified              OUT   VARCHAR2,
   p_allow_acc_po_curr_mismatch int := 0,
   p_allow_multiple_pi_sub_rcnrc int :=0
)
AS
   real_begin_date        DATE;
   real_end_date          DATE;
   temp_id_acc            INT;
   temp_guid              RAW (16);
   varmaxdatetime         DATE;
   varsystemgmtdatetime   DATE;
   id_group               INTEGER;
   cycle_type             INTEGER;
   po_cycle               INTEGER;
   dummy                  INT;
BEGIN
   varmaxdatetime := dbo.mtmaxdate ();
   /* step 1: compute usage cycle dates if necessary */
   p_status := 0;

   BEGIN
      SELECT id_sub_ext
        INTO temp_guid
        FROM t_sub
       WHERE id_sub = p_id_sub;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         NULL;
   END;

   IF p_id_acc IS NOT NULL
   THEN
      IF (p_nextcycleafterstartdate = 'Y')
      THEN
         real_begin_date :=
                         dbo.nextdateafterbillingcycle (p_id_acc, p_dt_start);
      ELSE
         real_begin_date := p_dt_start;
      END IF;

      IF (p_nextcycleafterenddate = 'Y')
      THEN
         /* CR 5785: make sure the end date of the subscription if using billing cycle */
         /* relative is at the end of the current billing cycle */
         real_end_date :=
            dbo.subtractsecond (dbo.nextdateafterbillingcycle (p_id_acc,
                                                               p_dt_end
                                                              )
                               );
      ELSE
         real_end_date := p_dt_end;
      END IF;

      /* step 2: if the begin date is after the end date, make the begin date match the end date */
      IF (real_begin_date > real_end_date)
      THEN
         real_begin_date := real_end_date;
      END IF;

      p_status :=
         dbo.checksubscriptionconflicts (p_id_acc,
                                         p_id_po,
                                         real_begin_date,
                                         real_end_date,
                                         p_id_sub,
                                         p_allow_acc_po_curr_mismatch,
                                         p_allow_multiple_pi_sub_rcnrc
                                        );

      IF (p_status <> 1)
      THEN
         RETURN;
      END IF;

      /* check if the po is BCR constrained.  If it is, make sure that the
       usage cycles for all the payers during the subscription interval
       matches the cycle type on the po. */
      SELECT COUNT (1)
        INTO dummy
        FROM t_payment_redirection pr INNER JOIN t_acc_usage_cycle auc
             ON pr.id_payer = auc.id_acc
             INNER JOIN t_usage_cycle uc
             ON uc.id_usage_cycle = auc.id_usage_cycle
       WHERE pr.id_payee = p_id_acc
         AND pr.vt_start <= real_end_date
         AND real_begin_date <= pr.vt_end
         AND EXISTS (
                SELECT 1
                  FROM t_pl_map plm
                 WHERE plm.id_paramtable IS NULL
                   AND plm.id_po = p_id_po
                   AND (   EXISTS (
                              SELECT 1
                                FROM t_aggregate a
                               WHERE a.id_prop = plm.id_pi_instance
                                 AND a.id_cycle_type IS NOT NULL
                                 AND a.id_cycle_type <> uc.id_cycle_type)
                        OR EXISTS (
                              SELECT 1
                                FROM t_discount d
                               WHERE d.id_prop = plm.id_pi_instance
                                 AND d.id_cycle_type IS NOT NULL
                                 AND d.id_cycle_type <> uc.id_cycle_type)
                        OR EXISTS (
                              SELECT 1
                                FROM t_recur r
                               WHERE r.id_prop = plm.id_pi_instance
                                 AND r.tx_cycle_mode = 'BCR Constrained'
                                 AND r.id_cycle_type IS NOT NULL
                                 AND r.id_cycle_type <> uc.id_cycle_type)
                       ));

      IF (dummy > 0)
      THEN
         p_status := -289472464;
         /* MTPCUSER_CYCLE_CONFLICTS_WITH_ACCOUNT_CYCLE (0xEEBF0030) */
         RETURN;
      END IF;

      SELECT COUNT (1)
        INTO dummy
        FROM t_payment_redirection pr INNER JOIN t_acc_usage_cycle auc
             ON pr.id_payer = auc.id_acc
             INNER JOIN t_usage_cycle uc
             ON uc.id_usage_cycle = auc.id_usage_cycle
       WHERE pr.id_payee = p_id_acc
         AND pr.vt_start <= real_end_date
         AND real_begin_date <= pr.vt_end
         AND EXISTS (
                SELECT 1
                  FROM t_pl_map plm
                 WHERE plm.id_paramtable IS NULL
                   AND plm.id_po = p_id_po
                   AND EXISTS (
                          SELECT 1
                            FROM t_recur rc
                           WHERE rc.id_prop = plm.id_pi_instance
                             AND rc.tx_cycle_mode = 'EBCR'
                             AND NOT (    (   (rc.id_cycle_type = 4)
                                           OR (rc.id_cycle_type = 5)
                                          )
                                      AND (   (uc.id_cycle_type = 4)
                                           OR (uc.id_cycle_type = 5)
                                          )
                                     )
                             AND NOT (    (   (rc.id_cycle_type = 1)
                                           OR (rc.id_cycle_type = 7)
                                           OR (rc.id_cycle_type = 8)
                                           OR (rc.id_cycle_type = 9)
                                          )
                                      AND (   (uc.id_cycle_type = 1)
                                           OR (uc.id_cycle_type = 7)
                                           OR (uc.id_cycle_type = 8)
                                           OR (uc.id_cycle_type = 9)
                                          )
                                     )));

      IF (dummy > 0)
      THEN
         p_status := -289472444;
         /* MTPCUSER_EBCR_CYCLE_CONFLICTS_WITH_ACCOUNT_CYCLE (0xEEBF0044) */
         RETURN;
      END IF;
   ELSE
      FOR i IN (SELECT p_dt_start, p_dt_end, id_group
                  FROM t_sub
                 WHERE id_sub = p_id_sub)
      LOOP
         real_begin_date := i.p_dt_start;
         real_end_date := i.p_dt_end;
         id_group := i.id_group;
      END LOOP;
   END IF;

   /* verify that the start and end dates are inside the product offering effective */
   /* date */
   adjustsubdates (p_id_po,
                   real_begin_date,
                   real_end_date,
                   real_begin_date,
                   real_end_date,
                   p_datemodified,
                   p_status
                  );

   IF p_status <> 1
   THEN
      RETURN;
   END IF;

   createsubscriptionrecord (p_id_sub,
                             temp_guid,
                             p_id_acc,
                             id_group,
                             p_id_po,
                             p_systemdate,
                             null,
                             real_begin_date,
                             real_end_date,
                             p_systemdate,
                             p_status
                            );
   RETURN;
END;
/

CREATE OR REPLACE PROCEDURE MeterInitialFromRecurWindow (currentDate date) AS
  enabled varchar2(10);
BEGIN
  SELECT value INTO enabled FROM t_db_values WHERE parameter = N'InstantRc';
  IF (enabled = 'false') THEN RETURN; END IF;

  INSERT INTO tmp_rc
  SELECT
    'Initial'                                                                           AS c_RCActionType,
    pci.dt_start                                                                        AS c_RCIntervalStart,
    pci.dt_end                                                                          AS c_RCIntervalEnd,
    ui.dt_start                                                                         AS c_BillingIntervalStart,
    ui.dt_end                                                                           AS c_BillingIntervalEnd,
    dbo.mtmaxoftwodates(pci.dt_start, rw.c_SubscriptionStart)                           AS c_RCIntervalSubscriptionStart,
    dbo.mtminoftwodates(pci.dt_end, rw.c_SubscriptionEnd)                               AS c_RCIntervalSubscriptionEnd,
    rw.c_SubscriptionStart                                                              AS c_SubscriptionStart,
    rw.c_SubscriptionEnd                                                                AS c_SubscriptionEnd,
    CASE WHEN rw.c_advance  ='Y' THEN '1' ELSE '0' END                                  AS c_Advance,
    CASE WHEN rcr.b_prorate_on_activate ='Y' THEN '1' ELSE '0' END                      AS c_ProrateOnSubscription,
    CASE WHEN rcr.b_prorate_instantly  ='Y' THEN '1' ELSE '0' END                       AS c_ProrateInstantly,
    rw.c_UnitValueStart                                                                 AS c_UnitValueStart,
    rw.c_UnitValueEnd                                                                   AS c_UnitValueEnd,
    rw.c_UnitValue                                                                      AS c_UnitValue,
    rcr.n_rating_type                                                                   AS c_RatingType,
    CASE WHEN rcr.b_prorate_on_deactivate  ='Y' THEN '1' ELSE '0' END                   AS c_ProrateOnUnsubscription,
    CASE WHEN rcr.b_fixed_proration_length = 'Y' THEN fxd.n_proration_length ELSE 0 END AS c_ProrationCycleLength,
    rw.c__accountid                                                                     AS c__AccountID,
    rw.c__payingaccount                                                                 AS c__PayingAccount,
    rw.c__priceableiteminstanceid                                                       AS c__PriceableItemInstanceID,
    rw.c__priceableitemtemplateid                                                       AS c__PriceableItemTemplateID,
    rw.c__productofferingid                                                             AS c__ProductOfferingID,
    dbo.MTMinOfTwoDates(pci.dt_end,rw.c_SubscriptionEnd)                                AS c_BilledRateDate,
    rw.c__subscriptionid                                                                AS c__SubscriptionID,
    currentui.id_interval                                                               AS c__IntervalID,
    SYS_GUID()                                                                          AS id_source_sess,
    rw.c__QuoteBatchId                                                                  AS c__QuoteBatchId
  FROM t_usage_interval ui
    INNER JOIN tmp_newrw rw
      ON  rw.c_payerstart           < ui.dt_end AND rw.c_payerend          > ui.dt_start /* next interval overlaps with payer */
      AND rw.c_cycleeffectivestart  < ui.dt_end AND rw.c_cycleeffectiveend > ui.dt_start /* next interval overlaps with cycle */
      AND rw.c_membershipstart      < ui.dt_end AND rw.c_membershipend     > ui.dt_start /* next interval overlaps with membership */
      AND rw.c_SubscriptionStart    < ui.dt_end AND rw.c_SubscriptionEnd   > ui.dt_start
      AND rw.c_unitvaluestart       < ui.dt_end AND rw.c_unitvalueend      > ui.dt_start /* next interval overlaps with UDRC */
    INNER JOIN t_recur rcr ON rw.c__priceableiteminstanceid = rcr.id_prop
    INNER JOIN t_acc_usage_cycle auc ON auc.id_acc = rw.c__payingaccount AND auc.id_usage_cycle = ui.id_usage_cycle
    INNER JOIN t_usage_cycle ccl
      ON  ccl.id_usage_cycle = CASE
                            WHEN rcr.tx_cycle_mode = 'Fixed' THEN rcr.id_usage_cycle
                            WHEN rcr.tx_cycle_mode = 'BCR Constrained' THEN ui.id_usage_cycle
                            WHEN rcr.tx_cycle_mode = 'EBCR' THEN dbo.DeriveEBCRCycle(ui.id_usage_cycle, rw.c_SubscriptionStart, rcr.id_cycle_type)
                            ELSE NULL
                        END
    INNER JOIN t_usage_cycle_type fxd ON fxd.id_cycle_type = ccl.id_cycle_type
    INNER JOIN t_pc_interval pci ON pci.id_cycle = ccl.id_usage_cycle
      AND (
            (rcr.b_advance = 'Y' AND pci.dt_start BETWEEN ui.dt_start AND ui.dt_end)      /* If this is in advance, check if rc start falls in this interval */
            OR pci.dt_end BETWEEN ui.dt_start AND ui.dt_end                               /* or check if the cycle end falls into this interval */
            OR (pci.dt_start < ui.dt_start and pci.dt_end > ui.dt_end)                    /* or this interval could be in the middle of the cycle */
          )
      AND pci.dt_end BETWEEN rw.c_payerstart AND rw.c_payerend                            /* rc start goes to this payer */
      AND rw.c_unitvaluestart      < pci.dt_end AND rw.c_unitvalueend      > pci.dt_start /* rc overlaps with this UDRC */
      AND rw.c_membershipstart     < pci.dt_end AND rw.c_membershipend     > pci.dt_start /* rc overlaps with this membership */
      AND rw.c_cycleeffectivestart < pci.dt_end AND rw.c_cycleeffectiveend > pci.dt_start /* rc overlaps with this cycle */
      AND rw.c_SubscriptionStart   < pci.dt_end AND rw.c_subscriptionend   > pci.dt_start /* rc overlaps with this subscription */
    INNER JOIN t_usage_interval currentui ON currentDate BETWEEN currentui.dt_start AND currentui.dt_end
      AND currentui.id_usage_cycle = ui.id_usage_cycle
  WHERE
    /*Only meter new subscriptions as initial -- so select only items that have at most one entry in t_sub_history*/
    NOT EXISTS (SELECT 1 FROM t_sub_history tsh WHERE tsh.id_sub = rw.c__SubscriptionID AND tsh.id_acc = rw.c__AccountID AND tsh.tt_end < currentDate)
    /*Also no old unit values*/
    AND NOT EXISTS (SELECT 1 FROM t_recur_value trv WHERE trv.id_sub = rw.c__SubscriptionID AND trv.tt_end < dbo.MTMaxDate())
    /* Don't meter in the current interval for initial*/
    AND ui.dt_start < currentDate
    AND rw.c__IsAllowGenChargeByTrigger = 1;

  insertChargesIntoSvcTables('Initial','Initial');

	UPDATE  tmp_newrw rw
	SET     c_BilledThroughDate = currentDate
	WHERE   rw.c__IsAllowGenChargeByTrigger = 1;

END MeterInitialFromRecurWindow;
/

CREATE OR REPLACE PROCEDURE bulksubscriptionchange (
				id_old_po          INT,
				id_new_po          INT,
				temp_date          DATE,
				nextbillingcycle   VARCHAR2,
				p_systemdate       DATE,
				p_new_sub					 INT,
				p_status out			 INT
				)
				AS
				CURSOR cursorvar IS
				SELECT id_acc, t_sub.vt_start, t_sub.vt_end, id_sub
        FROM t_sub
				WHERE t_sub.id_po = id_old_po AND t_sub.vt_end >= temp_date
				/* only deal with individual subscriptions */
				AND id_group is NULL;
				temp_id_acc            INT;
				start_date               DATE;
				end_date               DATE;
				temp_id_sub            INT;
				varmaxdatetime         DATE;
        subext                 raw(16);
        realenddate            date;
	 	    v_datemodified       VARCHAR2(1);
	 	    new_sub									int;
  tmp int;
  a int;

				BEGIN
        p_status := 1;
				new_sub := p_new_sub;
					varmaxdatetime := dbo.mtmaxdate ();
					OPEN cursorvar;
					LOOP
					FETCH cursorvar INTO temp_id_acc, start_date, end_date, temp_id_sub;
					EXIT WHEN cursorvar%NOTFOUND;


  select case when nextbillingcycle = 'Y' AND temp_date is not null then
		dbo.subtractsecond(dbo.NextDateAfterBillingCycle(temp_id_acc,temp_date))
	else
		dbo.subtractsecond(temp_date)
	end	into realenddate from dual;

  /* it is possible that temp_date <= end_date <= realenddate. */
  /* for this case treat as though subscription doesn't match at all */
  if end_date > realenddate then
	  /* either delete or update the old subscription */
    if realenddate >= start_date then
	    UPDATE t_sub SET vt_end = realenddate WHERE
	    id_sub = temp_id_sub;

	    /* update the old subscription tt_end */
	    UPDATE t_sub_history
      SET tt_end = dbo.subtractsecond (p_systemdate)
	    WHERE id_sub = temp_id_sub
	    AND tt_end =varmaxdatetime;

	    /* insert the new record*/
	    INSERT INTO t_sub_history
      SELECT id_sub, id_sub_ext, id_acc, id_po, dt_crt, id_group,
             vt_start, realenddate, p_systemdate, varmaxdatetime, TX_QUOTING_BATCH
      FROM t_sub_history
       WHERE id_sub = temp_id_sub
         AND tt_end = dbo.subtractsecond (p_systemdate);
    else
      DELETE FROM t_sub WHERE id_sub = temp_id_sub;

	    UPDATE t_sub_history
      SET tt_end = dbo.subtractsecond (p_systemdate)
	    WHERE id_sub = temp_id_sub
	    AND tt_end =varmaxdatetime;
    end if;

  tmp := new_sub;
  -- set @tmp = @tmp + (@tmp * 4096);
  tmp := tmp +(tmp * 4096);
  -- set @tmp = @tmp AND 0x7fffffff;
  tmp := bitand(tmp, 2147483647);
  -- set @tmp = @tmp ^ (@tmp / 4194304);
  a := FLOOR(tmp / 4194304);
  tmp := (tmp + a) - BITAND(tmp, a) * 2;
  -- set @tmp = @tmp + (@tmp * 16);
  tmp := tmp + (tmp * 16);
  --    set @tmp = @tmp AND 0x7fffffff;
  tmp := bitand(tmp, 2147483647);
  -- set @tmp = @tmp ^ (@tmp / 512);
  a := FLOOR(tmp / 512);
  tmp := (tmp + a) - BITAND(tmp, a) * 2;
  -- set @tmp = @tmp + (@tmp * 1024);
  tmp := tmp + (tmp * 1024);
  -- set @tmp = @tmp AND 0x7fffffff;
  tmp := bitand(tmp, 2147483647);
  -- set @tmp = @tmp ^ (@tmp / 4);
  a := FLOOR(tmp / 4);
  tmp := (tmp + a) - BITAND(tmp, a) * 2;
  -- set @tmp = @tmp + (@tmp * 128);
  tmp := tmp + (tmp * 128);
  -- set @tmp = @tmp AND 0x7fffffff;
  tmp := bitand(tmp, 2147483647);
  -- set @tmp = @tmp ^ (@tmp / 4096);
  a := FLOOR(tmp / 4096);
  tmp := (tmp + a) - BITAND(tmp, a) * 2;

    addnewsub (temp_id_acc,temp_date,end_date,nextbillingcycle,/* next billing cycle after start date */
		  'N',id_new_po,SYS_GUID (),p_systemdate,tmp,p_status,v_datemodified);
    if p_status <> 1 then
      raise_application_error(-20001, 'Unexpected error creating a subscription: error ' || p_status);
    end if;
	  /* CR 12529 - increment the id */
	  new_sub := new_sub + 1;
  end if;
  END LOOP;
  CLOSE cursorvar;
END;
/

CREATE OR REPLACE PROCEDURE MeterPayerChangeFromRecWind (currentDate date)
AS
  enabled VARCHAR2(10);
  BEGIN
  SELECT value INTO enabled FROM t_db_values WHERE parameter = N'InstantRc';
  IF (enabled = 'false') THEN RETURN; END IF;
    
   INSERT INTO TMP_PAYER_CHANGES
  SELECT
    pci.dt_start                                                                        AS c_RCIntervalStart,
    pci.dt_end                                                                          AS c_RCIntervalEnd,
    ui.dt_start                                                                         AS c_BillingIntervalStart,
    ui.dt_end                                                                           AS c_BillingIntervalEnd,
    dbo.mtmaxoftwodates(pci.dt_start, rw.c_SubscriptionStart)                           AS c_RCIntervalSubscriptionStart,
    dbo.mtminoftwodates(pci.dt_end, rw.c_SubscriptionEnd)                               AS c_RCIntervalSubscriptionEnd,
    rw.c_SubscriptionStart                                                              AS c_SubscriptionStart,
    rw.c_SubscriptionEnd                                                                AS c_SubscriptionEnd,
    CASE WHEN rw.c_advance  ='Y' THEN '1' ELSE '0' END                                  AS c_Advance,
    CASE WHEN rcr.b_prorate_on_activate ='Y' THEN '1' ELSE '0' END                      AS c_ProrateOnSubscription,
    CASE WHEN rcr.b_prorate_instantly  ='Y' THEN '1' ELSE '0' END                       AS c_ProrateInstantly,
    rw.c_UnitValueStart                                                                 AS c_UnitValueStart,
    rw.c_UnitValueEnd                                                                   AS c_UnitValueEnd,
    rw.c_UnitValue                                                                      AS c_UnitValue,
    rcr.n_rating_type                                                                   AS c_RatingType,
    CASE WHEN rcr.b_prorate_on_deactivate  ='Y' THEN '1' ELSE '0' END                   AS c_ProrateOnUnsubscription,
    CASE WHEN rcr.b_fixed_proration_length = 'Y' THEN fxd.n_proration_length ELSE 0 END AS c_ProrationCycleLength,
    rw.c__accountid                                                                     AS c__AccountID,
    rw.c__payingaccount                                                                 AS c__PayingAccount,
    rw.c__priceableiteminstanceid                                                       AS c__PriceableItemInstanceID,
    rw.c__priceableitemtemplateid                                                       AS c__PriceableItemTemplateID,
    rw.c__productofferingid                                                             AS c__ProductOfferingID,
    dbo.MTMinOfTwoDates(pci.dt_end,rw.c_SubscriptionEnd)                                AS c_BilledRateDate,
    rw.c__subscriptionid                                                                AS c__SubscriptionID,
    currentui.id_interval                                                               AS c__IntervalID
  FROM t_usage_interval ui
    INNER JOIN tmp_newrw rw
      ON  rw.c_payerstart           < ui.dt_end AND rw.c_payerend          > ui.dt_start /* next interval overlaps with payer */
      AND rw.c_cycleeffectivestart  < ui.dt_end AND rw.c_cycleeffectiveend > ui.dt_start /* next interval overlaps with cycle */
           AND rw.c_membershipstart     < ui.dt_end AND rw.c_membershipend > ui.dt_start /* next interval overlaps with membership */
      AND rw.c_SubscriptionStart    < ui.dt_end AND rw.c_SubscriptionEnd   > ui.dt_start
      AND rw.c_unitvaluestart       < ui.dt_end AND rw.c_unitvalueend      > ui.dt_start /* next interval overlaps with UDRC */
      INNER JOIN t_recur rcr ON rw.c__priceableiteminstanceid = rcr.id_prop
    INNER JOIN t_acc_usage_cycle auc ON auc.id_acc = rw.c__payingaccount AND auc.id_usage_cycle = ui.id_usage_cycle
    INNER JOIN t_usage_cycle ccl
      ON  ccl.id_usage_cycle = CASE
	    WHEN rcr.tx_cycle_mode = 'Fixed' THEN rcr.id_usage_cycle
		WHEN rcr.tx_cycle_mode = 'BCR Constrained' THEN ui.id_usage_cycle
		WHEN rcr.tx_cycle_mode = 'EBCR' THEN dbo.DeriveEBCRCycle(ui.id_usage_cycle, rw.c_SubscriptionStart, rcr.id_cycle_type)
                            ELSE NULL
                        END
    INNER JOIN t_usage_cycle_type fxd ON fxd.id_cycle_type = ccl.id_cycle_type
      INNER JOIN t_pc_interval pci ON pci.id_cycle = ccl.id_usage_cycle
      AND (
            (rcr.b_advance = 'Y' AND pci.dt_start BETWEEN ui.dt_start AND ui.dt_end)      /* If this is in advance, check if rc start falls in this interval */
            OR pci.dt_end BETWEEN ui.dt_start AND ui.dt_end                               /* or check if the cycle end falls into this interval */
            OR (pci.dt_start < ui.dt_start and pci.dt_end > ui.dt_end)                    /* or this interval could be in the middle of the cycle */
          )
      AND pci.dt_end BETWEEN rw.c_payerstart AND rw.c_payerend                            /* rc start goes to this payer */
      AND rw.c_unitvaluestart      < pci.dt_end AND rw.c_unitvalueend      > pci.dt_start /* rc overlaps with this UDRC */
      AND rw.c_membershipstart     < pci.dt_end AND rw.c_membershipend     > pci.dt_start /* rc overlaps with this membership */
                                   AND rw.c_cycleeffectivestart < pci.dt_end AND rw.c_cycleeffectiveend > pci.dt_start /* rc overlaps with this cycle */
                                   AND rw.c_SubscriptionStart   < pci.dt_end AND rw.c_subscriptionend   > pci.dt_start /* rc overlaps with this subscription */
    INNER JOIN t_usage_interval currentui ON currentDate BETWEEN currentui.dt_start AND currentui.dt_end
      AND currentui.id_usage_cycle = ui.id_usage_cycle
  WHERE
    ui.dt_start < currentDate
    AND rw.c__IsAllowGenChargeByTrigger = 1;
	  
  INSERT INTO TMP_RC
  SELECT 'InitialDebit' AS c_RCActionType,
         c_RCIntervalStart,
         c_RCIntervalEnd,
         c_BillingIntervalStart,
         c_BillingIntervalEnd,
         c_RCIntervalSubscriptionStart,
         c_RCIntervalSubscriptionEnd,
         c_SubscriptionStart,
         c_SubscriptionEnd,
         c_Advance,
         c_ProrateOnSubscription,
         c_ProrateInstantly,
         c_UnitValueStart,
         c_UnitValueEnd,
         c_UnitValue,
         c_RatingType,
         c_ProrateOnUnsubscription,
         c_ProrationCycleLength,
         c__AccountID,
         c__PayingAccount,
         c__PriceableItemInstanceID,
         c__PriceableItemTemplateID,
         c__ProductOfferingID,
         c_BilledRateDate,
         c__SubscriptionID,
         c__IntervalID,
         SYS_GUID() AS idSourceSess,
         null
  FROM   TMP_PAYER_CHANGES
  UNION ALL
  SELECT 'InitialCredit' AS c_RCActionType,
         tmp.c_RCIntervalStart,
         tmp.c_RCIntervalEnd,
         tmp.c_BillingIntervalStart,
         tmp.c_BillingIntervalEnd,
         tmp.c_RCIntervalSubscriptionStart,
         tmp.c_RCIntervalSubscriptionEnd,
         tmp.c_SubscriptionStart,
         tmp.c_SubscriptionEnd,
         tmp.c_Advance,
         tmp.c_ProrateOnSubscription,
         tmp.c_ProrateInstantly,
         tmp.c_UnitValueStart,
         tmp.c_UnitValueEnd,
         tmp.c_UnitValue,
         tmp.c_RatingType,
         tmp.c_ProrateOnUnsubscription,
         tmp.c_ProrationCycleLength,
         tmp.c__AccountID,
         rwold.c__PayingAccount,
         tmp.c__PriceableItemInstanceID,
         tmp.c__PriceableItemTemplateID,
         tmp.c__ProductOfferingID,
         tmp.c_BilledRateDate,
         tmp.c__SubscriptionID,
         tmp.c__IntervalID,
         SYS_GUID() AS idSourceSess,
         null
  FROM   TMP_PAYER_CHANGES tmp
         JOIN TMP_OLDRW rwold
            ON tmp.c__SubscriptionID = rwold.c__SubscriptionID
            AND tmp.c__PriceableItemInstanceID = rwold.c__PriceableItemInstanceID
            AND tmp.c__PriceableItemTemplateID = rwold.c__PriceableItemTemplateID;
          
    InsertChargesIntoSvcTables('InitialCredit','InitialDebit');
	
	UPDATE tmp_newrw rw
	SET c_BilledThroughDate = currentDate
  WHERE  rw.c__IsAllowGenChargeByTrigger = 1;

END MeterPayerChangeFromRecWind;
/

ALTER PROCEDURE checkgroupsubbusinessrules COMPILE;

CREATE OR REPLACE PROCEDURE creategroupsubscription (
   p_sub_guid                   IN       RAW,
   p_group_guid                 IN       RAW,
   p_name                       IN       NVARCHAR2,
   p_desc                       IN       NVARCHAR2,
   p_usage_cycle                IN       INTEGER,
   p_startdate                  IN       DATE,
   p_enddate                    IN       DATE,
   p_id_po                      IN       INTEGER,
   p_proportional               IN       VARCHAR2,
   p_supportgroupops            IN       VARCHAR2,
   p_discountaccount            IN       INTEGER,
   p_corporateaccount           IN       INTEGER,
   p_systemdate                 IN       DATE,
   p_enforce_same_corporation            VARCHAR2,
   p_allow_acc_po_curr_mismatch IN       INTEGER DEFAULT 0,
   p_id_sub													     INTEGER,
   p_quoting_batch_id                    VARCHAR2,
   p_id_group                   OUT      INTEGER,
   p_status                     OUT      INTEGER,
   p_datemodified               OUT      VARCHAR2
)
AS
   existingpo             INTEGER;
   realenddate            DATE;
   varmaxdatetime         DATE;
   varsystemgmtdatetime   DATE;
   desctouse NVARCHAR2(255);
BEGIN /* business rule checks*/
   p_datemodified := 'N';
   varmaxdatetime := dbo.mtmaxdate;
   p_status := 0;
   checkgroupsubbusinessrules (p_name,
                               p_desc,
                               p_startdate,
                               p_enddate,
                               p_id_po,
                               p_proportional,
                               p_discountaccount,
                               p_corporateaccount,
                               NULL,
                               p_usage_cycle,
                               p_systemdate,
                               p_enforce_same_corporation,
                               p_allow_acc_po_curr_mismatch,
                               p_status
                              );

   IF p_status <> 1
   THEN
      RETURN;
   END IF; /* set the end date to max date if it is not specified*/

   IF p_enddate IS NULL
   THEN
      realenddate := varmaxdatetime;
   ELSE
      realenddate := p_enddate;
   END IF; /* add group entry*/

  if (p_desc is null) then
    desctouse := ' ';
  else
    desctouse := p_desc;
  end if;
   INSERT INTO t_group_sub
               (id_group, id_group_ext, tx_name, tx_desc, b_visable,
                b_supportgroupops, id_usage_cycle, b_proportional,
                id_discountaccount, id_corporate_account)
      SELECT seq_t_group_sub.NEXTVAL, p_group_guid, p_name,
      desctouse, 'N',
             p_supportgroupops, p_usage_cycle, p_proportional,
             p_discountaccount, p_corporateaccount
        FROM DUAL; /* group subscription ID*/

   SELECT seq_t_group_sub.CURRVAL
     INTO p_id_group
     FROM DUAL; /* add subscription entry*/

   addsubscriptionbase (NULL,
                        p_id_group,
                        p_id_po,
                        p_startdate,
                        p_enddate,
                        p_group_guid,
                        p_systemdate,
                        p_id_sub,
                        p_quoting_batch_id,
                        p_status,
                        p_datemodified,
                        0,
                        0
                       ); /* done*/
END;
/

CREATE OR REPLACE FORCE VIEW vw_audit_log ("TIME",username,userid,eventid,eventname,entityname,entityid,entitytype,details,loggedinas,applicationname,id_audit,id_event,id_userid,id_entitytype,id_entity,tx_logged_in_as,tx_application_name,dt_crt) AS
SELECT
       audit1.dt_crt AS Time,
       accmap1.nm_login
       || CASE accmap1.nm_login WHEN NULL THEN NULL ELSE '/' END
       || accmap1.nm_space
          AS username,
       audit1.id_userid userid,
       audit1.id_Event eventid,
       d.tx_desc EventName,
       (CASE audit1.id_entitytype
           WHEN 1
           THEN accmap2.nm_login
           WHEN 2
           THEN bp2.nm_name
           WHEN 3
           THEN gs2.tx_name
           WHEN 5
           THEN ft2.tx_FailureCompoundId_encoded
           WHEN 6
           THEN b2.tx_namespace || '\' || b2.tx_name || '\' || b2.tx_sequence
           WHEN 9
           THEN accmap2.nm_login
           ELSE NULL
        END) EntityName,
       audit1.id_entity EntityId,
       audit1.id_entitytype EntityType,
       auditdetail.tx_details Details,
       audit1.tx_logged_in_as LoggedInAs,
       audit1.tx_application_name ApplicationName,
       audit1."ID_AUDIT",
       audit1."ID_EVENT",
       audit1."ID_USERID",
       audit1."ID_ENTITYTYPE",
       audit1."ID_ENTITY",
       audit1."TX_LOGGED_IN_AS",
       audit1."TX_APPLICATION_NAME",
       audit1."DT_CRT"
  FROM t_audit audit1
       INNER JOIN t_audit_events auditevent
          ON audit1.id_event = auditevent.id_event
       INNER JOIN t_description d
          ON auditevent.id_desc = d.id_desc AND d.id_lang_code = 840
       INNER JOIN t_account_mapper accmap1 ON audit1.id_userid = accmap1.id_acc
       -- CORE-5043 add filtering account aliases
       INNER JOIN t_namespace ns1
         ON accmap1.nm_space  = ns1.nm_space
        AND lower(ns1.tx_typ_space) != 'metered'
        AND lower(ns1.tx_typ_space) != 'system_ar'
       LEFT OUTER JOIN t_audit_details auditdetail
         ON audit1.id_audit = auditdetail.id_audit
       /* Handle different entity types below */
       LEFT OUTER JOIN t_account_mapper accmap2
         ON audit1.id_entitytype IN (1, 9)
        AND audit1.id_entity = accmap2.id_acc
        AND accmap2.nm_space NOT IN (select nm_space from t_namespace where lower(tx_typ_space) in ('metered', 'system_ar'))
       LEFT OUTER JOIN t_base_props bp2
         ON audit1.id_entitytype = 2
        AND audit1.id_entity = bp2.id_prop
       LEFT OUTER JOIN t_group_sub gs2
         ON audit1.id_entitytype = 3
        AND audit1.id_entity = gs2.id_group
       LEFT OUTER JOIN t_failed_transaction ft2
         ON audit1.id_entitytype = 5
        AND audit1.id_entity = ft2.id_failed_transaction
       LEFT OUTER JOIN t_batch b2
         ON audit1.id_entitytype = 6
        AND audit1.id_entity = b2.id_batch;

CREATE OR REPLACE TRIGGER trig_recur_window_pay_redir
  /* We don't want to trigger on delete, because the insert comes right after a delete, and we can get the info that was deleted
  from payment_redir_history*/
  AFTER
  INSERT ON t_payment_redirection REFERENCING NEW AS NEW
  FOR EACH row
  DECLARE currentDate DATE;
  BEGIN
    /*Get the old vt_start and vt_end for payees that have changed*/
    insert into tmp_redir
    SELECT DISTINCT redirold.id_payer,
      redirold.id_payee,
      redirold.vt_start,
      redirold.vt_end
    FROM t_payment_redir_history redirnew
    JOIN t_payment_redir_history redirold
       ON redirold.tt_end      = dbo.subtractSecond(redirnew.tt_start)
       WHERE redirnew.id_payee = :new.id_payee
         AND redirnew.tt_end     = dbo.MTMaxDate();

   /*Get the old windows for payees that have changed*/
    insert into tmp_oldrw
      SELECT * FROM t_recur_window trw JOIN tmp_redir
        ON trw.c__AccountID  = tmp_redir.id_payee
        AND trw.c_PayerStart = tmp_redir.vt_start
        AND trw.c_PayerEnd   = tmp_redir.vt_end;

SELECT metratime(1,'RC') INTO currentDate FROM dual;

insert into tmp_newrw
  SELECT orw.c_CycleEffectiveDate ,
    orw.c_CycleEffectiveStart ,
    orw.c_CycleEffectiveEnd ,
    orw.c_SubscriptionStart ,
    orw.c_SubscriptionEnd ,
    orw.c_Advance ,
    orw.c__AccountID ,
    :new.id_payer c__PayingAccount ,
    orw.c__PriceableItemInstanceID ,
    orw.c__PriceableItemTemplateID ,
    orw.c__ProductOfferingID ,
    :new.vt_start c_PayerStart ,
    :new.vt_end c_PayerEnd ,
    orw.c__SubscriptionID ,
    orw.c_UnitValueStart ,
    orw.c_UnitValueEnd ,
    orw.c_UnitValue ,
    orw.c_BilledThroughDate ,
    orw.c_LastIdRun ,
    orw.c_MembershipStart ,
    orw.c_MembershipEnd,
    AllowInitialArrersCharge(orw.c_Advance, :new.id_payer, orw.c_SubscriptionEnd, currentDate, 0) c__IsAllowGenChargeByTrigger,
    orw.c__QuoteBatchId c__QuoteBatchId
  FROM tmp_oldrw orw
  WHERE orw.c__AccountId = :new.id_payee;
  
  MeterPayerChangeFromRecWind(currentDate);
  
  DELETE
  FROM t_recur_window
  WHERE EXISTS
    (SELECT 1
    FROM tmp_oldrw orw where
    t_recur_window.c__PayingAccount      = orw.c__PayingAccount
    AND t_recur_window.c__ProductOfferingID = orw.c__ProductOfferingID
    AND t_recur_window.c_PayerStart         = orw.c_PayerStart
    AND t_recur_window.c_PayerEnd           = orw.c_PayerEnd
    AND t_recur_window.c__SubscriptionID    = orw.c__SubscriptionID
    );
  
  INSERT INTO t_recur_window
    SELECT c_CycleEffectiveDate,
    c_CycleEffectiveStart,
    c_CycleEffectiveEnd,
    c_SubscriptionStart,
    c_SubscriptionEnd,
    c_Advance,
    c__AccountID,
    c__PayingAccount,
    c__PriceableItemInstanceID,
    c__PriceableItemTemplateID,
    c__ProductOfferingID,
    c_PayerStart,
    c_PayerEnd,
    c__SubscriptionID,
    c_UnitValueStart,
    c_UnitValueEnd,
    c_UnitValue,
    c_BilledThroughDate,
    c_LastIdRun,
    c_MembershipStart,
    c_MembershipEnd,
    c__quotebatchid
    FROM tmp_newrw;

  UPDATE t_recur_window w1
  SET c_CycleEffectiveEnd =
    (SELECT MIN(NVL(w2.c_CycleEffectiveDate,w2.c_SubscriptionEnd))
    FROM t_recur_window w2
    WHERE w2.c__SubscriptionID  = w1.c__SubscriptionID
    AND w1.c_PayerStart         = w2.c_PayerStart
    AND w1.c_PayerEnd           = w2.c_PayerEnd
    AND w1.c_UnitValueStart     = w2.c_UnitValueStart
    AND w1.c_UnitValueEnd       = w2.c_UnitValueEnd
    AND w2.c_CycleEffectiveDate > w1.c_CycleEffectiveDate
    )
  WHERE EXISTS
    (SELECT 1
    FROM t_recur_window w2
    WHERE w2.c__SubscriptionID  = w1.c__SubscriptionID
    AND w1.c_PayerStart         = w2.c_PayerStart
    AND w1.c_PayerEnd           = w2.c_PayerEnd
    AND w1.c_UnitValueStart     = w2.c_UnitValueStart
    AND w1.c_UnitValueEnd       = w2.c_UnitValueEnd
    AND w2.c_CycleEffectiveDate > w1.c_CycleEffectiveDate
    ) ;
END;
/

CREATE OR REPLACE TRIGGER trg_rec_win_on_t_gsubmember AFTER
  INSERT OR
  DELETE OR
  UPDATE ON t_gsubmember REFERENCING NEW AS new OLD AS OLD
  FOR EACH row
  DECLARE
	currentDate DATE;
	v_id_sub INTEGER;
  BEGIN
  IF deleting THEN
  BEGIN
	  SELECT sub.id_sub INTO v_id_sub
	  FROM t_sub sub
	  where sub.id_group = :old.id_group
		AND ROWNUM = 1;
	  
	  DELETE FROM t_recur_window trw
	  WHERE
			trw.c__subscriptionid = v_id_sub
			AND trw.c__accountid = :old.id_acc;
  END;
ELSE
  /*inserting or updating*/
  SELECT sub.id_sub INTO v_id_sub
  FROM t_sub sub
  WHERE sub.id_group = :new.id_group
	AND ROWNUM = 1;
  
   DELETE FROM tmp_newrw WHERE c__subscriptionid = v_id_sub;
      
   UPDATE t_recur_window trw
      SET trw.c_MembershipStart = :new.vt_start,
          trw.c_MembershipEnd = :new.vt_end
      WHERE exists
      (SELECT 1
         FROM t_sub ts inner join t_pl_map plm on ts.id_po = plm.id_po
            and plm.id_sub = null and plm.id_paramtable = null
   WHERE
              trw.c__accountid       = :new.id_acc
              AND ts.id_group           = :new.id_group
              AND trw.c__subscriptionid = ts.id_sub
           and trw.c__PriceableItemInstanceID = plm.id_pi_instance
              AND trw.c__PriceableItemTemplateID = plm.id_pi_template
      );
	  
	SELECT metratime(1,'RC') INTO currentDate FROM dual;
      
  INSERT INTO tmp_newrw
  SELECT
       :new.vt_start AS c_CycleEffectiveDate
      ,:new.vt_start AS c_CycleEffectiveStart
      ,:new.vt_end AS c_CycleEffectiveEnd
      ,:new.vt_start          AS c_SubscriptionStart
      ,:new.vt_end          AS c_SubscriptionEnd
      ,rcr.b_advance          AS c_Advance
      ,pay.id_payee AS c__AccountID
      ,pay.id_payer      AS c__PayingAccount
      ,plm.id_pi_instance      AS c__PriceableItemInstanceID
      ,plm.id_pi_template      AS c__PriceableItemTemplateID
      ,plm.id_po      AS c__ProductOfferingID
      ,pay.vt_start AS c_PayerStart
      ,pay.vt_end AS c_PayerEnd
      ,sub.id_sub      AS c__SubscriptionID
      , nvl(rv.vt_start, dbo.mtmindate()) AS c_UnitValueStart
      , nvl(rv.vt_end, dbo.mtmaxdate()) AS c_UnitValueEnd
      , rv.n_value AS c_UnitValue
      , metratime(1,'RC') as c_BilledThroughDate
      , -1 AS c_LastIdRun
      , dbo.mtmindate() AS c_MembershipStart
      , dbo.mtmaxdate() AS c_MembershipEnd
      , AllowInitialArrersCharge(rcr.b_advance, pay.id_payer, :new.vt_end, currentDate) c__IsAllowGenChargeByTrigger
      ,sub.TX_QUOTING_BATCH
      FROM t_sub sub
      INNER JOIN t_payment_redirection pay ON pay.id_payee = :new.id_acc AND pay.vt_start < sub.vt_end AND pay.vt_end > sub.vt_start AND pay.vt_start < :new.vt_end AND pay.vt_end > :new.vt_start
      INNER JOIN t_pl_map plm ON plm.id_po = sub.id_po AND plm.id_paramtable IS NULL
      INNER JOIN t_recur rcr ON plm.id_pi_instance = rcr.id_prop
      INNER JOIN t_base_props bp ON bp.id_prop = rcr.id_prop
      LEFT OUTER JOIN t_recur_value rv ON rv.id_prop = rcr.id_prop AND sub.id_sub = rv.id_sub AND rv.tt_end = dbo.MTMaxDate() AND rv.vt_start < sub.vt_end AND rv.vt_end > sub.vt_start AND rv.vt_start < pay.vt_end AND rv.vt_end > pay.vt_start AND rv.vt_start < :new.vt_end AND rv.vt_end > :new.vt_start
      WHERE sub.id_group = :new.id_group
       AND not EXISTS
        (SELECT 1
		FROM T_RECUR_WINDOW
		where c__AccountID = :new.id_acc
			AND c__SubscriptionID = sub.id_sub
			and c__PriceableItemInstanceID = plm.id_pi_instance
			and c__PriceableItemTemplateID = plm.id_pi_template)
		AND rcr.b_charge_per_participant = 'Y'
		AND (bp.n_kind = 20 OR rv.id_prop IS NOT NULL);
  
	/* adds charges to METER tables */
	MeterInitialFromRecurWindow(currentDate);
	MeterCreditFromRecurWindow(currentDate);
 
	INSERT INTO t_recur_window
    SELECT c_CycleEffectiveDate,
    c_CycleEffectiveStart,
    c_CycleEffectiveEnd,
    c_SubscriptionStart,
    c_SubscriptionEnd,
    c_Advance,
    c__AccountID,
    c__PayingAccount,
    c__PriceableItemInstanceID,
    c__PriceableItemTemplateID,
    c__ProductOfferingID,
    c_PayerStart,
    c_PayerEnd,
    c__SubscriptionID,
    c_UnitValueStart,
    c_UnitValueEnd,
    c_UnitValue,
    c_BilledThroughDate,
    c_LastIdRun,
    c_MembershipStart,
    c_MembershipEnd,
    c__quotebatchid
    FROM tmp_newrw
	WHERE c__subscriptionid = v_id_sub;
 
	 /* TODO: do we need it for delete action? */
	UPDATE t_recur_window w1
	SET c_CycleEffectiveEnd =
	  (SELECT MIN(NVL(w2.c_CycleEffectiveDate,w2.c_SubscriptionEnd))
	  FROM t_recur_window w2
	  WHERE w2.c__SubscriptionID  = w1.c__SubscriptionID
	  AND w1.c_PayerStart         = w2.c_PayerStart
	  AND w1.c_PayerEnd           = w2.c_PayerEnd
	  AND w1.c_UnitValueStart     = w2.c_UnitValueStart
	  AND w1.c_UnitValueEnd       = w2.c_UnitValueEnd
	  AND w2.c_CycleEffectiveDate > w1.c_CycleEffectiveDate
	  )
	WHERE EXISTS
	  (SELECT 1
	  FROM t_recur_window w2
	  WHERE w2.c__SubscriptionID  = w1.c__SubscriptionID
	  AND w1.c_PayerStart         = w2.c_PayerStart
	  AND w1.c_PayerEnd           = w2.c_PayerEnd
	  AND w1.c_UnitValueStart     = w2.c_UnitValueStart
	  AND w1.c_UnitValueEnd       = w2.c_UnitValueEnd
	  AND w2.c_CycleEffectiveDate > w1.c_CycleEffectiveDate
	  ) ;
END IF;
END;
/

CREATE OR REPLACE TRIGGER TRG_UPDATE_REC_WIND_ON_REC_VAL
  FOR INSERT OR UPDATE ON T_RECUR_VALUE
    COMPOUND TRIGGER

  startDate DATE;
  v_id_sub INTEGER;
  v_QuoteBatchId raw(16);
  num_notnull_quote_batchids INTEGER;

  AFTER EACH ROW IS
  BEGIN
    IF UPDATING THEN
      INSERT
      INTO TMP_CHANGED_UNITS VALUES
        (
          :OLD.id_prop,
          :OLD.id_sub,
          :OLD.n_value,
          :OLD.vt_start,
          :OLD.vt_end,
          :OLD.tt_start,
          :OLD.tt_end
        );
    END IF;

    IF INSERTING THEN
      INSERT
      INTO TMP_CHANGED_UNITS VALUES
        (
          :NEW.id_prop,
          :NEW.id_sub,
          :NEW.n_value,
          :NEW.vt_start,
          :NEW.vt_end,
          :NEW.tt_start,
          :NEW.tt_end
        );
      v_id_sub:= :NEW.id_sub;
     
      SELECT sub.TX_QUOTING_BATCH INTO v_QuoteBatchId
		  FROM t_sub sub
		  WHERE sub.id_sub = :new.id_sub
			AND ROWNUM = 1;
    END IF;

  END AFTER EACH ROW;


  AFTER STATEMENT IS BEGIN

    IF sql%rowcount != 0 THEN
      /*TODO: look at MSSQL version... now it different */
      SELECT metratime(1,'RC') INTO startDate FROM dual;
      
      IF v_QuoteBatchId is not null THEN
        num_notnull_quote_batchids := 1;
      ELSE
        num_notnull_quote_batchids := 0;
      END IF;

      IF UPDATING THEN
        INSERT INTO TMP_NEWRW
        SELECT
          C_CYCLEEFFECTIVEDATE,
          C_CYCLEEFFECTIVESTART,
          C_CYCLEEFFECTIVEEND,
          C_SUBSCRIPTIONSTART,
          C_SUBSCRIPTIONEND,
          C_ADVANCE,
          C__ACCOUNTID,
          C__PAYINGACCOUNT,
          C__PRICEABLEITEMINSTANCEID,
          C__PRICEABLEITEMTEMPLATEID,
          C__PRODUCTOFFERINGID,
          C_PAYERSTART,
          C_PAYEREND,
          C__SUBSCRIPTIONID,
          C_UNITVALUESTART,
          C_UNITVALUEEND,
          C_UNITVALUE,
          C_BILLEDTHROUGHDATE,
          C_LASTIDRUN,
          C_MEMBERSHIPSTART,
          C_MEMBERSHIPEND,
          1 c__IsAllowGenChargeByTrigger,
          c__QuoteBatchId
        FROM   t_recur_window
        WHERE  EXISTS
           (
             SELECT 1 FROM TMP_CHANGED_UNITS d
             WHERE  t_recur_window.c__SubscriptionID = d.id_sub
                AND t_recur_window.c__PriceableItemInstanceID = d.id_prop
                AND t_recur_window.c_UnitValueStart = d.vt_start
                AND t_recur_window.c_UnitValueEnd = d.vt_end
           );

        MERGE
        INTO    TMP_NEWRW rw
        USING   (
                  SELECT current_sub.* FROM t_sub_history new_sub
                    JOIN t_sub_history current_sub ON current_sub.id_acc = new_sub.id_acc
                      AND current_sub.id_sub = new_sub.id_sub
                      AND current_sub.tt_end = dbo.SubtractSecond(new_sub.tt_start)
                  WHERE new_sub.tt_end = dbo.MTMaxDate()
                ) cur_sub
        ON      ( rw.c__AccountID = cur_sub.id_acc AND rw.c__SubscriptionID = cur_sub.id_sub)
        WHEN MATCHED THEN
        UPDATE
        SET     rw.c_SubscriptionStart = cur_sub.vt_start, rw.c_SubscriptionEnd = cur_sub.vt_end;

        DELETE
        FROM   t_recur_window
        WHERE  EXISTS
               (
                   SELECT 1 FROM TMP_CHANGED_UNITS d
                   WHERE  t_recur_window.c__SubscriptionID = d.id_sub
                          AND t_recur_window.c__PriceableItemInstanceID = d.id_prop
                          AND t_recur_window.c_UnitValueStart = d.vt_start
                          AND t_recur_window.c_UnitValueEnd = d.vt_end
               );

        MeterUdrcFromRecurWindow(startDate, 'AdvanceCorrection');

      END IF;


      IF INSERTING THEN

        /*Get the old windows for recur values that have changed*/
        INSERT INTO TMP_NEWRW
        SELECT sub.vt_start c_CycleEffectiveDate ,
          sub.vt_start c_CycleEffectiveStart ,
          sub.vt_end c_CycleEffectiveEnd ,
          sub.vt_start c_SubscriptionStart ,
          sub.vt_end c_SubscriptionEnd ,
          rcr.b_advance c_Advance ,
          pay.id_payee c__AccountID ,
          pay.id_payer c__PayingAccount ,
          plm.id_pi_instance c__PriceableItemInstanceID ,
          plm.id_pi_template c__PriceableItemTemplateID ,
          plm.id_po c__ProductOfferingID ,
          pay.vt_start c_PayerStart ,
          pay.vt_end c_PayerEnd ,
          sub.id_sub c__SubscriptionID ,
          NVL(rv.vt_start, dbo.mtmindate()) c_UnitValueStart ,
          NVL(rv.vt_end, dbo.mtmaxdate()) c_UnitValueEnd ,
          rv.n_value c_UnitValue ,
          dbo.mtmindate() c_BilledThroughDate ,
          -1 c_LastIdRun ,
          dbo.mtmindate() c_MembershipStart ,
          dbo.mtmaxdate() c_MembershipEnd,
          AllowInitialArrersCharge(rcr.b_advance, pay.id_payer, sub.vt_end, startDate, num_notnull_quote_batchids) c__IsAllowGenChargeByTrigger,
          sub.TX_QUOTING_BATCH c__QuoteBatchId
          FROM t_sub sub
            INNER JOIN t_payment_redirection pay ON pay.id_payee = sub.id_acc AND pay.vt_start < sub.vt_end AND pay.vt_end > sub.vt_start
            INNER JOIN t_pl_map plm ON plm.id_po = sub.id_po AND plm.id_paramtable IS NULL
            INNER JOIN t_recur rcr ON plm.id_pi_instance = rcr.id_prop
            INNER JOIN t_base_props bp ON bp.id_prop = rcr.id_prop
            JOIN TMP_CHANGED_UNITS rv ON rv.id_prop = rcr.id_prop AND sub.id_sub = rv.id_sub AND rv.tt_end = dbo.MTMaxDate()
              AND rv.vt_start < sub.vt_end AND rv.vt_end > sub.vt_start
              AND rv.vt_start < pay.vt_end AND rv.vt_end > pay.vt_start
            WHERE
                sub.id_group IS NULL
                AND (bp.n_kind = 20 OR rv.id_prop IS NOT NULL)
        
        UNION ALL
        
        SELECT gsm.vt_start c_CycleEffectiveDate ,
          gsm.vt_start c_CycleEffectiveStart ,
          gsm.vt_end c_CycleEffectiveEnd ,
          gsm.vt_start c_SubscriptionStart ,
          gsm.vt_end c_SubscriptionEnd ,
          rcr.b_advance c_Advance ,
          pay.id_payee c__AccountID ,
          pay.id_payer c__PayingAccount ,
          plm.id_pi_instance c__PriceableItemInstanceID ,
          plm.id_pi_template c__PriceableItemTemplateID ,
          plm.id_po c__ProductOfferingID ,
          pay.vt_start c_PayerStart ,
          pay.vt_end c_PayerEnd ,
          sub.id_sub c__SubscriptionID ,
          NVL(rv.vt_start, dbo.mtmindate()) c_UnitValueStart ,
          NVL(rv.vt_end, dbo.mtmaxdate()) c_UnitValueEnd ,
          rv.n_value c_UnitValue ,
          dbo.mtmindate() c_BilledThroughDate ,
          -1 c_LastIdRun ,
          dbo.mtmindate() c_MembershipStart ,
          dbo.mtmaxdate() c_MembershipEnd,
          AllowInitialArrersCharge(rcr.b_advance, pay.id_payer, gsm.vt_end, startDate, num_notnull_quote_batchids) c__IsAllowGenChargeByTrigger,
          sub.TX_QUOTING_BATCH c__QuoteBatchId
          FROM t_gsubmember gsm
            INNER JOIN t_sub sub ON sub.id_group = gsm.id_group
            INNER JOIN t_payment_redirection pay ON pay.id_payee = gsm.id_acc
              AND pay.vt_start < sub.vt_end AND pay.vt_end > sub.vt_start
              AND pay.vt_start < gsm.vt_end AND pay.vt_end > gsm.vt_start
            INNER JOIN t_pl_map plm ON plm.id_po = sub.id_po AND plm.id_paramtable IS NULL
            INNER JOIN t_recur rcr ON plm.id_pi_instance = rcr.id_prop
            INNER JOIN t_base_props bp ON bp.id_prop = rcr.id_prop
            JOIN TMP_CHANGED_UNITS rv ON rv.id_prop = rcr.id_prop
              AND sub.id_sub = rv.id_sub
              AND rv.tt_end = dbo.MTMaxDate()
              AND rv.vt_start < sub.vt_end AND rv.vt_end > sub.vt_start
              AND rv.vt_start < pay.vt_end AND rv.vt_end > pay.vt_start
              AND rv.vt_start < gsm.vt_end AND rv.vt_end > gsm.vt_start
        WHERE
          rcr.b_charge_per_participant = 'Y'
              AND (bp.n_kind = 20 OR rv.id_prop IS NOT NULL)
        
        UNION ALL
        
        SELECT sub.vt_start c_CycleEffectiveDate ,
          sub.vt_start c_CycleEffectiveStart ,
          sub.vt_end c_CycleEffectiveEnd ,
          sub.vt_start c_SubscriptionStart ,
          sub.vt_end c_SubscriptionEnd ,
          rcr.b_advance c_Advance ,
          pay.id_payee c__AccountID ,
          pay.id_payer c__PayingAccount ,
          plm.id_pi_instance c__PriceableItemInstanceID ,
          plm.id_pi_template c__PriceableItemTemplateID ,
          plm.id_po c__ProductOfferingID ,
          pay.vt_start c_PayerStart ,
          pay.vt_end c_PayerEnd ,
          sub.id_sub c__SubscriptionID ,
          NVL(rv.vt_start, dbo.mtmindate()) c_UnitValueStart ,
          NVL(rv.vt_end, dbo.mtmaxdate()) c_UnitValueEnd ,
          rv.n_value c_UnitValue ,
          dbo.mtmindate() c_BilledThroughDate ,
          -1 c_LastIdRun ,
          grm.vt_start c_MembershipStart ,
          grm.vt_end c_MembershipEnd,
          AllowInitialArrersCharge(rcr.b_advance, pay.id_payee, sub.vt_end, null, num_notnull_quote_batchids) c__IsAllowGenChargeByTrigger,
          sub.TX_QUOTING_BATCH c__QuoteBatchId
          FROM t_gsub_recur_map grm
            /* TODO: GRM dates or sub dates or both for filtering */
            INNER JOIN t_sub sub ON grm.id_group = sub.id_group
            INNER JOIN t_payment_redirection pay ON pay.id_payee = grm.id_acc AND pay.vt_start < sub.vt_end AND pay.vt_end > sub.vt_start
            INNER JOIN t_pl_map plm ON plm.id_po = sub.id_po AND plm.id_paramtable IS NULL
            INNER JOIN t_recur rcr ON plm.id_pi_instance = rcr.id_prop
            INNER JOIN t_base_props bp ON bp.id_prop = rcr.id_prop
            JOIN TMP_CHANGED_UNITS rv ON rv.id_prop = rcr.id_prop AND sub.id_sub = rv.id_sub
            AND rv.tt_end = dbo.MTMaxDate()
            AND rv.vt_start < sub.vt_end AND rv.vt_end > sub.vt_start
            AND rv.vt_start < pay.vt_end AND rv.vt_end > pay.vt_start
        WHERE
          grm.tt_end = dbo.mtmaxdate()
              AND rcr.b_charge_per_participant = 'N'
              AND (bp.n_kind = 20 OR rv.id_prop IS NOT NULL);

        /* Should be analozed for Arrears RC*/
        MeterInitialFromRecurWindow(startDate);
        MeterUdrcFromRecurWindow(startDate, 'DebitCorrection');

        INSERT INTO t_recur_window
          SELECT DISTINCT c_CycleEffectiveDate,
          c_CycleEffectiveStart,
          c_CycleEffectiveEnd,
          c_SubscriptionStart,
          c_SubscriptionEnd,
          c_Advance,
          c__AccountID,
          c__PayingAccount,
          c__PriceableItemInstanceID,
          c__PriceableItemTemplateID,
          c__ProductOfferingID,
          c_PayerStart,
          c_PayerEnd,
          c__SubscriptionID,
          c_UnitValueStart,
          c_UnitValueEnd,
          c_UnitValue,
          c_BilledThroughDate,
          c_LastIdRun,
          c_MembershipStart,
          c_MembershipEnd,
          c__QuoteBatchId
          FROM TMP_NEWRW
          WHERE c__SubscriptionID = v_id_sub;

      END IF;
      /* TODO: Using "ON COMMIT DELETE ROWS" caused "ORA-14450: attempt to access a transactional temp table already in use" some time ago */
      DELETE FROM TMP_CHANGED_UNITS;
      DELETE FROM TMP_NEWRW;
      DELETE FROM TMP_UDRC;

    END IF;
  END AFTER STATEMENT;
END;
/

CREATE OR REPLACE TRIGGER trg_recur_win_acc_usage_int AFTER INSERT OR DELETE OR UPDATE
  ON T_ACC_USAGE_INTERVAL
    REFERENCING OLD AS old NEW AS new
    FOR EACH ROW
	when (new.tx_status ='O' or new.tx_status is null)
  BEGIN
    IF deleting THEN
      DELETE FROM t_recur_window
        WHERE c__AccountID = :old.id_acc
           AND c_CycleEffectiveDate = :old.dt_effective;
    ELSE
      INSERT INTO t_recur_window
        SELECT :new.dt_effective c_CycleEffectiveDate ,
          dbo.AddSecond(:new.dt_effective) c_CycleEffectiveStart ,
          sub.vt_end c_CycleEffectiveEnd ,
          sub.vt_start c_SubscriptionStart ,
          sub.vt_end c_SubscriptionEnd ,
          rcr.b_advance c_Advance ,
          pay.id_payee c__AccountID ,
          pay.id_payer c__PayingAccount ,
          plm.id_pi_instance c__PriceableItemInstanceID ,
          plm.id_pi_template c__PriceableItemTemplateID ,
          plm.id_po c__ProductOfferingID ,
          pay.vt_start c_PayerStart ,
          pay.vt_end c_PayerEnd ,
          sub.id_sub c__SubscriptionID ,
          NVL(rv.vt_start, dbo.mtmindate()) c_UnitValueStart,
          NVL(rv.vt_end, dbo.mtmaxdate()) c_UnitValueEnd,
          rv.n_value c_UnitValue ,
          metratime(1,'RC') c_BilledThroughDate ,
          -1 c_LastIdRun ,
          dbo.mtmindate() c_MembershipStart ,
          dbo.mtmaxdate() c_MembershipEnd,
          sub.TX_QUOTING_BATCH
       FROM t_sub sub INNER JOIN t_payment_redirection pay
         ON pay.id_payee  = sub.id_acc AND pay.vt_start < sub.vt_end
           AND pay.vt_end   > sub.vt_start
         INNER JOIN t_pl_map plm ON plm.id_po = sub.id_po AND plm.id_paramtable IS NULL
         INNER JOIN t_recur rcr ON plm.id_pi_instance = rcr.id_prop
         INNER JOIN t_base_props bp ON bp.id_prop = rcr.id_prop
         LEFT OUTER JOIN t_recur_value rv ON rv.id_prop = rcr.id_prop
           AND sub.id_sub = rv.id_sub AND rv.tt_end = dbo.MTMaxDate()
           AND rv.vt_start < sub.vt_end AND rv.vt_end > sub.vt_start
           AND rv.vt_start < pay.vt_end AND rv.vt_end > pay.vt_start
           AND dbo.AddSecond(:new.dt_effective) < rv.vt_end AND dbo.AddSecond(:new.dt_effective) >= rv.vt_start
        WHERE 1 =1
           AND pay.id_payer = :new.id_acc
           AND dbo.AddSecond(:new.dt_effective) < sub.vt_end AND dbo.AddSecond(:new.dt_effective) >= sub.vt_start
           AND dbo.AddSecond(:new.dt_effective) < pay.vt_end AND dbo.AddSecond(:new.dt_effective) >= pay.vt_start
           AND sub.id_group IS NULL AND (bp.n_kind = 20 OR rv.id_prop IS NOT NULL)
  UNION ALL
       SELECT :new.dt_effective c_CycleEffectiveDate ,
         dbo.AddSecond(:new.dt_effective) c_CycleEffectiveStart ,
         gsm.vt_end c_CycleEffectiveEnd ,
         gsm.vt_start c_SubscriptionStart ,
         gsm.vt_end c_SubscriptionEnd ,
         rcr.b_advance c_Advance ,
         pay.id_payee c__AccountID ,
         pay.id_payer c__PayingAccount ,
         plm.id_pi_instance c__PriceableItemInstanceID ,
         plm.id_pi_template c__PriceableItemTemplateID ,
         plm.id_po c__ProductOfferingID ,
         pay.vt_start c_PayerStart ,
         pay.vt_end c_PayerEnd ,
         sub.id_sub c__SubscriptionID ,
         NVL(rv.vt_start, dbo.mtmindate()) c_UnitValueStart,
         NVL(rv.vt_end, dbo.mtmaxdate()) c_UnitValueEnd,
         rv.n_value c_UnitValue ,
         dbo.mtmindate() c_BilledThroughDate ,
         -1 c_LastIdRun ,
         dbo.mtmindate() c_MembershipStart ,
         dbo.mtmaxdate() c_MembershipEnd,
         sub.TX_QUOTING_BATCH
       FROM t_gsubmember gsm INNER JOIN t_sub sub ON sub.id_group = gsm.id_group
         INNER JOIN t_payment_redirection pay ON pay.id_payee  = gsm.id_acc
           AND pay.vt_start < sub.vt_end AND pay.vt_end   > sub.vt_start
           AND pay.vt_start < gsm.vt_end AND pay.vt_end   > gsm.vt_start
         INNER JOIN t_pl_map plm ON plm.id_po = sub.id_po AND plm.id_paramtable IS NULL
         INNER JOIN t_recur rcr ON plm.id_pi_instance = rcr.id_prop
         INNER JOIN t_base_props bp ON bp.id_prop = rcr.id_prop
         LEFT OUTER JOIN t_recur_value rv ON rv.id_prop = rcr.id_prop
           AND sub.id_sub = rv.id_sub AND rv.tt_end = dbo.MTMaxDate()
           AND rv.vt_start < sub.vt_end AND rv.vt_end > sub.vt_start
           AND rv.vt_start < pay.vt_end AND rv.vt_end > pay.vt_start
           AND rv.vt_start < gsm.vt_end AND rv.vt_end > gsm.vt_start
           AND dbo.AddSecond(:new.dt_effective)  < rv.vt_end
           AND dbo.AddSecond(:new.dt_effective) >= rv.vt_start
          WHERE 1  =1
          AND pay.id_payer = :new.id_acc
          AND dbo.AddSecond(:new.dt_effective) < sub.vt_end AND dbo.AddSecond(:new.dt_effective) >= sub.vt_start
          AND dbo.AddSecond(:new.dt_effective)  < pay.vt_end
          AND dbo.AddSecond(:new.dt_effective) >= pay.vt_start
          AND rcr.b_charge_per_participant = 'Y'
          AND (bp.n_kind = 20 OR rv.id_prop IS NOT NULL)
   UNION ALL
     SELECT :new.dt_effective c_CycleEffectiveDate ,
         dbo.AddSecond(:new.dt_effective) c_CycleEffectiveStart ,
         sub.vt_end c_CycleEffectiveEnd ,
         sub.vt_start c_SubscriptionStart ,
         sub.vt_end c_SubscriptionEnd ,
         rcr.b_advance c_Advance ,
         pay.id_payee c__AccountID ,
         pay.id_payer c__PayingAccount ,
         plm.id_pi_instance c__PriceableItemInstanceID ,
         plm.id_pi_template c__PriceableItemTemplateID ,
         plm.id_po c__ProductOfferingID ,
         pay.vt_start c_PayerStart ,
         pay.vt_end c_PayerEnd ,
         sub.id_sub c__SubscriptionID ,
         NVL(rv.vt_start, dbo.mtmindate()) c_UnitValueStart,
         NVL(rv.vt_end, dbo.mtmaxdate()) c_UnitValueEnd,
         rv.n_value c_UnitValue ,
         dbo.mtmindate() c_BilledThroughDate ,
         -1 c_LastIdRun ,
         grm.vt_start c_MembershipStart ,
         grm.vt_end c_MembershipEnd,
          sub.TX_QUOTING_BATCH
    FROM t_gsub_recur_map grm
    /* TODO: GRM dates or sub dates or both for filtering */
       INNER JOIN t_sub sub ON grm.id_group = sub.id_group
       INNER JOIN t_payment_redirection pay ON pay.id_payee  = grm.id_acc
         AND pay.vt_start < sub.vt_end AND pay.vt_end   > sub.vt_start
       INNER JOIN t_pl_map plm ON plm.id_po = sub.id_po AND plm.id_paramtable IS NULL
       INNER JOIN t_recur rcr ON plm.id_pi_instance = rcr.id_prop
       INNER JOIN t_base_props bp ON bp.id_prop = rcr.id_prop
       LEFT OUTER JOIN t_recur_value rv ON rv.id_prop = rcr.id_prop
         AND sub.id_sub = rv.id_sub AND rv.tt_end = dbo.MTMaxDate()
         AND rv.vt_start < sub.vt_end AND rv.vt_end > sub.vt_start
         AND rv.vt_start < pay.vt_end AND rv.vt_end > pay.vt_start
         AND dbo.AddSecond(:new.dt_effective)  < rv.vt_end AND :new.dt_effective > rv.vt_start
    WHERE 1                               =1
       AND pay.id_payer = :new.id_acc
       AND dbo.AddSecond(:new.dt_effective)  < sub.vt_end AND dbo.AddSecond(:new.dt_effective) >= sub.vt_start
       AND dbo.AddSecond(:new.dt_effective)  < pay.vt_end AND dbo.AddSecond(:new.dt_effective) >= pay.vt_start
       AND grm.tt_end =  dbo.mtmaxdate() AND rcr.b_charge_per_participant      = 'N'
       AND (bp.n_kind = 20 OR rv.id_prop IS NOT NULL) ;
END IF;
UPDATE t_recur_window w1
SET c_CycleEffectiveEnd =
  (SELECT MIN(NVL(w2.c_CycleEffectiveDate,w2.c_SubscriptionEnd))
  FROM t_recur_window w2
  WHERE w2.c__SubscriptionID  = w1.c__SubscriptionID
  AND w1.c_PayerStart         = w2.c_PayerStart
  AND w1.c_PayerEnd           = w2.c_PayerEnd
  AND w1.c_UnitValueStart     = w2.c_UnitValueStart
  AND w1.c_UnitValueEnd       = w2.c_UnitValueEnd
  AND w2.c_CycleEffectiveDate > w1.c_CycleEffectiveDate
  )
WHERE 1=1
 AND c__PayingAccount = :new.id_acc
AND EXISTS
  (SELECT 1
  FROM t_recur_window w2
  WHERE w2.c__SubscriptionID  = w1.c__SubscriptionID
  AND w1.c_PayerStart         = w2.c_PayerStart
  AND w1.c_PayerEnd           = w2.c_PayerEnd
  AND w1.c_UnitValueStart     = w2.c_UnitValueStart
  AND w1.c_UnitValueEnd       = w2.c_UnitValueEnd
  AND w2.c_CycleEffectiveDate > w1.c_CycleEffectiveDate
  ) ;
END;
/

CREATE OR REPLACE TRIGGER trig_recur_window_recur_map
AFTER INSERT OR UPDATE OR DELETE ON t_gsub_recur_map
REFERENCING NEW AS new OLD AS OLD
FOR EACH row
DECLARE
currentDate DATE;
v_id_sub INTEGER;
v_QuoteBatchId raw(16);
num_notnull_quote_batchids INTEGER;
  BEGIN
    IF deleting THEN
      DELETE FROM t_recur_window WHERE EXISTS
       (SELECT 1
          FROM t_sub sub join t_pl_map plm on sub.id_po = plm.id_po
		  WHERE t_recur_window.c__AccountID = :old.id_acc
            AND t_recur_window.c__SubscriptionID = sub.id_sub
            AND sub.id_group = :old.id_group
			AND t_recur_window.c__PriceableItemInstanceID = plm.id_pi_instance
			AND t_recur_window.c__PriceableItemTemplateID = plm.id_pi_template
       );
    ELSE
	/*inserting or updating*/
		SELECT sub.id_sub INTO v_id_sub
		  FROM t_sub sub
		  WHERE sub.id_group = :new.id_group
			AND ROWNUM = 1;
      
    SELECT sub.TX_QUOTING_BATCH INTO v_QuoteBatchId
		  FROM t_sub sub
		  WHERE sub.id_group = :new.id_group
			AND ROWNUM = 1;
		
		DELETE FROM TMP_NEWRW WHERE c__SubscriptionID = v_id_sub;
        UPDATE t_recur_window
          SET c_MembershipStart = :new.vt_start,
              c_MembershipEnd     = :new.vt_end
        WHERE EXISTS
         (SELECT 1
			FROM t_recur_window trw JOIN t_sub sub on trw.c__AccountID    = sub.id_acc
				AND trw.c__SubscriptionID = sub.id_sub
            WHERE sub.id_group = :new.id_group
      ) ;
	
	SELECT NVL(:new.tt_start, metratime(1,'RC')) INTO currentDate FROM dual;
  
      if v_QuoteBatchId is not null then
        num_notnull_quote_batchids := 1;
      else
        num_notnull_quote_batchids := 0;
      end if;
	  
    insert into TMP_NEWRW
    SELECT sub.vt_start c_CycleEffectiveDate,
      sub.vt_start c_CycleEffectiveStart,
      sub.vt_end c_CycleEffectiveEnd,
      sub.vt_start c_SubscriptionStart,
      sub.vt_end c_SubscriptionEnd,
      rcr.b_advance c_Advance,
      pay.id_payee c__AccountID,
      pay.id_payer c__PayingAccount,
      plm.id_pi_instance c__PriceableItemInstanceID,
      plm.id_pi_template c__PriceableItemTemplateID,
      plm.id_po c__ProductOfferingID,
      pay.vt_start c_PayerStart,
      pay.vt_end c_PayerEnd,
      sub.id_sub c__SubscriptionID,
      NVL(rv.vt_start, dbo.mtmindate()) c_UnitValueStart,
      NVL(rv.vt_end, dbo.mtmaxdate()) c_UnitValueEnd,
      rv.n_value c_UnitValue,
      currentDate c_BilledThroughDate,
      -1 c_LastIdRun,
      :new.vt_start c_MembershipStart,
      :new.vt_end c_MembershipEnd,
	    AllowInitialArrersCharge(rcr.b_advance, pay.id_payer, sub.vt_end, currentDate, num_notnull_quote_batchids) c__IsAllowGenChargeByTrigger,
      v_QuoteBatchId
      from t_sub sub INNER JOIN t_payment_redirection pay
         ON pay.id_payee = :new.id_acc AND pay.vt_start < sub.vt_end
          AND pay.vt_end > sub.vt_start
      INNER JOIN t_pl_map plm ON plm.id_po = sub.id_po
         AND plm.id_paramtable IS NULL
      INNER JOIN t_recur rcr ON plm.id_pi_instance = rcr.id_prop
      INNER JOIN t_base_props bp ON bp.id_prop = rcr.id_prop
      LEFT OUTER JOIN t_recur_value rv ON rv.id_prop = rcr.id_prop
        AND sub.id_sub = rv.id_sub AND rv.tt_end = dbo.MTMaxDate()
        AND rv.vt_start < sub.vt_end AND rv.vt_end > sub.vt_start
        AND rv.vt_start < pay.vt_end AND rv.vt_end > pay.vt_start
      WHERE
      	sub.id_group = :new.id_group
      	AND NOT EXISTS
	        (SELECT 1
	          FROM T_RECUR_WINDOW
			  WHERE c__AccountID = :new.id_acc
	            AND c__SubscriptionID = sub.id_sub
	        )
	    AND :new.tt_end  = dbo.mtmaxdate()
	    AND rcr.b_charge_per_participant = 'N'
	    AND (bp.n_kind = 20 OR rv.id_prop IS NOT NULL);
 /* adds charges to METER tables */
  MeterInitialFromRecurWindow(currentDate);
  MeterCreditFromRecurWindow(currentDate);
  
  INSERT INTO t_recur_window
    SELECT c_CycleEffectiveDate,
    c_CycleEffectiveStart,
    c_CycleEffectiveEnd,
    c_SubscriptionStart,
    c_SubscriptionEnd,
    c_Advance,
    c__AccountID,
    c__PayingAccount,
    c__PriceableItemInstanceID,
    c__PriceableItemTemplateID,
    c__ProductOfferingID,
    c_PayerStart,
    c_PayerEnd,
    c__SubscriptionID,
    c_UnitValueStart,
    c_UnitValueEnd,
    c_UnitValue,
    c_BilledThroughDate,
    c_LastIdRun,
    c_MembershipStart,
    c_MembershipEnd,
    C__QUOTEBATCHID
    FROM tmp_newrw
	WHERE c__SubscriptionID = v_id_sub;
  
  UPDATE t_recur_window w1
    SET c_CycleEffectiveEnd =
    (SELECT MIN(NVL(w2.c_CycleEffectiveDate,w2.c_SubscriptionEnd))
      FROM t_recur_window w2
        WHERE w2.c__SubscriptionID  = w1.c__SubscriptionID
        AND w1.c_PayerStart         = w2.c_PayerStart
        AND w1.c_PayerEnd           = w2.c_PayerEnd
        AND w1.c_UnitValueStart     = w2.c_UnitValueStart
        AND w1.c_UnitValueEnd       = w2.c_UnitValueEnd
        AND w2.c_CycleEffectiveDate > w1.c_CycleEffectiveDate
    )
  WHERE 1=1
  AND EXISTS
  (SELECT 1
    FROM t_recur_window w2
      WHERE w2.c__SubscriptionID  = w1.c__SubscriptionID
      AND w1.c_PayerStart         = w2.c_PayerStart
      AND w1.c_PayerEnd           = w2.c_PayerEnd
      AND w1.c_UnitValueStart     = w2.c_UnitValueStart
      AND w1.c_UnitValueEnd       = w2.c_UnitValueEnd
      AND w2.c_CycleEffectiveDate > w1.c_CycleEffectiveDate
  ) ;
	
  END IF;
END;
/

CREATE OR REPLACE TRIGGER trig_recur_window_sub AFTER INSERT OR UPDATE OR DELETE
ON t_sub
REFERENCING NEW AS new old as old
FOR EACH row
DECLARE currentDate DATE;
        num_notnull_quote_batchids INTEGER;
BEGIN
	IF deleting THEN
	BEGIN
		/* dt_crt is nullable. Use SystemDate as workaround not disable possibility of fail on production */
        SELECT NVL(:old.dt_crt, metratime(1,'RC')) INTO currentDate FROM dual;
        DELETE FROM t_recur_window
           WHERE c__SubscriptionID   = :old.id_sub;
    END;
    ELSE
	/*inserting or deleting*/
		/* dt_crt is nullable. Use SystemDate as workaround not disable possibility of fail on production */
		SELECT NVL(:new.dt_crt, metratime(1,'RC')) INTO currentDate FROM dual;
		
		DELETE FROM TMP_NEWRW where c__SubscriptionID = :new.id_sub;
	
		UPDATE t_recur_window
            SET c_SubscriptionStart = :new.vt_start,
				c_SubscriptionEnd   = :new.vt_end
            WHERE EXISTS
             (	SELECT 1
				FROM t_recur_window trw
					JOIN t_pl_map plm on :new.id_po = plm.id_po
                and plm.id_sub = :new.id_sub and plm.id_paramtable = null
                WHERE
				  c__AccountID      = :new.id_acc
				  AND c__SubscriptionID   = :new.id_sub
          ) ;
          
		UPDATE t_recur_window
			SET 	c_SubscriptionStart = :new.vt_start,
					c_SubscriptionEnd   = :new.vt_end
			WHERE c__AccountID      = :new.id_acc
				AND c__SubscriptionID   = :new.id_sub;
      
      DELETE FROM TMP_NEWRW;
      
      if :new.tx_quoting_batch is not null then
        num_notnull_quote_batchids := 1;
      else
        num_notnull_quote_batchids := 0;
      end if;
      
      INSERT INTO TMP_NEWRW
      SELECT :new.vt_start c_CycleEffectiveDate,
        :new.vt_start c_CycleEffectiveStart,
        :new.vt_end c_CycleEffectiveEnd,
        :new.vt_start c_SubscriptionStart,
        :new.vt_end c_SubscriptionEnd,
        rcr.b_advance c_Advance ,
        pay.id_payee c__AccountID,
        pay.id_payer c__PayingAccount,
        plm.id_pi_instance c__PriceableItemInstanceID,
        plm.id_pi_template c__PriceableItemTemplateID,
        plm.id_po c__ProductOfferingID,
        pay.vt_start c_PayerStart,
        pay.vt_end c_PayerEnd,
        :new.id_sub c__SubscriptionID,
        NVL(rv.vt_start, dbo.mtmindate()) c_UnitValueStart,
        NVL(rv.vt_end, dbo.mtmaxdate()) c_UnitValueEnd,
        rv.n_value c_UnitValue,
        dbo.mtmindate() c_BilledThroughDate,
        -1 c_LastIdRun,
        dbo.mtmindate() c_MembershipStart,
        dbo.mtmaxdate() c_MembershipEnd,
        AllowInitialArrersCharge(rcr.b_advance, pay.id_payer, :new.vt_end, :new.dt_crt, num_notnull_quote_batchids) c__IsAllowGenChargeByTrigger,
        :new.TX_QUOTING_BATCH c__QuoteBatchId
      from t_payment_redirection pay INNER JOIN t_pl_map plm
         ON plm.id_po = :new.id_po AND plm.id_paramtable IS NULL
      INNER JOIN t_recur rcr ON plm.id_pi_instance = rcr.id_prop
      INNER JOIN t_base_props bp ON bp.id_prop = rcr.id_prop
      LEFT OUTER JOIN t_recur_value rv ON rv.id_prop = rcr.id_prop
        AND :new.id_sub  = rv.id_sub AND rv.tt_end   = dbo.MTMaxDate()
        AND rv.vt_start < :new.vt_end AND rv.vt_end   > :new.vt_start
        AND rv.vt_start < pay.vt_end  AND rv.vt_end   > pay.vt_start
      WHERE
		pay.id_payee  = :new.id_acc
		AND pay.vt_start < :new.vt_end
		AND pay.vt_end   > :new.vt_start
      /*Make sure not to insert a row that already takes care of this account/sub id*/
		AND NOT EXISTS
			(SELECT 1
			FROM T_RECUR_WINDOW
			  WHERE c__AccountID    = :new.id_acc
			  AND c__SubscriptionID = :new.id_sub
			)
		AND :new.id_group IS NULL
		AND (bp.n_kind = 20 OR rv.id_prop IS NOT NULL);
 	
	/* adds charges to METER tables */
	MeterInitialFromRecurWindow(currentDate);
	MeterCreditFromRecurWindow(currentDate);

	INSERT INTO t_recur_window
    SELECT c_CycleEffectiveDate,
    c_CycleEffectiveStart,
    c_CycleEffectiveEnd,
    c_SubscriptionStart,
    c_SubscriptionEnd,
    c_Advance,
    c__AccountID,
    c__PayingAccount,
    c__PriceableItemInstanceID,
    c__PriceableItemTemplateID,
    c__ProductOfferingID,
    c_PayerStart,
    c_PayerEnd,
    c__SubscriptionID,
    c_UnitValueStart,
    c_UnitValueEnd,
    c_UnitValue,
    c_BilledThroughDate,
    c_LastIdRun,
    c_MembershipStart,
    c_MembershipEnd,
    c__QuoteBatchId
    FROM tmp_newrw
	WHERE c__SubscriptionID = :new.id_sub;
	
	END IF;
END;
/

ALTER PROCEDURE mtsp_generate_stateful_rcs COMPILE;

ALTER PROCEDURE removegsubs_quoting COMPILE;

ALTER PROCEDURE mtsp_generate_st_rcs_quoting COMPILE;

ALTER PROCEDURE mtsp_generate_charges_quoting COMPILE;

ALTER PROCEDURE subscribebatchgroupsub COMPILE;

ALTER PROCEDURE rev_updatestatefrompfbtoclosed COMPILE;

ALTER PROCEDURE sequencedinsertgsubrecur COMPILE;

ALTER PROCEDURE sequencedupsertgsubrecur COMPILE;

ALTER PROCEDURE createpaymentrecord COMPILE;

ALTER PACKAGE  mt_acc_template COMPILE BODY;

ALTER PROCEDURE geticbmappingforsub COMPILE;

ALTER PACKAGE  mt_rate_pkg COMPILE BODY;

ALTER PROCEDURE updategroupsubscription COMPILE;

ALTER PROCEDURE updatestatefrompfbtoclosed COMPILE;

ALTER PROCEDURE removegroupsubscription COMPILE;

ALTER PROCEDURE removesubscription COMPILE;

ALTER PROCEDURE addaccounttogroupsub COMPILE;

ALTER PROCEDURE deleteaccounts COMPILE;

ALTER PROCEDURE seqinsertgsubrecurinitialize COMPILE;

ALTER PROCEDURE mtsp_generate_st_nrcs_quoting COMPILE;

ALTER PROCEDURE getrateschedules COMPILE;

ALTER PROCEDURE piresolutionbyname COMPILE;

ALTER PROCEDURE canbulksubscribe COMPILE;

ALTER PROCEDURE piresolutionbyid COMPILE;

ALTER PROCEDURE adjustgsubmemberdates COMPILE;

